,id,revisions,comments,inline_comments,status,is_accepted,url,commit_message,exist_target_file,added_satd,is_added_satd,deleted_satd,is_deleted_satd,added_and_deleted_satd
92,298.0,2.0,5.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/298,Refactor glyph pretransform check,1.0,"{'// ### Remove the TestFontEngine and Box engine crap, in these<KAIGYO>// ### cases we should delegate painting to the font engine<KAIGYO>// ### directly...': 1}",1.0,"{'// ### Remove the TestFontEngine and Box engine crap, in these<KAIGYO>// ### cases we should delegate painting to the font engine<KAIGYO>// ### directly...': 1}",1.0,{}
56,302.0,1.0,5.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/302,tst_qnetworkreply: add a test for http abort.,1.0,{},0.0,{'// FIXME: Implement a test that aborts a big HTTP reply<KAIGYO>// a) after the first readyRead()<KAIGYO>// b) immediatly after the get()<KAIGYO>// c) after the finished()<KAIGYO>// The goal is no crash and no irrelevant signals after the abort': 1},1.0,{}
163,663.0,1.0,8.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/663,Replace try/catch blocks in favour of destructors in the event loop.,1.0,{},0.0,{'// uglehack: copied from below': 1},1.0,{}
232,865.0,1.0,6.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/865,remove QT3_SUPPORT in corelib/io,1.0,{},0.0,{'// copy the QObject stuff over (hack)': 1},1.0,{}
231,967.0,1.0,6.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/967,qtmod_test: use `qt-modularization-base' branch for qtwebkit,1.0,"{""# FIXME: currently we support testing a module only against some tracking branch<KAIGYO># (usually `master') of all other modules.<KAIGYO># Later, this should also support parsing of sync.profile."": 1}",1.0,"{""# FIXME: currently we support testing a module only against the `master' of all<KAIGYO># other modules.  Later, this should also support parsing of sync.profile."": 1}",1.0,{}
248,968.0,8.0,27.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/968,Squashed Particle System Stateful Rewrite,1.0,"{'//TODO: Transitions': 1, '//TODO: Infinite & kill zone': 1, '//Click to enflame<KAIGYO>//TODO: Aux emiiters in the state definition (which allows the occasional ball to spontaneously combust)': 1, '//TODO: Split out particle system dependency': 1, '/* TODO: Split out image logic from stochastic state logic<KAIGYO>   Also make sharable<KAIGYO>   Also solve the state data initialization/transfer issue so as to not need to make friends<KAIGYO>*/': 1, ""//TODO: emit this when a psuedostate changes too<KAIGYO>//Batched so that update list doesn't change midway"": 1, '//TODO: Proper list property': 1, '//TODO: Staggered loading (as emitted)': 1, '//qDebug() << """" << perfLevel;<KAIGYO>//perfLevel == Sprites?//TODO: use signals?': 1, '//###Data can be zero if creating an item leads to a reset - this screws things up.<KAIGYO>//TODO: adjust for system?': 1, '//In case an ancestor changed in some way<KAIGYO>//### TODO: some resizeing so that particles can reallocate on size change instead of recreate': 1, '//###For auto-follow on states, perhaps should be in emitter?': 1, '//XXX allow shrinking': 1, '//TODO: a way to Unregister emitters, painters and affectors<KAIGYO>//###Set or uniqueness checking?': 1, '//XXX': 1, '//TODO: Garbage collection?': 1, '//XXX when GC done right': 1, '//TODO: Needed? Or just in component complete?': 1, '//TODO: Reset data<KAIGYO>//    foreach(QSGParticlePainter* p, m_particlePainters)<KAIGYO>//        p->reset();<KAIGYO>//    foreach(QSGParticleEmitter* e, m_emitters)<KAIGYO>//        e->reset();<KAIGYO>//### Do affectors need reset too?': 1, '//TODO: Better placement': 1, ""//XXX shouldn't really be an assert"": 1, '//### Elapsed time never shrinks - may cause problems if left emitting for weeks at a time.': 1, '//TODO: Affect all engines': 1, ""//systemStates && no stochastic states defined. So cut out the engine<KAIGYO>//TODO: It's possible to move to a group that is intermediate and not used by painters or emitters - but right now that will redirect to the default group"": 1, '//One place that could be a lot more efficient...': 4, '//TODO: Can they add custom attributes?': 4, ""//TODO: Perhaps just swap the shaders, and don't mind the extra vector?"": 4, ""//TODO: intermediate levels<KAIGYO>//But we're in colored level (or higher)"": 4, '//Direct bit manipulation is presumably more efficient': 4, ""//TODO: Doesn't this overlap the corners?"": 4, '//TODO: Reset data<KAIGYO>//    foreach (QSGParticlePainter* p, m_particlePainters)<KAIGYO>//        p->reset();<KAIGYO>//    foreach (QSGParticleEmitter* e, m_emitters)<KAIGYO>//        e->reset();<KAIGYO>//### Do affectors need reset too?': 4, '//TODO: Surely this can be done better': 4}",1.0,"{'//TODO: Transitions between modes': 1, '//TODO: emit something? Remember to emit this when a psuedostate changes too': 1, '//TODO: What was this for again?': 1, '//XXX: Is now a vaild intermediate state...': 1, '//TODO: Multiple levels': 1, '//TODO: Staggered loading (as emitted)': 1, '//###Data can be zero if creating an item leads to a reset - this screws things up.<KAIGYO>//TODO: adjust for system?': 1, '//TODO: What if particles switched so indices change but total count is the same?': 1, ""//Shuffle stuff around<KAIGYO>//TODO: In place shuffling because it's faster"": 1, ""//TODO: When group didn't exist before"": 1, '//XXX': 1, ""//XXX:shouldn't assert, but bugs here were hard to find in the past"": 1, '//TODO: a way to Unregister emitters, painters and affectors<KAIGYO>//###Set or uniqueness checking?': 1, '//TODO: Shrink back down! (but it has the problem of trying to remove the dead particles while maintaining integrity)': 1, '            /*TODO:Consider salvaging partial updates, but have to batch changes to a single painter<KAIGYO>            int delta = 0;<KAIGYO>            delta = gd->size - previousSizes[id];<KAIGYO>            foreach(QSGParticlePainter* painter, gd->painters){<KAIGYO>                if(!painter->count() && delta){<KAIGYO>                    painter->reset();<KAIGYO>                    painter->update();<KAIGYO>                }<KAIGYO>                qDebug() << """" << painter << painter->count() << delta;<KAIGYO>                painter->setCount(painter->count() + delta);<KAIGYO>            }<KAIGYO>            */': 1, '//TODO: Needed?': 1, '//TODO: Reset data<KAIGYO>//    foreach(QSGParticlePainter* p, m_particlePainters)<KAIGYO>//        p->reset();<KAIGYO>//    foreach(QSGParticleEmitter* e, m_emitters)<KAIGYO>//        e->reset();<KAIGYO>//### Do affectors need reset too?': 1, '//TODO: Better placement': 1, ""//XXX shouldn't really be an assert"": 1, '//### Elapsed time never shrinks - may cause problems if left emitting for weeks at a time.': 1, ""//Can't find it<KAIGYO>//TODO: Affect all engines"": 1, '//No to states means stay here<KAIGYO>//TODO: emit something? Remember to emit this when a psuedostate changes too': 4, '//One place that could be a lot more efficient...': 4, '//TODO: Can they add custom attributes?': 4, ""//TODO: Perhaps just swap the shaders, and don't mind the extra vector?"": 4, ""//TODO: intermediate levels<KAIGYO>//But we're in colored level (or higher)"": 4, '//Direct bit manipulation is presumably more efficient': 4, ""//TODO: Doesn't this overlap the corners?"": 4, '//TODO: Affect all engines': 4, '//TODO: Surely this can be done better': 4}",1.0,{'//TODO: Affect all engines': '1-4'}
238,969.0,1.0,9.0,0.0,ABANDONED,False,https://codereview.qt-project.org/#/c/969,tiled canvas,1.0,{},0.0,{'//TODO:update(d->context->dirtyRect());': 1},1.0,{}
5,1028.0,1.0,5.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/1028,Implement translation functions for V8,1.0,{},0.0,{'// XXX TODO - Implement translator functions': 1},1.0,{}
64,1060.0,4.0,15.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/1060,Remove references to demos.,1.0,{'//TODO: Transitions between modes': 4},1.0,{'//TODO: Transitions': 4},1.0,{}
33,1161.0,1.0,4.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/1161,QNAM HTTP: Fix canReadLine() for zerocopy,1.0,{},0.0,{'// FIXME zerocopy buffer?': 1},1.0,{}
47,1163.0,6.0,21.0,33.0,MERGED,True,https://codereview.qt-project.org/#/c/1163,Use sync.profile dependencies for checkout,1.0,"{""# FIXME: This implementation does not do any special case checking for webkit,<KAIGYO># which might not be using master and which doesn't have the same internal mirrors"": 1, '# FIXME: When qt5.git is no longer used, this step can be skipped and the module can be built from $base_dir directly': 2, ""# FIXME how do we guarantee we have this SHA1?<KAIGYO># If it's not reachable from a branch obtained from a default `clone', it could be missing.<KAIGYO># Is a SHA1, else is a ref and may need to be fetched"": 5}",1.0,"{""# FIXME: this implementation clones all the modules, even those we don't need.<KAIGYO># It should be improved to get only those modules we need (if at all possible ...)"": 1, ""# FIXME: currently we support testing a module only against some tracking branch<KAIGYO># (usually `master') of all other modules.<KAIGYO># Later, this should also support parsing of sync.profile.<KAIGYO># Also, this code assumes that init-repository always uses `origin' as the remote."": 1, ""# FIXME: this implementation clones all the modules, even those we don't need.<KAIGYO># It should be improved to get only those modules we need (if at all possible ...)<KAIGYO># FIXME: currently we support testing a module only against some tracking branch<KAIGYO># (usually `master') of all other modules.<KAIGYO># Later, this should also support parsing of sync.profile."": 3}",1.0,{}
153,1200.0,8.0,25.0,10.0,MERGED,True,https://codereview.qt-project.org/#/c/1200,Refactor ListView and GridView implementations,1.0,{},0.0,{'// XXX todo - the original did scene()->removeItem().  Why?': 1},1.0,{}
82,1341.0,1.0,3.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/1341,Merge branch 'v8',1.0,{},0.0,{'// the client wishes to release the resource in this SRD.': 1},1.0,{}
100,1381.0,1.0,7.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/1381,QNAM: Remove QNetworkAccessHttpBackend,1.0,{},0.0,"{""// for safety reasons, we don't know what the operation does"": 1, '// Move the delegate to the http thread': 1, '// FIXME Maybe we can get rid of this whole architecture part': 1, '// We know that readBuffer maximum size limiting is broken since quite a while.<KAIGYO>// The task to fix this is QTBUG-15065': 1, '// We need to usa a copy for calling writeDownstreamData as we could<KAIGYO>// possibly recurse into this this function when we call<KAIGYO>// appendDownstreamDataSignalEmissions because the user might call<KAIGYO>// processEvents() or spin an event loop when this occur.': 1}",1.0,{}
140,1465.0,2.0,6.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/1465,Rewrite the canvas item's paint logic.,1.0,{'//TODO:XXX': 1},1.0,"{'//TODO:update(d->context->dirtyRect());': 1, '//        painter->setMatrix(state.matrix, false);<KAIGYO>//        QPainterPath tmp = state.matrix.inverted().map(path); //why?<KAIGYO>//        painter->strokePath(tmp, painter->pen());': 1}",1.0,{}
127,1479.0,1.0,3.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/1479,Enable support for QObject based module APIs,1.0,"{""// XXX TODO: Currently module APIs are implemented against QScriptValues.  Consequently we<KAIGYO>// can't do anything for script module apis here until the QtScript/V8 binding is complete."": 1}",1.0,"{""// XXX TODO: Currently module APIs are implemented against QScriptValues.  Consequently we<KAIGYO>// can't do anything here until the QtScript/V8 binding is complete."": 1}",1.0,{}
130,1484.0,1.0,7.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/1484,Refactor QByteArray to allow for const data,1.0,{},0.0,{'// FIXME count from 0 to make it fail': 1},1.0,{}
309,1735.0,1.0,2.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/1735,Rename QPixmapData to QPlatformPixmap.,1.0,"{""// TODO: Replace the pixmap's data with a new QX11PlatformPixmap"": 1, ""// TODO: Replace the pixmap's data with a new QX11PlatformPixmap<KAIGYO>//    QPixmap - yes, create the EGLSurface but store it in QX11PlatformPixmap::gl_surface"": 1}",1.0,"{""// TODO: Replace the pixmap's data with a new QX11PixmapData"": 1, ""// TODO: Replace the pixmap's data with a new QX11PixmapData<KAIGYO>//    QPixmap - yes, create the EGLSurface but store it in QX11PixmapData::gl_surface"": 1}",1.0,{}
225,1744.0,1.0,8.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/1744,Implement todos in touchscreen generic plug-in.,1.0,{},0.0,"{""// ### TODO Add timestamps and remove points that stay unchanged for too long.<KAIGYO>// The user's finger may fall off the touchscreen, which means there will be<KAIGYO>// no released event sent ever for that particular point."": 1}",1.0,{}
275,1909.0,2.0,22.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/1909,Drive ParticleSystem with an animation instead,1.0,{'//error in initialization<KAIGYO>//### Elapsed time never shrinks - may cause problems if left emitting for weeks at a time.': 1},1.0,"{'//TODO: Better placement': 1, '//### Elapsed time never shrinks - may cause problems if left emitting for weeks at a time.': 1}",1.0,{}
15,2054.0,1.0,4.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/2054,Notify when the TextInput cursorRectangle property changes within pre-edit,1.0,"{""//TODO: Only update rect between pos's"": 1}",1.0,"{""//TODO: Only update rect between pos's"": 1}",1.0,{}
31,2075.0,1.0,3.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/2075,Allow object to be accessed by multiple QDeclarativeEngines,1.0,{},0.0,{'// XXX aakenend': 1},1.0,{}
108,2161.0,5.0,12.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/2161,Use QFreeList for timer id allocation,1.0,{},0.0,{'//.loadAcquire(); // ### FIXME Proper memory ordering semantics': 1},1.0,{}
103,2194.0,2.0,5.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/2194,Remove nativeimagehandleprovider.,1.0,{},0.0,{'// Support QS60Style in more efficient skin graphics retrieval.': 1},1.0,{}
127,2256.0,1.0,4.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/2256,Guard macdeployqt against @rpath and @loader_path too.,1.0,{},0.0,{'// frameworks and dylibs lists themselves as a dependency.': 1},1.0,{}
160,2261.0,2.0,5.0,3.0,MERGED,True,https://codereview.qt-project.org/#/c/2261,Fix positioning of items after move,1.0,"{""// Ensure we don't cause an ugly list scroll."": 1, '// Only move forwards - flip if backwards moving': 1}",1.0,{'// move outside visible area': 1},1.0,{}
152,2270.0,1.0,5.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/2270,Renamed ShaderEffectItem to ShaderEffect and some API changes.,1.0,"{'// TODO: Remove after grace period.': 1, '// TODO: Remove after grace period.<KAIGYO>// TODO: Remove after grace period.': 1, '// TODO: Replace QVariant with QSize after grace period.': 1, '// TODO: Remove !m_deprecatedMesh check after grace period.': 1, '// TODO: Copy better solution in QSGShaderEffect when they find it.': 1}",1.0,{'// TODO: Copy better solution in QSGShaderEffectItem when they find it.': 1},1.0,{}
140,2291.0,1.0,3.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/2291,Mark the QJSValue array test as xfail,1.0,{},0.0,"{'// FIXME v8 have a limitation that max size of an array is 512 MB (it is defined in object.h FixedArray::kMaxSize)<KAIGYO>// It is wrong as ECMA standard says something different (15.4). It have to be reported, for now try to not crash.': 1}",1.0,{}
139,2293.0,1.0,3.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/2293,Fix failing QJSValue::evaluate auto-test,1.0,{'// ###FIXME: No support for the line number of an uncaught exception': 1},1.0,{'// ###FIXME: No support for the line number of an uncaught exception': 1},1.0,{}
172,2321.0,1.0,2.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/2321,Make QPlatformIntegration not have a factory for eventdispatcher,1.0,{},0.0,"{'// A bit hacky to do this here, but we need an eventloop before we can instantiate<KAIGYO>// the input context.': 1}",1.0,{}
205,2398.0,3.0,10.0,3.0,MERGED,True,https://codereview.qt-project.org/#/c/2398,Fix QJSEngine::newQObject ownership behaviour,1.0,{},0.0,"{'// ###FIXME: ScriptOwnership': 1, '// FIXME: ownership tests need to be revivewed': 2}",1.0,{}
216,2439.0,2.0,4.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/2439,Enable globalObjectProperties_enumerate test.,1.0,{},0.0,{'// ###FIXME: No QScriptValueIterator API': 1},1.0,{}
218,2440.0,3.0,5.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/2440,Enable tst_QJSEngine::stacktrace test.,1.0,"{'// QEXPECT_FAIL("""", Abort);<KAIGYO>// FIXME? it is not standard.<KAIGYO>//QCOMPARE(result.property("""").toString(), fileName);<KAIGYO>//QCOMPARE(result.property("""").toInt32(), 9);': 1, '// FIXME? it is not standard.<KAIGYO>// QVERIFY(stack.isArray());<KAIGYO>//QCOMPARE(stack.property("""").toInt32(), 7);': 1, '//    FIXME? it is not standard.<KAIGYO>//    {<KAIGYO>//        QJSValue bt = result.property("""").call(result);<KAIGYO>//        QCOMPARE(qjsvalue_cast<QStringList>(bt), backtrace);<KAIGYO>//    }': 1}",1.0,{'// ###FIXME: No QScriptValueIterator API': 1},1.0,{}
251,2512.0,2.0,6.0,4.0,MERGED,True,https://codereview.qt-project.org/#/c/2512,Improve QJSValueIterator implementation.,1.0,{},0.0,"{'// FIXME (Qt5) This class should be refactored. It should use the common Iterator interface.<KAIGYO>// FIXME it could be faster!': 1, '// FIXME we need newer V8!<KAIGYO>//names = obj->GetOwnPropertyNames();': 1, '// it is suboptimal, it would be better to write iterator instead': 1, '//FIXME: we need register this QJSVAlueIterator': 1, '// FIXME leak ?': 1}",1.0,{}
353,2614.0,8.0,14.0,16.0,MERGED,True,https://codereview.qt-project.org/#/c/2614,Enable v8 debugging,1.0,{'//TODO::v8::Exception': 1},1.0,"{'//        if (/*object.isQObject() &&*/ it.value().isFunction()) {<KAIGYO>//            // Cosmetics: skip all functions and slot, there are too many of them,<KAIGYO>//            // and it is not useful information in the debugger.<KAIGYO>//            continue;<KAIGYO>//        }<KAIGYO>//        JSAgentWatchData data = fromScriptValue(it.name(), it.value());<KAIGYO>//        result.append(data);<KAIGYO>//    }<KAIGYO>//    if (result.isEmpty()) {<KAIGYO>//        JSAgentWatchData data;<KAIGYO>//        data.name = """";<KAIGYO>//        data.hasChildren = false;<KAIGYO>//        data.value = """";<KAIGYO>//        data.objectId = 0;<KAIGYO>//        result.append(data);<KAIGYO>//    }<KAIGYO>    return result;<KAIGYO>}<KAIGYO><KAIGYO>static QString fileName(const QString &fileUrl)<KAIGYO>{<KAIGYO>    int lastDelimiterPos = fileUrl.lastIndexOf(QLatin1Char(\'/\'));<KAIGYO>    return fileUrl.mid(lastDelimiterPos, fileUrl.size() - lastDelimiterPos);<KAIGYO>}<KAIGYO><KAIGYO>void QJSDebuggerAgentPrivate::recordKnownObjects(const QList<JSAgentWatchData>& list)<KAIGYO>{<KAIGYO>    foreach (const JSAgentWatchData &data, list)<KAIGYO>        knownObjectIds << data.objectId;<KAIGYO>}<KAIGYO><KAIGYO>QList<JSAgentWatchData> QJSDebuggerAgentPrivate::getLocals(void *ctx)<KAIGYO>{<KAIGYO>    QList<JSAgentWatchData> locals;<KAIGYO>//    if (ctx) {<KAIGYO>//        QScriptValue activationObject = ctx->activationObject();<KAIGYO>//        QScriptValue thisObject = ctx->thisObject();<KAIGYO>//        locals = expandObject(activationObject);<KAIGYO>//        if (thisObject.isObject()<KAIGYO>//                && thisObject.objectId() != engine()->globalObject().objectId()<KAIGYO>//                && QScriptValueIterator(thisObject).hasNext())<KAIGYO>//            locals.prepend(fromScriptValue(QLatin1String(""""), thisObject));<KAIGYO>//        recordKnownObjects(locals);<KAIGYO>//        knownObjectIds << activationObject.objectId();<KAIGYO>//    }<KAIGYO>    return locals;<KAIGYO>}<KAIGYO><KAIGYO>/*!<KAIGYO>  Constructs a new agent for the given \\a engine. The agent will<KAIGYO>  report debugging-related events (e.g. step completion) to the given<KAIGYO>  \\a backend.<KAIGYO>*/': 4, '//TODO: feedback': 4}",1.0,{}
311,2677.0,1.0,2.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/2677,Ported use of QInputContext to QPlatformInputContext for now,1.0,{},0.0,"{'// ### refactor: port properly...': 1, '//            if (QInputContext *ic = inputContext())<KAIGYO>//                ic->reset();<KAIGYO>// ### refactor: port properly': 1, '// ### refactor: port properly': 1, '//        if (canvas() && canvas() == qApp->focusWidget()) {<KAIGYO>//            QEvent event(QEvent::RequestSoftwareInputPanel);<KAIGYO>//            QApplication::sendEvent(canvas(), &event);<KAIGYO>//        }<KAIGYO>// ### refactor: port properly': 1}",1.0,{}
330,2720.0,1.0,4.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/2720,Revise QDeclarativeChangeSet.,1.0,"{'// Insert,then move': 1}",1.0,"{'// Moved signals.': 1, '// Insert queued moved signals ordered by destination position.': 1, '// No merging of moves yet.<KAIGYO>//    QTest::newRow("""")<KAIGYO>//            << (SignalList() << Move(5, 7, 13) << Move(5, 8, 12))<KAIGYO>//            << (SignalList() << Move(5, 10, 10));': 1}",1.0,{}
437,2735.0,2.0,7.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/2735,Add documentation,1.0,"{'/*!<KAIGYO>    \\qmlproperty bool QtQuick2::Flickable::flicking<KAIGYO>    \\qmlproperty bool QtQuick2::Flickable::flickingHorizontally<KAIGYO>    \\qmlproperty bool QtQuick2::Flickable::flickingVertically<KAIGYO><KAIGYO>    These properties describe whether the view is currently moving horizontally,<KAIGYO>    vertically or in either direction, due to the user flicking the view.<KAIGYO>*/': 1, '/*!<KAIGYO>    \\qmlproperty bool QtQuick2::Flickable::moving<KAIGYO>    \\qmlproperty bool QtQuick2::Flickable::movingHorizontally<KAIGYO>    \\qmlproperty bool QtQuick2::Flickable::movingVertically<KAIGYO><KAIGYO>    These properties describe whether the view is currently moving horizontally,<KAIGYO>    vertically or in either direction, due to the user either dragging or<KAIGYO>    flicking the view.<KAIGYO>*/': 1, '/*!<KAIGYO>    \\qmlclass GridView QSGGridView<KAIGYO>    \\inqmlmodule QtQuick 2<KAIGYO>    \\ingroup qml-view-elements<KAIGYO><KAIGYO>    \\inherits Flickable<KAIGYO>    \\brief The GridView item provides a grid view of items provided by a model.<KAIGYO><KAIGYO>    A GridView displays data from models created from built-in QML elements like ListModel<KAIGYO>    and XmlListModel, or custom model classes defined in C++ that inherit from<KAIGYO>    QAbstractListModel.<KAIGYO><KAIGYO>    A GridView has a \\l model, which defines the data to be displayed, and<KAIGYO>    a \\l delegate, which defines how the data should be displayed. Items in a<KAIGYO>    GridView are laid out horizontally or vertically. Grid views are inherently flickable<KAIGYO>    as GridView inherits from \\l Flickable.<KAIGYO><KAIGYO>    \\section1 Example Usage<KAIGYO><KAIGYO>    The following example shows the definition of a simple list model defined<KAIGYO>    in a file called \\c ContactModel.qml:<KAIGYO><KAIGYO>    \\snippet doc/src/snippets/declarative/gridview/ContactModel.qml 0<KAIGYO><KAIGYO>    \\div {class=""""}<KAIGYO>    \\inlineimage gridview-simple.png<KAIGYO>    \\enddiv<KAIGYO><KAIGYO>    This model can be referenced as \\c ContactModel in other QML files. See \\l{QML Modules}<KAIGYO>    for more information about creating reusable components like this.<KAIGYO><KAIGYO>    Another component can display this model data in a GridView, as in the following<KAIGYO>    example, which creates a \\c ContactModel component for its model, and a \\l Column element<KAIGYO>    (containing \\l Image and \\l Text elements) for its delegate.<KAIGYO><KAIGYO>    \\clearfloat<KAIGYO>    \\snippet doc/src/snippets/declarative/gridview/gridview.qml import<KAIGYO>    \\codeline<KAIGYO>    \\snippet doc/src/snippets/declarative/gridview/gridview.qml classdocs simple<KAIGYO><KAIGYO>    \\div {class=""""}<KAIGYO>    \\inlineimage gridview-highlight.png<KAIGYO>    \\enddiv<KAIGYO><KAIGYO>    The view will create a new delegate for each item in the model. Note that the delegate<KAIGYO>    is able to access the model\'s \\c name and \\c portrait data directly.<KAIGYO><KAIGYO>    An improved grid view is shown below. The delegate is visually improved and is moved<KAIGYO>    into a separate \\c contactDelegate component.<KAIGYO><KAIGYO>    \\clearfloat<KAIGYO>    \\snippet doc/src/snippets/declarative/gridview/gridview.qml classdocs advanced<KAIGYO><KAIGYO>    The currently selected item is highlighted with a blue \\l Rectangle using the \\l highlight property,<KAIGYO>    and \\c focus is set to \\c true to enable keyboard navigation for the grid view.<KAIGYO>    The grid view itself is a focus scope (see \\l{qmlfocus#Acquiring Focus and Focus Scopes}{the focus documentation page} for more details).<KAIGYO><KAIGYO>    Delegates are instantiated as needed and may be destroyed at any time.<KAIGYO>    State should \\e never be stored in a delegate.<KAIGYO><KAIGYO>    GridView attaches a number of properties to the root item of the delegate, for example<KAIGYO>    \\c {GridView.isCurrentItem}.  In the following example, the root delegate item can access<KAIGYO>    this attached property directly as \\c GridView.isCurrentItem, while the child<KAIGYO>    \\c contactInfo object must refer to this property as \\c wrapper.GridView.isCurrentItem.<KAIGYO><KAIGYO>    \\snippet doc/src/snippets/declarative/gridview/gridview.qml isCurrentItem<KAIGYO><KAIGYO>    \\note Views do not set the \\l{Item::}{clip} property automatically.<KAIGYO>    If the view is not clipped by another item or the screen, it will be necessary<KAIGYO>    to set this property to true in order to clip the items that are partially or<KAIGYO>    fully outside the view.<KAIGYO><KAIGYO>    \\sa {declarative/modelviews/gridview}{GridView example}<KAIGYO>*/': 1, '/*!<KAIGYO>  \\qmlproperty enumeration QtQuick2::GridView::layoutDirection<KAIGYO>  This property holds the layout direction of the grid.<KAIGYO><KAIGYO>    Possible values:<KAIGYO><KAIGYO>  \\list<KAIGYO>  \\o Qt.LeftToRight (default) - Items will be laid out starting in the top, left corner. The flow is<KAIGYO>  dependent on the \\l GridView::flow property.<KAIGYO>  \\o Qt.RightToLeft - Items will be laid out starting in the top, right corner. The flow is dependent<KAIGYO>  on the \\l GridView::flow property.<KAIGYO>  \\endlist<KAIGYO><KAIGYO>  \\bold Note: If GridView::flow is set to GridView.LeftToRight, this is not to be confused if<KAIGYO>  GridView::layoutDirection is set to Qt.RightToLeft. The GridView.LeftToRight flow value simply<KAIGYO>  indicates that the flow is horizontal.<KAIGYO>*/': 1, '/*!<KAIGYO>    \\qmlmethod QtQuick2::GridView::positionViewAtIndex(int index, PositionMode mode)<KAIGYO>    Positions the view such that the \\a index is at the position specified by<KAIGYO>    \\a mode:<KAIGYO><KAIGYO>    \\list<KAIGYO>    \\o GridView.Beginning - position item at the top (or left for \\c GridView.TopToBottom flow) of the view.<KAIGYO>    \\o GridView.Center - position item in the center of the view.<KAIGYO>    \\o GridView.End - position item at bottom (or right for horizontal orientation) of the view.<KAIGYO>    \\o GridView.Visible - if any part of the item is visible then take no action, otherwise<KAIGYO>    bring the item into view.<KAIGYO>    \\o GridView.Contain - ensure the entire item is visible.  If the item is larger than<KAIGYO>    the view the item is positioned at the top (or left for \\c GridView.TopToBottom flow) of the view.<KAIGYO>    \\endlist<KAIGYO><KAIGYO>    If positioning the view at the index would cause empty space to be displayed at<KAIGYO>    the beginning or end of the view, the view will be positioned at the boundary.<KAIGYO><KAIGYO>    It is not recommended to use \\l {Flickable::}{contentX} or \\l {Flickable::}{contentY} to position the view<KAIGYO>    at a particular index.  This is unreliable since removing items from the start<KAIGYO>    of the view does not cause all other items to be repositioned.<KAIGYO>    The correct way to bring an item into view is with \\c positionViewAtIndex.<KAIGYO><KAIGYO>    \\bold Note: methods should only be called after the Component has completed.  To position<KAIGYO>    the view at startup, this method should be called by Component.onCompleted.  For<KAIGYO>    example, to position the view at the end:<KAIGYO><KAIGYO>    \\code<KAIGYO>    Component.onCompleted: positionViewAtIndex(count - 1, GridView.Beginning)<KAIGYO>    \\endcode<KAIGYO>*/': 1, ""/*!<KAIGYO>    \\qmlclass KeyNavigation QSGKeyNavigationAttached<KAIGYO>    \\inqmlmodule QtQuick 2<KAIGYO>    \\ingroup qml-basic-interaction-elements<KAIGYO>    \\brief The KeyNavigation attached property supports key navigation by arrow keys.<KAIGYO><KAIGYO>    Key-based user interfaces commonly allow the use of arrow keys to navigate between<KAIGYO>    focusable items.  The KeyNavigation attached property enables this behavior by providing a<KAIGYO>    convenient way to specify the item that should gain focus when an arrow or tab key is pressed.<KAIGYO><KAIGYO>    The following example provides key navigation for a 2x2 grid of items:<KAIGYO><KAIGYO>    \\snippet doc/src/snippets/declarative/keynavigation.qml 0<KAIGYO><KAIGYO>    The top-left item initially receives focus by setting \\l {Item::}{focus} to<KAIGYO>    \\c true. When an arrow key is pressed, the focus will move to the<KAIGYO>    appropriate item, as defined by the value that has been set for<KAIGYO>    the KeyNavigation \\l left, \\l right, \\l up or \\l down properties.<KAIGYO><KAIGYO>    Note that if a KeyNavigation attached property receives the key press and release<KAIGYO>    events for a requested arrow or tab key, the event is accepted and does not<KAIGYO>    propagate any further.<KAIGYO><KAIGYO>    By default, KeyNavigation receives key events after the item to which it is attached.<KAIGYO>    If the item accepts the key event, the KeyNavigation attached property will not<KAIGYO>    receive an event for that key.  Setting the \\l priority property to<KAIGYO>    \\c KeyNavigation.BeforeItem allows the event to be used for key navigation<KAIGYO>    before the item, rather than after.<KAIGYO><KAIGYO>    If item to which the focus is switching is not enabled or visible, an attempt will<KAIGYO>    be made to skip this item and focus on the next. This is possible if there are<KAIGYO>    a chain of items with the same KeyNavigation handler. If multiple items in a row are not enabled<KAIGYO>    or visible, they will also be skipped.<KAIGYO><KAIGYO>    KeyNavigation will implicitly set the other direction to return focus to this item. So if you set<KAIGYO>    \\l left to another item, \\l right will be set on that item's KeyNavigation to set focus back to this<KAIGYO>    item. However, if that item's KeyNavigation has had right explicitly set then no change will occur.<KAIGYO>    This means that the above example could have been written, with the same behaviour, without specifing<KAIGYO>    KeyNavigation.right or KeyNavigation.down for any of the items.<KAIGYO><KAIGYO>    \\sa {Keys}{Keys attached property}<KAIGYO>*/"": 1, '// XXX todo - we need to be able to handle common parents better and detect': 1, '/*!<KAIGYO>    \\property QSGItem::smooth<KAIGYO>    \\brief whether the item is smoothly transformed.<KAIGYO><KAIGYO>    This property is provided purely for the purpose of optimization. Turning<KAIGYO>    smooth transforms off is faster, but looks worse; turning smooth<KAIGYO>    transformations on is slower, but looks better.<KAIGYO><KAIGYO>    By default smooth transformations are off.<KAIGYO>*/': 1, '/*!<KAIGYO>    \\enum QSGItem::TransformOrigin<KAIGYO><KAIGYO>    Controls the point about which simple transforms like scale apply.<KAIGYO><KAIGYO>    \\value TopLeft The top-left corner of the item.<KAIGYO>    \\value Top The center point of the top of the item.<KAIGYO>    \\value TopRight The top-right corner of the item.<KAIGYO>    \\value Left The left most point of the vertical middle.<KAIGYO>    \\value Center The center of the item.<KAIGYO>    \\value Right The right most point of the vertical middle.<KAIGYO>    \\value BottomLeft The bottom-left corner of the item.<KAIGYO>    \\value Bottom The center point of the bottom of the item.<KAIGYO>    \\value BottomRight The bottom-right corner of the item.<KAIGYO>*/': 1, ""/*!<KAIGYO>    \\qmlclass ListView QSGListView<KAIGYO>    \\inqmlmodule QtQuick 2<KAIGYO>    \\ingroup qml-view-elements<KAIGYO>    \\inherits Flickable<KAIGYO>    \\brief The ListView item provides a list view of items provided by a model.<KAIGYO><KAIGYO>    A ListView displays data from models created from built-in QML elements like ListModel<KAIGYO>    and XmlListModel, or custom model classes defined in C++ that inherit from<KAIGYO>    QAbstractListModel.<KAIGYO><KAIGYO>    A ListView has a \\l model, which defines the data to be displayed, and<KAIGYO>    a \\l delegate, which defines how the data should be displayed. Items in a<KAIGYO>    ListView are laid out horizontally or vertically. List views are inherently<KAIGYO>    flickable because ListView inherits from \\l Flickable.<KAIGYO><KAIGYO>    \\section1 Example Usage<KAIGYO><KAIGYO>    The following example shows the definition of a simple list model defined<KAIGYO>    in a file called \\c ContactModel.qml:<KAIGYO><KAIGYO>    \\snippet doc/src/snippets/declarative/listview/ContactModel.qml 0<KAIGYO><KAIGYO>    Another component can display this model data in a ListView, like this:<KAIGYO><KAIGYO>    \\snippet doc/src/snippets/declarative/listview/listview.qml import<KAIGYO>    \\codeline<KAIGYO>    \\snippet doc/src/snippets/declarative/listview/listview.qml classdocs simple<KAIGYO><KAIGYO>    \\image listview-simple.png<KAIGYO><KAIGYO>    Here, the ListView creates a \\c ContactModel component for its model, and a \\l Text element<KAIGYO>    for its delegate. The view will create a new \\l Text component for each item in the model. Notice<KAIGYO>    the delegate is able to access the model's \\c name and \\c number data directly.<KAIGYO><KAIGYO>    An improved list view is shown below. The delegate is visually improved and is moved<KAIGYO>    into a separate \\c contactDelegate component.<KAIGYO><KAIGYO>    \\snippet doc/src/snippets/declarative/listview/listview.qml classdocs advanced<KAIGYO>    \\image listview-highlight.png<KAIGYO><KAIGYO>    The currently selected item is highlighted with a blue \\l Rectangle using the \\l highlight property,<KAIGYO>    and \\c focus is set to \\c true to enable keyboard navigation for the list view.<KAIGYO>    The list view itself is a focus scope (see \\l{qmlfocus#Acquiring Focus and Focus Scopes}{the focus documentation page} for more details).<KAIGYO><KAIGYO>    Delegates are instantiated as needed and may be destroyed at any time.<KAIGYO>    State should \\e never be stored in a delegate.<KAIGYO><KAIGYO>    ListView attaches a number of properties to the root item of the delegate, for example<KAIGYO>    \\c {ListView.isCurrentItem}.  In the following example, the root delegate item can access<KAIGYO>    this attached property directly as \\c ListView.isCurrentItem, while the child<KAIGYO>    \\c contactInfo object must refer to this property as \\c wrapper.ListView.isCurrentItem.<KAIGYO><KAIGYO>    \\snippet doc/src/snippets/declarative/listview/listview.qml isCurrentItem<KAIGYO><KAIGYO>    \\note Views do not enable \\e clip automatically.  If the view<KAIGYO>    is not clipped by another item or the screen, it will be necessary<KAIGYO>    to set \\e {clip: true} in order to have the out of view items clipped<KAIGYO>    nicely.<KAIGYO><KAIGYO>    \\sa {QML Data Models}, GridView, {declarative/modelviews/listview}{ListView examples}<KAIGYO>*/"": 1, '/*!<KAIGYO>    \\qmlproperty int QtQuick2::ListView::cacheBuffer<KAIGYO>    This property determines whether delegates are retained outside the<KAIGYO>    visible area of the view.<KAIGYO><KAIGYO>    If this value is non-zero, the view keeps as many delegates<KAIGYO>    instantiated as it can fit within the buffer specified.  For example,<KAIGYO>    if in a vertical view the delegate is 20 pixels high and \\c cacheBuffer is<KAIGYO>    set to 40, then up to 2 delegates above and 2 delegates below the visible<KAIGYO>    area may be retained.<KAIGYO><KAIGYO>    Note that cacheBuffer is not a pixel buffer - it only maintains additional<KAIGYO>    instantiated delegates.<KAIGYO><KAIGYO>    Setting this value can improve the smoothness of scrolling behavior at the expense<KAIGYO>    of additional memory usage.  It is not a substitute for creating efficient<KAIGYO>    delegates; the fewer elements in a delegate, the faster a view can be<KAIGYO>    scrolled.<KAIGYO>*/': 1, '/*!<KAIGYO>    \\qmlproperty real QtQuick2::ListView::highlightMoveSpeed<KAIGYO>    \\qmlproperty int QtQuick2::ListView::highlightMoveDuration<KAIGYO>    \\qmlproperty real QtQuick2::ListView::highlightResizeSpeed<KAIGYO>    \\qmlproperty int QtQuick2::ListView::highlightResizeDuration<KAIGYO><KAIGYO>    These properties hold the move and resize animation speed of the highlight delegate.<KAIGYO><KAIGYO>    \\l highlightFollowsCurrentItem must be true for these properties<KAIGYO>    to have effect.<KAIGYO><KAIGYO>    The default value for the speed properties is 400 pixels/second.<KAIGYO>    The default value for the duration properties is -1, i.e. the<KAIGYO>    highlight will take as much time as necessary to move at the set speed.<KAIGYO><KAIGYO>    These properties have the same characteristics as a SmoothedAnimation.<KAIGYO><KAIGYO>    \\sa highlightFollowsCurrentItem<KAIGYO>*/': 1, '/*!<KAIGYO>    \\qmlmethod QtQuick2::ListView::positionViewAtIndex(int index, PositionMode mode)<KAIGYO><KAIGYO>    Positions the view such that the \\a index is at the position specified by<KAIGYO>    \\a mode:<KAIGYO><KAIGYO>    \\list<KAIGYO>    \\o ListView.Beginning - position item at the top (or left for horizontal orientation) of the view.<KAIGYO>    \\o ListView.Center - position item in the center of the view.<KAIGYO>    \\o ListView.End - position item at bottom (or right for horizontal orientation) of the view.<KAIGYO>    \\o ListView.Visible - if any part of the item is visible then take no action, otherwise<KAIGYO>    bring the item into view.<KAIGYO>    \\o ListView.Contain - ensure the entire item is visible.  If the item is larger than<KAIGYO>    the view the item is positioned at the top (or left for horizontal orientation) of the view.<KAIGYO>    \\endlist<KAIGYO><KAIGYO>    If positioning the view at \\a index would cause empty space to be displayed at<KAIGYO>    the beginning or end of the view, the view will be positioned at the boundary.<KAIGYO><KAIGYO>    It is not recommended to use \\l {Flickable::}{contentX} or \\l {Flickable::}{contentY} to position the view<KAIGYO>    at a particular index.  This is unreliable since removing items from the start<KAIGYO>    of the list does not cause all other items to be repositioned, and because<KAIGYO>    the actual start of the view can vary based on the size of the delegates.<KAIGYO>    The correct way to bring an item into view is with \\c positionViewAtIndex.<KAIGYO><KAIGYO>    \\bold Note: methods should only be called after the Component has completed.  To position<KAIGYO>    the view at startup, this method should be called by Component.onCompleted.  For<KAIGYO>    example, to position the view at the end:<KAIGYO><KAIGYO>    \\code<KAIGYO>    Component.onCompleted: positionViewAtIndex(count - 1, ListView.Beginning)<KAIGYO>    \\endcode<KAIGYO>*/': 1, '/*!<KAIGYO>    \\qmlsignal QtQuick2::MouseArea::onExited()<KAIGYO><KAIGYO>    This handler is called when the mouse exits the mouse area.<KAIGYO><KAIGYO>    By default the onExited handler is only called while a button is<KAIGYO>    pressed. Setting hoverEnabled to true enables handling of<KAIGYO>    onExited when no mouse button is pressed.<KAIGYO><KAIGYO>    The example below shows a fairly typical relationship between<KAIGYO>    two MouseAreas, with \\c mouseArea2 on top of \\c mouseArea1. Moving the<KAIGYO>    mouse into \\c mouseArea2 from \\c mouseArea1 will cause \\c onExited<KAIGYO>    to be called for \\c mouseArea1.<KAIGYO>    \\qml<KAIGYO>    Rectangle {<KAIGYO>        width: 400; height: 400<KAIGYO>        MouseArea {<KAIGYO>            id: mouseArea1<KAIGYO>            anchors.fill: parent<KAIGYO>            hoverEnabled: true<KAIGYO>        }<KAIGYO>        MouseArea {<KAIGYO>            id: mouseArea2<KAIGYO>            width: 100; height: 100<KAIGYO>            anchors.centerIn: parent<KAIGYO>            hoverEnabled: true<KAIGYO>        }<KAIGYO>    }<KAIGYO>    \\endqml<KAIGYO><KAIGYO>    If instead you give the two mouseAreas a parent-child relationship,<KAIGYO>    moving the mouse into \\c mouseArea2 from \\c mouseArea1 will \\b not<KAIGYO>    cause \\c onExited to be called for \\c mouseArea1. Instead, they will<KAIGYO>    both be considered to be simultaneously hovered.<KAIGYO><KAIGYO>    \\sa hoverEnabled<KAIGYO>*/': 1, '/*!<KAIGYO>    \\qmlproperty Item QtQuick2::MouseArea::drag.target<KAIGYO>    \\qmlproperty bool QtQuick2::MouseArea::drag.active<KAIGYO>    \\qmlproperty enumeration QtQuick2::MouseArea::drag.axis<KAIGYO>    \\qmlproperty real QtQuick2::MouseArea::drag.minimumX<KAIGYO>    \\qmlproperty real QtQuick2::MouseArea::drag.maximumX<KAIGYO>    \\qmlproperty real QtQuick2::MouseArea::drag.minimumY<KAIGYO>    \\qmlproperty real QtQuick2::MouseArea::drag.maximumY<KAIGYO>    \\qmlproperty bool QtQuick2::MouseArea::drag.filterChildren<KAIGYO><KAIGYO>    \\c drag provides a convenient way to make an item draggable.<KAIGYO><KAIGYO>    \\list<KAIGYO>    \\i \\c drag.target specifies the id of the item to drag.<KAIGYO>    \\i \\c drag.active specifies if the target item is currently being dragged.<KAIGYO>    \\i \\c drag.axis specifies whether dragging can be done horizontally (\\c Drag.XAxis), vertically (\\c Drag.YAxis), or both (\\c Drag.XandYAxis)<KAIGYO>    \\i \\c drag.minimum and \\c drag.maximum limit how far the target can be dragged along the corresponding axes.<KAIGYO>    \\endlist<KAIGYO><KAIGYO>    The following example displays a \\l Rectangle that can be dragged along the X-axis. The opacity<KAIGYO>    of the rectangle is reduced when it is dragged to the right.<KAIGYO><KAIGYO>    \\snippet doc/src/snippets/declarative/mousearea/mousearea.qml drag<KAIGYO><KAIGYO>    \\note Items cannot be dragged if they are anchored for the requested<KAIGYO>    \\c drag.axis. For example, if \\c anchors.left or \\c anchors.right was set<KAIGYO>    for \\c rect in the above example, it cannot be dragged along the X-axis.<KAIGYO>    This can be avoided by settng the anchor value to \\c undefined in<KAIGYO>    an \\l onPressed handler.<KAIGYO><KAIGYO>    If \\c drag.filterChildren is set to true, a drag can override descendant MouseAreas.  This<KAIGYO>    enables a parent MouseArea to handle drags, for example, while descendants handle clicks:<KAIGYO><KAIGYO>    \\snippet doc/src/snippets/declarative/mousearea/mouseareadragfilter.qml dragfilter<KAIGYO><KAIGYO>*/': 1, '/*!<KAIGYO>    \\qmlclass PathView QSGPathView<KAIGYO>    \\inqmlmodule QtQuick 2<KAIGYO>    \\ingroup qml-view-elements<KAIGYO>    \\brief The PathView element lays out model-provided items on a path.<KAIGYO>    \\inherits Item<KAIGYO><KAIGYO>    A PathView displays data from models created from built-in QML elements like ListModel<KAIGYO>    and XmlListModel, or custom model classes defined in C++ that inherit from<KAIGYO>    QAbstractListModel.<KAIGYO><KAIGYO>    The view has a \\l model, which defines the data to be displayed, and<KAIGYO>    a \\l delegate, which defines how the data should be displayed.<KAIGYO>    The \\l delegate is instantiated for each item on the \\l path.<KAIGYO>    The items may be flicked to move them along the path.<KAIGYO><KAIGYO>    For example, if there is a simple list model defined in a file \\c ContactModel.qml like this:<KAIGYO><KAIGYO>    \\snippet doc/src/snippets/declarative/pathview/ContactModel.qml 0<KAIGYO><KAIGYO>    This data can be represented as a PathView, like this:<KAIGYO><KAIGYO>    \\snippet doc/src/snippets/declarative/pathview/pathview.qml 0<KAIGYO><KAIGYO>    \\image pathview.gif<KAIGYO><KAIGYO>    (Note the above example uses PathAttribute to scale and modify the<KAIGYO>    opacity of the items as they rotate. This additional code can be seen in the<KAIGYO>    PathAttribute documentation.)<KAIGYO><KAIGYO>    PathView does not automatically handle keyboard navigation.  This is because<KAIGYO>    the keys to use for navigation will depend upon the shape of the path.  Navigation<KAIGYO>    can be added quite simply by setting \\c focus to \\c true and calling<KAIGYO>    \\l decrementCurrentIndex() or \\l incrementCurrentIndex(), for example to navigate<KAIGYO>    using the left and right arrow keys:<KAIGYO><KAIGYO>    \\qml<KAIGYO>    PathView {<KAIGYO>        // ...<KAIGYO>        focus: true<KAIGYO>        Keys.onLeftPressed: decrementCurrentIndex()<KAIGYO>        Keys.onRightPressed: incrementCurrentIndex()<KAIGYO>    }<KAIGYO>    \\endqml<KAIGYO><KAIGYO>    The path view itself is a focus scope (see \\l{qmlfocus#Acquiring Focus and Focus Scopes}{the focus documentation page} for more details).<KAIGYO><KAIGYO>    Delegates are instantiated as needed and may be destroyed at any time.<KAIGYO>    State should \\e never be stored in a delegate.<KAIGYO><KAIGYO>    PathView attaches a number of properties to the root item of the delegate, for example<KAIGYO>    \\c {PathView.isCurrentItem}.  In the following example, the root delegate item can access<KAIGYO>    this attached property directly as \\c PathView.isCurrentItem, while the child<KAIGYO>    \\c nameText object must refer to this property as \\c wrapper.PathView.isCurrentItem.<KAIGYO><KAIGYO>    \\snippet doc/src/snippets/declarative/pathview/pathview.qml 1<KAIGYO><KAIGYO>    \\bold Note that views do not enable \\e clip automatically.  If the view<KAIGYO>    is not clipped by another item or the screen, it will be necessary<KAIGYO>    to set \\e {clip: true} in order to have the out of view items clipped<KAIGYO>    nicely.<KAIGYO><KAIGYO>    \\sa Path, {declarative/modelviews/pathview}{PathView example}<KAIGYO>*/': 1, '/*!<KAIGYO>    \\qmlclass Rectangle QSGRectangle<KAIGYO>    \\inqmlmodule QtQuick 2<KAIGYO>    \\ingroup qml-basic-visual-elements<KAIGYO>    \\brief The Rectangle item provides a filled rectangle with an optional border.<KAIGYO>    \\inherits Item<KAIGYO><KAIGYO>    Rectangle items are used to fill areas with solid color or gradients, and are<KAIGYO>    often used to hold other items.<KAIGYO><KAIGYO>    \\section1 Appearance<KAIGYO><KAIGYO>    Each Rectangle item is painted using either a solid fill color, specified using<KAIGYO>    the \\l color property, or a gradient, defined using a Gradient element and set<KAIGYO>    using the \\l gradient property. If both a color and a gradient are specified,<KAIGYO>    the gradient is used.<KAIGYO><KAIGYO>    You can add an optional border to a rectangle with its own color and thickness<KAIGYO>    by settting the \\l border.color and \\l border.width properties.<KAIGYO><KAIGYO>    You can also create rounded rectangles using the \\l radius property. Since this<KAIGYO>    introduces curved edges to the corners of a rectangle, it may be appropriate to<KAIGYO>    set the \\l smooth property to improve its appearance.<KAIGYO><KAIGYO>    \\section1 Example Usage<KAIGYO><KAIGYO>    \\div {class=""""}<KAIGYO>    \\inlineimage declarative-rect.png<KAIGYO>    \\enddiv<KAIGYO><KAIGYO>    The following example shows the effects of some of the common properties on a<KAIGYO>    Rectangle item, which in this case is used to create a square:<KAIGYO><KAIGYO>    \\snippet doc/src/snippets/declarative/rectangle/rectangle.qml document<KAIGYO><KAIGYO>    \\clearfloat<KAIGYO>    \\section1 Performance<KAIGYO><KAIGYO>    Using the \\l smooth property improves the appearance of a rounded rectangle at<KAIGYO>    the cost of rendering performance. You should consider unsetting this property<KAIGYO>    for rectangles in motion, and only set it when they are stationary.<KAIGYO><KAIGYO>    \\sa Image<KAIGYO>*/': 1, ""/*!<KAIGYO>    \\qmlclass Repeater QSGRepeater<KAIGYO>    \\inqmlmodule QtQuick 2<KAIGYO>    \\ingroup qml-utility-elements<KAIGYO>    \\inherits Item<KAIGYO><KAIGYO>    \\brief The Repeater element allows you to repeat an Item-based component using a model.<KAIGYO><KAIGYO>    The Repeater element is used to create a large number of<KAIGYO>    similar items. Like other view elements, a Repeater has a \\l model and a \\l delegate:<KAIGYO>    for each entry in the model, the delegate is instantiated<KAIGYO>    in a context seeded with data from the model. A Repeater item is usually<KAIGYO>    enclosed in a positioner element such as \\l Row or \\l Column to visually<KAIGYO>    position the multiple delegate items created by the Repeater.<KAIGYO><KAIGYO>    The following Repeater creates three instances of a \\l Rectangle item within<KAIGYO>    a \\l Row:<KAIGYO><KAIGYO>    \\snippet doc/src/snippets/declarative/repeaters/repeater.qml import<KAIGYO>    \\codeline<KAIGYO>    \\snippet doc/src/snippets/declarative/repeaters/repeater.qml simple<KAIGYO><KAIGYO>    \\image repeater-simple.png<KAIGYO><KAIGYO>    A Repeater's \\l model can be any of the supported \\l {qmlmodels}{data models}.<KAIGYO>    Additionally, like delegates for other views, a Repeater delegate can access<KAIGYO>    its index within the repeater, as well as the model data relevant to the<KAIGYO>    delegate. See the \\l delegate property documentation for details.<KAIGYO><KAIGYO>    Items instantiated by the Repeater are inserted, in order, as<KAIGYO>    children of the Repeater's parent.  The insertion starts immediately after<KAIGYO>    the repeater's position in its parent stacking list.  This allows<KAIGYO>    a Repeater to be used inside a layout. For example, the following Repeater's<KAIGYO>    items are stacked between a red rectangle and a blue rectangle:<KAIGYO><KAIGYO>    \\snippet doc/src/snippets/declarative/repeaters/repeater.qml layout<KAIGYO><KAIGYO>    \\image repeater.png<KAIGYO><KAIGYO><KAIGYO>    \\note A Repeater item owns all items it instantiates. Removing or dynamically destroying<KAIGYO>    an item created by a Repeater results in unpredictable behavior.<KAIGYO><KAIGYO><KAIGYO>    \\section2 Considerations when using Repeater<KAIGYO><KAIGYO>    The Repeater element creates all of its delegate items when the repeater is first<KAIGYO>    created. This can be inefficient if there are a large number of delegate items and<KAIGYO>    not all of the items are required to be visible at the same time. If this is the case,<KAIGYO>    consider using other view elements like ListView (which only creates delegate items<KAIGYO>    when they are scrolled into view) or use the \\l {Dynamic Object Creation} methods to<KAIGYO>    create items as they are required.<KAIGYO><KAIGYO>    Also, note that Repeater is \\l {Item}-based, and can only repeat \\l {Item}-derived objects.<KAIGYO>    For example, it cannot be used to repeat QtObjects:<KAIGYO>    \\badcode<KAIGYO>    Item {<KAIGYO>        //XXX does not work! Can't repeat QtObject as it doesn't derive from Item.<KAIGYO>        Repeater {<KAIGYO>            model: 10<KAIGYO>            QtObject {}<KAIGYO>        }<KAIGYO>    }<KAIGYO>    \\endcode<KAIGYO> */"": 1, '/*!<KAIGYO>    \\qmlproperty Component QtQuick2::Repeater::delegate<KAIGYO>    \\default<KAIGYO><KAIGYO>    The delegate provides a template defining each item instantiated by the repeater.<KAIGYO><KAIGYO>    Delegates are exposed to a read-only \\c index property that indicates the index<KAIGYO>    of the delegate within the repeater. For example, the following \\l Text delegate<KAIGYO>    displays the index of each repeated item:<KAIGYO><KAIGYO>    \\table<KAIGYO>    \\row<KAIGYO>    \\o \\snippet doc/src/snippets/declarative/repeaters/repeater.qml index<KAIGYO>    \\o \\image repeater-index.png<KAIGYO>    \\endtable<KAIGYO><KAIGYO>    If the \\l model is a \\l{QStringList-based model}{string list} or<KAIGYO>    \\l{QObjectList-based model}{object list}, the delegate is also exposed to<KAIGYO>    a read-only \\c modelData property that holds the string or object data. For<KAIGYO>    example:<KAIGYO><KAIGYO>    \\table<KAIGYO>    \\row<KAIGYO>    \\o \\snippet doc/src/snippets/declarative/repeaters/repeater.qml modeldata<KAIGYO>    \\o \\image repeater-modeldata.png<KAIGYO>    \\endtable<KAIGYO><KAIGYO>    If the \\l model is a model object (such as a \\l ListModel) the delegate<KAIGYO>    can access all model roles as named properties, in the same way that delegates<KAIGYO>    do for view classes like ListView.<KAIGYO><KAIGYO>    \\sa {QML Data Models}<KAIGYO> */': 1}",1.0,{'// XXX todo - we need to be able to handle common parents better and detect ': 1},1.0,{}
336,2742.0,1.0,2.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/2742,Removed faked resize / show / hide events.,1.0,{},0.0,{'// Fake a resize/show/hide events until QWindow starts sending events properly.': 1},1.0,{}
345,2764.0,1.0,1.0,0.0,ABANDONED,False,https://codereview.qt-project.org/#/c/2764,Disable keyboard in generic/linuxinput plugin to get it compiling,1.0,{},0.0,{'//This is a hack to avoid copying all the QWS code': 1},1.0,{}
342,2765.0,1.0,2.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/2765,Get linux input plugin compiling by removing keyboard support,1.0,{},0.0,{'//This is a hack to avoid copying all the QWS code': 1},1.0,{}
406,2838.0,4.0,10.0,4.0,ABANDONED,False,https://codereview.qt-project.org/#/c/2838,Support variant to JS value conversion for more types,1.0,{},0.0,"{'// XXX TODO: To be compatible, we still need to handle:<KAIGYO>//    + QJSValue<KAIGYO>//    + QObjectList<KAIGYO>//    + QList<int>': 1}",1.0,{}
386,2853.0,1.0,6.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/2853,Refactor BasicEmitter into Emitter,1.0,{'//TODO:Promote to base class?': 1},1.0,"{'//TODO:Promote to base class?': 1, '//Probably should be nocreate types<KAIGYO>//TODO: Rename BasicEmitter?': 1}",1.0,{}
436,2865.0,5.0,12.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/2865,Make QSGTextNode back-end for QML's TextInput and TextEdit,1.0,"{""// Nonsmooth text just ugly, so don't do that.."": 1}",1.0,"{'// XXX todo': 1, '// Take care of overflow when translating """"': 1}",1.0,{}
412,2910.0,1.0,3.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/2910,Fixed QSGNode leak.,1.0,{'// cleanup root<KAIGYO>// XXX todo - optimize': 1},1.0,"{'// XXX todo - optimize': 1, ""// XXX todo - why aren't these added to the destroy list?"": 1}",1.0,{}
29,3025.0,1.0,10.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/3025,Implement text interface for QLineEdit.,1.0,{},0.0,{'// TODO': 1},1.0,{}
40,3036.0,3.0,16.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/3036,Implemented QAccessibleTextEdit::attributes(),1.0,{},0.0,{'// TODO - wait for a definition of attributes': 1},1.0,{}
107,3093.0,9.0,30.0,5.0,MERGED,True,https://codereview.qt-project.org/#/c/3093,Remove V8 submodule from QtDeclarative,1.0,{},0.0,"{""// XXX Opportunity for optimization - don't invoke user callback if objects are<KAIGYO>// equal.  "": 3}",1.0,{}
64,3132.0,2.0,17.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/3132,Add a deformable level shader for QSGImageParticle,1.0,"{'//TODO: TabledParticle so as to not have the unused anim attributes': 1, ""//TODO: More Intermediate levels<KAIGYO>//But we're in colored level (or higher)"": 1, '//Fall-through intended... eventually //TODO: solve m_material/m_namedMaterial!': 1, '//Advance State<KAIGYO>//perfLevel == Sprites?//TODO: use signals?': 1, '//TODO: Us': 1}",1.0,{'//Advance State<KAIGYO>//perfLevel == Sprites?//TODO: use signals?': 1},1.0,{}
70,3158.0,1.0,2.0,0.0,ABANDONED,False,https://codereview.qt-project.org/#/c/3158,Move the PDF related functionality into QPdf,1.0,"{""// hack time... getting the maximum number of open<KAIGYO>// files, if possible.  if not we assume it's the<KAIGYO>// larger of 256 and the fd we got"": 1}",1.0,"{""// hack time... getting the maximum number of open<KAIGYO>// files, if possible.  if not we assume it's the<KAIGYO>// larger of 256 and the fd we got"": 1}",1.0,{}
82,3174.0,3.0,10.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/3174,Add the rest of the tiered shaders to QSGImageParticle,1.0,"{""//TODO: Move shaders inline once they've stablilized"": 1, '//TODO: Lift this limit for desktop?<KAIGYO>//ES 2 vertex count limit is ushort': 1}",1.0,"{""//TODO: Perhaps just swap the shaders, and don't mind the extra vector?"": 1, '//TODO: Intermediate levels': 1, '//TODO: TabledParticle so as to not have the unused anim attributes': 1, ""//TODO: More Intermediate levels<KAIGYO>//But we're in colored level (or higher)"": 1, ""//TODO: intermediate levels<KAIGYO>//But we're in colored level (or higher)"": 1, '//Fall-through intended... eventually //TODO: solve m_material/m_namedMaterial!': 1, '//perfLevel == Sprites?//TODO: use signals?': 1, '//TODO: Us': 1}",1.0,{}
85,3201.0,1.0,2.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/3201,Move the PDF related functionality into QPdf,1.0,"{""// hack time... getting the maximum number of open<KAIGYO>// files, if possible.  if not we assume it's the<KAIGYO>// larger of 256 and the fd we got"": 1}",1.0,"{""// hack time... getting the maximum number of open<KAIGYO>// files, if possible.  if not we assume it's the<KAIGYO>// larger of 256 and the fd we got"": 1}",1.0,{}
98,3246.0,1.0,2.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/3246,Remove qtessellator.* from QtGui,1.0,{},0.0,{'// ### could probably get better limit by looping over sorted list and counting down on ending edges': 1},1.0,{}
101,3247.0,1.0,1.0,0.0,ABANDONED,False,https://codereview.qt-project.org/#/c/3247,"QSurfaceFormat: Add missing 'profile' accessors, fix detaching.",1.0,{},0.0,{'// format.profile(): TODO: Not implemented yet.': 1},1.0,{}
104,3254.0,1.0,2.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/3254,"QSurfaceFormat: Add missing 'profile' accessors, fix detaching.",1.0,{},0.0,{'// format.profile(): TODO: Not implemented yet.': 1},1.0,{}
156,3355.0,3.0,6.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/3355,Lift particle limits on desktop,1.0,{},0.0,{'//TODO: Lift this limit for desktop?': 1},1.0,{}
185,3393.0,1.0,4.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/3393,Absorb CustomEmitter/Affector,1.0,{},0.0,"{'//TODO: Work it out (best added alongside autoTimeScaling)': 1, '//TODO:Promote to base class?': 1}",1.0,{}
225,3496.0,2.0,3.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/3496,tests: Remove `qtessellator' autotests,1.0,{},0.0,{'/*<KAIGYO> * Polygon tesselator - can probably be optimized a bit more<KAIGYO> */': 1},1.0,{}
217,3534.0,3.0,10.0,4.0,MERGED,True,https://codereview.qt-project.org/#/c/3534,qtmod_test: support testing of modules hosted outside of qt/qt5.git,1.0,"{""# XXX this only works when all the module's dependencies are located in qt5.git."": 1, ""# XXX this does not work if Qt is configured such that `make install' needs to be<KAIGYO># done on the dependencies.  At least the path to `qmake' will be wrong."": 1}",1.0,"{""# `configure' is expected to generate a makefile with a `module-FOO'<KAIGYO># target for every module.  That target should have correct module<KAIGYO># dependency information, so now issuing a `make module-FOO' should<KAIGYO># automatically build the module and all deps, as parallel as possible.<KAIGYO># XXX: this will not work for modules which aren't hosted in qt/qt5.git"": 1}",1.0,{}
221,3543.0,2.0,7.0,3.0,MERGED,True,https://codereview.qt-project.org/#/c/3543,Add an update flag to Custom Affectors,1.0,"{'//TODO: Non-floats (color, update?) once floats are working well': 1}",1.0,{'//TODO: Non-floats (color) and special floats (curX) once basic floats are working well': 1},1.0,{}
279,3545.0,2.0,11.0,2.0,MERGED,True,https://codereview.qt-project.org/#/c/3545,Update animation examples to QtQuick 2.0 and remove obsolete files.,1.0,{},0.0,"{""// In state 'middleRight', move the image to middleRightRect"": 1, ""// In state 'bottomLeft', move the image to bottomLeftRect"": 1}",1.0,{}
242,3560.0,1.0,4.0,3.0,ABANDONED,False,https://codereview.qt-project.org/#/c/3560,Add API to access and the manipulate items in a VisualDataModel.,1.0,"{'// Only move forwards - flip if backwards moving': 1, '// Transfering an item the model that owns it simply moves the item.': 1}",1.0,"{'// XXX todo - the original did item->scene()->removeItem().  Why?': 1, '// XXX - highly inefficient': 1, '//XXX perhaps better to maintain separately': 1}",1.0,{}
237,3586.0,1.0,2.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/3586,Merge branch 'master' into refactor,1.0,{},0.0,"{""// XXX todo - why aren't these added to the destroy list?"": 1}",1.0,{}
313,3615.0,1.0,9.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/3615,Update modelviews examples to QtQuick 2.0,1.0,{},0.0,"{'// This example shows how to create your own highlight delegate for a ListView<KAIGYO>// that uses a SpringAnimation to provide custom movement when the<KAIGYO>// highlight bar is moved between items.': 1, '// Set the highlight delegate. Note we must also set highlightFollowsCurrentItem<KAIGYO>// to false so the highlight delegate can control how the highlight is moved.': 1}",1.0,{}
285,3630.0,2.0,10.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/3630,Update more examples to QtQuick 2.0,1.0,{'// TODO: Use qrc path once QTBUG-21129 is fixed': 1},1.0,"{'// XXX should resolve relative to script, not component': 1}",1.0,{}
271,3670.0,1.0,4.0,1.0,MERGED,True,https://codereview.qt-project.org/#/c/3670,Optimized QMatrix4x4 by improving how 'flagBits' are used.,1.0,{},0.0,"{'// We can express this projection as a translate and scale<KAIGYO>// which will be more efficient to modify with further<KAIGYO>// transformations than producing a """" matrix.': 1}",1.0,{}
328,3697.0,6.0,10.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/3697,Batch view changes instead of applying them immediately,1.0,"{""// Ensure we don't cause an ugly list scroll"": 1, ""// only 1 item moved back, so items shift accordingly and first row doesn't move<KAIGYO>// 1st row (it's above visible area) disappears, 0 drops down 1 row, first visible item (6) stays where it is<KAIGYO>// top row moved and shifted to below 3rd row, all items should shift down by 1 row<KAIGYO>// to minimize movement, items are added above visible area, all items move up by 1 row<KAIGYO>// 16,17,18 move to above item 0, all items move up by 1 row"": 1, '// Move': 1, ""// only 1 item moved back, so items shift accordingly and first row doesn't move<KAIGYO>// only 1 item moved back, so items shift accordingly and first row doesn't move<KAIGYO>// 1st row (it's above visible area) disappears, 0 drops down 1 row, first visible item (6) stays where it is<KAIGYO>// top row moved and shifted to below 3rd row, all items should shift down by 1 row<KAIGYO>// to minimize movement, items are added above visible area, all items move up by 1 row<KAIGYO>// 16,17,18 move to above item 0, all items move up by 1 row"": 2}",1.0,"{""// Ensure we don't cause an ugly list scroll."": 1, '// Only move forwards - flip if backwards moving': 1, '// this results in a forward movement that removes 6 items (2 rows)<KAIGYO>// first visible item moved, so all items shift 2 rows down with it<KAIGYO>// top row moved, all items should shift down by 1 row<KAIGYO>// top row moved, all items should shift down by 1 row<KAIGYO>// this results in a forward movement that removes 15 items (5 rows)<KAIGYO>// this results in a forward movement that removes 16 items (5 rows)': 1}",1.0,{}
315,3738.0,2.0,3.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/3738,Build on Windows/clean build on Linux.,1.0,{'//TODO': 1},1.0,"{""// If the products 'ad' and 'bc' fit into 64 bits, they can be directly compared."": 1, '// Assuming 21 bits per vector component.<KAIGYO>// TODO: Make code path for 31 bits per vector component.': 1, '// TODO: Make code path for coordinates with more than 21 bits.': 1}",1.0,{}
314,3742.0,4.0,11.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/3742,Remove some QByteArray<->QString conversions,1.0,{},0.0,{'// XXX fromUtf8': 1},1.0,{}
326,3768.0,3.0,10.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/3768,Use the cached property data when possible,1.0,{},0.0,{'// XXX aakenned': 1},1.0,{}
340,3769.0,3.0,10.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/3769,Optimize default property resolution in compiler,1.0,{},0.0,{'// XXX aakenned': 1},1.0,{}
448,3797.0,3.0,10.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/3797,Move all QML file parsing into the QDeclarativeScript namespace,1.0,{'// XXX aakenned': 1},1.0,{'// XXX aakenned': 1},1.0,{}
379,3839.0,1.0,5.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/3839,Custom Particle now supplies default code,1.0,{},0.0,"{""//TODO: Someway that you don't have to rewrite the basics for a simple addition"": 1, ""//TODO: Can we make the code such that you don't have to copy the whole vertex shader just to add one little calculation?"": 1, '//TODO: Can they add custom attributes?': 1, '// TODO: Remove after grace period.': 1}",1.0,{}
431,3927.0,1.0,2.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/3927,Add a QStyleHints class to QtGui,1.0,{},0.0,{'// The screens are a bit too small to for your thumb when using only 4 pixels drag distance.<KAIGYO>//XXX move to qplatformdefs.h': 1},1.0,{}
447,3991.0,2.0,5.0,1.0,MERGED,True,https://codereview.qt-project.org/#/c/3991,Use QMouseEvent instead of QGraphicsSceneMouseEvent,1.0,{'// XXX todo - should sendEvent be doing this?  how does it relate to forwarded events? ': 1},1.0,{'// XXX todo - should sendEvent be doing this?  how does it relate to forwarded events?': 1},1.0,{}
450,3992.0,3.0,6.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/3992,Remove the remaining dependencies onto QtWidgets,1.0,{},0.0,"{'// Note, this is exported but in a private header as qtopengl depends on it.<KAIGYO>// But it really should be considered private API': 1}",1.0,{}
7,4003.0,1.0,8.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/4003,Exported QSGShaderEffectMesh.,1.0,{},0.0,"{'// TODO: Remove after grace period.<KAIGYO>// TODO: Remove after grace period.': 1, '// TODO: Replace QVariant with QSize after grace period.': 1, '// TODO: Remove !m_deprecatedMesh check after grace period.': 1}",1.0,{}
25,4022.0,1.0,2.0,0.0,ABANDONED,False,https://codereview.qt-project.org/#/c/4022,"Revert ""Batch view changes instead of applying them immediately""",1.0,"{""// Ensure we don't cause an ugly list scroll."": 1, '// Only move forwards - flip if backwards moving': 1, '// this results in a forward movement that removes 6 items (2 rows)<KAIGYO>// first visible item moved, so all items shift 2 rows down with it<KAIGYO>// top row moved, all items should shift down by 1 row<KAIGYO>// top row moved, all items should shift down by 1 row<KAIGYO>// this results in a forward movement that removes 15 items (5 rows)<KAIGYO>// this results in a forward movement that removes 16 items (5 rows)': 1}",1.0,"{""// Ensure we don't cause an ugly list scroll"": 1, ""// only 1 item moved back, so items shift accordingly and first row doesn't move<KAIGYO>// only 1 item moved back, so items shift accordingly and first row doesn't move<KAIGYO>// 1st row (it's above visible area) disappears, 0 drops down 1 row, first visible item (6) stays where it is<KAIGYO>// top row moved and shifted to below 3rd row, all items should shift down by 1 row<KAIGYO>// to minimize movement, items are added above visible area, all items move up by 1 row<KAIGYO>// 16,17,18 move to above item 0, all items move up by 1 row"": 1, '// Move': 1}",1.0,{}
33,4033.0,3.0,6.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/4033,Refactor QSGVisualDataModel.,1.0,"{'// XXX - highly inefficient': 1, '//XXX perhaps better to maintain separately': 3}",1.0,"{'// XXX todo - the original did item->scene()->removeItem().  Why?': 1, '// XXX - highly inefficient': 1, '//XXX perhaps better to maintain separately': 3}",1.0,{}
36,4035.0,2.0,2.0,0.0,ABANDONED,False,https://codereview.qt-project.org/#/c/4035,Add a data accessor and move and remove functions to VisualDataModel.,1.0,{},0.0,"{'// XXX - highly inefficient': 1, '//XXX perhaps better to maintain separately': 1}",1.0,{}
34,4041.0,2.0,7.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/4041,Animation-like API for ParticleSystem,1.0,{},0.0,"{'//TODO: Needed? Or just in component complete?': 1, '//TODO: Reset data<KAIGYO>//    foreach (QSGParticlePainter* p, m_particlePainters)<KAIGYO>//        p->reset();<KAIGYO>//    foreach (QSGParticleEmitter* e, m_emitters)<KAIGYO>//        e->reset();<KAIGYO>//### Do affectors need reset too?': 1}",1.0,{}
15,4053.0,3.0,10.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/4053,Allow affectors to be transformed,1.0,{},0.0,{'//TODO: in componentComplete and all relevant signals': 3},1.0,{}
65,4064.0,6.0,12.0,2.0,MERGED,True,https://codereview.qt-project.org/#/c/4064,Allow particles to have eternal life,1.0,{'//TODO: Optimize 0 lifespan (or already dead) case': 1},1.0,"{'//TODO:Promote to base class?': 1, '//TODO: Optimize 0 lifespan (or already dead) case': 1}",1.0,{}
126,4068.0,5.0,8.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/4068,Cocoa: QMenu refactor.,1.0,{},0.0,"{'// Turn on the no native menubar here, since we used to<KAIGYO>// do this implicitly. We DO NOT flip it off if someone sets<KAIGYO>// it to false.<KAIGYO>// Ideally, we\'d have magic that would be something along the lines of<KAIGYO>// """" unless explicitly set.<KAIGYO>// Considering this attribute isn\'t only at the beginning<KAIGYO>// it\'s unlikely it will ever be a problem, but I want<KAIGYO>// to have the behavior documented here.': 3}",1.0,{}
157,4351.0,6.0,14.0,14.0,MERGED,True,https://codereview.qt-project.org/#/c/4351,Separate declarative builtin functions from QV8Engine class,1.0,"{'/*!<KAIGYO>\\qmlmethod color Qt::rgba(real red, real green, real blue, real alpha)<KAIGYO><KAIGYO>Returns a color with the specified \\c red, \\c green, \\c blue and \\c alpha components.<KAIGYO>All components should be in the range 0-1 inclusive.<KAIGYO>*/': 1, '/*!<KAIGYO>\\qmlmethod color Qt::lighter(color baseColor, real factor)<KAIGYO>Returns a color lighter than \\c baseColor by the \\c factor provided.<KAIGYO><KAIGYO>If the factor is greater than 1.0, this functions returns a lighter color.<KAIGYO>Setting factor to 1.5 returns a color that is 50% brighter. If the factor is less than 1.0,<KAIGYO>the return color is darker, but we recommend using the Qt.darker() function for this purpose.<KAIGYO>If the factor is 0 or negative, the return value is unspecified.<KAIGYO><KAIGYO>The function converts the current RGB color to HSV, multiplies the value (V) component<KAIGYO>by factor and converts the color back to RGB.<KAIGYO><KAIGYO>If \\c factor is not supplied, returns a color 50% lighter than \\c baseColor (factor 1.5).<KAIGYO>*/': 1}",1.0,"{'/*!<KAIGYO>\\qmlmethod color Qt::rgba(real red, real green, real blue, real alpha)<KAIGYO><KAIGYO>Returns a color with the specified \\c red, \\c green, \\c blue and \\c alpha components.<KAIGYO>All components should be in the range 0-1 inclusive.<KAIGYO>*/': 1, '/*!<KAIGYO>\\qmlmethod color Qt::lighter(color baseColor, real factor)<KAIGYO>Returns a color lighter than \\c baseColor by the \\c factor provided.<KAIGYO><KAIGYO>If the factor is greater than 1.0, this functions returns a lighter color.<KAIGYO>Setting factor to 1.5 returns a color that is 50% brighter. If the factor is less than 1.0,<KAIGYO>the return color is darker, but we recommend using the Qt.darker() function for this purpose.<KAIGYO>If the factor is 0 or negative, the return value is unspecified.<KAIGYO><KAIGYO>The function converts the current RGB color to HSV, multiplies the value (V) component<KAIGYO>by factor and converts the color back to RGB.<KAIGYO><KAIGYO>If \\c factor is not supplied, returns a color 50% lighter than \\c baseColor (factor 1.5).<KAIGYO>*/': 1}",1.0,{}
186,4461.0,1.0,2.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/4461,get various autotests working for refactor,1.0,"{'//void tst_QSGMouseArea::updateMouseAreaPosOnClick()<KAIGYO>//{<KAIGYO>//    QSGView *canvas = createView();<KAIGYO>//    canvas->setSource(QUrl::fromLocalFile(SRCDIR """"));<KAIGYO>//    canvas->show();<KAIGYO>//    canvas->requestActivateWindow();<KAIGYO>//    QVERIFY(canvas->rootObject() != 0);<KAIGYO>//    QSGMouseArea *mouseRegion = canvas->rootObject()->findChild<QSGMouseArea*>("""");<KAIGYO>//    QVERIFY(mouseRegion != 0);<KAIGYO>//    QSGRectangle *rect = canvas->rootObject()->findChild<QSGRectangle*>("""");<KAIGYO>//    QVERIFY(rect != 0);<KAIGYO>//    QCOMPARE(mouseRegion->mouseX(), rect->x());<KAIGYO>//    QCOMPARE(mouseRegion->mouseY(), rect->y());<KAIGYO>//    QMouseEvent event(QEvent::MouseButtonPress, QPoint(100, 100), Qt::LeftButton, Qt::LeftButton, 0);<KAIGYO>//    QApplication::sendEvent(canvas, &event);<KAIGYO>//    QCOMPARE(mouseRegion->mouseX(), 100.0);<KAIGYO>//    QCOMPARE(mouseRegion->mouseY(), 100.0);<KAIGYO>//    QCOMPARE(mouseRegion->mouseX(), rect->x());<KAIGYO>//    QCOMPARE(mouseRegion->mouseY(), rect->y());<KAIGYO>//    delete canvas;<KAIGYO>//}<KAIGYO>//void tst_QSGMouseArea::updateMouseAreaPosOnResize()<KAIGYO>//{<KAIGYO>//    QSGView *canvas = createView();<KAIGYO>//    canvas->setSource(QUrl::fromLocalFile(SRCDIR """"));<KAIGYO>//    canvas->show();<KAIGYO>//    canvas->requestActivateWindow();<KAIGYO>//    QVERIFY(canvas->rootObject() != 0);<KAIGYO>//    QSGMouseArea *mouseRegion = canvas->rootObject()->findChild<QSGMouseArea*>("""");<KAIGYO>//    QVERIFY(mouseRegion != 0);<KAIGYO>//    QSGRectangle *rect = canvas->rootObject()->findChild<QSGRectangle*>("""");<KAIGYO>//    QVERIFY(rect != 0);<KAIGYO>//    QCOMPARE(mouseRegion->mouseX(), 0.0);<KAIGYO>//    QCOMPARE(mouseRegion->mouseY(), 0.0);<KAIGYO>//    QMouseEvent event(QEvent::MouseButtonPress, rect->pos().toPoint(), Qt::LeftButton, Qt::LeftButton, 0);<KAIGYO>//    QApplication::sendEvent(canvas, &event);<KAIGYO>//    QVERIFY(!mouseRegion->property("""").toBool());<KAIGYO>//    QVERIFY(mouseRegion->property("""").toBool());<KAIGYO>//    QCOMPARE(mouseRegion->property("""").toInt(), 0);<KAIGYO>//    QCOMPARE(mouseRegion->property("""").toInt(), 0);<KAIGYO>//    // XXX: is it on purpose that mouseX is real and mouse.x is int?<KAIGYO>//    QCOMPARE(mouseRegion->property("""").toInt(), (int) rect->x());<KAIGYO>//    QCOMPARE(mouseRegion->property("""").toInt(), (int) rect->y());<KAIGYO>//    QCOMPARE(mouseRegion->mouseX(), rect->x());<KAIGYO>//    QCOMPARE(mouseRegion->mouseY(), rect->y());<KAIGYO>//    delete canvas;<KAIGYO>//}<KAIGYO>//void tst_QSGMouseArea::noOnClickedWithPressAndHold()<KAIGYO>//{<KAIGYO>//    {<KAIGYO>//        // We handle onPressAndHold, therefore no onClicked<KAIGYO>//        QSGView *canvas = createView();<KAIGYO>//        canvas->setSource(QUrl::fromLocalFile(SRCDIR """"));<KAIGYO>//        canvas->show();<KAIGYO>//        canvas->requestActivateWindow();<KAIGYO>//        QVERIFY(canvas->rootObject() != 0);<KAIGYO>//        QMouseEvent pressEvent(QEvent::MouseButtonPress, QPoint(100, 100), Qt::LeftButton, Qt::LeftButton, 0);<KAIGYO>//        QApplication::sendEvent(canvas, &pressEvent);<KAIGYO>//        QVERIFY(!canvas->rootObject()->property("""").toBool());<KAIGYO>//        QVERIFY(!canvas->rootObject()->property("""").toBool());<KAIGYO>//        QTest::qWait(1000);<KAIGYO>//        QMouseEvent releaseEvent(QEvent::MouseButtonRelease, QPoint(100, 100), Qt::LeftButton, Qt::LeftButton, 0);<KAIGYO>//        QApplication::sendEvent(canvas, &releaseEvent);<KAIGYO>//        QVERIFY(!canvas->rootObject()->property("""").toBool());<KAIGYO>//        QVERIFY(canvas->rootObject()->property("""").toBool());<KAIGYO>//        delete canvas;<KAIGYO>//    }<KAIGYO>//    {<KAIGYO>//        // We do not handle onPressAndHold, therefore we get onClicked<KAIGYO>//        QSGView *canvas = createView();<KAIGYO>//        canvas->setSource(QUrl::fromLocalFile(SRCDIR """"));<KAIGYO>//        canvas->show();<KAIGYO>//        canvas->requestActivateWindow();<KAIGYO>//        QVERIFY(canvas->rootObject() != 0);<KAIGYO>//        QMouseEvent pressEvent(QEvent::MouseButtonPress, QPoint(100, 100), Qt::LeftButton, Qt::LeftButton, 0);<KAIGYO>//        QApplication::sendEvent(canvas, &pressEvent);<KAIGYO>//        QVERIFY(!canvas->rootObject()->property("""").toBool());<KAIGYO>//        QTest::qWait(1000);<KAIGYO>//        QMouseEvent releaseEvent(QEvent::MouseButtonRelease, QPoint(100, 100), Qt::LeftButton, Qt::LeftButton, 0);<KAIGYO>//        QApplication::sendEvent(canvas, &releaseEvent);<KAIGYO>//        QVERIFY(canvas->rootObject()->property("""").toBool());<KAIGYO>//        delete canvas;<KAIGYO>//    }<KAIGYO>//}<KAIGYO>//void tst_QSGMouseArea::onMousePressRejected()<KAIGYO>//{<KAIGYO>//    QSGView *canvas = createView();<KAIGYO>//    canvas->setSource(QUrl::fromLocalFile(SRCDIR """"));<KAIGYO>//    canvas->show();<KAIGYO>//    canvas->requestActivateWindow();<KAIGYO>//    QVERIFY(canvas->rootObject() != 0);<KAIGYO>//    QVERIFY(canvas->rootObject()->property("""").toBool());<KAIGYO>//    QVERIFY(!canvas->rootObject()->property("""").toBool());<KAIGYO>//    QVERIFY(!canvas->rootObject()->property("""").toBool());<KAIGYO>//    QVERIFY(!canvas->rootObject()->property("""").toBool());<KAIGYO>//    QVERIFY(!canvas->rootObject()->property("""").toBool());<KAIGYO>//    QVERIFY(!canvas->rootObject()->property("""").toBool());<KAIGYO>//    QVERIFY(!canvas->rootObject()->property("""").toBool());<KAIGYO>//    QMouseEvent pressEvent(QEvent::MouseButtonPress, QPoint(100, 100), Qt::LeftButton, Qt::LeftButton, 0);<KAIGYO>//    QApplication::sendEvent(canvas, &pressEvent);<KAIGYO>//    QVERIFY(canvas->rootObject()->property("""").toBool());<KAIGYO>//    QVERIFY(!canvas->rootObject()->property("""").toBool());<KAIGYO>//    QVERIFY(!canvas->rootObject()->property("""").toBool());<KAIGYO>//    QVERIFY(canvas->rootObject()->property("""").toBool());<KAIGYO>//    QVERIFY(!canvas->rootObject()->property("""").toBool());<KAIGYO>//    QVERIFY(canvas->rootObject()->property("""").toBool());<KAIGYO>//    QTest::qWait(200);<KAIGYO>//    QMouseEvent releaseEvent(QEvent::MouseButtonRelease, QPoint(100, 100), Qt::LeftButton, Qt::LeftButton, 0);<KAIGYO>//    QApplication::sendEvent(canvas, &releaseEvent);<KAIGYO>//    QVERIFY(canvas->rootObject()->property("""").toBool());<KAIGYO>//    QVERIFY(!canvas->rootObject()->property("""").toBool());<KAIGYO>//    QVERIFY(!canvas->rootObject()->property("""").toBool());<KAIGYO>//    delete canvas;<KAIGYO>//}<KAIGYO>//void tst_QSGMouseArea::pressedCanceledOnWindowDeactivate()<KAIGYO>//{<KAIGYO>//    QSGView *canvas = createView();<KAIGYO>//    canvas->setSource(QUrl::fromLocalFile(SRCDIR """"));<KAIGYO>//    canvas->show();<KAIGYO>//    canvas->requestActivateWindow();<KAIGYO>//    QVERIFY(canvas->rootObject() != 0);<KAIGYO>//    QVERIFY(!canvas->rootObject()->property("""").toBool());<KAIGYO>//    QVERIFY(!canvas->rootObject()->property("""").toBool());<KAIGYO>//    QVERIFY(!canvas->rootObject()->property("""").toBool());<KAIGYO>//    QMouseEvent pressEvent(QEvent::MouseButtonPress, QPoint(100, 100), Qt::LeftButton, Qt::LeftButton, 0);<KAIGYO>//    QApplication::sendEvent(canvas, &pressEvent);<KAIGYO>//    QVERIFY(canvas->rootObject()->property("""").toBool());<KAIGYO>//    QVERIFY(!canvas->rootObject()->property("""").toBool());<KAIGYO>//    QVERIFY(!canvas->rootObject()->property("""").toBool());<KAIGYO>//    QTest::qWait(200);<KAIGYO>//    QEvent windowDeactivateEvent(QEvent::WindowDeactivate);<KAIGYO>//    QApplication::sendEvent(canvas, &windowDeactivateEvent);<KAIGYO>//    QVERIFY(!canvas->rootObject()->property("""").toBool());<KAIGYO>//    QVERIFY(canvas->rootObject()->property("""").toBool());<KAIGYO>//    QVERIFY(!canvas->rootObject()->property("""").toBool());<KAIGYO>//    QTest::qWait(200);<KAIGYO>//    //press again<KAIGYO>//    QApplication::sendEvent(canvas, &pressEvent);<KAIGYO>//    QVERIFY(canvas->rootObject()->property("""").toBool());<KAIGYO>//    QVERIFY(!canvas->rootObject()->property("""").toBool());<KAIGYO>//    QVERIFY(!canvas->rootObject()->property("""").toBool());<KAIGYO>//    QTest::qWait(200);<KAIGYO>//    //release<KAIGYO>//    QMouseEvent releaseEvent(QEvent::MouseButtonRelease, QPoint(100, 100), Qt::LeftButton, Qt::LeftButton, 0);<KAIGYO>//    QApplication::sendEvent(canvas, &releaseEvent);<KAIGYO>//    QVERIFY(!canvas->rootObject()->property("""").toBool());<KAIGYO>//    QVERIFY(!canvas->rootObject()->property("""").toBool());<KAIGYO>//    QVERIFY(canvas->rootObject()->property("""").toBool());<KAIGYO>//    delete canvas;<KAIGYO>//}<KAIGYO>//void tst_QSGMouseArea::doubleClick()<KAIGYO>//{<KAIGYO>//    QSGView *canvas = createView();<KAIGYO>//    canvas->setSource(QUrl::fromLocalFile(SRCDIR """"));<KAIGYO>//    canvas->show();<KAIGYO>//    canvas->requestActivateWindow();<KAIGYO>//    QVERIFY(canvas->rootObject() != 0);<KAIGYO>//    QMouseEvent pressEvent(QEvent::MouseButtonPress, QPoint(100, 100), Qt::LeftButton, Qt::LeftButton, 0);<KAIGYO>//    QApplication::sendEvent(canvas, &pressEvent);<KAIGYO>//    QMouseEvent releaseEvent(QEvent::MouseButtonRelease, QPoint(100, 100), Qt::LeftButton, Qt::LeftButton, 0);<KAIGYO>//    QApplication::sendEvent(canvas, &releaseEvent);<KAIGYO>//    QCOMPARE(canvas->rootObject()->property("""").toInt(), 1);<KAIGYO>//    pressEvent = QMouseEvent(QEvent::MouseButtonDblClick, QPoint(100, 100), Qt::LeftButton, Qt::LeftButton, 0);<KAIGYO>//    QApplication::sendEvent(canvas, &pressEvent);<KAIGYO>//    QApplication::sendEvent(canvas, &releaseEvent);<KAIGYO>//    QCOMPARE(canvas->rootObject()->property("""").toInt(), 1);<KAIGYO>//    QCOMPARE(canvas->rootObject()->property("""").toInt(), 1);<KAIGYO>//    QCOMPARE(canvas->rootObject()->property("""").toInt(), 2);<KAIGYO>//    delete canvas;<KAIGYO>//}<KAIGYO>//// QTBUG-14832<KAIGYO>//void tst_QSGMouseArea::clickTwice()<KAIGYO>//{<KAIGYO>//    QSGView *canvas = createView();<KAIGYO>//    canvas->setSource(QUrl::fromLocalFile(SRCDIR """"));<KAIGYO>//    canvas->show();<KAIGYO>//    canvas->requestActivateWindow();<KAIGYO>//    QVERIFY(canvas->rootObject() != 0);<KAIGYO>//    QMouseEvent pressEvent(QEvent::MouseButtonPress, QPoint(100, 100), Qt::LeftButton, Qt::LeftButton, 0);<KAIGYO>//    QApplication::sendEvent(canvas, &pressEvent);<KAIGYO>//    QMouseEvent releaseEvent(QEvent::MouseButtonRelease, QPoint(100, 100), Qt::LeftButton, Qt::LeftButton, 0);<KAIGYO>//    QApplication::sendEvent(canvas, &releaseEvent);<KAIGYO>//    QCOMPARE(canvas->rootObject()->property("""").toInt(), 1);<KAIGYO>//    QCOMPARE(canvas->rootObject()->property("""").toInt(), 1);<KAIGYO>//    QCOMPARE(canvas->rootObject()->property("""").toInt(), 1);<KAIGYO>//    pressEvent = QMouseEvent(QEvent::MouseButtonDblClick, QPoint(100, 100), Qt::LeftButton, Qt::LeftButton, 0);<KAIGYO>//    QApplication::sendEvent(canvas, &pressEvent);<KAIGYO>//    QApplication::sendEvent(canvas, &pressEvent);<KAIGYO>//    QApplication::sendEvent(canvas, &releaseEvent);<KAIGYO>//    QCOMPARE(canvas->rootObject()->property("""").toInt(), 2);<KAIGYO>//    QCOMPARE(canvas->rootObject()->property("""").toInt(), 2);<KAIGYO>//    QCOMPARE(canvas->rootObject()->property("""").toInt(), 2);<KAIGYO>//    delete canvas;<KAIGYO>//}<KAIGYO>//void tst_QSGMouseArea::pressedOrdering()<KAIGYO>//{<KAIGYO>//    QSGView *canvas = createView();<KAIGYO>//    canvas->setSource(QUrl::fromLocalFile(SRCDIR """"));<KAIGYO>//    canvas->show();<KAIGYO>//    canvas->requestActivateWindow();<KAIGYO>//    QVERIFY(canvas->rootObject() != 0);<KAIGYO>//    QCOMPARE(canvas->rootObject()->property(""""));<KAIGYO>//    QMouseEvent pressEvent(QEvent::MouseButtonPress, QPoint(100, 100), Qt::LeftButton, Qt::LeftButton, 0);<KAIGYO>//    QApplication::sendEvent(canvas, &pressEvent);<KAIGYO>//    QCOMPARE(canvas->rootObject()->property(""""));<KAIGYO>//    QMouseEvent releaseEvent(QEvent::MouseButtonRelease, QPoint(100, 100), Qt::LeftButton, Qt::LeftButton, 0);<KAIGYO>//    QApplication::sendEvent(canvas, &releaseEvent);<KAIGYO>//    QCOMPARE(canvas->rootObject()->property(""""));<KAIGYO>//    QApplication::sendEvent(canvas, &pressEvent);<KAIGYO>//    QCOMPARE(canvas->rootObject()->property(""""));<KAIGYO>//    delete canvas;<KAIGYO>//}<KAIGYO>//void tst_QSGMouseArea::preventStealing()<KAIGYO>//{<KAIGYO>//    QSGView *canvas = createView();<KAIGYO>//    canvas->setSource(QUrl::fromLocalFile(SRCDIR """"));<KAIGYO>//    canvas->show();<KAIGYO>//    canvas->requestActivateWindow();<KAIGYO>//    QVERIFY(canvas->rootObject() != 0);<KAIGYO>//    QSGFlickable *flickable = qobject_cast<QSGFlickable*>(canvas->rootObject());<KAIGYO>//    QVERIFY(flickable != 0);<KAIGYO>//    QSGMouseArea *mouseArea = canvas->rootObject()->findChild<QSGMouseArea*>("""");<KAIGYO>//    QVERIFY(mouseArea != 0);<KAIGYO>//    QSignalSpy mousePositionSpy(mouseArea, SIGNAL(positionChanged(QSGMouseEvent*)));<KAIGYO>//    QTest::mousePress(canvas, Qt::LeftButton, 0, QPoint(80, 80));<KAIGYO>//    // Without preventStealing, mouse movement over MouseArea would<KAIGYO>//    // cause the Flickable to steal mouse and trigger content movement.<KAIGYO>//    QMouseEvent moveEvent(QEvent::MouseMove, QPoint(70, 70), Qt::LeftButton, Qt::LeftButton, 0);<KAIGYO>//    QApplication::sendEvent(canvas, &moveEvent);<KAIGYO>//    moveEvent = QMouseEvent(QEvent::MouseMove, QPoint(60, 60), Qt::LeftButton, Qt::LeftButton, 0);<KAIGYO>//    QApplication::sendEvent(canvas, &moveEvent);<KAIGYO>//    moveEvent = QMouseEvent(QEvent::MouseMove, QPoint(50, 50), Qt::LeftButton, Qt::LeftButton, 0);<KAIGYO>//    QApplication::sendEvent(canvas, &moveEvent);<KAIGYO>//    // We should have received all three move events<KAIGYO>//    QCOMPARE(mousePositionSpy.count(), 3);<KAIGYO>//    QVERIFY(mouseArea->pressed());<KAIGYO>//    // Flickable content should not have moved.<KAIGYO>//    QCOMPARE(flickable->contentX(), 0.);<KAIGYO>//    QCOMPARE(flickable->contentY(), 0.);<KAIGYO>//    QTest::mouseRelease(canvas, Qt::LeftButton, 0, QPoint(50, 50));<KAIGYO>//    // Now allow stealing and confirm Flickable does its thing.<KAIGYO>//    canvas->rootObject()->setProperty("""", false);<KAIGYO>//    QTest::mousePress(canvas, Qt::LeftButton, 0, QPoint(80, 80));<KAIGYO>//    // Without preventStealing, mouse movement over MouseArea would<KAIGYO>//    // cause the Flickable to steal mouse and trigger content movement.<KAIGYO>//    moveEvent = QMouseEvent(QEvent::MouseMove, QPoint(70, 70), Qt::LeftButton, Qt::LeftButton, 0);<KAIGYO>//    QApplication::sendEvent(canvas, &moveEvent);<KAIGYO>//    moveEvent = QMouseEvent(QEvent::MouseMove, QPoint(60, 60), Qt::LeftButton, Qt::LeftButton, 0);<KAIGYO>//    QApplication::sendEvent(canvas, &moveEvent);<KAIGYO>//    moveEvent = QMouseEvent(QEvent::MouseMove, QPoint(50, 50), Qt::LeftButton, Qt::LeftButton, 0);<KAIGYO>//    QApplication::sendEvent(canvas, &moveEvent);<KAIGYO>//    // We should only have received the first move event<KAIGYO>//    QCOMPARE(mousePositionSpy.count(), 4);<KAIGYO>//    // Our press should be taken away<KAIGYO>//    QVERIFY(!mouseArea->pressed());<KAIGYO>//    // Flickable content should have moved.<KAIGYO>//    QCOMPARE(flickable->contentX(), 10.);<KAIGYO>//    QCOMPARE(flickable->contentY(), 10.);<KAIGYO>//    QTest::mouseRelease(canvas, Qt::LeftButton, 0, QPoint(50, 50));<KAIGYO>//    delete canvas;<KAIGYO>//}<KAIGYO>//void tst_QSGMouseArea::clickThrough()<KAIGYO>//{<KAIGYO>//    //With no handlers defined click, doubleClick and PressAndHold should propagate to those with handlers<KAIGYO>//    QSGView *canvas = createView();<KAIGYO>//    canvas->setSource(QUrl::fromLocalFile(SRCDIR """"));<KAIGYO>//    canvas->show();<KAIGYO>//    canvas->requestActivateWindow();<KAIGYO>//    QVERIFY(canvas->rootObject() != 0);<KAIGYO>//    QMouseEvent pressEvent(QEvent::MouseButtonPress, QPoint(100, 100), Qt::LeftButton, Qt::LeftButton, 0);<KAIGYO>//    QApplication::sendEvent(canvas, &pressEvent);<KAIGYO>//    QMouseEvent releaseEvent(QEvent::MouseButtonRelease, QPoint(100, 100), Qt::LeftButton, Qt::LeftButton, 0);<KAIGYO>//    QApplication::sendEvent(canvas, &releaseEvent);<KAIGYO>//    QCOMPARE(canvas->rootObject()->property("""").toInt(), 0);<KAIGYO>//    QCOMPARE(canvas->rootObject()->property("""").toInt(), 1);<KAIGYO>//    QApplication::sendEvent(canvas, &pressEvent);<KAIGYO>//    QTest::qWait(1000);<KAIGYO>//    QApplication::sendEvent(canvas, &releaseEvent);<KAIGYO>//    QCOMPARE(canvas->rootObject()->property("""").toInt(), 0);<KAIGYO>//    QCOMPARE(canvas->rootObject()->property("""").toInt(), 1);<KAIGYO>//    QCOMPARE(canvas->rootObject()->property("""").toInt(), 1);<KAIGYO>//    QApplication::sendEvent(canvas, &pressEvent);<KAIGYO>//    QApplication::sendEvent(canvas, &releaseEvent);<KAIGYO>//    pressEvent = QMouseEvent(QEvent::MouseButtonDblClick, QPoint(100, 100), Qt::LeftButton, Qt::LeftButton, 0);<KAIGYO>//    QApplication::sendEvent(canvas, &pressEvent);<KAIGYO>//    QApplication::sendEvent(canvas, &releaseEvent);<KAIGYO>//    QCOMPARE(canvas->rootObject()->property("""").toInt(), 0);<KAIGYO>//    QCOMPARE(canvas->rootObject()->property("""").toInt(), 2);<KAIGYO>//    QCOMPARE(canvas->rootObject()->property("""").toInt(), 1);<KAIGYO>//    QCOMPARE(canvas->rootObject()->property("""").toInt(), 1);<KAIGYO>//    delete canvas;<KAIGYO>//    //With handlers defined click, doubleClick and PressAndHold should propagate only when explicitly ignored<KAIGYO>//    canvas = createView();<KAIGYO>//    canvas->setSource(QUrl::fromLocalFile(SRCDIR """"));<KAIGYO>//    canvas->show();<KAIGYO>//    canvas->requestActivateWindow();<KAIGYO>//    QVERIFY(canvas->rootObject() != 0);<KAIGYO>//    pressEvent = QMouseEvent(QEvent::MouseButtonPress, QPoint(100, 100), Qt::LeftButton, Qt::LeftButton, 0);<KAIGYO>//    QApplication::sendEvent(canvas, &pressEvent);<KAIGYO>//    releaseEvent = QMouseEvent(QEvent::MouseButtonRelease, QPoint(100, 100), Qt::LeftButton, Qt::LeftButton, 0);<KAIGYO>//    QApplication::sendEvent(canvas, &releaseEvent);<KAIGYO>//    QCOMPARE(canvas->rootObject()->property("""").toInt(), 0);<KAIGYO>//    QCOMPARE(canvas->rootObject()->property("""").toInt(), 0);<KAIGYO>//    QApplication::sendEvent(canvas, &pressEvent);<KAIGYO>//    QTest::qWait(1000);<KAIGYO>//    QApplication::sendEvent(canvas, &releaseEvent);<KAIGYO>//    QCOMPARE(canvas->rootObject()->property("""").toInt(), 0);<KAIGYO>//    QCOMPARE(canvas->rootObject()->property("""").toInt(), 0);<KAIGYO>//    QCOMPARE(canvas->rootObject()->property("""").toInt(), 0);<KAIGYO>//    QApplication::sendEvent(canvas, &pressEvent);<KAIGYO>//    QApplication::sendEvent(canvas, &releaseEvent);<KAIGYO>//    pressEvent = QMouseEvent(QEvent::MouseButtonDblClick, QPoint(100, 100), Qt::LeftButton, Qt::LeftButton, 0);<KAIGYO>//    QApplication::sendEvent(canvas, &pressEvent);<KAIGYO>//    QApplication::sendEvent(canvas, &releaseEvent);<KAIGYO>//    QCOMPARE(canvas->rootObject()->property("""").toInt(), 0);<KAIGYO>//    QCOMPARE(canvas->rootObject()->property("""").toInt(), 0);<KAIGYO>//    QCOMPARE(canvas->rootObject()->property("""").toInt(), 0);<KAIGYO>//    QCOMPARE(canvas->rootObject()->property("""").toInt(), 0);<KAIGYO>//    canvas->rootObject()->setProperty("""", QVariant(true));<KAIGYO>//    pressEvent = QMouseEvent(QEvent::MouseButtonPress, QPoint(100, 100), Qt::LeftButton, Qt::LeftButton, 0);<KAIGYO>//    QApplication::sendEvent(canvas, &pressEvent);<KAIGYO>//    releaseEvent = QMouseEvent(QEvent::MouseButtonRelease, QPoint(100, 100), Qt::LeftButton, Qt::LeftButton, 0);<KAIGYO>//    QApplication::sendEvent(canvas, &releaseEvent);<KAIGYO>//    QCOMPARE(canvas->rootObject()->property("""").toInt(), 0);<KAIGYO>//    QCOMPARE(canvas->rootObject()->property("""").toInt(), 1);<KAIGYO>//    QApplication::sendEvent(canvas, &pressEvent);<KAIGYO>//    QTest::qWait(1000);<KAIGYO>//    QApplication::sendEvent(canvas, &releaseEvent);<KAIGYO>//    QCOMPARE(canvas->rootObject()->property("""").toInt(), 0);<KAIGYO>//    QCOMPARE(canvas->rootObject()->property("""").toInt(), 1);<KAIGYO>//    QCOMPARE(canvas->rootObject()->property("""").toInt(), 1);<KAIGYO>//    QApplication::sendEvent(canvas, &pressEvent);<KAIGYO>//    QApplication::sendEvent(canvas, &releaseEvent);<KAIGYO>//    pressEvent = QMouseEvent(QEvent::MouseButtonDblClick, QPoint(100, 100), Qt::LeftButton, Qt::LeftButton, 0);<KAIGYO>//    QApplication::sendEvent(canvas, &pressEvent);<KAIGYO>//    QApplication::sendEvent(canvas, &releaseEvent);<KAIGYO>//    QCOMPARE(canvas->rootObject()->property("""").toInt(), 0);<KAIGYO>//    QCOMPARE(canvas->rootObject()->property("""").toInt(), 2);<KAIGYO>//    QCOMPARE(canvas->rootObject()->property("""").toInt(), 1);<KAIGYO>//    QCOMPARE(canvas->rootObject()->property("""").toInt(), 1);<KAIGYO>//    delete canvas;<KAIGYO>//}<KAIGYO>//void tst_QSGMouseArea::testQtQuick11Attributes()<KAIGYO>//{<KAIGYO>//    QFETCH(QString, code);<KAIGYO>//    QFETCH(QString, warning);<KAIGYO>//    QFETCH(QString, error);<KAIGYO>//    QDeclarativeEngine engine;<KAIGYO>//    QObject *obj;<KAIGYO>//    QDeclarativeComponent valid(&engine);<KAIGYO>//    valid.setData(""""));<KAIGYO>//    obj = valid.create();<KAIGYO>//    QVERIFY(obj);<KAIGYO>//    QVERIFY(valid.errorString().isEmpty());<KAIGYO>//    delete obj;<KAIGYO>//    QDeclarativeComponent invalid(&engine);<KAIGYO>//    invalid.setData(""""));<KAIGYO>//    QTest::ignoreMessage(QtWarningMsg, warning.toUtf8());<KAIGYO>//    obj = invalid.create();<KAIGYO>//    QCOMPARE(invalid.errorString(), error);<KAIGYO>//    delete obj;<KAIGYO>//}<KAIGYO>//void tst_QSGMouseArea::testQtQuick11Attributes_data()<KAIGYO>//{<KAIGYO>//    QTest::addColumn<QString>("""");<KAIGYO>//    QTest::addColumn<QString>("""");<KAIGYO>//    QTest::addColumn<QString>("""");<KAIGYO>//    QTest::newRow(""""<KAIGYO>//        << """"<KAIGYO>//        << """";<KAIGYO>//}<KAIGYO>//void tst_QSGMouseArea::hoverPosition()<KAIGYO>//{<KAIGYO>//    QSGView *canvas = createView();<KAIGYO>//    canvas->setSource(QUrl::fromLocalFile(SRCDIR """"));<KAIGYO>//    QSGItem *root = canvas->rootObject();<KAIGYO>//    QVERIFY(root != 0);<KAIGYO>//    QCOMPARE(root->property("""").toReal(), qreal(0));<KAIGYO>//    QCOMPARE(root->property("""").toReal(), qreal(0));<KAIGYO>//    QMouseEvent moveEvent(QEvent::MouseMove, QPoint(10, 32), Qt::NoButton, Qt::NoButton, 0);<KAIGYO>//    QApplication::sendEvent(canvas, &moveEvent);<KAIGYO>//#ifdef Q_WS_QPA<KAIGYO>//    QEXPECT_FAIL("""", Abort);<KAIGYO>//#endif<KAIGYO>//    QCOMPARE(root->property("""").toReal(), qreal(10));<KAIGYO>//    QCOMPARE(root->property("""").toReal(), qreal(32));<KAIGYO>//    delete canvas;<KAIGYO>//}<KAIGYO>//void tst_QSGMouseArea::hoverPropagation()<KAIGYO>//{<KAIGYO>//    //QTBUG-18175, to behave like GV did.<KAIGYO>//    QSGView *canvas = createView();<KAIGYO>//    canvas->setSource(QUrl::fromLocalFile(SRCDIR """"));<KAIGYO>//    QSGItem *root = canvas->rootObject();<KAIGYO>//    QVERIFY(root != 0);<KAIGYO>//    QCOMPARE(root->property("""").toBool(), false);<KAIGYO>//    QCOMPARE(root->property("""").toBool(), false);<KAIGYO>//    QMouseEvent moveEvent(QEvent::MouseMove, QPoint(32, 32), Qt::NoButton, Qt::NoButton, 0);<KAIGYO>//    QApplication::sendEvent(canvas, &moveEvent);<KAIGYO>//#ifdef Q_WS_QPA<KAIGYO>//    QEXPECT_FAIL("""", Abort);<KAIGYO>//#endif<KAIGYO>//    QCOMPARE(root->property("""").toBool(), true);<KAIGYO>//    QCOMPARE(root->property("""").toBool(), false);<KAIGYO>//    QMouseEvent moveEvent2(QEvent::MouseMove, QPoint(232, 32), Qt::NoButton, Qt::NoButton, 0);<KAIGYO>//    QApplication::sendEvent(canvas, &moveEvent2);<KAIGYO>//    QCOMPARE(root->property("""").toBool(), false);<KAIGYO>//    QCOMPARE(root->property("""").toBool(), true);<KAIGYO>//    delete canvas;<KAIGYO>//}': 1}",1.0,{'// XXX: is it on purpose that mouseX is real and mouse.x is int?': 1},1.0,{}
180,4464.0,1.0,2.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/4464,uncomment tests,1.0,{'// XXX: is it on purpose that mouseX is real and mouse.x is int?': 1},1.0,"{'//    void updateMouseAreaPosOnClick();<KAIGYO>//    void updateMouseAreaPosOnResize();<KAIGYO>//    void noOnClickedWithPressAndHold();<KAIGYO>//    void onMousePressRejected();<KAIGYO>//    void pressedCanceledOnWindowDeactivate();<KAIGYO>//    void doubleClick();<KAIGYO>//    void clickTwice();<KAIGYO>//    void pressedOrdering();<KAIGYO>//    void preventStealing();<KAIGYO>//    void clickThrough();<KAIGYO>//    void testQtQuick11Attributes();<KAIGYO>//    void testQtQuick11Attributes_data();<KAIGYO>//    void hoverPosition();<KAIGYO>//    void hoverPropagation();<KAIGYO>//void tst_QSGMouseArea::dragProperties()<KAIGYO>//{<KAIGYO>//    QSGView *canvas = createView();<KAIGYO>//    canvas->setSource(QUrl::fromLocalFile(SRCDIR """"));<KAIGYO>//    canvas->show();<KAIGYO>//    canvas->requestActivateWindow();<KAIGYO>//    QVERIFY(canvas->rootObject() != 0);<KAIGYO>//    QSGMouseArea *mouseRegion = canvas->rootObject()->findChild<QSGMouseArea*>("""");<KAIGYO>//    QSGDrag *drag = mouseRegion->drag();<KAIGYO>//    QVERIFY(mouseRegion != 0);<KAIGYO>//    QVERIFY(drag != 0);<KAIGYO>//    // target<KAIGYO>//    QSGItem *blackRect = canvas->rootObject()->findChild<QSGItem*>("""");<KAIGYO>//    QVERIFY(blackRect != 0);<KAIGYO>//    QVERIFY(blackRect == drag->target());<KAIGYO>//    QSGItem *rootItem = qobject_cast<QSGItem*>(canvas->rootObject());<KAIGYO>//    QVERIFY(rootItem != 0);<KAIGYO>//    QSignalSpy targetSpy(drag, SIGNAL(targetChanged()));<KAIGYO>//    drag->setTarget(rootItem);<KAIGYO>//    QCOMPARE(targetSpy.count(),1);<KAIGYO>//    drag->setTarget(rootItem);<KAIGYO>//    QCOMPARE(targetSpy.count(),1);<KAIGYO>//    // axis<KAIGYO>//    QCOMPARE(drag->axis(), QSGDrag::XandYAxis);<KAIGYO>//    QSignalSpy axisSpy(drag, SIGNAL(axisChanged()));<KAIGYO>//    drag->setAxis(QSGDrag::XAxis);<KAIGYO>//    QCOMPARE(drag->axis(), QSGDrag::XAxis);<KAIGYO>//    QCOMPARE(axisSpy.count(),1);<KAIGYO>//    drag->setAxis(QSGDrag::XAxis);<KAIGYO>//    QCOMPARE(axisSpy.count(),1);<KAIGYO>//    // minimum and maximum properties<KAIGYO>//    QSignalSpy xminSpy(drag, SIGNAL(minimumXChanged()));<KAIGYO>//    QSignalSpy xmaxSpy(drag, SIGNAL(maximumXChanged()));<KAIGYO>//    QSignalSpy yminSpy(drag, SIGNAL(minimumYChanged()));<KAIGYO>//    QSignalSpy ymaxSpy(drag, SIGNAL(maximumYChanged()));<KAIGYO>//    QCOMPARE(drag->xmin(), 0.0);<KAIGYO>//    QCOMPARE(drag->xmax(), rootItem->width()-blackRect->width());<KAIGYO>//    QCOMPARE(drag->ymin(), 0.0);<KAIGYO>//    QCOMPARE(drag->ymax(), rootItem->height()-blackRect->height());<KAIGYO>//    drag->setXmin(10);<KAIGYO>//    drag->setXmax(10);<KAIGYO>//    drag->setYmin(10);<KAIGYO>//    drag->setYmax(10);<KAIGYO>//    QCOMPARE(drag->xmin(), 10.0);<KAIGYO>//    QCOMPARE(drag->xmax(), 10.0);<KAIGYO>//    QCOMPARE(drag->ymin(), 10.0);<KAIGYO>//    QCOMPARE(drag->ymax(), 10.0);<KAIGYO>//    QCOMPARE(xminSpy.count(),1);<KAIGYO>//    QCOMPARE(xmaxSpy.count(),1);<KAIGYO>//    QCOMPARE(yminSpy.count(),1);<KAIGYO>//    QCOMPARE(ymaxSpy.count(),1);<KAIGYO>//    drag->setXmin(10);<KAIGYO>//    drag->setXmax(10);<KAIGYO>//    drag->setYmin(10);<KAIGYO>//    drag->setYmax(10);<KAIGYO>//    QCOMPARE(xminSpy.count(),1);<KAIGYO>//    QCOMPARE(xmaxSpy.count(),1);<KAIGYO>//    QCOMPARE(yminSpy.count(),1);<KAIGYO>//    QCOMPARE(ymaxSpy.count(),1);<KAIGYO>//    // filterChildren<KAIGYO>//    QSignalSpy filterChildrenSpy(drag, SIGNAL(filterChildrenChanged()));<KAIGYO>//    drag->setFilterChildren(true);<KAIGYO>//    QVERIFY(drag->filterChildren());<KAIGYO>//    QCOMPARE(filterChildrenSpy.count(), 1);<KAIGYO>//    drag->setFilterChildren(true);<KAIGYO>//    QCOMPARE(filterChildrenSpy.count(), 1);<KAIGYO>//    delete canvas;<KAIGYO>//}<KAIGYO>//void tst_QSGMouseArea::resetDrag()<KAIGYO>//{<KAIGYO>//    QSGView *canvas = createView();<KAIGYO>//    canvas->rootContext()->setContextProperty("""", QVariant(true));<KAIGYO>//    canvas->setSource(QUrl::fromLocalFile(SRCDIR """"));<KAIGYO>//    canvas->show();<KAIGYO>//    canvas->requestActivateWindow();<KAIGYO>//    QVERIFY(canvas->rootObject() != 0);<KAIGYO>//    QSGMouseArea *mouseRegion = canvas->rootObject()->findChild<QSGMouseArea*>("""");<KAIGYO>//    QSGDrag *drag = mouseRegion->drag();<KAIGYO>//    QVERIFY(mouseRegion != 0);<KAIGYO>//    QVERIFY(drag != 0);<KAIGYO>//    // target<KAIGYO>//    QSGItem *blackRect = canvas->rootObject()->findChild<QSGItem*>("""");<KAIGYO>//    QVERIFY(blackRect != 0);<KAIGYO>//    QVERIFY(blackRect == drag->target());<KAIGYO>//    QSGItem *rootItem = qobject_cast<QSGItem*>(canvas->rootObject());<KAIGYO>//    QVERIFY(rootItem != 0);<KAIGYO>//    QSignalSpy targetSpy(drag, SIGNAL(targetChanged()));<KAIGYO>//    QVERIFY(drag->target() != 0);<KAIGYO>//    canvas->rootContext()->setContextProperty("""", QVariant(false));<KAIGYO>//    QCOMPARE(targetSpy.count(),1);<KAIGYO>//    QVERIFY(drag->target() == 0);<KAIGYO>//    delete canvas;<KAIGYO>//}<KAIGYO>//void tst_QSGMouseArea::updateMouseAreaPosOnClick()<KAIGYO>//{<KAIGYO>//    QSGView *canvas = createView();<KAIGYO>//    canvas->setSource(QUrl::fromLocalFile(SRCDIR """"));<KAIGYO>//    canvas->show();<KAIGYO>//    canvas->requestActivateWindow();<KAIGYO>//    QVERIFY(canvas->rootObject() != 0);<KAIGYO>//    QSGMouseArea *mouseRegion = canvas->rootObject()->findChild<QSGMouseArea*>("""");<KAIGYO>//    QVERIFY(mouseRegion != 0);<KAIGYO>//    QSGRectangle *rect = canvas->rootObject()->findChild<QSGRectangle*>("""");<KAIGYO>//    QVERIFY(rect != 0);<KAIGYO>//    QCOMPARE(mouseRegion->mouseX(), rect->x());<KAIGYO>//    QCOMPARE(mouseRegion->mouseY(), rect->y());<KAIGYO>//    QMouseEvent event(QEvent::MouseButtonPress, QPoint(100, 100), Qt::LeftButton, Qt::LeftButton, 0);<KAIGYO>//    QApplication::sendEvent(canvas, &event);<KAIGYO>//    QCOMPARE(mouseRegion->mouseX(), 100.0);<KAIGYO>//    QCOMPARE(mouseRegion->mouseY(), 100.0);<KAIGYO>//    QCOMPARE(mouseRegion->mouseX(), rect->x());<KAIGYO>//    QCOMPARE(mouseRegion->mouseY(), rect->y());<KAIGYO>//    delete canvas;<KAIGYO>//}<KAIGYO>//void tst_QSGMouseArea::updateMouseAreaPosOnResize()<KAIGYO>//{<KAIGYO>//    QSGView *canvas = createView();<KAIGYO>//    canvas->setSource(QUrl::fromLocalFile(SRCDIR """"));<KAIGYO>//    canvas->show();<KAIGYO>//    canvas->requestActivateWindow();<KAIGYO>//    QVERIFY(canvas->rootObject() != 0);<KAIGYO>//    QSGMouseArea *mouseRegion = canvas->rootObject()->findChild<QSGMouseArea*>("""");<KAIGYO>//    QVERIFY(mouseRegion != 0);<KAIGYO>//    QSGRectangle *rect = canvas->rootObject()->findChild<QSGRectangle*>("""");<KAIGYO>//    QVERIFY(rect != 0);<KAIGYO>//    QCOMPARE(mouseRegion->mouseX(), 0.0);<KAIGYO>//    QCOMPARE(mouseRegion->mouseY(), 0.0);<KAIGYO>//    QMouseEvent event(QEvent::MouseButtonPress, rect->pos().toPoint(), Qt::LeftButton, Qt::LeftButton, 0);<KAIGYO>//    QApplication::sendEvent(canvas, &event);<KAIGYO>//    QVERIFY(!mouseRegion->property("""").toBool());<KAIGYO>//    QVERIFY(mouseRegion->property("""").toBool());<KAIGYO>//    QCOMPARE(mouseRegion->property("""").toInt(), 0);<KAIGYO>//    QCOMPARE(mouseRegion->property("""").toInt(), 0);<KAIGYO>//    // XXX: is it on purpose that mouseX is real and mouse.x is int?<KAIGYO>//    QCOMPARE(mouseRegion->property("""").toInt(), (int) rect->x());<KAIGYO>//    QCOMPARE(mouseRegion->property("""").toInt(), (int) rect->y());<KAIGYO>//    QCOMPARE(mouseRegion->mouseX(), rect->x());<KAIGYO>//    QCOMPARE(mouseRegion->mouseY(), rect->y());<KAIGYO>//    delete canvas;<KAIGYO>//}<KAIGYO>//void tst_QSGMouseArea::noOnClickedWithPressAndHold()<KAIGYO>//{<KAIGYO>//    {<KAIGYO>//        // We handle onPressAndHold, therefore no onClicked<KAIGYO>//        QSGView *canvas = createView();<KAIGYO>//        canvas->setSource(QUrl::fromLocalFile(SRCDIR """"));<KAIGYO>//        canvas->show();<KAIGYO>//        canvas->requestActivateWindow();<KAIGYO>//        QVERIFY(canvas->rootObject() != 0);<KAIGYO>//        QMouseEvent pressEvent(QEvent::MouseButtonPress, QPoint(100, 100), Qt::LeftButton, Qt::LeftButton, 0);<KAIGYO>//        QApplication::sendEvent(canvas, &pressEvent);<KAIGYO>//        QVERIFY(!canvas->rootObject()->property("""").toBool());<KAIGYO>//        QVERIFY(!canvas->rootObject()->property("""").toBool());<KAIGYO>//        QTest::qWait(1000);<KAIGYO>//        QMouseEvent releaseEvent(QEvent::MouseButtonRelease, QPoint(100, 100), Qt::LeftButton, Qt::LeftButton, 0);<KAIGYO>//        QApplication::sendEvent(canvas, &releaseEvent);<KAIGYO>//        QVERIFY(!canvas->rootObject()->property("""").toBool());<KAIGYO>//        QVERIFY(canvas->rootObject()->property("""").toBool());<KAIGYO>//        delete canvas;<KAIGYO>//    }<KAIGYO>//    {<KAIGYO>//        // We do not handle onPressAndHold, therefore we get onClicked<KAIGYO>//        QSGView *canvas = createView();<KAIGYO>//        canvas->setSource(QUrl::fromLocalFile(SRCDIR """"));<KAIGYO>//        canvas->show();<KAIGYO>//        canvas->requestActivateWindow();<KAIGYO>//        QVERIFY(canvas->rootObject() != 0);<KAIGYO>//        QMouseEvent pressEvent(QEvent::MouseButtonPress, QPoint(100, 100), Qt::LeftButton, Qt::LeftButton, 0);<KAIGYO>//        QApplication::sendEvent(canvas, &pressEvent);<KAIGYO>//        QVERIFY(!canvas->rootObject()->property("""").toBool());<KAIGYO>//        QTest::qWait(1000);<KAIGYO>//        QMouseEvent releaseEvent(QEvent::MouseButtonRelease, QPoint(100, 100), Qt::LeftButton, Qt::LeftButton, 0);<KAIGYO>//        QApplication::sendEvent(canvas, &releaseEvent);<KAIGYO>//        QVERIFY(canvas->rootObject()->property("""").toBool());<KAIGYO>//        delete canvas;<KAIGYO>//    }<KAIGYO>//}<KAIGYO>//void tst_QSGMouseArea::onMousePressRejected()<KAIGYO>//{<KAIGYO>//    QSGView *canvas = createView();<KAIGYO>//    canvas->setSource(QUrl::fromLocalFile(SRCDIR """"));<KAIGYO>//    canvas->show();<KAIGYO>//    canvas->requestActivateWindow();<KAIGYO>//    QVERIFY(canvas->rootObject() != 0);<KAIGYO>//    QVERIFY(canvas->rootObject()->property("""").toBool());<KAIGYO>//    QVERIFY(!canvas->rootObject()->property("""").toBool());<KAIGYO>//    QVERIFY(!canvas->rootObject()->property("""").toBool());<KAIGYO>//    QVERIFY(!canvas->rootObject()->property("""").toBool());<KAIGYO>//    QVERIFY(!canvas->rootObject()->property("""").toBool());<KAIGYO>//    QVERIFY(!canvas->rootObject()->property("""").toBool());<KAIGYO>//    QVERIFY(!canvas->rootObject()->property("""").toBool());<KAIGYO>//    QMouseEvent pressEvent(QEvent::MouseButtonPress, QPoint(100, 100), Qt::LeftButton, Qt::LeftButton, 0);<KAIGYO>//    QApplication::sendEvent(canvas, &pressEvent);<KAIGYO>//    QVERIFY(canvas->rootObject()->property("""").toBool());<KAIGYO>//    QVERIFY(!canvas->rootObject()->property("""").toBool());<KAIGYO>//    QVERIFY(!canvas->rootObject()->property("""").toBool());<KAIGYO>//    QVERIFY(canvas->rootObject()->property("""").toBool());<KAIGYO>//    QVERIFY(!canvas->rootObject()->property("""").toBool());<KAIGYO>//    QVERIFY(canvas->rootObject()->property("""").toBool());<KAIGYO>//    QTest::qWait(200);<KAIGYO>//    QMouseEvent releaseEvent(QEvent::MouseButtonRelease, QPoint(100, 100), Qt::LeftButton, Qt::LeftButton, 0);<KAIGYO>//    QApplication::sendEvent(canvas, &releaseEvent);<KAIGYO>//    QVERIFY(canvas->rootObject()->property("""").toBool());<KAIGYO>//    QVERIFY(!canvas->rootObject()->property("""").toBool());<KAIGYO>//    QVERIFY(!canvas->rootObject()->property("""").toBool());<KAIGYO>//    delete canvas;<KAIGYO>//}<KAIGYO>//void tst_QSGMouseArea::pressedCanceledOnWindowDeactivate()<KAIGYO>//{<KAIGYO>//    QSGView *canvas = createView();<KAIGYO>//    canvas->setSource(QUrl::fromLocalFile(SRCDIR """"));<KAIGYO>//    canvas->show();<KAIGYO>//    canvas->requestActivateWindow();<KAIGYO>//    QVERIFY(canvas->rootObject() != 0);<KAIGYO>//    QVERIFY(!canvas->rootObject()->property("""").toBool());<KAIGYO>//    QVERIFY(!canvas->rootObject()->property("""").toBool());<KAIGYO>//    QVERIFY(!canvas->rootObject()->property("""").toBool());<KAIGYO>//    QMouseEvent pressEvent(QEvent::MouseButtonPress, QPoint(100, 100), Qt::LeftButton, Qt::LeftButton, 0);<KAIGYO>//    QApplication::sendEvent(canvas, &pressEvent);<KAIGYO>//    QVERIFY(canvas->rootObject()->property("""").toBool());<KAIGYO>//    QVERIFY(!canvas->rootObject()->property("""").toBool());<KAIGYO>//    QVERIFY(!canvas->rootObject()->property("""").toBool());<KAIGYO>//    QTest::qWait(200);<KAIGYO>//    QEvent windowDeactivateEvent(QEvent::WindowDeactivate);<KAIGYO>//    QApplication::sendEvent(canvas, &windowDeactivateEvent);<KAIGYO>//    QVERIFY(!canvas->rootObject()->property("""").toBool());<KAIGYO>//    QVERIFY(canvas->rootObject()->property("""").toBool());<KAIGYO>//    QVERIFY(!canvas->rootObject()->property("""").toBool());<KAIGYO>//    QTest::qWait(200);<KAIGYO>//    //press again<KAIGYO>//    QApplication::sendEvent(canvas, &pressEvent);<KAIGYO>//    QVERIFY(canvas->rootObject()->property("""").toBool());<KAIGYO>//    QVERIFY(!canvas->rootObject()->property("""").toBool());<KAIGYO>//    QVERIFY(!canvas->rootObject()->property("""").toBool());<KAIGYO>//    QTest::qWait(200);<KAIGYO>//    //release<KAIGYO>//    QMouseEvent releaseEvent(QEvent::MouseButtonRelease, QPoint(100, 100), Qt::LeftButton, Qt::LeftButton, 0);<KAIGYO>//    QApplication::sendEvent(canvas, &releaseEvent);<KAIGYO>//    QVERIFY(!canvas->rootObject()->property("""").toBool());<KAIGYO>//    QVERIFY(!canvas->rootObject()->property("""").toBool());<KAIGYO>//    QVERIFY(canvas->rootObject()->property("""").toBool());<KAIGYO>//    delete canvas;<KAIGYO>//}<KAIGYO>//void tst_QSGMouseArea::doubleClick()<KAIGYO>//{<KAIGYO>//    QSGView *canvas = createView();<KAIGYO>//    canvas->setSource(QUrl::fromLocalFile(SRCDIR """"));<KAIGYO>//    canvas->show();<KAIGYO>//    canvas->requestActivateWindow();<KAIGYO>//    QVERIFY(canvas->rootObject() != 0);<KAIGYO>//    QMouseEvent pressEvent(QEvent::MouseButtonPress, QPoint(100, 100), Qt::LeftButton, Qt::LeftButton, 0);<KAIGYO>//    QApplication::sendEvent(canvas, &pressEvent);<KAIGYO>//    QMouseEvent releaseEvent(QEvent::MouseButtonRelease, QPoint(100, 100), Qt::LeftButton, Qt::LeftButton, 0);<KAIGYO>//    QApplication::sendEvent(canvas, &releaseEvent);<KAIGYO>//    QCOMPARE(canvas->rootObject()->property("""").toInt(), 1);<KAIGYO>//    pressEvent = QMouseEvent(QEvent::MouseButtonDblClick, QPoint(100, 100), Qt::LeftButton, Qt::LeftButton, 0);<KAIGYO>//    QApplication::sendEvent(canvas, &pressEvent);<KAIGYO>//    QApplication::sendEvent(canvas, &releaseEvent);<KAIGYO>//    QCOMPARE(canvas->rootObject()->property("""").toInt(), 1);<KAIGYO>//    QCOMPARE(canvas->rootObject()->property("""").toInt(), 1);<KAIGYO>//    QCOMPARE(canvas->rootObject()->property("""").toInt(), 2);<KAIGYO>//    delete canvas;<KAIGYO>//}<KAIGYO>//// QTBUG-14832<KAIGYO>//void tst_QSGMouseArea::clickTwice()<KAIGYO>//{<KAIGYO>//    QSGView *canvas = createView();<KAIGYO>//    canvas->setSource(QUrl::fromLocalFile(SRCDIR """"));<KAIGYO>//    canvas->show();<KAIGYO>//    canvas->requestActivateWindow();<KAIGYO>//    QVERIFY(canvas->rootObject() != 0);<KAIGYO>//    QMouseEvent pressEvent(QEvent::MouseButtonPress, QPoint(100, 100), Qt::LeftButton, Qt::LeftButton, 0);<KAIGYO>//    QApplication::sendEvent(canvas, &pressEvent);<KAIGYO>//    QMouseEvent releaseEvent(QEvent::MouseButtonRelease, QPoint(100, 100), Qt::LeftButton, Qt::LeftButton, 0);<KAIGYO>//    QApplication::sendEvent(canvas, &releaseEvent);<KAIGYO>//    QCOMPARE(canvas->rootObject()->property("""").toInt(), 1);<KAIGYO>//    QCOMPARE(canvas->rootObject()->property("""").toInt(), 1);<KAIGYO>//    QCOMPARE(canvas->rootObject()->property("""").toInt(), 1);<KAIGYO>//    pressEvent = QMouseEvent(QEvent::MouseButtonDblClick, QPoint(100, 100), Qt::LeftButton, Qt::LeftButton, 0);<KAIGYO>//    QApplication::sendEvent(canvas, &pressEvent);<KAIGYO>//    QApplication::sendEvent(canvas, &pressEvent);<KAIGYO>//    QApplication::sendEvent(canvas, &releaseEvent);<KAIGYO>//    QCOMPARE(canvas->rootObject()->property("""").toInt(), 2);<KAIGYO>//    QCOMPARE(canvas->rootObject()->property("""").toInt(), 2);<KAIGYO>//    QCOMPARE(canvas->rootObject()->property("""").toInt(), 2);<KAIGYO>//    delete canvas;<KAIGYO>//}<KAIGYO>//void tst_QSGMouseArea::pressedOrdering()<KAIGYO>//{<KAIGYO>//    QSGView *canvas = createView();<KAIGYO>//    canvas->setSource(QUrl::fromLocalFile(SRCDIR """"));<KAIGYO>//    canvas->show();<KAIGYO>//    canvas->requestActivateWindow();<KAIGYO>//    QVERIFY(canvas->rootObject() != 0);<KAIGYO>//    QCOMPARE(canvas->rootObject()->property(""""));<KAIGYO>//    QMouseEvent pressEvent(QEvent::MouseButtonPress, QPoint(100, 100), Qt::LeftButton, Qt::LeftButton, 0);<KAIGYO>//    QApplication::sendEvent(canvas, &pressEvent);<KAIGYO>//    QCOMPARE(canvas->rootObject()->property(""""));<KAIGYO>//    QMouseEvent releaseEvent(QEvent::MouseButtonRelease, QPoint(100, 100), Qt::LeftButton, Qt::LeftButton, 0);<KAIGYO>//    QApplication::sendEvent(canvas, &releaseEvent);<KAIGYO>//    QCOMPARE(canvas->rootObject()->property(""""));<KAIGYO>//    QApplication::sendEvent(canvas, &pressEvent);<KAIGYO>//    QCOMPARE(canvas->rootObject()->property(""""));<KAIGYO>//    delete canvas;<KAIGYO>//}<KAIGYO>//void tst_QSGMouseArea::preventStealing()<KAIGYO>//{<KAIGYO>//    QSGView *canvas = createView();<KAIGYO>//    canvas->setSource(QUrl::fromLocalFile(SRCDIR """"));<KAIGYO>//    canvas->show();<KAIGYO>//    canvas->requestActivateWindow();<KAIGYO>//    QVERIFY(canvas->rootObject() != 0);<KAIGYO>//    QSGFlickable *flickable = qobject_cast<QSGFlickable*>(canvas->rootObject());<KAIGYO>//    QVERIFY(flickable != 0);<KAIGYO>//    QSGMouseArea *mouseArea = canvas->rootObject()->findChild<QSGMouseArea*>("""");<KAIGYO>//    QVERIFY(mouseArea != 0);<KAIGYO>//    QSignalSpy mousePositionSpy(mouseArea, SIGNAL(positionChanged(QSGMouseEvent*)));<KAIGYO>//    QTest::mousePress(canvas, Qt::LeftButton, 0, QPoint(80, 80));<KAIGYO>//    // Without preventStealing, mouse movement over MouseArea would<KAIGYO>//    // cause the Flickable to steal mouse and trigger content movement.<KAIGYO>//    QMouseEvent moveEvent(QEvent::MouseMove, QPoint(70, 70), Qt::LeftButton, Qt::LeftButton, 0);<KAIGYO>//    QApplication::sendEvent(canvas, &moveEvent);<KAIGYO>//    moveEvent = QMouseEvent(QEvent::MouseMove, QPoint(60, 60), Qt::LeftButton, Qt::LeftButton, 0);<KAIGYO>//    QApplication::sendEvent(canvas, &moveEvent);<KAIGYO>//    moveEvent = QMouseEvent(QEvent::MouseMove, QPoint(50, 50), Qt::LeftButton, Qt::LeftButton, 0);<KAIGYO>//    QApplication::sendEvent(canvas, &moveEvent);<KAIGYO>//    // We should have received all three move events<KAIGYO>//    QCOMPARE(mousePositionSpy.count(), 3);<KAIGYO>//    QVERIFY(mouseArea->pressed());<KAIGYO>//    // Flickable content should not have moved.<KAIGYO>//    QCOMPARE(flickable->contentX(), 0.);<KAIGYO>//    QCOMPARE(flickable->contentY(), 0.);<KAIGYO>//    QTest::mouseRelease(canvas, Qt::LeftButton, 0, QPoint(50, 50));<KAIGYO>//    // Now allow stealing and confirm Flickable does its thing.<KAIGYO>//    canvas->rootObject()->setProperty("""", false);<KAIGYO>//    QTest::mousePress(canvas, Qt::LeftButton, 0, QPoint(80, 80));<KAIGYO>//    // Without preventStealing, mouse movement over MouseArea would<KAIGYO>//    // cause the Flickable to steal mouse and trigger content movement.<KAIGYO>//    moveEvent = QMouseEvent(QEvent::MouseMove, QPoint(70, 70), Qt::LeftButton, Qt::LeftButton, 0);<KAIGYO>//    QApplication::sendEvent(canvas, &moveEvent);<KAIGYO>//    moveEvent = QMouseEvent(QEvent::MouseMove, QPoint(60, 60), Qt::LeftButton, Qt::LeftButton, 0);<KAIGYO>//    QApplication::sendEvent(canvas, &moveEvent);<KAIGYO>//    moveEvent = QMouseEvent(QEvent::MouseMove, QPoint(50, 50), Qt::LeftButton, Qt::LeftButton, 0);<KAIGYO>//    QApplication::sendEvent(canvas, &moveEvent);<KAIGYO>//    // We should only have received the first move event<KAIGYO>//    QCOMPARE(mousePositionSpy.count(), 4);<KAIGYO>//    // Our press should be taken away<KAIGYO>//    QVERIFY(!mouseArea->pressed());<KAIGYO>//    // Flickable content should have moved.<KAIGYO>//    QCOMPARE(flickable->contentX(), 10.);<KAIGYO>//    QCOMPARE(flickable->contentY(), 10.);<KAIGYO>//    QTest::mouseRelease(canvas, Qt::LeftButton, 0, QPoint(50, 50));<KAIGYO>//    delete canvas;<KAIGYO>//}<KAIGYO>//void tst_QSGMouseArea::clickThrough()<KAIGYO>//{<KAIGYO>//    //With no handlers defined click, doubleClick and PressAndHold should propagate to those with handlers<KAIGYO>//    QSGView *canvas = createView();<KAIGYO>//    canvas->setSource(QUrl::fromLocalFile(SRCDIR """"));<KAIGYO>//    canvas->show();<KAIGYO>//    canvas->requestActivateWindow();<KAIGYO>//    QVERIFY(canvas->rootObject() != 0);<KAIGYO>//    QMouseEvent pressEvent(QEvent::MouseButtonPress, QPoint(100, 100), Qt::LeftButton, Qt::LeftButton, 0);<KAIGYO>//    QApplication::sendEvent(canvas, &pressEvent);<KAIGYO>//    QMouseEvent releaseEvent(QEvent::MouseButtonRelease, QPoint(100, 100), Qt::LeftButton, Qt::LeftButton, 0);<KAIGYO>//    QApplication::sendEvent(canvas, &releaseEvent);<KAIGYO>//    QCOMPARE(canvas->rootObject()->property("""").toInt(), 0);<KAIGYO>//    QCOMPARE(canvas->rootObject()->property("""").toInt(), 1);<KAIGYO>//    QApplication::sendEvent(canvas, &pressEvent);<KAIGYO>//    QTest::qWait(1000);<KAIGYO>//    QApplication::sendEvent(canvas, &releaseEvent);<KAIGYO>//    QCOMPARE(canvas->rootObject()->property("""").toInt(), 0);<KAIGYO>//    QCOMPARE(canvas->rootObject()->property("""").toInt(), 1);<KAIGYO>//    QCOMPARE(canvas->rootObject()->property("""").toInt(), 1);<KAIGYO>//    QApplication::sendEvent(canvas, &pressEvent);<KAIGYO>//    QApplication::sendEvent(canvas, &releaseEvent);<KAIGYO>//    pressEvent = QMouseEvent(QEvent::MouseButtonDblClick, QPoint(100, 100), Qt::LeftButton, Qt::LeftButton, 0);<KAIGYO>//    QApplication::sendEvent(canvas, &pressEvent);<KAIGYO>//    QApplication::sendEvent(canvas, &releaseEvent);<KAIGYO>//    QCOMPARE(canvas->rootObject()->property("""").toInt(), 0);<KAIGYO>//    QCOMPARE(canvas->rootObject()->property("""").toInt(), 2);<KAIGYO>//    QCOMPARE(canvas->rootObject()->property("""").toInt(), 1);<KAIGYO>//    QCOMPARE(canvas->rootObject()->property("""").toInt(), 1);<KAIGYO>//    delete canvas;<KAIGYO>//    //With handlers defined click, doubleClick and PressAndHold should propagate only when explicitly ignored<KAIGYO>//    canvas = createView();<KAIGYO>//    canvas->setSource(QUrl::fromLocalFile(SRCDIR """"));<KAIGYO>//    canvas->show();<KAIGYO>//    canvas->requestActivateWindow();<KAIGYO>//    QVERIFY(canvas->rootObject() != 0);<KAIGYO>//    pressEvent = QMouseEvent(QEvent::MouseButtonPress, QPoint(100, 100), Qt::LeftButton, Qt::LeftButton, 0);<KAIGYO>//    QApplication::sendEvent(canvas, &pressEvent);<KAIGYO>//    releaseEvent = QMouseEvent(QEvent::MouseButtonRelease, QPoint(100, 100), Qt::LeftButton, Qt::LeftButton, 0);<KAIGYO>//    QApplication::sendEvent(canvas, &releaseEvent);<KAIGYO>//    QCOMPARE(canvas->rootObject()->property("""").toInt(), 0);<KAIGYO>//    QCOMPARE(canvas->rootObject()->property("""").toInt(), 0);<KAIGYO>//    QApplication::sendEvent(canvas, &pressEvent);<KAIGYO>//    QTest::qWait(1000);<KAIGYO>//    QApplication::sendEvent(canvas, &releaseEvent);<KAIGYO>//    QCOMPARE(canvas->rootObject()->property("""").toInt(), 0);<KAIGYO>//    QCOMPARE(canvas->rootObject()->property("""").toInt(), 0);<KAIGYO>//    QCOMPARE(canvas->rootObject()->property("""").toInt(), 0);<KAIGYO>//    QApplication::sendEvent(canvas, &pressEvent);<KAIGYO>//    QApplication::sendEvent(canvas, &releaseEvent);<KAIGYO>//    pressEvent = QMouseEvent(QEvent::MouseButtonDblClick, QPoint(100, 100), Qt::LeftButton, Qt::LeftButton, 0);<KAIGYO>//    QApplication::sendEvent(canvas, &pressEvent);<KAIGYO>//    QApplication::sendEvent(canvas, &releaseEvent);<KAIGYO>//    QCOMPARE(canvas->rootObject()->property("""").toInt(), 0);<KAIGYO>//    QCOMPARE(canvas->rootObject()->property("""").toInt(), 0);<KAIGYO>//    QCOMPARE(canvas->rootObject()->property("""").toInt(), 0);<KAIGYO>//    QCOMPARE(canvas->rootObject()->property("""").toInt(), 0);<KAIGYO>//    canvas->rootObject()->setProperty("""", QVariant(true));<KAIGYO>//    pressEvent = QMouseEvent(QEvent::MouseButtonPress, QPoint(100, 100), Qt::LeftButton, Qt::LeftButton, 0);<KAIGYO>//    QApplication::sendEvent(canvas, &pressEvent);<KAIGYO>//    releaseEvent = QMouseEvent(QEvent::MouseButtonRelease, QPoint(100, 100), Qt::LeftButton, Qt::LeftButton, 0);<KAIGYO>//    QApplication::sendEvent(canvas, &releaseEvent);<KAIGYO>//    QCOMPARE(canvas->rootObject()->property("""").toInt(), 0);<KAIGYO>//    QCOMPARE(canvas->rootObject()->property("""").toInt(), 1);<KAIGYO>//    QApplication::sendEvent(canvas, &pressEvent);<KAIGYO>//    QTest::qWait(1000);<KAIGYO>//    QApplication::sendEvent(canvas, &releaseEvent);<KAIGYO>//    QCOMPARE(canvas->rootObject()->property("""").toInt(), 0);<KAIGYO>//    QCOMPARE(canvas->rootObject()->property("""").toInt(), 1);<KAIGYO>//    QCOMPARE(canvas->rootObject()->property("""").toInt(), 1);<KAIGYO>//    QApplication::sendEvent(canvas, &pressEvent);<KAIGYO>//    QApplication::sendEvent(canvas, &releaseEvent);<KAIGYO>//    pressEvent = QMouseEvent(QEvent::MouseButtonDblClick, QPoint(100, 100), Qt::LeftButton, Qt::LeftButton, 0);<KAIGYO>//    QApplication::sendEvent(canvas, &pressEvent);<KAIGYO>//    QApplication::sendEvent(canvas, &releaseEvent);<KAIGYO>//    QCOMPARE(canvas->rootObject()->property("""").toInt(), 0);<KAIGYO>//    QCOMPARE(canvas->rootObject()->property("""").toInt(), 2);<KAIGYO>//    QCOMPARE(canvas->rootObject()->property("""").toInt(), 1);<KAIGYO>//    QCOMPARE(canvas->rootObject()->property("""").toInt(), 1);<KAIGYO>//    delete canvas;<KAIGYO>//}<KAIGYO>//void tst_QSGMouseArea::testQtQuick11Attributes()<KAIGYO>//{<KAIGYO>//    QFETCH(QString, code);<KAIGYO>//    QFETCH(QString, warning);<KAIGYO>//    QFETCH(QString, error);<KAIGYO>//    QDeclarativeEngine engine;<KAIGYO>//    QObject *obj;<KAIGYO>//    QDeclarativeComponent valid(&engine);<KAIGYO>//    valid.setData(""""));<KAIGYO>//    obj = valid.create();<KAIGYO>//    QVERIFY(obj);<KAIGYO>//    QVERIFY(valid.errorString().isEmpty());<KAIGYO>//    delete obj;<KAIGYO>//    QDeclarativeComponent invalid(&engine);<KAIGYO>//    invalid.setData(""""));<KAIGYO>//    QTest::ignoreMessage(QtWarningMsg, warning.toUtf8());<KAIGYO>//    obj = invalid.create();<KAIGYO>//    QCOMPARE(invalid.errorString(), error);<KAIGYO>//    delete obj;<KAIGYO>//}<KAIGYO>//void tst_QSGMouseArea::testQtQuick11Attributes_data()<KAIGYO>//{<KAIGYO>//    QTest::addColumn<QString>("""");<KAIGYO>//    QTest::addColumn<QString>("""");<KAIGYO>//    QTest::addColumn<QString>("""");<KAIGYO>//    QTest::newRow(""""<KAIGYO>//        << """"<KAIGYO>//        << """";<KAIGYO>//}<KAIGYO>//void tst_QSGMouseArea::hoverPosition()<KAIGYO>//{<KAIGYO>//    QSGView *canvas = createView();<KAIGYO>//    canvas->setSource(QUrl::fromLocalFile(SRCDIR """"));<KAIGYO>//    QSGItem *root = canvas->rootObject();<KAIGYO>//    QVERIFY(root != 0);<KAIGYO>//    QCOMPARE(root->property("""").toReal(), qreal(0));<KAIGYO>//    QCOMPARE(root->property("""").toReal(), qreal(0));<KAIGYO>//    QMouseEvent moveEvent(QEvent::MouseMove, QPoint(10, 32), Qt::NoButton, Qt::NoButton, 0);<KAIGYO>//    QApplication::sendEvent(canvas, &moveEvent);<KAIGYO>//#ifdef Q_WS_QPA<KAIGYO>//    QEXPECT_FAIL("""", Abort);<KAIGYO>//#endif<KAIGYO>//    QCOMPARE(root->property("""").toReal(), qreal(10));<KAIGYO>//    QCOMPARE(root->property("""").toReal(), qreal(32));<KAIGYO>//    delete canvas;<KAIGYO>//}<KAIGYO>//void tst_QSGMouseArea::hoverPropagation()<KAIGYO>//{<KAIGYO>//    //QTBUG-18175, to behave like GV did.<KAIGYO>//    QSGView *canvas = createView();<KAIGYO>//    canvas->setSource(QUrl::fromLocalFile(SRCDIR """"));<KAIGYO>//    QSGItem *root = canvas->rootObject();<KAIGYO>//    QVERIFY(root != 0);<KAIGYO>//    QCOMPARE(root->property("""").toBool(), false);<KAIGYO>//    QCOMPARE(root->property("""").toBool(), false);<KAIGYO>//    QMouseEvent moveEvent(QEvent::MouseMove, QPoint(32, 32), Qt::NoButton, Qt::NoButton, 0);<KAIGYO>//    QApplication::sendEvent(canvas, &moveEvent);<KAIGYO>//#ifdef Q_WS_QPA<KAIGYO>//    QEXPECT_FAIL("""", Abort);<KAIGYO>//#endif<KAIGYO>//    QCOMPARE(root->property("""").toBool(), true);<KAIGYO>//    QCOMPARE(root->property("""").toBool(), false);<KAIGYO>//    QMouseEvent moveEvent2(QEvent::MouseMove, QPoint(232, 32), Qt::NoButton, Qt::NoButton, 0);<KAIGYO>//    QApplication::sendEvent(canvas, &moveEvent2);<KAIGYO>//    QCOMPARE(root->property("""").toBool(), false);<KAIGYO>//    QCOMPARE(root->property("""").toBool(), true);<KAIGYO>//    delete canvas;<KAIGYO>//}': 1}",1.0,{}
277,4497.0,3.0,14.0,4.0,MERGED,True,https://codereview.qt-project.org/#/c/4497,Reduce compile warnings,1.0,{'//qreal sizeOffset = d->size/2;//TODO: Current size? As an option': 1},1.0,"{'//TODO: Current size? As an option': 1, '//TODO: Faster': 2}",1.0,{}
291,4605.0,1.0,4.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/4605,synchronize qmake project parser with qt creator,1.0,"{""// Unlike QFileInfo, this won't accept a relative path with a drive letter.<KAIGYO>// Such paths result in a royal mess anyway ..."": 1, '// VariableName must be us-ascii, the content however can be non-us-ascii.<KAIGYO>// Temporaries for efficient toQString': 1, '// FIXME: this should not build new strings for direct sections.<KAIGYO>// Note that the E_SPRINTF and E_LIST implementations rely on the deep copy.': 1, '// stupid, but qmake is like that': 1, '// The (QChar*)current->constData() constructs below avoid pointless detach() calls<KAIGYO>// FIXME: This is inefficient. Should not make new string if it is a straight subsegment': 1, '// FIXME: ret.reserve(ret.size() + replacement.size() - 2);': 1, ""// This is stupid, but qmake doesn't propagate deletions"": 1, '// MSVC2010 doesn\'t seem to know the semantics of """" ...': 1, '// FIXME: could/should expand this immediately': 1, ""// '|' could actually work reasonably, but qmake does nonsense here."": 1}",1.0,"{'// XXX Ripped out caching, so this will be slow. Should not matter for current uses.': 1, '//fix separators': 1, '// stupid, but qmake is like that': 1, '// This is what qmake does, everything set in the mkspec is also set<KAIGYO>// But this also creates a lot of problems': 1, '// ### missing: breaking out of multiline blocks': 1, '//cond = isActiveConfig(args.first()); XXX': 1, ""// ### this breaks if we have include(c:/reallystupid.pri) but IMHO that's really bad style."": 1, '//parser file; qmake is a bit weird here': 1, '// FIXME?': 1}",1.0,{}
468,4699.0,3.0,9.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/4699,Refactor SpriteEngine out of StochasticEngine,1.0,{},0.0,"{'//TODO: Split out particle system dependency': 1, ""//TODO: Document particle 'type'"": 1}",1.0,{}
334,4735.0,1.0,6.0,0.0,ABANDONED,False,https://codereview.qt-project.org/#/c/4735,Merge branch 'refactor',1.0,{'// ### refactor<KAIGYO>// blur the alpha channel': 1},1.0,{'// ### refactor<KAIGYO>// blur the alpha channel': 1},1.0,{}
344,4753.0,1.0,5.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/4753,Remove invalid ASSERT,1.0,{},0.0,{'//XXX when GC done right': 1},1.0,{}
426,4776.0,2.0,10.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/4776,Remove uilib and QtUiTools from QtBase,1.0,{},0.0,"{'// maybe this should go first, before create()...': 1, '// VC6 would not find templated members, so we use statics and this utter hack.': 1, ' /* TODO<KAIGYO>    if (!ip.second.isEmpty())<KAIGYO>        pix->setAttributeResource(ip.second);<KAIGYO>*/': 1, '// Triggers in case of objects in Designer like Spacer/Line for which properties<KAIGYO>// are serialized using language introspection. On preview, however, these objects are<KAIGYO>// emulated by hacks in the formbuilder (size policy/orientation)': 1, '// ### special-casing for Line (QFrame) -- fix for 4.2. Jambi hack for enumerations': 1}",1.0,{}
416,4857.0,3.0,14.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/4857,fix broken canvas blur after merging refactor branch,1.0,{},0.0,{'// ### refactor<KAIGYO>// blur the alpha channel': 1},1.0,{}
51,5096.0,1.0,7.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/5096,Enable glyph caching on QPA,1.0,{},0.0,"{'// ### hm, perhaps an QFixed offs = QFixed::fromReal(aliasedCoordinateDelta) is needed here?': 1}",1.0,{}
83,5172.0,1.0,6.0,2.0,MERGED,True,https://codereview.qt-project.org/#/c/5172,Refactor QSGParticleAffector internals,1.0,{},0.0,{'//TODO: Surely this can be done better': 1},1.0,{}
245,5199.0,2.0,5.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/5199,Add whitespace,1.0,"{'//TODO: Aux emiiters in the state definition (which allows the occasional ball to spontaneously combust)': 1, '//acceleration: AngledDirection {angleVariation: 360; magnitude: 200}//Is this a better effect, more consistent speed?': 1, '//TODO: Augment with PARTICLES': 1, '//TODO: Transitions between modes (and a second mode...)': 1, '//TODO: Actual targetVariation': 1, '//TODO: Hardpoint abstraction': 1, '//Misses with Lasers are really rare': 1, '//TODO: Particle Text?': 1}",1.0,"{'//TODO: Aux emiiters in the state definition (which allows the occasional ball to spontaneously combust)': 1, '//acceleration: AngledDirection{angleVariation: 360; magnitude: 200}//Is this a better effect, more consistent speed?': 1, '//TODO: Augment with PARTICLES': 1, '//TODO: Transitions between modes (and a second mode...)': 1, '//TODO: Actual targetVariation': 1, '//TODO: Hardpoint abstraction': 1, '//Misses with Lasers are really rare': 1, '//TODO: Particle Text?': 1}",1.0,{}
110,5245.0,2.0,9.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/5245,"Make the QML-VME interpreter ""threading""-friendly",1.0,{'// ### What about failures in deferred creation?': 1},1.0,{'// ### What about failures in deferred creation?': 1},1.0,{}
146,5246.0,5.0,17.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/5246,Make the QML/VME interpreter threaded,1.0,"{'//        ss.bindingId = rewriteBinding(script, prop->name());<KAIGYO>// XXX': 5, '// XXX - bigger than necessary<KAIGYO>// XXX - bigger than necessary': 5}",1.0,"{'//        ss.storeScriptString.bindingId = rewriteBinding(script, prop->name());<KAIGYO>// XXX': 5, '// XXX - bigger than necessary<KAIGYO>// XXX - bigger than necessary': 5}",1.0,{}
457,5357.0,25.0,52.0,27.0,ABANDONED,False,https://codereview.qt-project.org/#/c/5357,Implement .pragma threaded JavaScript imports,1.0,"{'// XXX TODO: Handle errors that occur duing the script compile': 1, '// This is due to an unknown bug which sometimes seems to cause the context to be collected..?': 1, ""// JSON doesn't serialize null, undefined, RegExps or Dates properly."": 3, ""// XXX TODO: change our newScriptProxy code to take an initialised script instead?  then don't use two different codepaths.. but...?"": 6, '// build our receiver, argc and argv<KAIGYO>// XXX TODO: should this be script->scriptObject ??': 6, '// XXX TODO: test listmodel arguments': 6, '/*!<KAIGYO>  \\internal<KAIGYO>  \\class QV8ThreadedJsWrapper<KAIGYO>  \\brief Creates proxy JavaScript objects for threaded scripts<KAIGYO><KAIGYO>  This wrapper class is used to provide clients with callable script proxy<KAIGYO>  objects given a threaded script import.  The functions contained within<KAIGYO>  the import are exposed as callable (function proxy) object properties of<KAIGYO>  the script proxy object.<KAIGYO><KAIGYO>  The function proxy object may be generated given a script id and the name<KAIGYO>  of a function within that script, or given the function id of the function<KAIGYO>  if it has been tracked by the thread previously. XXX TODO: do we still track?<KAIGYO><KAIGYO>  The proxy object may be called, and when that happens, the<KAIGYO>  QV8ThreadedJsWrapperPrivate will be called and an event will be posted to<KAIGYO>  the thread to execute the proxied function.<KAIGYO> */': 16}",1.0,{'// XXX TODO: Handle errors that occur duing the script compile': 1},1.0,{}
163,5370.0,1.0,4.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/5370,Use m_pleaseReset more consistently,1.0,{},0.0,"{'//TODO: useful QML warnings, like line number?': 1}",1.0,{}
224,5526.0,1.0,5.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/5526,Remove dead code from QAccessibleTabBar.,1.0,{},0.0,{'// FIXME': 1},1.0,{}
228,5536.0,1.0,6.0,1.0,MERGED,True,https://codereview.qt-project.org/#/c/5536,QAccessibleToolButton fixes.,1.0,{},0.0,"{'// FIXME': 1, '// FIXME: sub buttons when SplitButton<KAIGYO>//    QStyleOptionToolButton opt;<KAIGYO>//    opt.init(widget());<KAIGYO>//    QRect subrect = widget()->style()->subControlRect(QStyle::CC_ToolButton, &opt,<KAIGYO>//                                                      QStyle::SC_ToolButtonMenu, toolButton());': 1}",1.0,{}
241,5564.0,1.0,2.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/5564,Remove QVariantAnimation2.,1.0,{},0.0,"{""/*!<KAIGYO>    \\class QVariantAnimation2<KAIGYO>    \\ingroup animation<KAIGYO>    \\brief The QVariantAnimation2 class provides an abstract base class for animations.<KAIGYO>    \\since 4.6<KAIGYO><KAIGYO>    This class is part of \\l{The Animation Framework}. It serves as a<KAIGYO>    base class for property and item animations, with functions for<KAIGYO>    shared functionality.<KAIGYO><KAIGYO>    QVariantAnimation2 cannot be used directly as it is an abstract<KAIGYO>    class; it has a pure virtual method called updateCurrentValue().<KAIGYO>    The class performs interpolation over<KAIGYO>    \\l{QVariant}s, but leaves using the interpolated values to its<KAIGYO>    subclasses. Currently, Qt provides QPropertyAnimation2, which<KAIGYO>    animates Qt \\l{Qt's Property System}{properties}. See the<KAIGYO>    QPropertyAnimation2 class description if you wish to animate such<KAIGYO>    properties.<KAIGYO><KAIGYO>    You can then set start and end values for the property by calling<KAIGYO>    setStartValue() and setEndValue(), and finally call start() to<KAIGYO>    start the animation. QVariantAnimation2 will interpolate the<KAIGYO>    property of the target object and emit valueChanged(). To react to<KAIGYO>    a change in the current value you have to reimplement the<KAIGYO>    updateCurrentValue() virtual function.<KAIGYO><KAIGYO>    It is also possible to set values at specified steps situated<KAIGYO>    between the start and end value. The interpolation will then<KAIGYO>    touch these points at the specified steps. Note that the start and<KAIGYO>    end values are defined as the key values at 0.0 and 1.0.<KAIGYO><KAIGYO>    There are two ways to affect how QVariantAnimation2 interpolates<KAIGYO>    the values. You can set an easing curve by calling<KAIGYO>    setEasingCurve(), and configure the duration by calling<KAIGYO>    setDuration(). You can change how the QVariants are interpolated<KAIGYO>    by creating a subclass of QVariantAnimation2, and reimplementing<KAIGYO>    the virtual interpolated() function.<KAIGYO><KAIGYO>    Subclassing QVariantAnimation2 can be an alternative if you have<KAIGYO>    \\l{QVariant}s that you do not wish to declare as Qt properties.<KAIGYO>    Note, however, that you in most cases will be better off declaring<KAIGYO>    your QVariant as a property.<KAIGYO><KAIGYO>    Not all QVariant types are supported. Below is a list of currently<KAIGYO>    supported QVariant types:<KAIGYO><KAIGYO>    \\list<KAIGYO>        \\o \\l{QMetaType::}{Int}<KAIGYO>        \\o \\l{QMetaType::}{Double}<KAIGYO>        \\o \\l{QMetaType::}{Float}<KAIGYO>        \\o \\l{QMetaType::}{QLine}<KAIGYO>        \\o \\l{QMetaType::}{QLineF}<KAIGYO>        \\o \\l{QMetaType::}{QPoint}<KAIGYO>        \\o \\l{QMetaType::}{QPointF}<KAIGYO>        \\o \\l{QMetaType::}{QSize}<KAIGYO>        \\o \\l{QMetaType::}{QSizeF}<KAIGYO>        \\o \\l{QMetaType::}{QRect}<KAIGYO>        \\o \\l{QMetaType::}{QRectF}<KAIGYO>        \\o \\l{QMetaType::}{QColor}<KAIGYO>    \\endlist<KAIGYO><KAIGYO>    If you need to interpolate other variant types, including custom<KAIGYO>    types, you have to implement interpolation for these yourself.<KAIGYO>    To do this, you can register an interpolator function for a given<KAIGYO>    type. This function takes 3 parameters: the start value, the end value<KAIGYO>    and the current progress.<KAIGYO><KAIGYO>    Example:<KAIGYO>    \\code<KAIGYO>        QVariant myColorInterpolator(const QColor &start, const QColor &end, qreal progress)<KAIGYO>        {<KAIGYO>            ...<KAIGYO>            return QColor(...);<KAIGYO>        }<KAIGYO>        ...<KAIGYO>        qRegisterAnimationInterpolator<QColor>(myColorInterpolator);<KAIGYO>    \\endcode<KAIGYO><KAIGYO>    Another option is to reimplement interpolated(), which returns<KAIGYO>    interpolation values for the value being interpolated.<KAIGYO><KAIGYO>    \\omit We need some snippets around here. \\endomit<KAIGYO><KAIGYO>    \\sa QPropertyAnimation2, QAbstractAnimation2, {The Animation Framework}<KAIGYO>*/"": 1, '    /*FIXME: anything else needed here?*/<KAIGYO>}<KAIGYO><KAIGYO>/*!<KAIGYO>    \\internal<KAIGYO>    The goal of this function is to update the currentInterval member. As a consequence, we also<KAIGYO>    need to update the currentValue.<KAIGYO>    Set \\a force to true to always recalculate the interval.<KAIGYO>*/': 1, 'void QVariantAnimation2Private::recalculateCurrentInterval(bool force/*=false*/)<KAIGYO>{<KAIGYO>    // can\'t interpolate if we don\'t have at least 2 values<KAIGYO>    if (keyValues.count() < 2)<KAIGYO>        return;<KAIGYO><KAIGYO>    const qreal progress = easing.valueForProgress(((duration == 0) ? qreal(1) : qreal(currentTime) / qreal(duration)));<KAIGYO><KAIGYO>    //0 and 1 are still the boundaries<KAIGYO>    if (force || (currentInterval.start.first > 0 && progress < currentInterval.start.first)<KAIGYO>        || (currentInterval.end.first < 1 && progress > currentInterval.end.first)) {<KAIGYO>        //let\'s update currentInterval<KAIGYO>        QVariantAnimation2::KeyValues::const_iterator it = qLowerBound(keyValues.constBegin(),<KAIGYO>                                                                      keyValues.constEnd(),<KAIGYO>                                                                      qMakePair(progress, qreal(-1)),<KAIGYO>                                                                      animationValueLessThan);<KAIGYO>        if (it == keyValues.constBegin()) {<KAIGYO>            //the item pointed to by it is the start element in the range    <KAIGYO>            if (it->first == 0 && keyValues.count() > 1) {<KAIGYO>                currentInterval.start = *it;<KAIGYO>                currentInterval.end = *(it+1);<KAIGYO>            }<KAIGYO>        } else if (it == keyValues.constEnd()) {<KAIGYO>            --it; //position the iterator on the last item<KAIGYO>            if (it->first == 1 && keyValues.count() > 1) {<KAIGYO>                //we have an end value (item with progress = 1)<KAIGYO>                currentInterval.start = *(it-1);<KAIGYO>                currentInterval.end = *it;<KAIGYO>            }<KAIGYO>        } else {<KAIGYO>            currentInterval.start = *(it-1);<KAIGYO>            currentInterval.end = *it;<KAIGYO>        }<KAIGYO>    }<KAIGYO>    setCurrentValueForProgress(progress);<KAIGYO>}<KAIGYO><KAIGYO>void QVariantAnimation2Private::setCurrentValueForProgress(const qreal progress)<KAIGYO>{<KAIGYO>    const qreal startProgress = currentInterval.start.first;<KAIGYO>    const qreal endProgress = currentInterval.end.first;<KAIGYO>    const qreal localProgress = (progress - startProgress) / (endProgress - startProgress);<KAIGYO>    QVariantAnimation2* anim = static_cast<QVariantAnimation2*>(q);<KAIGYO>    qreal ret = anim->interpolated(currentInterval.start.second,<KAIGYO>                                   currentInterval.end.second,<KAIGYO>                                   localProgress);<KAIGYO>    qSwap(currentValue, ret);<KAIGYO>    anim->updateCurrentValue(currentValue);<KAIGYO>//    static QBasicAtomicInt changedSignalIndex = Q_BASIC_ATOMIC_INITIALIZER(0);<KAIGYO>//    if (!changedSignalIndex) {<KAIGYO>//        //we keep the mask so that we emit valueChanged only when needed (for performance reasons)<KAIGYO>//        changedSignalIndex.testAndSetRelaxed(0, signalIndex(""""));<KAIGYO>//    }<KAIGYO>//    if (isSignalConnected(changedSignalIndex) && currentValue != ret) {<KAIGYO>//        //the value has changed<KAIGYO>//        //anim->valueChanged(currentValue);<KAIGYO>//    }<KAIGYO>}<KAIGYO><KAIGYO>qreal QVariantAnimation2Private::valueAt(qreal step) const<KAIGYO>{<KAIGYO>    QVariantAnimation2::KeyValues::const_iterator result =<KAIGYO>        qBinaryFind(keyValues.begin(), keyValues.end(), qMakePair(step, qreal(-1)/*FIXME*/': 1, '    return -1; /*FIXME*/<KAIGYO>}<KAIGYO><KAIGYO>void QVariantAnimation2Private::setValueAt(qreal step, const qreal &value)<KAIGYO>{<KAIGYO>    if (step < qreal(0.0) || step > qreal(1.0)) {<KAIGYO>        qWarning("""", step);<KAIGYO>        return;<KAIGYO>    }<KAIGYO><KAIGYO>    QVariantAnimation2::KeyValue pair(step, value);<KAIGYO><KAIGYO>    QVariantAnimation2::KeyValues::iterator result = qLowerBound(keyValues.begin(), keyValues.end(), pair, animationValueLessThan);<KAIGYO>    if (result == keyValues.end() || result->first != step) {<KAIGYO>        keyValues.insert(result, pair);<KAIGYO>    } else {<KAIGYO>        result->second = value; // replaces the previous value<KAIGYO>    }<KAIGYO><KAIGYO>    recalculateCurrentInterval(/*force=*/': 1, '    d_func()->recalculateCurrentInterval(/*force=*/true);<KAIGYO>}<KAIGYO><KAIGYO>qreal QVariantAnimation2::currentValue() const<KAIGYO>{<KAIGYO>/*FIXME*/': 1}",1.0,{}
263,5576.0,2.0,6.0,1.0,MERGED,True,https://codereview.qt-project.org/#/c/5576,Don't move content forwards when items are moved down,1.0,"{'// show 7-22<KAIGYO>// 4,5,6 move to below 7<KAIGYO>// 4,5,6 moved down': 2}",1.0,{'// moved 3 items (i.e. 1 row) down': 1},1.0,{}
265,5624.0,1.0,5.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/5624,Simplify QAccessibleTextEdit.,1.0,"{""// we don't know the width of the character - maybe because we're at document end<KAIGYO>// in that case, IAccessible2 tells us to return the width of a default character"": 1, '// TODO - what exactly is before?': 1, '// TODO - what exactly is after?': 1, ""// TODO - what's a sentence?"": 1, '// TODO': 1}",1.0,"{""// we don't know the width of the character - maybe because we're at document end<KAIGYO>// in that case, IAccessible2 tells us to return the width of a default character"": 1, '// TODO - what exactly is before?': 1, '// TODO - what exactly is after?': 1, ""// TODO - what's a sentence?"": 1, '// TODO': 1}",1.0,{}
334,5629.0,2.0,8.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/5629,Widgets: Remove QT3_SUPPPORT.,1.0,{},0.0,"{'/*!<KAIGYO>  Returns the pixmap used for a standard icon. This<KAIGYO>  allows the pixmaps to be used in more complex message boxes.<KAIGYO>  \\a icon specifies the required icon, e.g. QMessageBox::Information,<KAIGYO>  QMessageBox::Warning or QMessageBox::Critical.<KAIGYO><KAIGYO>  \\a style is unused.<KAIGYO>*/': 1, ""    /*<KAIGYO>        Internal comment:<KAIGYO><KAIGYO>        This function tries to simulate the Qt 3.x ResizeMode<KAIGYO>        behavior using QSizePolicy stretch factors. This isn't easy,<KAIGYO>        because the default \\l ResizeMode was \\l Stretch, not \\l<KAIGYO>        KeepSize, whereas the default stetch factor is 0.<KAIGYO><KAIGYO>        So what we do is this: When the user calls setResizeMode()<KAIGYO>        the first time, we iterate through all the child widgets and<KAIGYO>        set their stretch factors to 1. Later on, if children are<KAIGYO>        added (using addWidget()), their stretch factors are also set<KAIGYO>        to 1.<KAIGYO><KAIGYO>        There is just one problem left: Often, setResizeMode() is<KAIGYO>        called \\e{before} addWidget(), because addWidget() is called<KAIGYO>        from the event loop. In that case, we use a special value,<KAIGYO>        243, instead of 0 to prevent 0 from being overwritten with 1<KAIGYO>        in addWidget(). This is a wicked hack, but fortunately it<KAIGYO>        only occurs as a result of calling a \\c QT3_SUPPORT function.<KAIGYO>    */"": 1, '/*! \\overload<KAIGYO>    \\obsolete<KAIGYO><KAIGYO>  Since Qt 3.0, QIcon contains both the On and Off icons.<KAIGYO><KAIGYO>  For ease of porting, this function ignores the \\a on parameter and<KAIGYO>  sets the \\l{QAbstractButton::icon} {icon} property. If you relied on<KAIGYO>  the \\a on parameter, you probably want to update your code to use<KAIGYO>  the QIcon On/Off mechanism.<KAIGYO><KAIGYO>  \\sa icon QIcon::State<KAIGYO>*/': 1, 'void QToolButton::setIconSet(const QIcon & set, bool /* on */)<KAIGYO>{<KAIGYO>    QAbstractButton::setIcon(set);<KAIGYO>}<KAIGYO><KAIGYO>/*! \\overload<KAIGYO>    \\obsolete<KAIGYO><KAIGYO>  Since Qt 3.0, QIcon contains both the On and Off icons.<KAIGYO><KAIGYO>  For ease of porting, this function ignores the \\a on parameter and<KAIGYO>  returns the \\l{QAbstractButton::icon} {icon} property. If you relied<KAIGYO>  on the \\a on parameter, you probably want to update your code to use<KAIGYO>  the QIcon On/Off mechanism.<KAIGYO>*/': 1}",1.0,{}
456,5657.0,4.0,12.0,69.0,MERGED,True,https://codereview.qt-project.org/#/c/5657,Remove Symbian-specific code from tests.,1.0,{},0.0,"{'// Expecting failures from a couple of OpenC bugs. Do checks only once.': 1, '// Sleep a while to ensure that consumers start properly': 1, '// temporary workaround for INC138398': 1, ""// GPU mem is very scarce resource on Symbian currently.<KAIGYO>// That's why we create only small textures."": 1, '// TODO: Remove XFAIL, as soon as we can launch Qt applications from within Qt applications on Symbian': 1, ""// Actually I wasn't able to get the forced orientation change to work properly,<KAIGYO>// but I'll leave the code here for the future in case we manage to test that<KAIGYO>// later. If someone knows how to force an orientation switch in an autotest, do<KAIGYO>// feel free to fix this testcase."": 1, '// ### FIXME: This will fail on Symbian on some tests and some environments until the file engine and QFileSystemModel<KAIGYO>// are fixed to properly capitalize paths, so that some folders are not duplicated in QFileSystemModel.': 1, '// Sanity test. Checks FEP for:<KAIGYO>// - T9 mode is default (it will attempt to fix this)<KAIGYO>// - Language is English (it cannot fix this; bail out if not correct)': 1, '// ### FIXME: task 257411 - remove xfail once this is fixed': 1, '// ### FIXME: task 257411 - remove xfail once this is fixed.<KAIGYO>// Oddly enough, this seems to work properly in HW, if given enough time and memory.': 1}",1.0,{}
315,5733.0,2.0,8.0,2.0,MERGED,True,https://codereview.qt-project.org/#/c/5733,Fix TextInput and TextEdit openInputPanel autotests,1.0,{},0.0,"{'// ### refactor: port properly': 1, '// ### refactor: implement virtual keyboard properly..': 1}",1.0,{}
329,5762.0,3.0,8.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/5762,Refactor ParticleSystem members,1.0,"{""//XXX shouldn't really be an assert"": 1}",1.0,"{""//XXX shouldn't really be an assert"": 1}",1.0,{}
328,5773.0,1.0,3.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/5773,Remove Symbian-specific code from tests.,1.0,{},0.0,{'// Compiler crash workaround': 1},1.0,{}
351,5803.0,1.0,10.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/5803,Support rich text elements in QSGTextNode,1.0,{},0.0,"{""/*!<KAIGYO>  Returns true if \\a text contains any HTML tags, attributes or CSS properties which are unrelated<KAIGYO>   to text, fonts or text layout. Otherwise the function returns false. If the return value is<KAIGYO>  false, \\a text is considered to be easily representable in the scenegraph. If it returns true,<KAIGYO>  then the text should be prerendered into a pixmap before it's displayed on screen.<KAIGYO>*/"": 1}",1.0,{}
377,5805.0,4.0,20.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/5805,tests for canvas and a few bug fixes,1.0,"{'//TODO:infinite or NaN, a NOT_SUPPORTED_ERR exception must be raised.<KAIGYO>//If either of r0 or r1 are negative, an INDEX_SIZE_ERR exception must be raised.': 1, '//TODO: exception: SYNTAX_ERR': 1, '//FIXME: currently we only return premultipled pixels': 1}",1.0,"{'//        QString repetition = engine->toString(args[1]);<KAIGYO>//        if (repetition == """" || repetition.isEmpty()) {<KAIGYO>//            //TODO<KAIGYO>//        } else if (repetition == """") {<KAIGYO>//            //TODO<KAIGYO>//        } else if (repetition == """") {<KAIGYO>//            //TODO<KAIGYO>//        } else if (repetition == """") {<KAIGYO>//            //TODO<KAIGYO>//        } else {<KAIGYO>//            //TODO: exception: SYNTAX_ERR<KAIGYO>//        }<KAIGYO>//        r->brush = img;<KAIGYO>//        pattern->SetExternalResource(r);<KAIGYO>//       return pattern;<KAIGYO>//    }': 1}",1.0,{}
361,5827.0,1.0,4.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/5827,Improve QDeclarativeIncubator JS API,1.0,{},0.0,{'// XXX TryCatch': 1},1.0,{}
422,5836.0,3.0,7.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/5836,Moving wayland plugin to the qtwayland submodule,1.0,{},0.0,"{'    /* FIXME: Half of these are wrong... */<KAIGYO>    /* Qt::ArrowCursor */': 1, '// ### TODO<KAIGYO>// This is a bit broken: The QMimeData will only contain the data for<KAIGYO>// the first type. The Wayland protocol and QDropEvents/QMimeData do not<KAIGYO>// match perfectly at the moment.': 1, ""// ### TODO we'll need to add listening to destroyed() of QWindow that owns QWaylandWindow<KAIGYO>// once refactor changes are in, and connect to removeQueuedPropertiesForWindow()."": 1, '//  TODO enable this later once refactor changes are in.<KAIGYO>//    Q_D(QWaylandWindowManagerIntegration);<KAIGYO>//    QWaylandWindow *window = 0;<KAIGYO>//    d->m_queuedProperties.remove(window);': 1}",1.0,{}
395,5911.0,2.0,9.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/5911,QDeclarativeIncubator::clear() and autotests,1.0,{'// XXX Clear in error state': 1},1.0,"{'// XXX What about failures in deferred creation?': 1, '// XXX does context get leaked in this case?': 1, '// XXX (what if its deleted?)': 1}",1.0,{}
424,5950.0,3.0,7.0,1.0,MERGED,True,https://codereview.qt-project.org/#/c/5950,Split GroupGoal out of SpriteGoal,1.0,"{""//no stochastic states defined. So cut out the engine<KAIGYO>//TODO: It's possible to move to a group that is intermediate and not used by painters or emitters - but right now that will redirect to the default group"": 1}",1.0,"{'//TODO: Aux emiiters in the state definition (which allows the occasional ball to spontaneously combust)': 1, '//###Expensive if unconnected? Move to Affector?': 1}",1.0,{}
427,5957.0,2.0,9.0,1.0,MERGED,True,https://codereview.qt-project.org/#/c/5957,Don't build qitemview autotest on IRIX.,1.0,{},0.0,"{""// This test needs to be re-thought out, it takes too long and<KAIGYO>// doesn't really catch theproblem."": 1}",1.0,{}
431,5958.0,2.0,12.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/5958,Don't build qwindowsurface autotest on Mac OS.,1.0,{'// Fixme Qt 5': 1},1.0,{'// Fixme Qt 5<KAIGYO>// Q_WS_MAC': 1},1.0,{}
455,5962.0,6.0,13.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/5962,Add more unit tests for qsgcanvasitem and fix unstable tests,1.0,"{'           /*FIXME:<KAIGYO>           actual  :[255,0,0,255]<KAIGYO>           expected:[0,255,0,255] +/- 0<KAIGYO>           */': 1, '// might not be exactly 0.5, if it is rounded/quantised, so remember for future comparisons': 1, '//FIXME:!!!<KAIGYO>//verify(Helper.comparePixel(ctx, 1,1, 0,255,0,255));<KAIGYO>//verify(Helper.comparePixel(ctx, 48,1, 0,255,0,255));<KAIGYO>//verify(Helper.comparePixel(ctx, 48,48, 0,255,0,255));<KAIGYO>//verify(Helper.comparePixel(ctx, 1,48, 0,255,0,255));': 1, '           /*<KAIGYO>            //FIXME:<KAIGYO>           verify(Helper.comparePixel(ctx,  21,11, 0,255,0,255));<KAIGYO>           verify(Helper.comparePixel(ctx,  79,11, 0,255,0,255));<KAIGYO>           verify(Helper.comparePixel(ctx,  21,39, 0,255,0,255));<KAIGYO>           verify(Helper.comparePixel(ctx,  79,39, 0,255,0,255));<KAIGYO>           verify(Helper.comparePixel(ctx,  39,19, 0,255,0,255));<KAIGYO>           verify(Helper.comparePixel(ctx,  61,19, 0,255,0,255));<KAIGYO>           verify(Helper.comparePixel(ctx,  39,31, 0,255,0,255));<KAIGYO>           verify(Helper.comparePixel(ctx,  61,31, 0,255,0,255));<KAIGYO>           */': 3, '           /*<KAIGYO>             //FIXME:<KAIGYO>           verify(Helper.comparePixel(ctx,  21,11, 0,255,0,255));<KAIGYO>           verify(Helper.comparePixel(ctx,  79,11, 0,255,0,255));<KAIGYO>           verify(Helper.comparePixel(ctx,  21,39, 0,255,0,255));<KAIGYO>           verify(Helper.comparePixel(ctx,  79,39, 0,255,0,255));<KAIGYO>           verify(Helper.comparePixel(ctx,  39,19, 0,255,0,255));<KAIGYO>           verify(Helper.comparePixel(ctx,  61,19, 0,255,0,255));<KAIGYO>           verify(Helper.comparePixel(ctx,  39,31, 0,255,0,255));<KAIGYO>           verify(Helper.comparePixel(ctx,  61,31, 0,255,0,255));<KAIGYO>           */': 3, '//TODO': 4}",1.0,"{'//FIXME: currently we only return premultipled pixels': 2, '//TODO:infinite or NaN, the method must raise a NOT_SUPPORTED_ERR': 3, '//TODO:infinite or NaN, a NOT_SUPPORTED_ERR exception must be raised.<KAIGYO>//If either of r0 or r1 are negative, an INDEX_SIZE_ERR exception must be raised.<KAIGYO>//TODO:infinite or NaN, a NOT_SUPPORTED_ERR exception must be raised.<KAIGYO>//If either of r0 or r1 are negative, an INDEX_SIZE_ERR exception must be raised.': 3, '//TODO: check value:infinite or NaN': 3, '//TODO: handle exceptions': 3}",1.0,{}
9,6015.0,1.0,4.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/6015,Remove code to selectively run test functions.,1.0,{},0.0,"{'// If you wish to skip tests, set value as false. This is often very convinient because tests are so lengthy.<KAIGYO>// Better way still would be to make this readable from a file.': 1}",1.0,{}
48,6047.0,1.0,9.0,0.0,ABANDONED,False,https://codereview.qt-project.org/#/c/6047,Allow to create a custom event dispatcher for specific QThreads.,1.0,{'// was the move successful?': 1},1.0,{'// ### TODO: allow the user to create a custom event dispatcher': 1},1.0,{}
86,6118.0,2.0,5.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/6118,QDeclarativeIncubator autotests,1.0,{},0.0,{'// XXX Clear in error state': 1},1.0,{}
175,6184.0,7.0,16.0,5.0,MERGED,True,https://codereview.qt-project.org/#/c/6184,Optimize listmodel and allow nested elements from worker script.,1.0,{'// Only move forwards - flip if backwards moving': 1},1.0,"{'// Only move forwards - flip if backwards moving': 1, '// XXX TryCatch?': 1, '    if (modelCache) { modelCache->m_nested->_root = 0/* ==this */; delete modelCache; modelCache = 0; }<KAIGYO>    if (objectCache) { delete objectCache; objectCache = 0; }<KAIGYO>}<KAIGYO><KAIGYO>void ModelNode::clear()<KAIGYO>{<KAIGYO>    ModelNode *node;<KAIGYO>    for (int ii = 0; ii < values.count(); ++ii) {<KAIGYO>        node = qvariant_cast<ModelNode *>(values.at(ii));<KAIGYO>        if (node) { delete node; node = 0; }<KAIGYO>    }<KAIGYO>    values.clear();<KAIGYO><KAIGYO>    qDeleteAll(properties.values());<KAIGYO>    properties.clear();<KAIGYO>}<KAIGYO><KAIGYO>bool ModelNode::setObjectValue(v8::Handle<v8::Value> valuemap, bool writeToCache)<KAIGYO>{<KAIGYO>    if (!valuemap->IsObject())<KAIGYO>        return false;<KAIGYO><KAIGYO>    bool emitItemsChanged = false;<KAIGYO><KAIGYO>    QV8Engine *v8engine = m_model->engine();<KAIGYO><KAIGYO>    v8::Local<v8::Array> propertyNames = v8engine->getOwnPropertyNames(valuemap->ToObject());<KAIGYO>    uint32_t length = propertyNames->Length();<KAIGYO><KAIGYO>    for (uint32_t ii = 0; ii < length; ++ii) {<KAIGYO>        // XXX TryCatch?<KAIGYO>        v8::Handle<v8::Value> property = propertyNames->Get(ii);<KAIGYO>        v8::Handle<v8::Value> v = valuemap->ToObject()->Get(property);<KAIGYO><KAIGYO>        QString name = v8engine->toString(property);<KAIGYO>        ModelNode *prev = properties.value(name);<KAIGYO>        ModelNode *value = new ModelNode(m_model);<KAIGYO><KAIGYO>        if (v->IsArray()) {<KAIGYO>            value->isArray = true;<KAIGYO>            value->setListValue(v);<KAIGYO>            if (writeToCache && objectCache)<KAIGYO>                objectCache->setValue(name.toUtf8(), QVariant::fromValue(value->model(m_model)));<KAIGYO>            emitItemsChanged = true;    // for now, too inefficient to check whether list and sublists have changed<KAIGYO>        } else {<KAIGYO>            value->values << v8engine->toVariant(v, -1);<KAIGYO>            if (writeToCache && objectCache)<KAIGYO>                objectCache->setValue(name.toUtf8(), value->values.last());<KAIGYO>            if (!emitItemsChanged && prev && prev->values.count() == 1<KAIGYO>                    && prev->values[0] != value->values.last()) {<KAIGYO>                emitItemsChanged = true;<KAIGYO>            }<KAIGYO>        }<KAIGYO>        if (properties.contains(name))<KAIGYO>            delete properties[name];<KAIGYO>        properties.insert(name, value);<KAIGYO>    }<KAIGYO>    return emitItemsChanged;<KAIGYO>}<KAIGYO><KAIGYO>void ModelNode::setListValue(v8::Handle<v8::Value> valuelist) <KAIGYO>{<KAIGYO>    Q_ASSERT(valuelist->IsArray());<KAIGYO>    values.clear();<KAIGYO><KAIGYO>    QV8Engine *engine = m_model->engine();<KAIGYO><KAIGYO>    v8::Handle<v8::Array> array = v8::Handle<v8::Array>::Cast(valuelist);<KAIGYO>    uint32_t length = array->Length();<KAIGYO>    for (uint32_t ii = 0; ii < length; ++ii) {<KAIGYO>        ModelNode *value = new ModelNode(m_model);<KAIGYO><KAIGYO>        // XXX TryCatch?<KAIGYO>        v8::Handle<v8::Value> v = array->Get(ii);<KAIGYO><KAIGYO>        if (v->IsArray()) {<KAIGYO>            value->isArray = true;<KAIGYO>            value->setListValue(v);<KAIGYO>        } else if (v->IsObject()) {<KAIGYO>            value->listIndex = ii;<KAIGYO>            value->setObjectValue(v);<KAIGYO>        } else {<KAIGYO>            value->listIndex = ii;<KAIGYO>            value->values << engine->toVariant(v, -1);<KAIGYO>        }<KAIGYO><KAIGYO>        values.append(QVariant::fromValue(value));<KAIGYO>    }<KAIGYO>}<KAIGYO><KAIGYO>bool ModelNode::setProperty(const QString& prop, const QVariant& val) {<KAIGYO>    QHash<QString, ModelNode *>::const_iterator it = properties.find(prop);<KAIGYO>    bool emitItemsChanged = false;<KAIGYO>    if (it != properties.end()) {<KAIGYO>        if (val != (*it)->values[0])<KAIGYO>            emitItemsChanged = true;<KAIGYO>        (*it)->values[0] = val;<KAIGYO>    } else {<KAIGYO>        ModelNode *n = new ModelNode(m_model);<KAIGYO>        n->values << val;<KAIGYO>        properties.insert(prop,n);<KAIGYO>    }<KAIGYO>    if (objectCache)<KAIGYO>        objectCache->setValue(prop.toUtf8(), val);<KAIGYO>    return emitItemsChanged;<KAIGYO>}<KAIGYO><KAIGYO>void ModelNode::updateListIndexes()<KAIGYO>{<KAIGYO>    for (QHash<QString, ModelNode *>::ConstIterator iter = properties.begin(); iter != properties.end(); ++iter) {<KAIGYO>        ModelNode *node = iter.value();<KAIGYO>        if (node->isArray) {<KAIGYO>            for (int i=0; i<node->values.count(); ++i) {<KAIGYO>                ModelNode *subNode = qvariant_cast<ModelNode *>(node->values.at(i));<KAIGYO>                if (subNode)<KAIGYO>                    subNode->listIndex = i;<KAIGYO>            }<KAIGYO>        }<KAIGYO>        node->updateListIndexes();<KAIGYO>    }<KAIGYO>}<KAIGYO><KAIGYO>/*<KAIGYO>    Need to call this to emit itemsChanged() for modifications outside of set()<KAIGYO>    and setProperty(), i.e. if an item returned from get() is modified<KAIGYO>*/': 1}",1.0,{}
126,6293.0,1.0,2.0,1.0,ABANDONED,False,https://codereview.qt-project.org/#/c/6293,Fix crash when importing script with compile failure,1.0,{},0.0,{'// XXX Handle errors during the script compile!': 1},1.0,{}
128,6303.0,1.0,4.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/6303,Update SpriteImage to modern standards,1.0,"{'/*!<KAIGYO>    \\qmlproperty QVariantMap QtQuick2::Sprite::to<KAIGYO><KAIGYO>    A list of other sprites and weighted transitions to them,<KAIGYO>    for example {"""":0} would specify that one-third should<KAIGYO>    transition to sprite """" when this sprite is done, and two-thirds should<KAIGYO>    transition to sprite """" when this sprite is done. As the transitions are<KAIGYO>    chosen randomly, these proportions will not be exact. With """":0 in the list,<KAIGYO>    no sprites will randomly transition to """", but it wll be a valid path if a sprite<KAIGYO>    goal is set.<KAIGYO><KAIGYO>    If no list is specified, or the sum of weights in the list is zero, then the sprite<KAIGYO>    will repeat itself after completing.<KAIGYO>*/': 1, '//TODO: Implicitly size element to size of first sprite?': 1}",1.0,"{""//TODO: Move shaders inline once they've stablilized"": 1}",1.0,{}
153,6385.0,1.0,9.0,3.0,MERGED,True,https://codereview.qt-project.org/#/c/6385,Allow sizing of TrailEmitter emit area based on particle size,1.0,{},0.0,{'//qreal sizeOffset = d->size/2;//TODO: Current size? As an option<KAIGYO>//TODO: Set variations': 1},1.0,{}
238,6636.0,2.0,11.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/6636,Cache QObject method arguments,1.0,{},0.0,{'// XXX TODO: We should figure out a way to cache the parameter types to avoid resolving<KAIGYO>// them each time.': 1},1.0,{}
266,6711.0,2.0,7.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/6711,Debugger: Remove outdated test stub,1.0,{},0.0,{'/*<KAIGYO>This test covers evaluation of ECMAScript expressions and bindings from within<KAIGYO>QML.  This does not include static QML language issues.<KAIGYO><KAIGYO>Static QML language issues are covered in qmllanguage<KAIGYO>*/': 1},1.0,{}
278,6733.0,2.0,9.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/6733,Prefer QSKIP to QTEST_NOOP_MAIN.,1.0,{},0.0,"{'// TODO: Add testcase generic initialization code here.<KAIGYO>// suggestion:<KAIGYO>//    testWidget = new QPrinter(0,"""");<KAIGYO>//    testWidget->setFixedSize(200, 200);<KAIGYO>//    qApp->setMainWidget(testWidget);<KAIGYO>//    testWidget->show();': 1, '// TODO: Add testcase generic cleanup code here.<KAIGYO>// suggestion:<KAIGYO>//    testWidget->hide();<KAIGYO>//    qApp->setMainWidget(0);<KAIGYO>//    delete testWidget;': 1, '// TODO: Add testfunction specific initialization code here.': 1, '// TODO: Add testfunction specific cleanup code here.': 1}",1.0,{}
280,6742.0,3.0,9.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/6742,Prefer QSKIP to QTEST_NOOP_MAIN.,1.0,{},0.0,{'// Fixme Qt 5': 1},1.0,{}
320,6805.0,1.0,3.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/6805,Remove DEPENDS_ON from qtestlib API.,1.0,{},0.0,"{'/*<KAIGYO>    Obsolete function but as long as we provide it, it needs to work.<KAIGYO>*/': 1}",1.0,{}
350,6870.0,8.0,11.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/6870,Make QAbstractAnimation2 a value class,1.0,{},0.0,"{'//??? FIXME': 2, ""//TODO deal with 'old' animationInstance?"": 4}",1.0,{}
323,6880.0,1.0,1.0,0.0,ABANDONED,False,https://codereview.qt-project.org/#/c/6880,WIP:make QAbstractAnimation2 a value class,1.0,{},0.0,{'//??? FIXME': 1},1.0,{}
385,6881.0,9.0,46.0,7.0,MERGED,True,https://codereview.qt-project.org/#/c/6881,"Remove Q_WS_*, symbian and maemo code in QtDeclarative",1.0,{},0.0,{'// TODO: Test and remove this since 169701 has been fixed': 1},1.0,{}
357,6928.0,1.0,17.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/6928,Atomic implementation of create file and obtain handle for Win/Symbian,1.0,{},0.0,{'// First open the fd as an external file descriptor to<KAIGYO>// initialize the engine properly.': 1},1.0,{}
372,6966.0,2.0,5.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/6966,Debugger: Inspector code cleanup,1.0,{},0.0,{'// TODO<KAIGYO>// Make sure mouse hover events are received<KAIGYO>//    m_view->setMouseTracking(true);': 1},1.0,{}
83,7023.0,5.0,17.0,1.0,MERGED,True,https://codereview.qt-project.org/#/c/7023,Fold Move into Affector,1.0,{'//TODO: Move docs (and inheritence) to real base when docs can propagate. Currently this pretends to be the base class!': 1},1.0,"{'//TODO: Move docs (and inherit) to real base when docs can propagate': 1, ""/*!<KAIGYO>    \\qmlclass Move QSGMoveAffector<KAIGYO>    \\inqmlmodule QtQuick.Particles 2<KAIGYO>    \\inherits Affector<KAIGYO>    \\brief The Move element allows you to set a new position, speed or acceleration on particles<KAIGYO><KAIGYO>    You'll often want to set the 'once' property to true for efficiency in the case where you just<KAIGYO>    want to set the parameter. Otherwise, the parameter will be needlessly set to the same thing<KAIGYO>    every simulation cycle.<KAIGYO>*/"": 1}",1.0,{}
23,7036.0,4.0,19.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/7036,Add non-floats to particle type,1.0,{},0.0,"{'//TODO: Non-floats (color, update?) once floats are working well': 2}",1.0,{}
19,7041.0,1.0,6.0,4.0,MERGED,True,https://codereview.qt-project.org/#/c/7041,QtGui: Remove Q_WS and qpa.,1.0,{'// ## TODO: detect these': 1},1.0,"{'// ## TODO: detect these': 1, '// fix broken PS fonts returning .notdef for many glyphs': 1}",1.0,{}
10,7048.0,1.0,4.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/7048,Fix tst_qsocketnotifier,1.0,{},0.0,"{'// FIXME QTBUG-20982: this fails, and ignoreMessage can\'t be skipped or QEXPECT_FAILed<KAIGYO>// QTest::ignoreMessage(QtWarningMsg, """");': 1}",1.0,{}
26,7103.0,1.0,2.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/7103,Don't create animation instances for ParentAnimation unless needed.,1.0,"{'//take care of any child animations': 1, '//TODO: simplify/clarify logic': 1}",1.0,"{'//TODO: only create necessary animations': 1, '//take care of any child animations': 1}",1.0,{}
36,7111.0,1.0,2.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/7111,Always check the animation instance before calling its methods,1.0,{},0.0,{'//TODO can animationInstance be 0 here?': 1},1.0,{}
99,7213.0,6.0,22.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/7213,"Add QStandardPaths::RuntimeLocation, for sockets ($XDG_RUNTIME_DIR)",1.0,{},0.0,{'// TODO add XDG_RUNTIME_DIR?': 1},1.0,{}
121,7224.0,9.0,28.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/7224,Deprecate QDesktopServices::storageLocation/displayName,1.0,{},0.0,"{""// workaround for unlikely case of locations that return '/'"": 1}",1.0,{}
174,7326.0,1.0,1.0,0.0,ABANDONED,False,https://codereview.qt-project.org/#/c/7326,Merge branch 'master' into animation-refactor,1.0,"{'//take care of any child animations': 1, '//TODO: simplify/clarify logic': 1}",1.0,"{'//take care of any child animations': 1, '//### reverse should probably apply on a per-action basis': 1, '//TODO: simplify/clarify logic': 1, '/*<KAIGYO>  Threaded Rendering<KAIGYO><KAIGYO>  The threaded rendering uses a number of different variables to track potential<KAIGYO>  states used to handle resizing, initial paint, grabbing and driving animations<KAIGYO>  while ALWAYS keeping the GL context in the rendering thread and keeping the<KAIGYO>  overhead of normal one-shot paints and vblank driven animations at a minimum.<KAIGYO><KAIGYO>  Resize, initial show and grab suffer slightly in this model as they are locked<KAIGYO>  to the rendering in the rendering thread, but this is a necessary evil for<KAIGYO>  the system to work.<KAIGYO><KAIGYO>  Variables that are used:<KAIGYO><KAIGYO>  Private::animationRunning: This is true while the animations are running, and only<KAIGYO>  written to inside locks.<KAIGYO><KAIGYO>  RenderThread::isGuiBlocked: This is used to indicate that the GUI thread owns the<KAIGYO>  lock. This variable is an integer to allow for recursive calls to lockInGui()<KAIGYO>  without using a recursive mutex. See isGuiBlockPending.<KAIGYO><KAIGYO>  RenderThread::isPaintComplete: This variable is cleared when rendering starts and<KAIGYO>  set once rendering is complete. It is monitored in the paintEvent(),<KAIGYO>  resizeEvent() and grab() functions to force them to wait for rendering to<KAIGYO>  complete.<KAIGYO><KAIGYO>  RenderThread::isGuiBlockPending: This variable is set in the render thread just<KAIGYO>  before the sync event is sent to the GUI thread. It is used to avoid deadlocks<KAIGYO>  in the case where render thread waits while waiting for GUI to pick up the sync<KAIGYO>  event and GUI thread gets a resizeEvent, the initial paintEvent or a grab.<KAIGYO>  When this happens, we use the<KAIGYO>  exhaustSyncEvent() function to do the sync right there and mark the coming<KAIGYO>  sync event to be discarded. There can only ever be one sync incoming.<KAIGYO><KAIGYO>  RenderThread::isRenderBlock: This variable is true when animations are not<KAIGYO>  running and the render thread has gone to sleep, waiting for more to do.<KAIGYO><KAIGYO>  RenderThread::isExternalUpdatePending: This variable is set to false during<KAIGYO>  the sync phase in the GUI thread and to true in maybeUpdate(). It is an<KAIGYO>  indication to the render thread that another render pass needs to take<KAIGYO>  place, rather than the render thread going to sleep after completing its swap.<KAIGYO><KAIGYO>  RenderThread::doGrab: This variable is set by the grab() function and<KAIGYO>  tells the renderer to do a grab after rendering is complete and before<KAIGYO>  swapping happens.<KAIGYO><KAIGYO>  RenderThread::shouldExit: This variable is used to determine if the render<KAIGYO>  thread should do a nother pass. It is typically set as a result of show()<KAIGYO>  and unset as a result of hide() or during shutdown()<KAIGYO><KAIGYO>  RenderThread::hasExited: Used by the GUI thread to synchronize the shutdown<KAIGYO>  after shouldExit has been set to true.<KAIGYO> */': 1, '// ### should we change ~QSGItem to handle this better?<KAIGYO>// manually cleanup for the root item (item destructor only handles these when an item is parented)': 1, '//take care of any exits': 1, '//move': 1, ""//Not entering a new Item<KAIGYO>// ### Shouldn't we send moves for the parent items as well?"": 1, '// XXX todo - should sendEvent be doing this?  how does it relate to forwarded events?': 1, '// -ve velocity means list is moving up/left': 1, '/*!<KAIGYO>    \\qmlclass GridView QSGGridView<KAIGYO>    \\inqmlmodule QtQuick 2<KAIGYO>    \\ingroup qml-view-elements<KAIGYO><KAIGYO>    \\inherits Flickable<KAIGYO>    \\brief The GridView item provides a grid view of items provided by a model.<KAIGYO><KAIGYO>    A GridView displays data from models created from built-in QML elements like ListModel<KAIGYO>    and XmlListModel, or custom model classes defined in C++ that inherit from<KAIGYO>    QAbstractListModel.<KAIGYO><KAIGYO>    A GridView has a \\l model, which defines the data to be displayed, and<KAIGYO>    a \\l delegate, which defines how the data should be displayed. Items in a<KAIGYO>    GridView are laid out horizontally or vertically. Grid views are inherently flickable<KAIGYO>    as GridView inherits from \\l Flickable.<KAIGYO><KAIGYO>    \\section1 Example Usage<KAIGYO><KAIGYO>    The following example shows the definition of a simple list model defined<KAIGYO>    in a file called \\c ContactModel.qml:<KAIGYO><KAIGYO>    \\snippet doc/src/snippets/declarative/gridview/ContactModel.qml 0<KAIGYO><KAIGYO>    \\div {class=""""}<KAIGYO>    \\inlineimage gridview-simple.png<KAIGYO>    \\enddiv<KAIGYO><KAIGYO>    This model can be referenced as \\c ContactModel in other QML files. See \\l{QML Modules}<KAIGYO>    for more information about creating reusable components like this.<KAIGYO><KAIGYO>    Another component can display this model data in a GridView, as in the following<KAIGYO>    example, which creates a \\c ContactModel component for its model, and a \\l Column element<KAIGYO>    (containing \\l Image and \\l Text elements) for its delegate.<KAIGYO><KAIGYO>    \\clearfloat<KAIGYO>    \\snippet doc/src/snippets/declarative/gridview/gridview.qml import<KAIGYO>    \\codeline<KAIGYO>    \\snippet doc/src/snippets/declarative/gridview/gridview.qml classdocs simple<KAIGYO><KAIGYO>    \\div {class=""""}<KAIGYO>    \\inlineimage gridview-highlight.png<KAIGYO>    \\enddiv<KAIGYO><KAIGYO>    The view will create a new delegate for each item in the model. Note that the delegate<KAIGYO>    is able to access the model\'s \\c name and \\c portrait data directly.<KAIGYO><KAIGYO>    An improved grid view is shown below. The delegate is visually improved and is moved<KAIGYO>    into a separate \\c contactDelegate component.<KAIGYO><KAIGYO>    \\clearfloat<KAIGYO>    \\snippet doc/src/snippets/declarative/gridview/gridview.qml classdocs advanced<KAIGYO><KAIGYO>    The currently selected item is highlighted with a blue \\l Rectangle using the \\l highlight property,<KAIGYO>    and \\c focus is set to \\c true to enable keyboard navigation for the grid view.<KAIGYO>    The grid view itself is a focus scope (see \\l{qmlfocus#Acquiring Focus and Focus Scopes}{the focus documentation page} for more details).<KAIGYO><KAIGYO>    Delegates are instantiated as needed and may be destroyed at any time.<KAIGYO>    State should \\e never be stored in a delegate.<KAIGYO><KAIGYO>    GridView attaches a number of properties to the root item of the delegate, for example<KAIGYO>    \\c {GridView.isCurrentItem}.  In the following example, the root delegate item can access<KAIGYO>    this attached property directly as \\c GridView.isCurrentItem, while the child<KAIGYO>    \\c contactInfo object must refer to this property as \\c wrapper.GridView.isCurrentItem.<KAIGYO><KAIGYO>    \\snippet doc/src/snippets/declarative/gridview/gridview.qml isCurrentItem<KAIGYO><KAIGYO>    \\note Views do not set the \\l{Item::}{clip} property automatically.<KAIGYO>    If the view is not clipped by another item or the screen, it will be necessary<KAIGYO>    to set this property to true in order to clip the items that are partially or<KAIGYO>    fully outside the view.<KAIGYO><KAIGYO>    \\sa {declarative/modelviews/gridview}{GridView example}<KAIGYO>*/': 1, '/*!<KAIGYO>  \\qmlproperty enumeration QtQuick2::GridView::layoutDirection<KAIGYO>  This property holds the layout direction of the grid.<KAIGYO><KAIGYO>    Possible values:<KAIGYO><KAIGYO>  \\list<KAIGYO>  \\o Qt.LeftToRight (default) - Items will be laid out starting in the top, left corner. The flow is<KAIGYO>  dependent on the \\l GridView::flow property.<KAIGYO>  \\o Qt.RightToLeft - Items will be laid out starting in the top, right corner. The flow is dependent<KAIGYO>  on the \\l GridView::flow property.<KAIGYO>  \\endlist<KAIGYO><KAIGYO>  \\bold Note: If GridView::flow is set to GridView.LeftToRight, this is not to be confused if<KAIGYO>  GridView::layoutDirection is set to Qt.RightToLeft. The GridView.LeftToRight flow value simply<KAIGYO>  indicates that the flow is horizontal.<KAIGYO>*/': 1, '/*!<KAIGYO>    \\qmlmethod QtQuick2::GridView::positionViewAtIndex(int index, PositionMode mode)<KAIGYO><KAIGYO>    Positions the view such that the \\a index is at the position specified by<KAIGYO>    \\a mode:<KAIGYO><KAIGYO>    \\list<KAIGYO>    \\o GridView.Beginning - position item at the top (or left for \\c GridView.TopToBottom flow) of the view.<KAIGYO>    \\o GridView.Center - position item in the center of the view.<KAIGYO>    \\o GridView.End - position item at bottom (or right for horizontal orientation) of the view.<KAIGYO>    \\o GridView.Visible - if any part of the item is visible then take no action, otherwise<KAIGYO>    bring the item into view.<KAIGYO>    \\o GridView.Contain - ensure the entire item is visible.  If the item is larger than<KAIGYO>    the view the item is positioned at the top (or left for \\c GridView.TopToBottom flow) of the view.<KAIGYO>    \\endlist<KAIGYO><KAIGYO>    If positioning the view at the index would cause empty space to be displayed at<KAIGYO>    the beginning or end of the view, the view will be positioned at the boundary.<KAIGYO><KAIGYO>    It is not recommended to use \\l {Flickable::}{contentX} or \\l {Flickable::}{contentY} to position the view<KAIGYO>    at a particular index.  This is unreliable since removing items from the start<KAIGYO>    of the view does not cause all other items to be repositioned.<KAIGYO>    The correct way to bring an item into view is with \\c positionViewAtIndex.<KAIGYO><KAIGYO>    \\bold Note: methods should only be called after the Component has completed.  To position<KAIGYO>    the view at startup, this method should be called by Component.onCompleted.  For<KAIGYO>    example, to position the view at the end:<KAIGYO><KAIGYO>    \\code<KAIGYO>    Component.onCompleted: positionViewAtIndex(count - 1, GridView.Beginning)<KAIGYO>    \\endcode<KAIGYO>*/': 1, ""/*!<KAIGYO>    \\qmlclass ListView QSGListView<KAIGYO>    \\inqmlmodule QtQuick 2<KAIGYO>    \\ingroup qml-view-elements<KAIGYO>    \\inherits Flickable<KAIGYO>    \\brief The ListView item provides a list view of items provided by a model.<KAIGYO><KAIGYO>    A ListView displays data from models created from built-in QML elements like ListModel<KAIGYO>    and XmlListModel, or custom model classes defined in C++ that inherit from<KAIGYO>    QAbstractListModel.<KAIGYO><KAIGYO>    A ListView has a \\l model, which defines the data to be displayed, and<KAIGYO>    a \\l delegate, which defines how the data should be displayed. Items in a<KAIGYO>    ListView are laid out horizontally or vertically. List views are inherently<KAIGYO>    flickable because ListView inherits from \\l Flickable.<KAIGYO><KAIGYO>    \\section1 Example Usage<KAIGYO><KAIGYO>    The following example shows the definition of a simple list model defined<KAIGYO>    in a file called \\c ContactModel.qml:<KAIGYO><KAIGYO>    \\snippet doc/src/snippets/declarative/listview/ContactModel.qml 0<KAIGYO><KAIGYO>    Another component can display this model data in a ListView, like this:<KAIGYO><KAIGYO>    \\snippet doc/src/snippets/declarative/listview/listview.qml import<KAIGYO>    \\codeline<KAIGYO>    \\snippet doc/src/snippets/declarative/listview/listview.qml classdocs simple<KAIGYO><KAIGYO>    \\image listview-simple.png<KAIGYO><KAIGYO>    Here, the ListView creates a \\c ContactModel component for its model, and a \\l Text element<KAIGYO>    for its delegate. The view will create a new \\l Text component for each item in the model. Notice<KAIGYO>    the delegate is able to access the model's \\c name and \\c number data directly.<KAIGYO><KAIGYO>    An improved list view is shown below. The delegate is visually improved and is moved<KAIGYO>    into a separate \\c contactDelegate component.<KAIGYO><KAIGYO>    \\snippet doc/src/snippets/declarative/listview/listview.qml classdocs advanced<KAIGYO>    \\image listview-highlight.png<KAIGYO><KAIGYO>    The currently selected item is highlighted with a blue \\l Rectangle using the \\l highlight property,<KAIGYO>    and \\c focus is set to \\c true to enable keyboard navigation for the list view.<KAIGYO>    The list view itself is a focus scope (see \\l{qmlfocus#Acquiring Focus and Focus Scopes}{the focus documentation page} for more details).<KAIGYO><KAIGYO>    Delegates are instantiated as needed and may be destroyed at any time.<KAIGYO>    State should \\e never be stored in a delegate.<KAIGYO><KAIGYO>    ListView attaches a number of properties to the root item of the delegate, for example<KAIGYO>    \\c {ListView.isCurrentItem}.  In the following example, the root delegate item can access<KAIGYO>    this attached property directly as \\c ListView.isCurrentItem, while the child<KAIGYO>    \\c contactInfo object must refer to this property as \\c wrapper.ListView.isCurrentItem.<KAIGYO><KAIGYO>    \\snippet doc/src/snippets/declarative/listview/listview.qml isCurrentItem<KAIGYO><KAIGYO>    \\note Views do not enable \\e clip automatically.  If the view<KAIGYO>    is not clipped by another item or the screen, it will be necessary<KAIGYO>    to set \\e {clip: true} in order to have the out of view items clipped<KAIGYO>    nicely.<KAIGYO><KAIGYO>    \\sa {QML Data Models}, GridView, {declarative/modelviews/listview}{ListView examples}<KAIGYO>*/"": 1, '/*!<KAIGYO>    \\qmlproperty int QtQuick2::ListView::cacheBuffer<KAIGYO>    This property determines whether delegates are retained outside the<KAIGYO>    visible area of the view.<KAIGYO><KAIGYO>    If this value is non-zero, the view keeps as many delegates<KAIGYO>    instantiated as it can fit within the buffer specified.  For example,<KAIGYO>    if in a vertical view the delegate is 20 pixels high and \\c cacheBuffer is<KAIGYO>    set to 40, then up to 2 delegates above and 2 delegates below the visible<KAIGYO>    area may be retained.<KAIGYO><KAIGYO>    Note that cacheBuffer is not a pixel buffer - it only maintains additional<KAIGYO>    instantiated delegates.<KAIGYO><KAIGYO>    Setting this value can improve the smoothness of scrolling behavior at the expense<KAIGYO>    of additional memory usage.  It is not a substitute for creating efficient<KAIGYO>    delegates; the fewer elements in a delegate, the faster a view can be<KAIGYO>    scrolled.<KAIGYO>*/': 1, '/*!<KAIGYO>    \\qmlproperty string QtQuick2::ListView::section.property<KAIGYO>    \\qmlproperty enumeration QtQuick2::ListView::section.criteria<KAIGYO>    \\qmlproperty Component QtQuick2::ListView::section.delegate<KAIGYO>    \\qmlproperty enumeration QtQuick2::ListView::section.labelPositioning<KAIGYO><KAIGYO>    These properties determine the expression to be evaluated and appearance<KAIGYO>    of the section labels.<KAIGYO><KAIGYO>    \\c section.property holds the name of the property that is the basis<KAIGYO>    of each section.<KAIGYO><KAIGYO>    \\c section.criteria holds the criteria for forming each section based on<KAIGYO>    \\c section.property. This value can be one of:<KAIGYO><KAIGYO>    \\list<KAIGYO>    \\o ViewSection.FullString (default) - sections are created based on the<KAIGYO>    \\c section.property value.<KAIGYO>    \\o ViewSection.FirstCharacter - sections are created based on the first<KAIGYO>    character of the \\c section.property value (for example, \'A\', \'B\', \'C\'<KAIGYO>    sections, etc. for an address book)<KAIGYO>    \\endlist<KAIGYO><KAIGYO>    \\c section.delegate holds the delegate component for each section.<KAIGYO><KAIGYO>    \\c section.labelPositioning determines whether the current and/or<KAIGYO>    next section labels stick to the start/end of the view, and whether<KAIGYO>    the labels are shown inline.  This value can be a combination of:<KAIGYO><KAIGYO>    \\list<KAIGYO>    \\o ViewSection.InlineLabels - section labels are shown inline between<KAIGYO>    the item delegates separating sections (default).<KAIGYO>    \\o ViewSection.CurrentLabelAtStart - the current section label sticks to the<KAIGYO>    start of the view as it is moved.<KAIGYO>    \\o ViewSection.NextLabelAtEnd - the next section label (beyond all visible<KAIGYO>    sections) sticks to the end of the view as it is moved. \\note Enabling<KAIGYO>    \\c ViewSection.NextLabelAtEnd requires the view to scan ahead for the next<KAIGYO>    section, which has performance implications, especially for slower models.<KAIGYO>    \\endlist<KAIGYO><KAIGYO>    Each item in the list has attached properties named \\c ListView.section,<KAIGYO>    \\c ListView.previousSection and \\c ListView.nextSection.<KAIGYO><KAIGYO>    For example, here is a ListView that displays a list of animals, separated<KAIGYO>    into sections. Each item in the ListView is placed in a different section<KAIGYO>    depending on the """" property of the model item. The \\c sectionHeading<KAIGYO>    delegate component provides the light blue bar that marks the beginning of<KAIGYO>    each section.<KAIGYO><KAIGYO><KAIGYO>    \\snippet examples/declarative/modelviews/listview/sections.qml 0<KAIGYO><KAIGYO>    \\image qml-listview-sections-example.png<KAIGYO><KAIGYO>    \\note Adding sections to a ListView does not automatically re-order the<KAIGYO>    list items by the section criteria.<KAIGYO>    If the model is not ordered by section, then it is possible that<KAIGYO>    the sections created will not be unique; each boundary between<KAIGYO>    differing sections will result in a section header being created<KAIGYO>    even if that section exists elsewhere.<KAIGYO><KAIGYO>    \\sa {declarative/modelviews/listview}{ListView examples}<KAIGYO>*/': 1, '/*!<KAIGYO>    \\qmlproperty real QtQuick2::ListView::highlightMoveSpeed<KAIGYO>    \\qmlproperty int QtQuick2::ListView::highlightMoveDuration<KAIGYO>    \\qmlproperty real QtQuick2::ListView::highlightResizeSpeed<KAIGYO>    \\qmlproperty int QtQuick2::ListView::highlightResizeDuration<KAIGYO><KAIGYO>    These properties hold the move and resize animation speed of the highlight delegate.<KAIGYO><KAIGYO>    \\l highlightFollowsCurrentItem must be true for these properties<KAIGYO>    to have effect.<KAIGYO><KAIGYO>    The default value for the speed properties is 400 pixels/second.<KAIGYO>    The default value for the duration properties is -1, i.e. the<KAIGYO>    highlight will take as much time as necessary to move at the set speed.<KAIGYO><KAIGYO>    These properties have the same characteristics as a SmoothedAnimation.<KAIGYO><KAIGYO>    \\sa highlightFollowsCurrentItem<KAIGYO>*/': 1, '/*!<KAIGYO>    \\qmlmethod QtQuick2::ListView::positionViewAtIndex(int index, PositionMode mode)<KAIGYO><KAIGYO>    Positions the view such that the \\a index is at the position specified by<KAIGYO>    \\a mode:<KAIGYO><KAIGYO>    \\list<KAIGYO>    \\o ListView.Beginning - position item at the top (or left for horizontal orientation) of the view.<KAIGYO>    \\o ListView.Center - position item in the center of the view.<KAIGYO>    \\o ListView.End - position item at bottom (or right for horizontal orientation) of the view.<KAIGYO>    \\o ListView.Visible - if any part of the item is visible then take no action, otherwise<KAIGYO>    bring the item into view.<KAIGYO>    \\o ListView.Contain - ensure the entire item is visible.  If the item is larger than<KAIGYO>    the view the item is positioned at the top (or left for horizontal orientation) of the view.<KAIGYO>    \\endlist<KAIGYO><KAIGYO>    If positioning the view at \\a index would cause empty space to be displayed at<KAIGYO>    the beginning or end of the view, the view will be positioned at the boundary.<KAIGYO><KAIGYO>    It is not recommended to use \\l {Flickable::}{contentX} or \\l {Flickable::}{contentY} to position the view<KAIGYO>    at a particular index.  This is unreliable since removing items from the start<KAIGYO>    of the list does not cause all other items to be repositioned, and because<KAIGYO>    the actual start of the view can vary based on the size of the delegates.<KAIGYO>    The correct way to bring an item into view is with \\c positionViewAtIndex.<KAIGYO><KAIGYO>    \\bold Note: methods should only be called after the Component has completed.  To position<KAIGYO>    the view at startup, this method should be called by Component.onCompleted.  For<KAIGYO>    example, to position the view at the end:<KAIGYO><KAIGYO>    \\code<KAIGYO>    Component.onCompleted: positionViewAtIndex(count - 1, ListView.Beginning)<KAIGYO>    \\endcode<KAIGYO>*/': 1}",1.0,{}
178,7328.0,1.0,2.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/7328,Merge branch 'master' into animation-refactor,1.0,"{'//take care of any child animations': 1, '//TODO: simplify/clarify logic': 1}",1.0,"{'//take care of any child animations': 1, '//### reverse should probably apply on a per-action basis': 1, '//TODO: simplify/clarify logic': 1, '/*<KAIGYO>  Threaded Rendering<KAIGYO><KAIGYO>  The threaded rendering uses a number of different variables to track potential<KAIGYO>  states used to handle resizing, initial paint, grabbing and driving animations<KAIGYO>  while ALWAYS keeping the GL context in the rendering thread and keeping the<KAIGYO>  overhead of normal one-shot paints and vblank driven animations at a minimum.<KAIGYO><KAIGYO>  Resize, initial show and grab suffer slightly in this model as they are locked<KAIGYO>  to the rendering in the rendering thread, but this is a necessary evil for<KAIGYO>  the system to work.<KAIGYO><KAIGYO>  Variables that are used:<KAIGYO><KAIGYO>  Private::animationRunning: This is true while the animations are running, and only<KAIGYO>  written to inside locks.<KAIGYO><KAIGYO>  RenderThread::isGuiBlocked: This is used to indicate that the GUI thread owns the<KAIGYO>  lock. This variable is an integer to allow for recursive calls to lockInGui()<KAIGYO>  without using a recursive mutex. See isGuiBlockPending.<KAIGYO><KAIGYO>  RenderThread::isPaintComplete: This variable is cleared when rendering starts and<KAIGYO>  set once rendering is complete. It is monitored in the paintEvent(),<KAIGYO>  resizeEvent() and grab() functions to force them to wait for rendering to<KAIGYO>  complete.<KAIGYO><KAIGYO>  RenderThread::isGuiBlockPending: This variable is set in the render thread just<KAIGYO>  before the sync event is sent to the GUI thread. It is used to avoid deadlocks<KAIGYO>  in the case where render thread waits while waiting for GUI to pick up the sync<KAIGYO>  event and GUI thread gets a resizeEvent, the initial paintEvent or a grab.<KAIGYO>  When this happens, we use the<KAIGYO>  exhaustSyncEvent() function to do the sync right there and mark the coming<KAIGYO>  sync event to be discarded. There can only ever be one sync incoming.<KAIGYO><KAIGYO>  RenderThread::isRenderBlock: This variable is true when animations are not<KAIGYO>  running and the render thread has gone to sleep, waiting for more to do.<KAIGYO><KAIGYO>  RenderThread::isExternalUpdatePending: This variable is set to false during<KAIGYO>  the sync phase in the GUI thread and to true in maybeUpdate(). It is an<KAIGYO>  indication to the render thread that another render pass needs to take<KAIGYO>  place, rather than the render thread going to sleep after completing its swap.<KAIGYO><KAIGYO>  RenderThread::doGrab: This variable is set by the grab() function and<KAIGYO>  tells the renderer to do a grab after rendering is complete and before<KAIGYO>  swapping happens.<KAIGYO><KAIGYO>  RenderThread::shouldExit: This variable is used to determine if the render<KAIGYO>  thread should do a nother pass. It is typically set as a result of show()<KAIGYO>  and unset as a result of hide() or during shutdown()<KAIGYO><KAIGYO>  RenderThread::hasExited: Used by the GUI thread to synchronize the shutdown<KAIGYO>  after shouldExit has been set to true.<KAIGYO> */': 1, '// ### should we change ~QSGItem to handle this better?<KAIGYO>// manually cleanup for the root item (item destructor only handles these when an item is parented)': 1, '//take care of any exits': 1, '//move': 1, ""//Not entering a new Item<KAIGYO>// ### Shouldn't we send moves for the parent items as well?"": 1, '// XXX todo - should sendEvent be doing this?  how does it relate to forwarded events?': 1, '// -ve velocity means list is moving up/left': 1, '/*!<KAIGYO>    \\qmlclass GridView QSGGridView<KAIGYO>    \\inqmlmodule QtQuick 2<KAIGYO>    \\ingroup qml-view-elements<KAIGYO><KAIGYO>    \\inherits Flickable<KAIGYO>    \\brief The GridView item provides a grid view of items provided by a model.<KAIGYO><KAIGYO>    A GridView displays data from models created from built-in QML elements like ListModel<KAIGYO>    and XmlListModel, or custom model classes defined in C++ that inherit from<KAIGYO>    QAbstractListModel.<KAIGYO><KAIGYO>    A GridView has a \\l model, which defines the data to be displayed, and<KAIGYO>    a \\l delegate, which defines how the data should be displayed. Items in a<KAIGYO>    GridView are laid out horizontally or vertically. Grid views are inherently flickable<KAIGYO>    as GridView inherits from \\l Flickable.<KAIGYO><KAIGYO>    \\section1 Example Usage<KAIGYO><KAIGYO>    The following example shows the definition of a simple list model defined<KAIGYO>    in a file called \\c ContactModel.qml:<KAIGYO><KAIGYO>    \\snippet doc/src/snippets/declarative/gridview/ContactModel.qml 0<KAIGYO><KAIGYO>    \\div {class=""""}<KAIGYO>    \\inlineimage gridview-simple.png<KAIGYO>    \\enddiv<KAIGYO><KAIGYO>    This model can be referenced as \\c ContactModel in other QML files. See \\l{QML Modules}<KAIGYO>    for more information about creating reusable components like this.<KAIGYO><KAIGYO>    Another component can display this model data in a GridView, as in the following<KAIGYO>    example, which creates a \\c ContactModel component for its model, and a \\l Column element<KAIGYO>    (containing \\l Image and \\l Text elements) for its delegate.<KAIGYO><KAIGYO>    \\clearfloat<KAIGYO>    \\snippet doc/src/snippets/declarative/gridview/gridview.qml import<KAIGYO>    \\codeline<KAIGYO>    \\snippet doc/src/snippets/declarative/gridview/gridview.qml classdocs simple<KAIGYO><KAIGYO>    \\div {class=""""}<KAIGYO>    \\inlineimage gridview-highlight.png<KAIGYO>    \\enddiv<KAIGYO><KAIGYO>    The view will create a new delegate for each item in the model. Note that the delegate<KAIGYO>    is able to access the model\'s \\c name and \\c portrait data directly.<KAIGYO><KAIGYO>    An improved grid view is shown below. The delegate is visually improved and is moved<KAIGYO>    into a separate \\c contactDelegate component.<KAIGYO><KAIGYO>    \\clearfloat<KAIGYO>    \\snippet doc/src/snippets/declarative/gridview/gridview.qml classdocs advanced<KAIGYO><KAIGYO>    The currently selected item is highlighted with a blue \\l Rectangle using the \\l highlight property,<KAIGYO>    and \\c focus is set to \\c true to enable keyboard navigation for the grid view.<KAIGYO>    The grid view itself is a focus scope (see \\l{qmlfocus#Acquiring Focus and Focus Scopes}{the focus documentation page} for more details).<KAIGYO><KAIGYO>    Delegates are instantiated as needed and may be destroyed at any time.<KAIGYO>    State should \\e never be stored in a delegate.<KAIGYO><KAIGYO>    GridView attaches a number of properties to the root item of the delegate, for example<KAIGYO>    \\c {GridView.isCurrentItem}.  In the following example, the root delegate item can access<KAIGYO>    this attached property directly as \\c GridView.isCurrentItem, while the child<KAIGYO>    \\c contactInfo object must refer to this property as \\c wrapper.GridView.isCurrentItem.<KAIGYO><KAIGYO>    \\snippet doc/src/snippets/declarative/gridview/gridview.qml isCurrentItem<KAIGYO><KAIGYO>    \\note Views do not set the \\l{Item::}{clip} property automatically.<KAIGYO>    If the view is not clipped by another item or the screen, it will be necessary<KAIGYO>    to set this property to true in order to clip the items that are partially or<KAIGYO>    fully outside the view.<KAIGYO><KAIGYO>    \\sa {declarative/modelviews/gridview}{GridView example}<KAIGYO>*/': 1, '/*!<KAIGYO>  \\qmlproperty enumeration QtQuick2::GridView::layoutDirection<KAIGYO>  This property holds the layout direction of the grid.<KAIGYO><KAIGYO>    Possible values:<KAIGYO><KAIGYO>  \\list<KAIGYO>  \\o Qt.LeftToRight (default) - Items will be laid out starting in the top, left corner. The flow is<KAIGYO>  dependent on the \\l GridView::flow property.<KAIGYO>  \\o Qt.RightToLeft - Items will be laid out starting in the top, right corner. The flow is dependent<KAIGYO>  on the \\l GridView::flow property.<KAIGYO>  \\endlist<KAIGYO><KAIGYO>  \\bold Note: If GridView::flow is set to GridView.LeftToRight, this is not to be confused if<KAIGYO>  GridView::layoutDirection is set to Qt.RightToLeft. The GridView.LeftToRight flow value simply<KAIGYO>  indicates that the flow is horizontal.<KAIGYO>*/': 1, '/*!<KAIGYO>    \\qmlmethod QtQuick2::GridView::positionViewAtIndex(int index, PositionMode mode)<KAIGYO><KAIGYO>    Positions the view such that the \\a index is at the position specified by<KAIGYO>    \\a mode:<KAIGYO><KAIGYO>    \\list<KAIGYO>    \\o GridView.Beginning - position item at the top (or left for \\c GridView.TopToBottom flow) of the view.<KAIGYO>    \\o GridView.Center - position item in the center of the view.<KAIGYO>    \\o GridView.End - position item at bottom (or right for horizontal orientation) of the view.<KAIGYO>    \\o GridView.Visible - if any part of the item is visible then take no action, otherwise<KAIGYO>    bring the item into view.<KAIGYO>    \\o GridView.Contain - ensure the entire item is visible.  If the item is larger than<KAIGYO>    the view the item is positioned at the top (or left for \\c GridView.TopToBottom flow) of the view.<KAIGYO>    \\endlist<KAIGYO><KAIGYO>    If positioning the view at the index would cause empty space to be displayed at<KAIGYO>    the beginning or end of the view, the view will be positioned at the boundary.<KAIGYO><KAIGYO>    It is not recommended to use \\l {Flickable::}{contentX} or \\l {Flickable::}{contentY} to position the view<KAIGYO>    at a particular index.  This is unreliable since removing items from the start<KAIGYO>    of the view does not cause all other items to be repositioned.<KAIGYO>    The correct way to bring an item into view is with \\c positionViewAtIndex.<KAIGYO><KAIGYO>    \\bold Note: methods should only be called after the Component has completed.  To position<KAIGYO>    the view at startup, this method should be called by Component.onCompleted.  For<KAIGYO>    example, to position the view at the end:<KAIGYO><KAIGYO>    \\code<KAIGYO>    Component.onCompleted: positionViewAtIndex(count - 1, GridView.Beginning)<KAIGYO>    \\endcode<KAIGYO>*/': 1, ""/*!<KAIGYO>    \\qmlclass ListView QSGListView<KAIGYO>    \\inqmlmodule QtQuick 2<KAIGYO>    \\ingroup qml-view-elements<KAIGYO>    \\inherits Flickable<KAIGYO>    \\brief The ListView item provides a list view of items provided by a model.<KAIGYO><KAIGYO>    A ListView displays data from models created from built-in QML elements like ListModel<KAIGYO>    and XmlListModel, or custom model classes defined in C++ that inherit from<KAIGYO>    QAbstractListModel.<KAIGYO><KAIGYO>    A ListView has a \\l model, which defines the data to be displayed, and<KAIGYO>    a \\l delegate, which defines how the data should be displayed. Items in a<KAIGYO>    ListView are laid out horizontally or vertically. List views are inherently<KAIGYO>    flickable because ListView inherits from \\l Flickable.<KAIGYO><KAIGYO>    \\section1 Example Usage<KAIGYO><KAIGYO>    The following example shows the definition of a simple list model defined<KAIGYO>    in a file called \\c ContactModel.qml:<KAIGYO><KAIGYO>    \\snippet doc/src/snippets/declarative/listview/ContactModel.qml 0<KAIGYO><KAIGYO>    Another component can display this model data in a ListView, like this:<KAIGYO><KAIGYO>    \\snippet doc/src/snippets/declarative/listview/listview.qml import<KAIGYO>    \\codeline<KAIGYO>    \\snippet doc/src/snippets/declarative/listview/listview.qml classdocs simple<KAIGYO><KAIGYO>    \\image listview-simple.png<KAIGYO><KAIGYO>    Here, the ListView creates a \\c ContactModel component for its model, and a \\l Text element<KAIGYO>    for its delegate. The view will create a new \\l Text component for each item in the model. Notice<KAIGYO>    the delegate is able to access the model's \\c name and \\c number data directly.<KAIGYO><KAIGYO>    An improved list view is shown below. The delegate is visually improved and is moved<KAIGYO>    into a separate \\c contactDelegate component.<KAIGYO><KAIGYO>    \\snippet doc/src/snippets/declarative/listview/listview.qml classdocs advanced<KAIGYO>    \\image listview-highlight.png<KAIGYO><KAIGYO>    The currently selected item is highlighted with a blue \\l Rectangle using the \\l highlight property,<KAIGYO>    and \\c focus is set to \\c true to enable keyboard navigation for the list view.<KAIGYO>    The list view itself is a focus scope (see \\l{qmlfocus#Acquiring Focus and Focus Scopes}{the focus documentation page} for more details).<KAIGYO><KAIGYO>    Delegates are instantiated as needed and may be destroyed at any time.<KAIGYO>    State should \\e never be stored in a delegate.<KAIGYO><KAIGYO>    ListView attaches a number of properties to the root item of the delegate, for example<KAIGYO>    \\c {ListView.isCurrentItem}.  In the following example, the root delegate item can access<KAIGYO>    this attached property directly as \\c ListView.isCurrentItem, while the child<KAIGYO>    \\c contactInfo object must refer to this property as \\c wrapper.ListView.isCurrentItem.<KAIGYO><KAIGYO>    \\snippet doc/src/snippets/declarative/listview/listview.qml isCurrentItem<KAIGYO><KAIGYO>    \\note Views do not enable \\e clip automatically.  If the view<KAIGYO>    is not clipped by another item or the screen, it will be necessary<KAIGYO>    to set \\e {clip: true} in order to have the out of view items clipped<KAIGYO>    nicely.<KAIGYO><KAIGYO>    \\sa {QML Data Models}, GridView, {declarative/modelviews/listview}{ListView examples}<KAIGYO>*/"": 1, '/*!<KAIGYO>    \\qmlproperty int QtQuick2::ListView::cacheBuffer<KAIGYO>    This property determines whether delegates are retained outside the<KAIGYO>    visible area of the view.<KAIGYO><KAIGYO>    If this value is non-zero, the view keeps as many delegates<KAIGYO>    instantiated as it can fit within the buffer specified.  For example,<KAIGYO>    if in a vertical view the delegate is 20 pixels high and \\c cacheBuffer is<KAIGYO>    set to 40, then up to 2 delegates above and 2 delegates below the visible<KAIGYO>    area may be retained.<KAIGYO><KAIGYO>    Note that cacheBuffer is not a pixel buffer - it only maintains additional<KAIGYO>    instantiated delegates.<KAIGYO><KAIGYO>    Setting this value can improve the smoothness of scrolling behavior at the expense<KAIGYO>    of additional memory usage.  It is not a substitute for creating efficient<KAIGYO>    delegates; the fewer elements in a delegate, the faster a view can be<KAIGYO>    scrolled.<KAIGYO>*/': 1, '/*!<KAIGYO>    \\qmlproperty string QtQuick2::ListView::section.property<KAIGYO>    \\qmlproperty enumeration QtQuick2::ListView::section.criteria<KAIGYO>    \\qmlproperty Component QtQuick2::ListView::section.delegate<KAIGYO>    \\qmlproperty enumeration QtQuick2::ListView::section.labelPositioning<KAIGYO><KAIGYO>    These properties determine the expression to be evaluated and appearance<KAIGYO>    of the section labels.<KAIGYO><KAIGYO>    \\c section.property holds the name of the property that is the basis<KAIGYO>    of each section.<KAIGYO><KAIGYO>    \\c section.criteria holds the criteria for forming each section based on<KAIGYO>    \\c section.property. This value can be one of:<KAIGYO><KAIGYO>    \\list<KAIGYO>    \\o ViewSection.FullString (default) - sections are created based on the<KAIGYO>    \\c section.property value.<KAIGYO>    \\o ViewSection.FirstCharacter - sections are created based on the first<KAIGYO>    character of the \\c section.property value (for example, \'A\', \'B\', \'C\'<KAIGYO>    sections, etc. for an address book)<KAIGYO>    \\endlist<KAIGYO><KAIGYO>    \\c section.delegate holds the delegate component for each section.<KAIGYO><KAIGYO>    \\c section.labelPositioning determines whether the current and/or<KAIGYO>    next section labels stick to the start/end of the view, and whether<KAIGYO>    the labels are shown inline.  This value can be a combination of:<KAIGYO><KAIGYO>    \\list<KAIGYO>    \\o ViewSection.InlineLabels - section labels are shown inline between<KAIGYO>    the item delegates separating sections (default).<KAIGYO>    \\o ViewSection.CurrentLabelAtStart - the current section label sticks to the<KAIGYO>    start of the view as it is moved.<KAIGYO>    \\o ViewSection.NextLabelAtEnd - the next section label (beyond all visible<KAIGYO>    sections) sticks to the end of the view as it is moved. \\note Enabling<KAIGYO>    \\c ViewSection.NextLabelAtEnd requires the view to scan ahead for the next<KAIGYO>    section, which has performance implications, especially for slower models.<KAIGYO>    \\endlist<KAIGYO><KAIGYO>    Each item in the list has attached properties named \\c ListView.section,<KAIGYO>    \\c ListView.previousSection and \\c ListView.nextSection.<KAIGYO><KAIGYO>    For example, here is a ListView that displays a list of animals, separated<KAIGYO>    into sections. Each item in the ListView is placed in a different section<KAIGYO>    depending on the """" property of the model item. The \\c sectionHeading<KAIGYO>    delegate component provides the light blue bar that marks the beginning of<KAIGYO>    each section.<KAIGYO><KAIGYO><KAIGYO>    \\snippet examples/declarative/modelviews/listview/sections.qml 0<KAIGYO><KAIGYO>    \\image qml-listview-sections-example.png<KAIGYO><KAIGYO>    \\note Adding sections to a ListView does not automatically re-order the<KAIGYO>    list items by the section criteria.<KAIGYO>    If the model is not ordered by section, then it is possible that<KAIGYO>    the sections created will not be unique; each boundary between<KAIGYO>    differing sections will result in a section header being created<KAIGYO>    even if that section exists elsewhere.<KAIGYO><KAIGYO>    \\sa {declarative/modelviews/listview}{ListView examples}<KAIGYO>*/': 1, '/*!<KAIGYO>    \\qmlproperty real QtQuick2::ListView::highlightMoveSpeed<KAIGYO>    \\qmlproperty int QtQuick2::ListView::highlightMoveDuration<KAIGYO>    \\qmlproperty real QtQuick2::ListView::highlightResizeSpeed<KAIGYO>    \\qmlproperty int QtQuick2::ListView::highlightResizeDuration<KAIGYO><KAIGYO>    These properties hold the move and resize animation speed of the highlight delegate.<KAIGYO><KAIGYO>    \\l highlightFollowsCurrentItem must be true for these properties<KAIGYO>    to have effect.<KAIGYO><KAIGYO>    The default value for the speed properties is 400 pixels/second.<KAIGYO>    The default value for the duration properties is -1, i.e. the<KAIGYO>    highlight will take as much time as necessary to move at the set speed.<KAIGYO><KAIGYO>    These properties have the same characteristics as a SmoothedAnimation.<KAIGYO><KAIGYO>    \\sa highlightFollowsCurrentItem<KAIGYO>*/': 1, '/*!<KAIGYO>    \\qmlmethod QtQuick2::ListView::positionViewAtIndex(int index, PositionMode mode)<KAIGYO><KAIGYO>    Positions the view such that the \\a index is at the position specified by<KAIGYO>    \\a mode:<KAIGYO><KAIGYO>    \\list<KAIGYO>    \\o ListView.Beginning - position item at the top (or left for horizontal orientation) of the view.<KAIGYO>    \\o ListView.Center - position item in the center of the view.<KAIGYO>    \\o ListView.End - position item at bottom (or right for horizontal orientation) of the view.<KAIGYO>    \\o ListView.Visible - if any part of the item is visible then take no action, otherwise<KAIGYO>    bring the item into view.<KAIGYO>    \\o ListView.Contain - ensure the entire item is visible.  If the item is larger than<KAIGYO>    the view the item is positioned at the top (or left for horizontal orientation) of the view.<KAIGYO>    \\endlist<KAIGYO><KAIGYO>    If positioning the view at \\a index would cause empty space to be displayed at<KAIGYO>    the beginning or end of the view, the view will be positioned at the boundary.<KAIGYO><KAIGYO>    It is not recommended to use \\l {Flickable::}{contentX} or \\l {Flickable::}{contentY} to position the view<KAIGYO>    at a particular index.  This is unreliable since removing items from the start<KAIGYO>    of the list does not cause all other items to be repositioned, and because<KAIGYO>    the actual start of the view can vary based on the size of the delegates.<KAIGYO>    The correct way to bring an item into view is with \\c positionViewAtIndex.<KAIGYO><KAIGYO>    \\bold Note: methods should only be called after the Component has completed.  To position<KAIGYO>    the view at startup, this method should be called by Component.onCompleted.  For<KAIGYO>    example, to position the view at the end:<KAIGYO><KAIGYO>    \\code<KAIGYO>    Component.onCompleted: positionViewAtIndex(count - 1, ListView.Beginning)<KAIGYO>    \\endcode<KAIGYO>*/': 1, '//###For auto-follow on states, perhaps should be in emitter?': 1, '//TODO: Optimize 0 lifespan (or already dead) case': 1, '//XXX allow shrinking': 1, '//TODO: If the data is clear, gc (consider shrinking stack size)?': 1, '//TODO: a way to Unregister emitters, painters and affectors<KAIGYO>//###Set or uniqueness checking?': 1, '//XXX': 1, '//TODO: Garbage collection?': 1, ""//XXX shouldn't really be an assert"": 1, '//### Elapsed time never shrinks - may cause problems if left emitting for weeks at a time.': 1}",1.0,{}
192,7409.0,5.0,7.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/7409,Fix memory leaks in the new animation framework,1.0,"{'//FIXME:Need more work to make multiple animation instances play properly': 5, '//FIXME: Multiple animation instances problem:<KAIGYO>//       the animation instance should not tie to declarative object.': 5, '//FIXME: This should be changed to enable multiple animation instances properly.': 5}",1.0,"{""//FIXME: proxy shouldn't live with the declarative animation (needs to be unique per QActionAnimation)"": 3}",1.0,{}
220,7462.0,1.0,1.0,0.0,ABANDONED,False,https://codereview.qt-project.org/#/c/7462,Merge branch 'master' into ubercontext-optimizations,1.0,{},0.0,"{'// How much faster to decelerate when overshooting': 1, '// FlickThreshold determines how far the """" must have moved<KAIGYO>// before we perform a flick.': 1, '// -ve velocity means list is moving up': 1, '/*<KAIGYO>XXXTODO add docs describing moving, dragging, flicking properties, e.g.<KAIGYO><KAIGYO>When the user starts dragging the Flickable, the dragging and moving properties<KAIGYO>will be true.<KAIGYO><KAIGYO>If the velocity is sufficient when the drag is ended, flicking may begin.<KAIGYO><KAIGYO>The moving properties will remain true until all dragging and flicking<KAIGYO>is finished.<KAIGYO>*/': 1, '//XXX pixelAligned ignores the global position of the Flickable, i.e. assumes Flickable itself is pixel aligned.': 1, '// Use the event handler that will take care of finding the proper item to propagate the event': 1, '// XXX todo - do we want this?': 1, '// XXX todo': 1, '// if our mouse grab has been removed (probably by another Flickable),<KAIGYO>// fix our state': 1, '//Use the event handler that will take care of finding the proper item to propagate the event': 1, '/*!<KAIGYO>    \\qmlproperty bool QtQuick2::Flickable::flicking<KAIGYO>    \\qmlproperty bool QtQuick2::Flickable::flickingHorizontally<KAIGYO>    \\qmlproperty bool QtQuick2::Flickable::flickingVertically<KAIGYO><KAIGYO>    These properties describe whether the view is currently moving horizontally,<KAIGYO>    vertically or in either direction, due to the user flicking the view.<KAIGYO>*/': 1, '/*!<KAIGYO>    \\qmlproperty bool QtQuick2::Flickable::dragging<KAIGYO>    \\qmlproperty bool QtQuick2::Flickable::draggingHorizontally<KAIGYO>    \\qmlproperty bool QtQuick2::Flickable::draggingVertically<KAIGYO><KAIGYO>    These properties describe whether the view is currently moving horizontally,<KAIGYO>    vertically or in either direction, due to the user dragging the view.<KAIGYO>*/': 1, '/*!<KAIGYO>    \\qmlproperty bool QtQuick2::Flickable::moving<KAIGYO>    \\qmlproperty bool QtQuick2::Flickable::movingHorizontally<KAIGYO>    \\qmlproperty bool QtQuick2::Flickable::movingVertically<KAIGYO><KAIGYO>    These properties describe whether the view is currently moving horizontally,<KAIGYO>    vertically or in either direction, due to the user either dragging or<KAIGYO>    flicking the view.<KAIGYO>*/': 1, '// For stretch this algorithm could be simplified to use less vertices<KAIGYO>// as more vertices could be reused then, but I doubt its where our main<KAIGYO>// problem will lie. This way, we at least share the algorithm between all': 1, '// Fill in the vertices.. The loop below is pretty much an exact replica<KAIGYO>// of the one inside fillRow.': 1}",1.0,{}
289,7616.0,2.0,7.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/7616,Remove symbian threading primitive.,1.0,{},0.0,{'// ### TODO: allow the user to create a custom event dispatcher': 1},1.0,{}
303,7691.0,1.0,3.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/7691,Remove disabled code from QString autotest.,1.0,{},0.0,"{""    /*<KAIGYO>      The std::string support is fairly trivial in itself. The major<KAIGYO>      problem is whether it compiles or not, because of the way<KAIGYO>      different compilers choose an overload based on the type of the<KAIGYO>      argument. If it compiles, we're happy.<KAIGYO>    */"": 1}",1.0,{}
306,7696.0,1.0,3.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/7696,Remove unstable test from qgraphicsscene test.,1.0,{},0.0,"{'// ### This test is difficult to make work for all platforms; instead, a<KAIGYO>// hand crafted data set would make it stable. Its behavior is thoroughly<KAIGYO>// covered by other tests. Todo: Fix this test.': 1}",1.0,{}
315,7711.0,1.0,4.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/7711,Improve QWidget autotest,1.0,{'// ### fixme: embedded may choose a different size to fit on the screen.': 1},1.0,{'// ### fixme: embedded may choose a different size to fit on the screen. (QTBUG-22326)': 1},1.0,{}
350,7811.0,1.0,11.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/7811,Remove disabled code in QItemView test.,1.0,{},0.0,"{'// ### hide the first/last row,column and re-run all of these tests<KAIGYO>// ### Not 100% sure, but I think the next to are tableview specific only and everyone else just does up/down<KAIGYO>// QAbstractItemView::MoveNext, AbstractItemView::MovePrevious': 1}",1.0,{}
20,8004.0,2.0,7.0,4.0,MERGED,True,https://codereview.qt-project.org/#/c/8004,Cursory docs for QQuickCanvas and QQuickView,1.0,{},0.0,{'// XXX todo - This whole class should probably be merged with QDeclarativeView for<KAIGYO>// maximum seamlessness': 1},1.0,{}
75,8034.0,3.0,9.0,1.0,MERGED,True,https://codereview.qt-project.org/#/c/8034,Don't crash if contexts are deleted during refreshExpressions,1.0,"{'// Refreshes all expressions that could possibly depend on this context.  Refreshing flushes all<KAIGYO>// context-tree dependent caches in the expressions, and should occur every time the context tree<KAIGYO>// *structure* (not values) changes.<KAIGYO>// For efficiency, we try and minimize the number of guards we have to create': 1}",1.0,"{'/*<KAIGYO>Refreshes all expressions that could possibly depend on this context.  Refreshing flushes all<KAIGYO>context-tree dependent caches in the expressions, and should occur every time the context tree<KAIGYO> *structure* (not values) changes.<KAIGYO>*/': 1}",1.0,{}
18,8050.0,2.0,13.0,1.0,MERGED,True,https://codereview.qt-project.org/#/c/8050,Fixed returned geometry of toplevel child widgets,1.0,{},0.0,"{'// Note: Using frameGeometry (based on GetWindowRect)<KAIGYO>// has been observed to return a size based on a standard top level<KAIGYO>// frame for WS_CHILD windows (whose frame is zero), thus, use the real<KAIGYO>// client size instead.': 1}",1.0,{}
78,8185.0,2.0,7.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/8185,Allow disabling FreeType internal cache,1.0,{'// TODO move everything here to a method of its own to access glyphSets<KAIGYO>// to be shared with a new method that will replace loadTransformedGlyphSet()': 1},1.0,{'// TODO move everything here to a method of its own to access glyphSets<KAIGYO>// to be shared with a new method that will replace loadTransformedGlyphSet()': 1},1.0,{}
156,8187.0,5.0,11.0,4.0,MERGED,True,https://codereview.qt-project.org/#/c/8187,qmake: remove symbian support,1.0,{},0.0,"{'// Do not deploy resources in emulator builds, as that seems to cause conflicts<KAIGYO>// If there is ever a real need to deploy pre-built resources for emulator,<KAIGYO>// BLD_INF_RULES.prj_exports can be used as a workaround.': 1, '// In case user defines langs, he must take care also about SIS header': 1, ""// As a workaround for Symbian toolchain insistence to treat include<KAIGYO>// statements as relative to source file rather than the file they appear in,<KAIGYO>// we generate extra temporary include directories to make<KAIGYO>// relative include paths used in various headers to work properly.<KAIGYO>// Note that this is not a fix-all solution; it's just a stop-gap measure<KAIGYO>// to make Qt itself build until toolchain can support relative includes in<KAIGYO>// a way that Qt expects."": 1}",1.0,{}
138,8376.0,2.0,4.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/8376,Widgets: Remove dialog functionality from QGuiPlatformPlugin.,1.0,"{'// ### fixme: Call helper<KAIGYO>// if (d->nativeDialogInUse)<KAIGYO>//    qt_guiPlatformPlugin()->colorDialogSetCurrentColor(this, color);': 1}",1.0,"{'// TODO is Symbian, non-S60 behaviour required?<KAIGYO>//On Windows Mobile we create an empty menu to hide the current menu': 1}",1.0,{}
140,8384.0,1.0,4.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/8384,Widgets: Remove remains of Windows file dialog.,1.0,{},0.0,"{'/*<KAIGYO>    This is evil. MSVC doesn\'t let us remove private symbols, nor change their<KAIGYO>    visibility; yet there are some symbols we really needed to make public, e.g.,<KAIGYO>    ~QColorDialog(), and then there were some totally needless symbols in our<KAIGYO>    header files, e.g., setSelectedAlpha(). So we define a new version of<KAIGYO>    QColorDialog & Co. with only the private symbols that we removed from the<KAIGYO>    public header files. The friends are there only to prevent potential compiler<KAIGYO>    warnings.<KAIGYO><KAIGYO>    It would have been nicer to export the missing symbols as mangled """" symbols<KAIGYO>    instead but unfortunately MSVC uses out-of-reach characters like @ and . in<KAIGYO>    their mangled C++ symbols.<KAIGYO>*/': 1, ""// another thread did initialize the security function pointers,<KAIGYO>// so we shouldn't do it again."": 1}",1.0,{}
223,8584.0,1.0,4.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/8584,"QPlatformDialogHelper: Split class hierarchy, decouple from Dialog",1.0,{},0.0,{'// ### fixme: Remove once a dialog helper hierarchy is in place': 1},1.0,{}
272,8628.0,2.0,14.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/8628,Allow to create a custom event dispatcher for specific QThreads.,1.0,"{'// was the move successful?': 1, '// move was successful?': 2}",1.0,{'// ### TODO: allow the user to create a custom event dispatcher': 1},1.0,{}
264,8693.0,1.0,4.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/8693,Debugger: Remove option to constantly send tracing data,1.0,{'//### this is a suboptimal way to send batched messages': 1},1.0,{'//### this is a suboptimal way to send batched messages': 1},1.0,{}
352,8907.0,5.0,10.0,0.0,ABANDONED,False,https://codereview.qt-project.org/#/c/8907,Disable dnd for Windows,1.0,"{'//QWindowsDrag::QWindowsDrag() : m_dropDataObject(0), m_dragBeingCancelled(false)<KAIGYO>//{<KAIGYO>//}<KAIGYO>//QWindowsDrag::~QWindowsDrag()<KAIGYO>//{<KAIGYO>//}<KAIGYO>//void QWindowsDrag::startDrag()<KAIGYO>//{<KAIGYO>//    // TODO: Accessibility handling?<KAIGYO>//    QDragManager *dragManager = QDragManager::self();<KAIGYO>//    QMimeData *dropData = dragManager->dropData();<KAIGYO>//    m_dragBeingCancelled = false;<KAIGYO>//    DWORD resultEffect;<KAIGYO>//    QWindowsOleDropSource *windowDropSource = new QWindowsOleDropSource();<KAIGYO>//    windowDropSource->createCursors();<KAIGYO>//    QWindowsOleDataObject *dropDataObject = new QWindowsOleDataObject(dropData);<KAIGYO>//    const  Qt::DropActions possibleActions = dragManager->possible_actions;<KAIGYO>//    const DWORD allowedEffects = translateToWinDragEffects(possibleActions);<KAIGYO>//    if (QWindowsContext::verboseOLE)<KAIGYO>//          qDebug("""", __FUNCTION__,<KAIGYO>//                 int(possibleActions), allowedEffects);<KAIGYO>//    const HRESULT r = DoDragDrop(dropDataObject, windowDropSource, allowedEffects, &resultEffect);<KAIGYO>//    const DWORD  reportedPerformedEffect = dropDataObject->reportedPerformedEffect();<KAIGYO>//    Qt::DropAction ret = Qt::IgnoreAction;<KAIGYO>//    if (r == DRAGDROP_S_DROP) {<KAIGYO>//        if (reportedPerformedEffect == DROPEFFECT_MOVE && resultEffect != DROPEFFECT_MOVE) {<KAIGYO>//            ret = Qt::TargetMoveAction;<KAIGYO>//            resultEffect = DROPEFFECT_MOVE;<KAIGYO>//        } else {<KAIGYO>//            ret = translateToQDragDropAction(resultEffect);<KAIGYO>//        }<KAIGYO>//        // Force it to be a copy if an unsupported operation occurred.<KAIGYO>//        // This indicates a bug in the drop target.<KAIGYO>//        if (resultEffect != DROPEFFECT_NONE && !(resultEffect & allowedEffects))<KAIGYO>//            ret = Qt::CopyAction;<KAIGYO>//    } else {<KAIGYO>//        dragManager->setCurrentTarget(0);<KAIGYO>//    }<KAIGYO>//    // clean up<KAIGYO>//    dropDataObject->releaseQt();<KAIGYO>//    dropDataObject->Release();        // Will delete obj if refcount becomes 0<KAIGYO>//    windowDropSource->Release();        // Will delete src if refcount becomes 0<KAIGYO>//    if (QWindowsContext::verboseOLE)<KAIGYO>//        qDebug("""",<KAIGYO>//               __FUNCTION__, allowedEffects, reportedPerformedEffect, resultEffect, int(r), ret);<KAIGYO>//}<KAIGYO>//void QWindowsDrag::move(const QMouseEvent *me)<KAIGYO>//{<KAIGYO>//    const QPoint pos = me->pos();<KAIGYO>//    if (QWindowsContext::verboseOLE)<KAIGYO>//        qDebug("""", __FUNCTION__, pos.x(), pos.y());<KAIGYO>//}<KAIGYO>//void QWindowsDrag::drop(const QMouseEvent *me)<KAIGYO>//{<KAIGYO>//    const QPoint pos = me->pos();<KAIGYO>//    if (QWindowsContext::verboseOLE)<KAIGYO>//        qDebug("""", __FUNCTION__, pos.x(), pos.y());<KAIGYO>//}<KAIGYO>//void QWindowsDrag::cancel()<KAIGYO>//{<KAIGYO>//    // TODO: Accessibility handling?<KAIGYO>//    if (QWindowsContext::verboseOLE)<KAIGYO>//        qDebug("""", __FUNCTION__);<KAIGYO>//    m_dragBeingCancelled = true;<KAIGYO>//}<KAIGYO>//QWindowsDrag *QWindowsDrag::instance()<KAIGYO>//{<KAIGYO>//    return static_cast<QWindowsDrag *>(QWindowsIntegration::instance()->drag());<KAIGYO>//}<KAIGYO>//void QWindowsDrag::releaseDropDataObject()<KAIGYO>//{<KAIGYO>//    if (QWindowsContext::verboseOLE)<KAIGYO>//        qDebug("""", __FUNCTION__, m_dropDataObject);<KAIGYO>//    if (m_dropDataObject) {<KAIGYO>//        m_dropDataObject->Release();<KAIGYO>//        m_dropDataObject = 0;<KAIGYO>//    }<KAIGYO>//}<KAIGYO>//QT_END_NAMESPACE': 1}",1.0,{'// TODO: Accessibility handling?': 1},1.0,{}
383,8942.0,3.0,16.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/8942,Don't depend on moc to disable test functions.,1.0,{},0.0,"{'// This is a OS X only test (unless you know more about filesystems, then maybe you should try it ;)': 1, '// Mac has other ideas about alpha composition': 1, '// Exact matching on windows misses a lot because of the sample chars.': 1, '// Too much memory usage for testing on CE emulator.': 1, '// Mouse move related signals for Windows Mobile unavailable.': 1}",1.0,{}
69,9195.0,1.0,7.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/9195,Remove obsolete comment from QDataStream test.,1.0,{},0.0,{'//     ################ Bug : ref and orig has ff in alpha; readback has 0<KAIGYO>//     ### (Was like this in 1.44 as well)': 1},1.0,{}
117,9343.0,2.0,10.0,0.0,ABANDONED,False,https://codereview.qt-project.org/#/c/9343,Temporarily disable some tests that fail without threaded renderer,1.0,"{'// XXX QTBUG-22831 fails without threaded renderer<KAIGYO>//QTRY_VERIFY(!findItem<QQuickItem>(contentItem, """", 0));  // 0 shouldn\'t be visible': 1, '// XXX QTBUG-22831 contentY is wrong when threaded renderer is disabled': 1}",1.0,"{""// wait for refill to complete<KAIGYO>// 0 shouldn't be visible"": 1}",1.0,{}
130,9357.0,1.0,7.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/9357,Use the AST for binding rewriting when possible.,1.0,{'// XXX': 1},1.0,{'// XXX': 1},1.0,{}
121,9368.0,1.0,3.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/9368,Remove reset test from QTimeLine.,1.0,{},0.0,"{'//timeLine.reset(); ### todo<KAIGYO>// timeLine.reset(); ### todo<KAIGYO>//int currentFrame = timeLine.currentFrame();<KAIGYO>//int currentCurrentTime = timeLine.currentTime();<KAIGYO>//QCOMPARE(timeLine.currentFrame(), currentFrame); ### Behavioral change<KAIGYO>//QCOMPARE(timeLine.currentTime(), currentCurrentTime);': 1}",1.0,{}
199,9666.0,1.0,3.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/9666,Improve performance on touch event delivery.,1.0,{},0.0,"{""// XXX todo - optimize, don't sort and return items that are<KAIGYO>// ignored anyway, like invisible or disabled items."": 1}",1.0,{}
222,9787.0,1.0,3.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/9787,Removed ShaderEffectItem and qt_ModelViewProjectionMatrix.,1.0,{},0.0,{'// TODO: Remove after grace period.': 1},1.0,{}
271,9979.0,2.0,2.0,0.0,ABANDONED,False,https://codereview.qt-project.org/#/c/9979,Fix crash when accessing relations of scenegraphview.,1.0,"{'// FIXME: for now we assume to be a top level window...': 1, '// FIXME': 1}",1.0,{'// FIXME<KAIGYO>// FIXME': 1},1.0,{}
18,10109.0,1.0,1.0,0.0,ABANDONED,False,https://codereview.qt-project.org/#/c/10109,Accessibility: fix rect for qml.,1.0,{},0.0,"{'// FIXME<KAIGYO>//    QRect viewRect = viewRect();<KAIGYO>//    QRect itemRect = itemRect();<KAIGYO>//   // qDebug() << """" << itemRect;<KAIGYO>//    // error case:<KAIGYO>//    if (viewRect.isNull() || itemRect.isNull()) {<KAIGYO>//        state |= QAccessible::Invisible;<KAIGYO>//    }<KAIGYO>//    if (!viewRect.intersects(itemRect)) {<KAIGYO>//        state |= QAccessible::Offscreen;<KAIGYO>//        // state |= QAccessible::Invisible; // no set at this point to ease development<KAIGYO>//    }': 1}",1.0,{}
26,10124.0,2.0,5.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/10124,Don't update dependent anchors on destruction unless required.,1.0,{},0.0,{'// XXX todo - the original checks if the parent is being destroyed<KAIGYO>//child will be deleted anyway': 1},1.0,{}
35,10189.0,1.0,4.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/10189,Improve value type read performance,1.0,{},0.0,"{'// XXX This is horribly inefficient.  Sadly people seem to have taken a liking to <KAIGYO>// value type properties, so we should probably try and optimize it a little.<KAIGYO>// We should probably just replace all value properties with dedicated accessors.': 1}",1.0,{}
200,10678.0,1.0,7.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/10678,Remove ptmalloc from source tree,1.0,{},0.0,"{'/*<KAIGYO>  $Id: malloc.c,v 1.4 2006/03/30 16:47:29 wg Exp $<KAIGYO><KAIGYO>  This version of malloc.c was adapted for ptmalloc3 by Wolfram Gloger<KAIGYO>  <wg@malloc.de>.  Therefore, some of the comments below do not apply<KAIGYO>  for this modified version.  However, it is the intention to keep<KAIGYO>  differences to Doug Lea\'s original version minimal, hence the<KAIGYO>  comments were mostly left unchanged.<KAIGYO><KAIGYO> -----------------------------------------------------------------------<KAIGYO><KAIGYO>  This is a version (aka dlmalloc) of malloc/free/realloc written by<KAIGYO>  Doug Lea and released to the public domain, as explained at<KAIGYO>  httpcreativecommons.org/licenses/publicdomain.  Send questions,<KAIGYO>  comments, complaints, performance data, etc to dl@cs.oswego.edu<KAIGYO><KAIGYO>* Version pre-2.8.4 Wed Mar 29 19:46:29 2006    (dl at gee)<KAIGYO><KAIGYO>   Note: There may be an updated version of this malloc obtainable at<KAIGYO>           ftpgee.cs.oswego.edu/pub/misc/malloc.c<KAIGYO>         Check before installing!<KAIGYO><KAIGYO>* Quickstart<KAIGYO><KAIGYO>  This library is all in one file to simplify the most common usage:<KAIGYO>  ftp it, compile it (-O3), and link it into another program. All of<KAIGYO>  the compile-time options default to reasonable values for use on<KAIGYO>  most platforms.  You might later want to step through various<KAIGYO>  compile-time and dynamic tuning options.<KAIGYO><KAIGYO>  For convenience, an include file for code using this malloc is at:<KAIGYO>     ftpgee.cs.oswego.edu/pub/misc/malloc-2.8.3.h<KAIGYO>  You don\'t really need this .h file unless you call functions not<KAIGYO>  defined in your system include files.  The .h file contains only the<KAIGYO>  excerpts from this file needed for using this malloc on ANSI C/C++<KAIGYO>  systems, so long as you haven\'t changed compile-time options about<KAIGYO>  naming and tuning parameters.  If you do, then you can create your<KAIGYO>  own malloc.h that does include all settings by cutting at the point<KAIGYO>  indicated below. Note that you may already by default be using a C<KAIGYO>  library containing a malloc that is based on some version of this<KAIGYO>  malloc (for example in linux). You might still want to use the one<KAIGYO>  in this file to customize settings or to avoid overheads associated<KAIGYO>  with library versions.<KAIGYO><KAIGYO>* Vital statistics:<KAIGYO><KAIGYO>  Supported pointer/size_t representation:       4 or 8 bytes<KAIGYO>       size_t MUST be an unsigned type of the same width as<KAIGYO>       pointers. (If you are using an ancient system that declares<KAIGYO>       size_t as a signed type, or need it to be a different width<KAIGYO>       than pointers, you can use a previous release of this malloc<KAIGYO>       (e.g. 2.7.2) supporting these.)<KAIGYO><KAIGYO>  Alignment:                                     8 bytes (default)<KAIGYO>       This suffices for nearly all current machines and C compilers.<KAIGYO>       However, you can define MALLOC_ALIGNMENT to be wider than this<KAIGYO>       if necessary (up to 128bytes), at the expense of using more space.<KAIGYO><KAIGYO>  Minimum overhead per allocated chunk:   4 or  8 bytes (if 4byte sizes)<KAIGYO>                                          8 or 16 bytes (if 8byte sizes)<KAIGYO>       Each malloced chunk has a hidden word of overhead holding size<KAIGYO>       and status information, and additional cross-check word<KAIGYO>       if FOOTERS is defined.<KAIGYO><KAIGYO>  Minimum allocated size: 4-byte ptrs:  16 bytes    (including overhead)<KAIGYO>                          8-byte ptrs:  32 bytes    (including overhead)<KAIGYO><KAIGYO>       Even a request for zero bytes (i.e., malloc(0)) returns a<KAIGYO>       pointer to something of the minimum allocatable size.<KAIGYO>       The maximum overhead wastage (i.e., number of extra bytes<KAIGYO>       allocated than were requested in malloc) is less than or equal<KAIGYO>       to the minimum size, except for requests >= mmap_threshold that<KAIGYO>       are serviced via mmap(), where the worst case wastage is about<KAIGYO>       32 bytes plus the remainder from a system page (the minimal<KAIGYO>       mmap unit); typically 4096 or 8192 bytes.<KAIGYO><KAIGYO>  Security: static-safe; optionally more or less<KAIGYO>       The """" of malloc refers to the ability of malicious<KAIGYO>       code to accentuate the effects of errors (for example, freeing<KAIGYO>       space that is not currently malloc\'ed or overwriting past the<KAIGYO>       ends of chunks) in code that calls malloc.  This malloc<KAIGYO>       guarantees not to modify any memory locations below the base of<KAIGYO>       heap, i.e., static variables, even in the presence of usage<KAIGYO>       errors.  The routines additionally detect most improper frees<KAIGYO>       and reallocs.  All this holds as long as the static bookkeeping<KAIGYO>       for malloc itself is not corrupted by some other means.  This<KAIGYO>       is only one aspect of security -- these checks do not, and<KAIGYO>       cannot, detect all possible programming errors.<KAIGYO><KAIGYO>       If FOOTERS is defined nonzero, then each allocated chunk<KAIGYO>       carries an additional check word to verify that it was malloced<KAIGYO>       from its space.  These check words are the same within each<KAIGYO>       execution of a program using malloc, but differ across<KAIGYO>       executions, so externally crafted fake chunks cannot be<KAIGYO>       freed. This improves security by rejecting frees/reallocs that<KAIGYO>       could corrupt heap memory, in addition to the checks preventing<KAIGYO>       writes to statics that are always on.  This may further improve<KAIGYO>       security at the expense of time and space overhead.  (Note that<KAIGYO>       FOOTERS may also be worth using with MSPACES.)<KAIGYO><KAIGYO>       By default detected errors cause the program to abort (calling<KAIGYO>       """"). You can override this to instead proceed past<KAIGYO>       errors by defining PROCEED_ON_ERROR.  In this case, a bad free<KAIGYO>       has no effect, and a malloc that encounters a bad address<KAIGYO>       caused by user overwrites will ignore the bad address by<KAIGYO>       dropping pointers and indices to all known memory. This may<KAIGYO>       be appropriate for programs that should continue if at all<KAIGYO>       possible in the face of programming errors, although they may<KAIGYO>       run out of memory because dropped memory is never reclaimed.<KAIGYO><KAIGYO>       If you don\'t like either of these options, you can define<KAIGYO>       CORRUPTION_ERROR_ACTION and USAGE_ERROR_ACTION to do anything<KAIGYO>       else. And if if you are sure that your program using malloc has<KAIGYO>       no errors or vulnerabilities, you can define INSECURE to 1,<KAIGYO>       which might (or might not) provide a small performance improvement.<KAIGYO><KAIGYO>  Thread-safety: NOT thread-safe unless USE_LOCKS defined<KAIGYO>       When USE_LOCKS is defined, each public call to malloc, free,<KAIGYO>       etc is surrounded with either a pthread mutex or a win32<KAIGYO>       spinlock (depending on WIN32). This is not especially fast, and<KAIGYO>       can be a major bottleneck.  It is designed only to provide<KAIGYO>       minimal protection in concurrent environments, and to provide a<KAIGYO>       basis for extensions.  If you are using malloc in a concurrent<KAIGYO>       program, consider instead using nedmalloc<KAIGYO>       (httpwww.nedprod.com/programs/portable/nedmalloc/) or<KAIGYO>       ptmalloc (See httpwww.malloc.de), which are derived<KAIGYO>       from versions of this malloc.<KAIGYO><KAIGYO>  System requirements: Any combination of MORECORE and/or MMAP/MUNMAP<KAIGYO>       This malloc can use unix sbrk or any emulation (invoked using<KAIGYO>       the CALL_MORECORE macro) and/or mmap/munmap or any emulation<KAIGYO>       (invoked using CALL_MMAP/CALL_MUNMAP) to get and release system<KAIGYO>       memory.  On most unix systems, it tends to work best if both<KAIGYO>       MORECORE and MMAP are enabled.  On Win32, it uses emulations<KAIGYO>       based on VirtualAlloc. It also uses common C library functions<KAIGYO>       like memset.<KAIGYO><KAIGYO>  Compliance: I believe it is compliant with the Single Unix Specification<KAIGYO>       (See httpwww.unix.org). Also SVID/XPG, ANSI C, and probably<KAIGYO>       others as well.<KAIGYO><KAIGYO>* Overview of algorithms<KAIGYO><KAIGYO>  This is not the fastest, most space-conserving, most portable, or<KAIGYO>  most tunable malloc ever written. However it is among the fastest<KAIGYO>  while also being among the most space-conserving, portable and<KAIGYO>  tunable.  Consistent balance across these factors results in a good<KAIGYO>  general-purpose allocator for malloc-intensive programs.<KAIGYO><KAIGYO>  In most ways, this malloc is a best-fit allocator. Generally, it<KAIGYO>  chooses the best-fitting existing chunk for a request, with ties<KAIGYO>  broken in approximately least-recently-used order. (This strategy<KAIGYO>  normally maintains low fragmentation.) However, for requests less<KAIGYO>  than 256bytes, it deviates from best-fit when there is not an<KAIGYO>  exactly fitting available chunk by preferring to use space adjacent<KAIGYO>  to that used for the previous small request, as well as by breaking<KAIGYO>  ties in approximately most-recently-used order. (These enhance<KAIGYO>  locality of series of small allocations.)  And for very large requests<KAIGYO>  (>= 256Kb by default), it relies on system memory mapping<KAIGYO>  facilities, if supported.  (This helps avoid carrying around and<KAIGYO>  possibly fragmenting memory used only for large chunks.)<KAIGYO><KAIGYO>  All operations (except malloc_stats and mallinfo) have execution<KAIGYO>  times that are bounded by a constant factor of the number of bits in<KAIGYO>  a size_t, not counting any clearing in calloc or copying in realloc,<KAIGYO>  or actions surrounding MORECORE and MMAP that have times<KAIGYO>  proportional to the number of non-contiguous regions returned by<KAIGYO>  system allocation routines, which is often just 1. In real-time<KAIGYO>  applications, you can optionally suppress segment traversals using<KAIGYO>  NO_SEGMENT_TRAVERSAL, which assures bounded execution even when<KAIGYO>  system allocators return non-contiguous spaces, at the typical<KAIGYO>  expense of carrying around more memory and increased fragmentation.<KAIGYO><KAIGYO>  The implementation is not very modular and seriously overuses<KAIGYO>  macros. Perhaps someday all C compilers will do as good a job<KAIGYO>  inlining modular code as can now be done by brute-force expansion,<KAIGYO>  but now, enough of them seem not to.<KAIGYO><KAIGYO>  Some compilers issue a lot of warnings about code that is<KAIGYO>  dead/unreachable only on some platforms, and also about intentional<KAIGYO>  uses of negation on unsigned types. All known cases of each can be<KAIGYO>  ignored.<KAIGYO><KAIGYO>  For a longer but out of date high-level description, see<KAIGYO>     httpgee.cs.oswego.edu/dl/html/malloc.html<KAIGYO><KAIGYO>* MSPACES<KAIGYO>  If MSPACES is defined, then in addition to malloc, free, etc.,<KAIGYO>  this file also defines mspace_malloc, mspace_free, etc. These<KAIGYO>  are versions of malloc routines that take an """" argument<KAIGYO>  obtained using create_mspace, to control all internal bookkeeping.<KAIGYO>  If ONLY_MSPACES is defined, only these versions are compiled.<KAIGYO>  So if you would like to use this allocator for only some allocations,<KAIGYO>  and your system malloc for others, you can compile with<KAIGYO>  ONLY_MSPACES and then do something like...<KAIGYO>    static mspace mymspace = create_mspace(0,0); // for example<KAIGYO>    #define mymalloc(bytes)  mspace_malloc(mymspace, bytes)<KAIGYO><KAIGYO>  (Note: If you only need one instance of an mspace, you can instead<KAIGYO>  use """" to relabel the global malloc.)<KAIGYO><KAIGYO>  You can similarly create thread-local allocators by storing<KAIGYO>  mspaces as thread-locals. For example:<KAIGYO>    static __thread mspace tlms = 0;<KAIGYO>    void*  tlmalloc(size_t bytes) {<KAIGYO>      if (tlms == 0) tlms = create_mspace(0, 0);<KAIGYO>      return mspace_malloc(tlms, bytes);<KAIGYO>    }<KAIGYO>    void  tlfree(void* mem) { mspace_free(tlms, mem); }<KAIGYO><KAIGYO>  Unless FOOTERS is defined, each mspace is completely independent.<KAIGYO>  You cannot allocate from one and free to another (although<KAIGYO>  conformance is only weakly checked, so usage errors are not always<KAIGYO>  caught). If FOOTERS is defined, then each chunk carries around a tag<KAIGYO>  indicating its originating mspace, and frees are directed to their<KAIGYO>  originating spaces.<KAIGYO><KAIGYO> -------------------------  Compile-time options ---------------------------<KAIGYO><KAIGYO>Be careful in setting #define values for numerical constants of type<KAIGYO>size_t. On some systems, literal values are not automatically extended<KAIGYO>to size_t precision unless they are explicitly casted. You can also<KAIGYO>use the symbolic values MAX_SIZE_T, SIZE_T_ONE, etc below.<KAIGYO><KAIGYO>WIN32                    default: defined if _WIN32 defined<KAIGYO>  Defining WIN32 sets up defaults for MS environment and compilers.<KAIGYO>  Otherwise defaults are for unix.<KAIGYO><KAIGYO>MALLOC_ALIGNMENT         default: (size_t)8<KAIGYO>  Controls the minimum alignment for malloc\'ed chunks.  It must be a<KAIGYO>  power of two and at least 8, even on machines for which smaller<KAIGYO>  alignments would suffice. It may be defined as larger than this<KAIGYO>  though. Note however that code and data structures are optimized for<KAIGYO>  the case of 8-byte alignment.<KAIGYO><KAIGYO>MSPACES                  default: 0 (false)<KAIGYO>  If true, compile in support for independent allocation spaces.<KAIGYO>  This is only supported if HAVE_MMAP is true.<KAIGYO><KAIGYO>ONLY_MSPACES             default: 0 (false)<KAIGYO>  If true, only compile in mspace versions, not regular versions.<KAIGYO><KAIGYO>USE_LOCKS                default: 0 (false)<KAIGYO>  Causes each call to each public routine to be surrounded with<KAIGYO>  pthread or WIN32 mutex lock/unlock. (If set true, this can be<KAIGYO>  overridden on a per-mspace basis for mspace versions.) If set to a<KAIGYO>  non-zero value other than 1, locks are used, but their<KAIGYO>  implementation is left out, so lock functions must be supplied manually.<KAIGYO><KAIGYO>USE_SPIN_LOCKS           default: 1 iff USE_LOCKS and on x86 using gcc or MSC<KAIGYO>  If true, uses custom spin locks for locking. This is currently<KAIGYO>  supported only for x86 platforms using gcc or recent MS compilers.<KAIGYO>  Otherwise, posix locks or win32 critical sections are used.<KAIGYO><KAIGYO>FOOTERS                  default: 0<KAIGYO>  If true, provide extra checking and dispatching by placing<KAIGYO>  information in the footers of allocated chunks. This adds<KAIGYO>  space and time overhead.<KAIGYO><KAIGYO>INSECURE                 default: 0<KAIGYO>  If true, omit checks for usage errors and heap space overwrites.<KAIGYO><KAIGYO>USE_DL_PREFIX            default: NOT defined<KAIGYO>  Causes compiler to prefix all public routines with the string \'dl\'.<KAIGYO>  This can be useful when you only want to use this malloc in one part<KAIGYO>  of a program, using your regular system malloc elsewhere.<KAIGYO><KAIGYO>ABORT                    default: defined as abort()<KAIGYO>  Defines how to abort on failed checks.  On most systems, a failed<KAIGYO>  check cannot die with an """" or even print an informative<KAIGYO>  message, because the underlying print routines in turn call malloc,<KAIGYO>  which will fail again.  Generally, the best policy is to simply call<KAIGYO>  abort(). It\'s not very useful to do more than this because many<KAIGYO>  errors due to overwriting will show up as address faults (null, odd<KAIGYO>  addresses etc) rather than malloc-triggered checks, so will also<KAIGYO>  abort.  Also, most compilers know that abort() does not return, so<KAIGYO>  can better optimize code conditionally calling it.<KAIGYO><KAIGYO>PROCEED_ON_ERROR           default: defined as 0 (false)<KAIGYO>  Controls whether detected bad addresses cause them to bypassed<KAIGYO>  rather than aborting. If set, detected bad arguments to free and<KAIGYO>  realloc are ignored. And all bookkeeping information is zeroed out<KAIGYO>  upon a detected overwrite of freed heap space, thus losing the<KAIGYO>  ability to ever return it from malloc again, but enabling the<KAIGYO>  application to proceed. If PROCEED_ON_ERROR is defined, the<KAIGYO>  static variable malloc_corruption_error_count is compiled in<KAIGYO>  and can be examined to see if errors have occurred. This option<KAIGYO>  generates slower code than the default abort policy.<KAIGYO><KAIGYO>DEBUG                    default: NOT defined<KAIGYO>  The DEBUG setting is mainly intended for people trying to modify<KAIGYO>  this code or diagnose problems when porting to new platforms.<KAIGYO>  However, it may also be able to better isolate user errors than just<KAIGYO>  using runtime checks.  The assertions in the check routines spell<KAIGYO>  out in more detail the assumptions and invariants underlying the<KAIGYO>  algorithms.  The checking is fairly extensive, and will slow down<KAIGYO>  execution noticeably. Calling malloc_stats or mallinfo with DEBUG<KAIGYO>  set will attempt to check every non-mmapped allocated and free chunk<KAIGYO>  in the course of computing the summaries.<KAIGYO><KAIGYO>ABORT_ON_ASSERT_FAILURE   default: defined as 1 (true)<KAIGYO>  Debugging assertion failures can be nearly impossible if your<KAIGYO>  version of the assert macro causes malloc to be called, which will<KAIGYO>  lead to a cascade of further failures, blowing the runtime stack.<KAIGYO>  ABORT_ON_ASSERT_FAILURE cause assertions failures to call abort(),<KAIGYO>  which will usually make debugging easier.<KAIGYO><KAIGYO>MALLOC_FAILURE_ACTION     default: sets errno to ENOMEM, or no-op on win32<KAIGYO>  The action to take before """" when malloc fails to be able to<KAIGYO>  return memory because there is none available.<KAIGYO><KAIGYO>HAVE_MORECORE             default: 1 (true) unless win32 or ONLY_MSPACES<KAIGYO>  True if this system supports sbrk or an emulation of it.<KAIGYO><KAIGYO>MORECORE                  default: sbrk<KAIGYO>  The name of the sbrk-style system routine to call to obtain more<KAIGYO>  memory.  See below for guidance on writing custom MORECORE<KAIGYO>  functions. The type of the argument to sbrk/MORECORE varies across<KAIGYO>  systems.  It cannot be size_t, because it supports negative<KAIGYO>  arguments, so it is normally the signed type of the same width as<KAIGYO>  size_t (sometimes declared as """").  It doesn\'t much matter<KAIGYO>  though. Internally, we only call it with arguments less than half<KAIGYO>  the max value of a size_t, which should work across all reasonable<KAIGYO>  possibilities, although sometimes generating compiler warnings.  See<KAIGYO>  near the end of this file for guidelines for creating a custom<KAIGYO>  version of MORECORE.<KAIGYO><KAIGYO>MORECORE_CONTIGUOUS       default: 1 (true) if HAVE_MORECORE<KAIGYO>  If true, take advantage of fact that consecutive calls to MORECORE<KAIGYO>  with positive arguments always return contiguous increasing<KAIGYO>  addresses.  This is true of unix sbrk. It does not hurt too much to<KAIGYO>  set it true anyway, since malloc copes with non-contiguities.<KAIGYO>  Setting it false when definitely non-contiguous saves time<KAIGYO>  and possibly wasted space it would take to discover this though.<KAIGYO><KAIGYO>MORECORE_CANNOT_TRIM      default: NOT defined<KAIGYO>  True if MORECORE cannot release space back to the system when given<KAIGYO>  negative arguments. This is generally necessary only if you are<KAIGYO>  using a hand-crafted MORECORE function that cannot handle negative<KAIGYO>  arguments.<KAIGYO><KAIGYO>NO_SEGMENT_TRAVERSAL       default: 0<KAIGYO>  If non-zero, suppresses traversals of memory segments<KAIGYO>  returned by either MORECORE or CALL_MMAP. This disables<KAIGYO>  merging of segments that are contiguous, and selectively<KAIGYO>  releasing them to the OS if unused, but bounds execution times.<KAIGYO><KAIGYO>HAVE_MMAP                 default: 1 (true)<KAIGYO>  True if this system supports mmap or an emulation of it.  If so, and<KAIGYO>  HAVE_MORECORE is not true, MMAP is used for all system<KAIGYO>  allocation. If set and HAVE_MORECORE is true as well, MMAP is<KAIGYO>  primarily used to directly allocate very large blocks. It is also<KAIGYO>  used as a backup strategy in cases where MORECORE fails to provide<KAIGYO>  space from system. Note: A single call to MUNMAP is assumed to be<KAIGYO>  able to unmap memory that may have be allocated using multiple calls<KAIGYO>  to MMAP, so long as they are adjacent.<KAIGYO><KAIGYO>HAVE_MREMAP               default: 1 on linux, else 0<KAIGYO>  If true realloc() uses mremap() to re-allocate large blocks and<KAIGYO>  extend or shrink allocation spaces.<KAIGYO><KAIGYO>MMAP_CLEARS               default: 1 except on WINCE.<KAIGYO>  True if mmap clears memory so calloc doesn\'t need to. This is true<KAIGYO>  for standard unix mmap using /dev/zero and on WIN32 except for WINCE.<KAIGYO><KAIGYO>USE_BUILTIN_FFS            default: 0 (i.e., not used)<KAIGYO>  Causes malloc to use the builtin ffs() function to compute indices.<KAIGYO>  Some compilers may recognize and intrinsify ffs to be faster than the<KAIGYO>  supplied C version. Also, the case of x86 using gcc is special-cased<KAIGYO>  to an asm instruction, so is already as fast as it can be, and so<KAIGYO>  this setting has no effect. Similarly for Win32 under recent MS compilers.<KAIGYO>  (On most x86s, the asm version is only slightly faster than the C version.)<KAIGYO><KAIGYO>malloc_getpagesize         default: derive from system includes, or 4096.<KAIGYO>  The system page size. To the extent possible, this malloc manages<KAIGYO>  memory from the system in page-size units.  This may be (and<KAIGYO>  usually is) a function rather than a constant. This is ignored<KAIGYO>  if WIN32, where page size is determined using getSystemInfo during<KAIGYO>  initialization.<KAIGYO><KAIGYO>USE_DEV_RANDOM             default: 0 (i.e., not used)<KAIGYO>  Causes malloc to use /dev/random to initialize secure magic seed for<KAIGYO>  stamping footers. Otherwise, the current time is used.<KAIGYO><KAIGYO>NO_MALLINFO                default: 0<KAIGYO>  If defined, don\'t compile """". This can be a simple way<KAIGYO>  of dealing with mismatches between system declarations and<KAIGYO>  those in this file.<KAIGYO><KAIGYO>MALLINFO_FIELD_TYPE        default: size_t<KAIGYO>  The type of the fields in the mallinfo struct. This was originally<KAIGYO>  defined as """" in SVID etc, but is more usefully defined as<KAIGYO>  size_t. The value is used only if  HAVE_USR_INCLUDE_MALLOC_H is not set<KAIGYO><KAIGYO>REALLOC_ZERO_BYTES_FREES    default: not defined<KAIGYO>  This should be set if a call to realloc with zero bytes should<KAIGYO>  be the same as a call to free. Some people think it should. Otherwise,<KAIGYO>  since this malloc returns a unique pointer for malloc(0), so does<KAIGYO>  realloc(p, 0).<KAIGYO><KAIGYO>LACKS_UNISTD_H, LACKS_FCNTL_H, LACKS_SYS_PARAM_H, LACKS_SYS_MMAN_H<KAIGYO>LACKS_STRINGS_H, LACKS_STRING_H, LACKS_SYS_TYPES_H,  LACKS_ERRNO_H<KAIGYO>LACKS_STDLIB_H                default: NOT defined unless on WIN32<KAIGYO>  Define these if your system does not have these header files.<KAIGYO>  You might need to manually insert some of the declarations they provide.<KAIGYO><KAIGYO>DEFAULT_GRANULARITY        default: page size if MORECORE_CONTIGUOUS,<KAIGYO>                                system_info.dwAllocationGranularity in WIN32,<KAIGYO>                                otherwise 64K.<KAIGYO>      Also settable using mallopt(M_GRANULARITY, x)<KAIGYO>  The unit for allocating and deallocating memory from the system.  On<KAIGYO>  most systems with contiguous MORECORE, there is no reason to<KAIGYO>  make this more than a page. However, systems with MMAP tend to<KAIGYO>  either require or encourage larger granularities.  You can increase<KAIGYO>  this value to prevent system allocation functions to be called so<KAIGYO>  often, especially if they are slow.  The value must be at least one<KAIGYO>  page and must be a power of two.  Setting to 0 causes initialization<KAIGYO>  to either page size or win32 region size.  (Note: In previous<KAIGYO>  versions of malloc, the equivalent of this option was called<KAIGYO>  """")<KAIGYO><KAIGYO>DEFAULT_TRIM_THRESHOLD    default: 2MB<KAIGYO>      Also settable using mallopt(M_TRIM_THRESHOLD, x)<KAIGYO>  The maximum amount of unused top-most memory to keep before<KAIGYO>  releasing via malloc_trim in free().  Automatic trimming is mainly<KAIGYO>  useful in long-lived programs using contiguous MORECORE.  Because<KAIGYO>  trimming via sbrk can be slow on some systems, and can sometimes be<KAIGYO>  wasteful (in cases where programs immediately afterward allocate<KAIGYO>  more large chunks) the value should be high enough so that your<KAIGYO>  overall system performance would improve by releasing this much<KAIGYO>  memory.  As a rough guide, you might set to a value close to the<KAIGYO>  average size of a process (program) running on your system.<KAIGYO>  Releasing this much memory would allow such a process to run in<KAIGYO>  memory.  Generally, it is worth tuning trim thresholds when a<KAIGYO>  program undergoes phases where several large chunks are allocated<KAIGYO>  and released in ways that can reuse each other\'s storage, perhaps<KAIGYO>  mixed with phases where there are no such chunks at all. The trim<KAIGYO>  value must be greater than page size to have any useful effect.  To<KAIGYO>  disable trimming completely, you can set to MAX_SIZE_T. Note that the trick<KAIGYO>  some people use of mallocing a huge space and then freeing it at<KAIGYO>  program startup, in an attempt to reserve system memory, doesn\'t<KAIGYO>  have the intended effect under automatic trimming, since that memory<KAIGYO>  will immediately be returned to the system.<KAIGYO><KAIGYO>DEFAULT_MMAP_THRESHOLD       default: 256K<KAIGYO>      Also settable using mallopt(M_MMAP_THRESHOLD, x)<KAIGYO>  The request size threshold for using MMAP to directly service a<KAIGYO>  request. Requests of at least this size that cannot be allocated<KAIGYO>  using already-existing space will be serviced via mmap.  (If enough<KAIGYO>  normal freed space already exists it is used instead.)  Using mmap<KAIGYO>  segregates relatively large chunks of memory so that they can be<KAIGYO>  individually obtained and released from the host system. A request<KAIGYO>  serviced through mmap is never reused by any other request (at least<KAIGYO>  not directly; the system may just so happen to remap successive<KAIGYO>  requests to the same locations).  Segregating space in this way has<KAIGYO>  the benefits that: Mmapped space can always be individually released<KAIGYO>  back to the system, which helps keep the system level memory demands<KAIGYO>  of a long-lived program low.  Also, mapped memory doesn\'t become<KAIGYO>  `locked\' between other chunks, as can happen with normally allocated<KAIGYO>  chunks, which means that even trimming via malloc_trim would not<KAIGYO>  release them.  However, it has the disadvantage that the space<KAIGYO>  cannot be reclaimed, consolidated, and then used to service later<KAIGYO>  requests, as happens with normal chunks.  The advantages of mmap<KAIGYO>  nearly always outweigh disadvantages for """" chunks, but the<KAIGYO>  value of """" may vary across systems.  The default is an<KAIGYO>  empirically derived value that works well in most systems. You can<KAIGYO>  disable mmap by setting to MAX_SIZE_T.<KAIGYO><KAIGYO>MAX_RELEASE_CHECK_RATE   default: 255 unless not HAVE_MMAP<KAIGYO>  The number of consolidated frees between checks to release<KAIGYO>  unused segments when freeing. When using non-contiguous segments,<KAIGYO>  especially with multiple mspaces, checking only for topmost space<KAIGYO>  doesn\'t always suffice to trigger trimming. To compensate for this,<KAIGYO>  free() will, with a period of MAX_RELEASE_CHECK_RATE (or the<KAIGYO>  current number of segments, if greater) try to release unused<KAIGYO>  segments to the OS when freeing chunks that result in<KAIGYO>  consolidation. The best value for this parameter is a compromise<KAIGYO>  between slowing down frees with relatively costly checks that<KAIGYO>  rarely trigger versus holding on to unused memory. To effectively<KAIGYO>  disable, set to MAX_SIZE_T. This may lead to a very slight speed<KAIGYO>  improvement at the expense of carrying around more memory.<KAIGYO>*/': 1, '#endif  /* WIN32 */<KAIGYO><KAIGYO>#if defined(DARWIN) || defined(_DARWIN)<KAIGYO>/* Mac OSX docs advise not to use sbrk; it seems better to use mmap */': 1, '#endif /* USE_DL_PREFIX */<KAIGYO><KAIGYO><KAIGYO>/*<KAIGYO>  malloc(size_t n)<KAIGYO>  Returns a pointer to a newly allocated chunk of at least n bytes, or<KAIGYO>  null if no space is available, in which case errno is set to ENOMEM<KAIGYO>  on ANSI C systems.<KAIGYO><KAIGYO>  If n is zero, malloc returns a minimum-sized chunk. (The minimum<KAIGYO>  size is 16 bytes on most 32bit systems, and 32 bytes on 64bit<KAIGYO>  systems.)  Note that size_t is an unsigned type, so calls with<KAIGYO>  arguments that would be negative if signed are interpreted as<KAIGYO>  requests for huge amounts of space, which will often fail. The<KAIGYO>  maximum supported value of n differs across systems, but is in all<KAIGYO>  cases less than the maximum representable value of a size_t.<KAIGYO>*/': 1, ""/*<KAIGYO>  malloc_trim(size_t pad);<KAIGYO><KAIGYO>  If possible, gives memory back to the system (via negative arguments<KAIGYO>  to sbrk) if there is unused memory at the `high' end of the malloc<KAIGYO>  pool or in unused MMAP segments. You can call this after freeing<KAIGYO>  large blocks of memory to potentially reduce the system-level memory<KAIGYO>  requirements of a program. However, it cannot guarantee to reduce<KAIGYO>  memory. Under some allocation patterns, some large free blocks of<KAIGYO>  memory will be locked between two used chunks, so they cannot be<KAIGYO>  given back to the system.<KAIGYO><KAIGYO>  The `pad' argument to malloc_trim represents the amount of free<KAIGYO>  trailing space to leave untrimmed. If this argument is zero, only<KAIGYO>  the minimum amount of memory to maintain internal data structures<KAIGYO>  will be left. Non-zero arguments can be supplied to maintain enough<KAIGYO>  trailing space to service future expected allocations without having<KAIGYO>  to re-obtain memory from the system.<KAIGYO><KAIGYO>  Malloc_trim returns 1 if it actually released any memory, else 0.<KAIGYO>*/"": 1, '/* -----------------------  Chunk representations ------------------------ */<KAIGYO><KAIGYO>/*<KAIGYO>  (The following includes lightly edited explanations by Colin Plumb.)<KAIGYO><KAIGYO>  The malloc_chunk declaration below is misleading (but accurate and<KAIGYO>  necessary).  It declares a """" into memory allowing access to<KAIGYO>  necessary fields at known offsets from a given base.<KAIGYO><KAIGYO>  Chunks of memory are maintained using a `boundary tag\' method as<KAIGYO>  originally described by Knuth.  (See the paper by Paul Wilson<KAIGYO>  ftpftp.cs.utexas.edu/pub/garbage/allocsrv.ps for a survey of such<KAIGYO>  techniques.)  Sizes of free chunks are stored both in the front of<KAIGYO>  each chunk and at the end.  This makes consolidating fragmented<KAIGYO>  chunks into bigger chunks fast.  The head fields also hold bits<KAIGYO>  representing whether chunks are free or in use.<KAIGYO><KAIGYO>  Here are some pictures to make it clearer.  They are """" to<KAIGYO>  show that the state of a chunk can be thought of as extending from<KAIGYO>  the high 31 bits of the head field of its header through the<KAIGYO>  prev_foot and PINUSE_BIT bit of the following chunk header.<KAIGYO><KAIGYO>  A chunk that\'s in use looks like:<KAIGYO><KAIGYO>   chunk-> +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+<KAIGYO>           | Size of previous chunk (if P = 1)                             |<KAIGYO>           +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+<KAIGYO>         +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ |P|<KAIGYO>         | Size of this chunk                                         1| +-+<KAIGYO>   mem-> +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+<KAIGYO>         |                                                               |<KAIGYO>         +-                                                             -+<KAIGYO>         |                                                               |<KAIGYO>         +-                                                             -+<KAIGYO>         |                                                               :<KAIGYO>         +-      size - sizeof(size_t) available payload bytes          -+<KAIGYO>         :                                                               |<KAIGYO> chunk-> +-                                                             -+<KAIGYO>         |                                                               |<KAIGYO>         +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+<KAIGYO>       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ |1|<KAIGYO>       | Size of next chunk (may or may not be in use)               | +-+<KAIGYO> mem-> +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+<KAIGYO><KAIGYO>    And if it\'s free, it looks like this:<KAIGYO><KAIGYO>   chunk-> +-                                                             -+<KAIGYO>           | User payload (must be in use, or we would have merged!)       |<KAIGYO>           +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+<KAIGYO>         +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ |P|<KAIGYO>         | Size of this chunk                                         0| +-+<KAIGYO>   mem-> +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+<KAIGYO>         | Next pointer                                                  |<KAIGYO>         +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+<KAIGYO>         | Prev pointer                                                  |<KAIGYO>         +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+<KAIGYO>         |                                                               :<KAIGYO>         +-      size - sizeof(struct chunk) unused bytes               -+<KAIGYO>         :                                                               |<KAIGYO> chunk-> +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+<KAIGYO>         | Size of this chunk                                            |<KAIGYO>         +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+<KAIGYO>       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ |0|<KAIGYO>       | Size of next chunk (must be in use, or we would have merged)| +-+<KAIGYO> mem-> +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+<KAIGYO>       |                                                               :<KAIGYO>       +- User payload                                                -+<KAIGYO>       :                                                               |<KAIGYO>       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+<KAIGYO>                                                                     |0|<KAIGYO>                                                                     +-+<KAIGYO>  Note that since we always merge adjacent free chunks, the chunks<KAIGYO>  adjacent to a free chunk must be in use.<KAIGYO><KAIGYO>  Given a pointer to a chunk (which can be derived trivially from the<KAIGYO>  payload pointer) we can, in O(1) time, find out whether the adjacent<KAIGYO>  chunks are free, and if so, unlink them from the lists that they<KAIGYO>  are on and merge them with the current chunk.<KAIGYO><KAIGYO>  Chunks always begin on even word boundaries, so the mem portion<KAIGYO>  (which is returned to the user) is also on an even word boundary, and<KAIGYO>  thus at least double-word aligned.<KAIGYO><KAIGYO>  The P (PINUSE_BIT) bit, stored in the unused low-order bit of the<KAIGYO>  chunk size (which is always a multiple of two words), is an in-use<KAIGYO>  bit for the *previous* chunk.  If that bit is *clear*, then the<KAIGYO>  word before the current chunk size contains the previous chunk<KAIGYO>  size, and can be used to find the front of the previous chunk.<KAIGYO>  The very first chunk allocated always has this bit set, preventing<KAIGYO>  access to non-existent (or non-owned) memory. If pinuse is set for<KAIGYO>  any given chunk, then you CANNOT determine the size of the<KAIGYO>  previous chunk, and might even get a memory addressing fault when<KAIGYO>  trying to do so.<KAIGYO><KAIGYO>  The C (CINUSE_BIT) bit, stored in the unused second-lowest bit of<KAIGYO>  the chunk size redundantly records whether the current chunk is<KAIGYO>  inuse. This redundancy enables usage checks within free and realloc,<KAIGYO>  and reduces indirection when freeing and consolidating chunks.<KAIGYO><KAIGYO>  Each freshly allocated chunk must have both cinuse and pinuse set.<KAIGYO>  That is, each allocated chunk borders either a previously allocated<KAIGYO>  and still in-use chunk, or the base of its memory arena. This is<KAIGYO>  ensured by making all allocations from the the `lowest\' part of any<KAIGYO>  found chunk.  Further, no free chunk physically borders another one,<KAIGYO>  so each free chunk is known to be preceded and followed by either<KAIGYO>  inuse chunks or the ends of memory.<KAIGYO><KAIGYO>  Note that the `foot\' of the current chunk is actually represented<KAIGYO>  as the prev_foot of the NEXT chunk. This makes it easier to<KAIGYO>  deal with alignments etc but can be very confusing when trying<KAIGYO>  to extend or adapt this code.<KAIGYO><KAIGYO>  The exceptions to all this are<KAIGYO><KAIGYO>     1. The special chunk `top\' is the top-most available chunk (i.e.,<KAIGYO>        the one bordering the end of available memory). It is treated<KAIGYO>        specially.  Top is never included in any bin, is used only if<KAIGYO>        no other chunk is available, and is released back to the<KAIGYO>        system if it is very large (see M_TRIM_THRESHOLD).  In effect,<KAIGYO>        the top chunk is treated as larger (and thus less well<KAIGYO>        fitting) than any other available chunk.  The top chunk<KAIGYO>        doesn\'t update its trailing size field since there is no next<KAIGYO>        contiguous chunk that would have to index off it. However,<KAIGYO>        space is still allocated for it (TOP_FOOT_SIZE) to enable<KAIGYO>        separation or merging when space is extended.<KAIGYO><KAIGYO>     3. Chunks allocated via mmap, which have the lowest-order bit<KAIGYO>        (IS_MMAPPED_BIT) set in their prev_foot fields, and do not set<KAIGYO>        PINUSE_BIT in their head fields.  Because they are allocated<KAIGYO>        one-by-one, each must carry its own prev_foot field, which is<KAIGYO>        also used to hold the offset this chunk has within its mmapped<KAIGYO>        region, which is needed to preserve alignment. Each mmapped<KAIGYO>        chunk is trailed by the first two fields of a fake next-chunk<KAIGYO>        for sake of usage checks.<KAIGYO><KAIGYO>*/': 1, '/* ---------------------- Overlaid data structures ----------------------- */<KAIGYO><KAIGYO>/*<KAIGYO>  When chunks are not in use, they are treated as nodes of either<KAIGYO>  lists or trees.<KAIGYO><KAIGYO>  """"  chunks are stored in circular doubly-linked lists, and look<KAIGYO>  like this:<KAIGYO><KAIGYO>    chunk-> +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+<KAIGYO>            |             Size of previous chunk                            |<KAIGYO>            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+<KAIGYO>    `head:\' |             Size of chunk, in bytes                         |P|<KAIGYO>      mem-> +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+<KAIGYO>            |             Forward pointer to next chunk in list             |<KAIGYO>            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+<KAIGYO>            |             Back pointer to previous chunk in list            |<KAIGYO>            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+<KAIGYO>            |             Unused space (may be 0 bytes long)                .<KAIGYO>            .                                                               .<KAIGYO>            .                                                               |<KAIGYO>nextchunk-> +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+<KAIGYO>    `foot:\' |             Size of chunk, in bytes                           |<KAIGYO>            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+<KAIGYO><KAIGYO>  Larger chunks are kept in a form of bitwise digital trees (aka<KAIGYO>  tries) keyed on chunksizes.  Because malloc_tree_chunks are only for<KAIGYO>  free chunks greater than 256 bytes, their size doesn\'t impose any<KAIGYO>  constraints on user chunk sizes.  Each node looks like:<KAIGYO><KAIGYO>    chunk-> +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+<KAIGYO>            |             Size of previous chunk                            |<KAIGYO>            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+<KAIGYO>    `head:\' |             Size of chunk, in bytes                         |P|<KAIGYO>      mem-> +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+<KAIGYO>            |             Forward pointer to next chunk of same size        |<KAIGYO>            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+<KAIGYO>            |             Back pointer to previous chunk of same size       |<KAIGYO>            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+<KAIGYO>            |             Pointer to left child (child[0])                  |<KAIGYO>            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+<KAIGYO>            |             Pointer to right child (child[1])                 |<KAIGYO>            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+<KAIGYO>            |             Pointer to parent                                 |<KAIGYO>            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+<KAIGYO>            |             bin index of this chunk                           |<KAIGYO>            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+<KAIGYO>            |             Unused space                                      .<KAIGYO>            .                                                               |<KAIGYO>nextchunk-> +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+<KAIGYO>    `foot:\' |             Size of chunk, in bytes                           |<KAIGYO>            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+<KAIGYO><KAIGYO>  Each tree holding treenodes is a tree of unique chunk sizes.  Chunks<KAIGYO>  of the same size are arranged in a circularly-linked list, with only<KAIGYO>  the oldest chunk (the next to be used, in our FIFO ordering)<KAIGYO>  actually in the tree.  (Tree members are distinguished by a non-null<KAIGYO>  parent pointer.)  If a chunk with the same size an an existing node<KAIGYO>  is inserted, it is linked off the existing node using pointers that<KAIGYO>  work in the same way as fd/bk pointers of small chunks.<KAIGYO><KAIGYO>  Each tree contains a power of 2 sized range of chunk sizes (the<KAIGYO>  smallest is 0x100 <= x < 0x180), which is is divided in half at each<KAIGYO>  tree level, with the chunks in the smaller half of the range (0x100<KAIGYO>  <= x < 0x140 for the top nose) in the left subtree and the larger<KAIGYO>  half (0x140 <= x < 0x180) in the right subtree.  This is, of course,<KAIGYO>  done by inspecting individual bits.<KAIGYO><KAIGYO>  Using these rules, each node\'s left subtree contains all smaller<KAIGYO>  sizes than its right subtree.  However, the node at the root of each<KAIGYO>  subtree has no particular ordering relationship to either.  (The<KAIGYO>  dividing line between the subtree sizes is based on trie relation.)<KAIGYO>  If we remove the last chunk of a given size from the interior of the<KAIGYO>  tree, we need to replace it with a leaf node.  The tree ordering<KAIGYO>  rules permit a node to be replaced by any leaf below it.<KAIGYO><KAIGYO>  The smallest chunk in a tree (a common operation in a best-fit<KAIGYO>  allocator) can be found by walking a path to the leftmost leaf in<KAIGYO>  the tree.  Unlike a usual binary tree, where we follow left child<KAIGYO>  pointers until we reach a null, here we follow the right child<KAIGYO>  pointer any time the left one is null, until we reach a leaf with<KAIGYO>  both child pointers null. The smallest chunk in the tree will be<KAIGYO>  somewhere along that path.<KAIGYO><KAIGYO>  The worst case number of steps to add, find, or remove a node is<KAIGYO>  bounded by the number of bits differentiating chunks within<KAIGYO>  bins. Under current bin calculations, this ranges from 6 up to 21<KAIGYO>  (for 32 bit sizes) or up to 53 (for 64 bit sizes). The typical case<KAIGYO>  is of course much better.<KAIGYO>*/': 1, ""/*<KAIGYO>  Each malloc space may include non-contiguous segments, held in a<KAIGYO>  list headed by an embedded malloc_segment record representing the<KAIGYO>  top-most space. Segments also include flags holding properties of<KAIGYO>  the space. Large chunks that are directly allocated by mmap are not<KAIGYO>  included in this list. They are instead independently created and<KAIGYO>  destroyed without otherwise keeping track of them.<KAIGYO><KAIGYO>  Segment management mainly comes into play for spaces allocated by<KAIGYO>  MMAP.  Any call to MMAP might or might not return memory that is<KAIGYO>  adjacent to an existing segment.  MORECORE normally contiguously<KAIGYO>  extends the current space, so this space is almost always adjacent,<KAIGYO>  which is simpler and faster to deal with. (This is why MORECORE is<KAIGYO>  used preferentially to MMAP when both are available -- see<KAIGYO>  sys_alloc.)  When allocating using MMAP, we don't use any of the<KAIGYO>  hinting mechanisms (inconsistently) supported in various<KAIGYO>  implementations of unix mmap, or distinguish reserving from<KAIGYO>  committing memory. Instead, we just ask for space, and exploit<KAIGYO>  contiguity when we get it.  It is probably possible to do<KAIGYO>  better than this on some systems, but no general scheme seems<KAIGYO>  to be significantly better.<KAIGYO><KAIGYO>  Management entails a simpler variant of the consolidation scheme<KAIGYO>  used for chunks to reduce fragmentation -- new adjacent memory is<KAIGYO>  normally prepended or appended to an existing segment. However,<KAIGYO>  there are limitations compared to chunk consolidation that mostly<KAIGYO>  reflect the fact that segment processing is relatively infrequent<KAIGYO>  (occurring only when getting memory from system) and that we<KAIGYO>  don't expect to have huge numbers of segments:<KAIGYO><KAIGYO>  * Segments are not indexed, so traversal requires linear scans.  (It<KAIGYO>    would be possible to index these, but is not worth the extra<KAIGYO>    overhead and complexity for most programs on most platforms.)<KAIGYO>  * New segments are only appended to old ones when holding top-most<KAIGYO>    memory; if they cannot be prepended to others, they are held in<KAIGYO>    different segments.<KAIGYO><KAIGYO>  Except for the top-most segment of an mstate, each segment record<KAIGYO>  is kept at the tail of its segment. Segments are added by pushing<KAIGYO>  segment records onto the list headed by &mstate.seg for the<KAIGYO>  containing mstate.<KAIGYO><KAIGYO>  Segment flags control allocation/merge/deallocation policies:<KAIGYO>  * If EXTERN_BIT set, then we did not allocate this segment,<KAIGYO>    and so should not try to deallocate or merge with others.<KAIGYO>    (This currently holds only for the initial segment passed<KAIGYO>    into create_mspace_with_base.)<KAIGYO>  * If IS_MMAPPED_BIT set, the segment may be merged with<KAIGYO>    other surrounding mmapped segments and trimmed/de-allocated<KAIGYO>    using munmap.<KAIGYO>  * If neither bit is set, then the segment was obtained using<KAIGYO>    MORECORE so can be merged with surrounding MORECORE'd segments<KAIGYO>    and deallocated/trimmed using MORECORE with negative arguments.<KAIGYO>*/"": 1, '/* ---------------------------- malloc_state ----------------------------- */<KAIGYO><KAIGYO>/*<KAIGYO>   A malloc_state holds all of the bookkeeping for a space.<KAIGYO>   The main fields are:<KAIGYO><KAIGYO>  Top<KAIGYO>    The topmost chunk of the currently active segment. Its size is<KAIGYO>    cached in topsize.  The actual size of topmost space is<KAIGYO>    topsize+TOP_FOOT_SIZE, which includes space reserved for adding<KAIGYO>    fenceposts and segment records if necessary when getting more<KAIGYO>    space from the system.  The size at which to autotrim top is<KAIGYO>    cached from mparams in trim_check, except that it is disabled if<KAIGYO>    an autotrim fails.<KAIGYO><KAIGYO>  Designated victim (dv)<KAIGYO>    This is the preferred chunk for servicing small requests that<KAIGYO>    don\'t have exact fits.  It is normally the chunk split off most<KAIGYO>    recently to service another small request.  Its size is cached in<KAIGYO>    dvsize. The link fields of this chunk are not maintained since it<KAIGYO>    is not kept in a bin.<KAIGYO><KAIGYO>  SmallBins<KAIGYO>    An array of bin headers for free chunks.  These bins hold chunks<KAIGYO>    with sizes less than MIN_LARGE_SIZE bytes. Each bin contains<KAIGYO>    chunks of all the same size, spaced 8 bytes apart.  To simplify<KAIGYO>    use in double-linked lists, each bin header acts as a malloc_chunk<KAIGYO>    pointing to the real first node, if it exists (else pointing to<KAIGYO>    itself).  This avoids special-casing for headers.  But to avoid<KAIGYO>    waste, we allocate only the fd/bk pointers of bins, and then use<KAIGYO>    repositioning tricks to treat these as the fields of a chunk.<KAIGYO><KAIGYO>  TreeBins<KAIGYO>    Treebins are pointers to the roots of trees holding a range of<KAIGYO>    sizes. There are 2 equally spaced treebins for each power of two<KAIGYO>    from TREE_SHIFT to TREE_SHIFT+16. The last bin holds anything<KAIGYO>    larger.<KAIGYO><KAIGYO>  Bin maps<KAIGYO>    There is one bit map for small bins ("""") and one for<KAIGYO>    treebins (""treemap).  Each bin sets its bit when non-empty, and<KAIGYO>    clears the bit when empty.  Bit operations are then used to avoid<KAIGYO>    bin-by-bin searching -- nearly all """" is done without ever<KAIGYO>    looking at bins that won\'t be selected.  The bit maps<KAIGYO>    conservatively use 32 bits per map word, even if on 64bit system.<KAIGYO>    For a good description of some of the bit-based techniques used<KAIGYO>    here, see Henry S. Warren Jr\'s book """" (and<KAIGYO>    supplement at httphackersdelight.org/). Many of these are<KAIGYO>    intended to reduce the branchiness of paths through malloc etc, as<KAIGYO>    well as to reduce the number of memory locations read or written.<KAIGYO><KAIGYO>  Segments<KAIGYO>    A list of segments headed by an embedded malloc_segment record<KAIGYO>    representing the initial space.<KAIGYO><KAIGYO>  Address check support<KAIGYO>    The least_addr field is the least address ever obtained from<KAIGYO>    MORECORE or MMAP. Attempted frees and reallocs of any address less<KAIGYO>    than this are trapped (unless INSECURE is defined).<KAIGYO><KAIGYO>  Magic tag<KAIGYO>    A cross-check field that should always hold same value as mparams.magic.<KAIGYO><KAIGYO>  Flags<KAIGYO>    Bits recording whether to use MMAP, locks, or contiguous MORECORE<KAIGYO><KAIGYO>  Statistics<KAIGYO>    Each space keeps track of current and maximum system memory<KAIGYO>    obtained via MORECORE or MMAP.<KAIGYO><KAIGYO>  Trim support<KAIGYO>    Fields holding the amount of unused topmost memory that should trigger<KAIGYO>    timming, and a counter to force periodic scanning to release unused<KAIGYO>    non-topmost segments.<KAIGYO><KAIGYO>  Locking<KAIGYO>    If USE_LOCKS is defined, the """" lock is acquired and released<KAIGYO>    around every public call using this mspace.<KAIGYO><KAIGYO>  Extension support<KAIGYO>    A void* pointer and a size_t field that can be used to help implement<KAIGYO>    extensions to this malloc.<KAIGYO>*/': 1, '/* Bit representing maximum resolved size in a treebin at i */<KAIGYO>#define bit_for_tree_index(i) \\<KAIGYO>   (i == NTREEBINS-1)? (SIZE_T_BITSIZE-1) : (((i) >> 1) + TREEBIN_SHIFT - 2)<KAIGYO><KAIGYO>/* Shift placing maximum resolved bit in a treebin at i as sign bit */': 1, '      s &= ~(size_t)7U;   /* improve chances of fault for bad values */<KAIGYO><KAIGYO>    }<KAIGYO>#else /* (FOOTERS && !INSECURE) */': 1, '/* ----------------------- Operations on smallbins ----------------------- */<KAIGYO><KAIGYO>/*<KAIGYO>  Various forms of linking and unlinking are defined as macros.  Even<KAIGYO>  the ones for trees, which are very long but have very short typical<KAIGYO>  paths.  This is ugly but reduces reliance on inlining support of<KAIGYO>  compilers.<KAIGYO>*/': 1, '    /* Unmap any unused mmapped segments */<KAIGYO>    if (HAVE_MMAP)<KAIGYO>      released += release_unused_segments(m);<KAIGYO><KAIGYO>    /* On failure, disable autotrim to avoid repeated failed future calls */': 1, '  /*  If dv is a better fit, return 0 so malloc will use it */<KAIGYO>  if (v != 0 && rsize < (size_t)(m->dvsize - nb)) {<KAIGYO>    if (RTCHECK(ok_address(m, v))) { /* split */': 1, '    /* Try to either shrink or extend into top. Else malloc-copy-free */<KAIGYO><KAIGYO>    if (RTCHECK(ok_address(m, oldp) && ok_cinuse(oldp) &&<KAIGYO>                ok_next(oldp, next) && ok_pinuse(next))) {<KAIGYO>      size_t nb = request2size(bytes);<KAIGYO>      if (is_mmapped(oldp))<KAIGYO>        newp = mmap_resize(m, oldp, nb);<KAIGYO>      else if (oldsize >= nb) { /* already big enough */': 1, ""/* -------------------------- public routines ---------------------------- */<KAIGYO><KAIGYO>#if !ONLY_MSPACES<KAIGYO><KAIGYO>void* dlmalloc(size_t bytes) {<KAIGYO>  /*<KAIGYO>     Basic algorithm:<KAIGYO>     If a small request (< 256 bytes minus per-chunk overhead):<KAIGYO>       1. If one exists, use a remainderless chunk in associated smallbin.<KAIGYO>          (Remainderless means that there are too few excess bytes to<KAIGYO>          represent as a chunk.)<KAIGYO>       2. If it is big enough, use the dv chunk, which is normally the<KAIGYO>          chunk adjacent to the one used for the most recent small request.<KAIGYO>       3. If one exists, split the smallest available chunk in a bin,<KAIGYO>          saving remainder in dv.<KAIGYO>       4. If it is big enough, use the top chunk.<KAIGYO>       5. If available, get memory from system and use it<KAIGYO>     Otherwise, for a large request:<KAIGYO>       1. Find the smallest available binned chunk that fits, and use it<KAIGYO>          if it is better fitting than dv chunk, splitting if necessary.<KAIGYO>       2. If better fitting than any binned chunk, use the dv chunk.<KAIGYO>       3. If it is big enough, use the top chunk.<KAIGYO>       4. If request size >= mmap threshold, try to directly mmap this chunk.<KAIGYO>       5. If available, get memory from system and use it<KAIGYO><KAIGYO>     The ugly goto's here ensure that postaction occurs along all paths.<KAIGYO>  */"": 1, '      else { /* exhaust dv */<KAIGYO>        size_t dvs = gm->dvsize;<KAIGYO>        gm->dvsize = 0;<KAIGYO>        gm->dv = 0;<KAIGYO>        set_inuse_and_pinuse(gm, p, dvs);<KAIGYO>      }<KAIGYO>      mem = chunk2mem(p);<KAIGYO>      check_malloced_chunk(gm, mem, nb);<KAIGYO>      goto postaction;<KAIGYO>    }<KAIGYO><KAIGYO>    else if (nb < gm->topsize) { /* Split top */': 1, '  init_mparams(); /* Ensure pagesize etc initialized */<KAIGYO><KAIGYO>  if (capacity > msize + TOP_FOOT_SIZE &&<KAIGYO>      capacity < (size_t) -(msize + TOP_FOOT_SIZE + mparams.page_size)) {<KAIGYO>    m = init_user_mstate((char*)base, capacity);<KAIGYO>    m->seg.sflags = EXTERN_BIT;<KAIGYO>    set_lock(m, locked);<KAIGYO>  }<KAIGYO>  return (mspace)m;<KAIGYO>}<KAIGYO><KAIGYO>size_t destroy_mspace(mspace msp) {<KAIGYO>  size_t freed = 0;<KAIGYO>  mstate ms = (mstate)msp;<KAIGYO>  if (ok_magic(ms)) {<KAIGYO>    msegmentptr sp = &ms->seg;<KAIGYO>    while (sp != 0) {<KAIGYO>      char* base = sp->base;<KAIGYO>      size_t size = sp->size;<KAIGYO>      flag_t flag = sp->sflags;<KAIGYO>      sp = sp->next;<KAIGYO>      if ((flag & IS_MMAPPED_BIT) && !(flag & EXTERN_BIT) &&<KAIGYO>          CALL_MUNMAP(base, size) == 0)<KAIGYO>        freed += size;<KAIGYO>    }<KAIGYO>  }<KAIGYO>  else {<KAIGYO>    USAGE_ERROR_ACTION(ms,ms);<KAIGYO>  }<KAIGYO>  return freed;<KAIGYO>}<KAIGYO><KAIGYO>/*<KAIGYO>  mspace versions of routines are near-clones of the global<KAIGYO>  versions. This is not so nice but better than the alternatives.<KAIGYO>*/': 1, '      else { /* exhaust dv */<KAIGYO>        size_t dvs = ms->dvsize;<KAIGYO>        ms->dvsize = 0;<KAIGYO>        ms->dv = 0;<KAIGYO>        set_inuse_and_pinuse(ms, p, dvs);<KAIGYO>      }<KAIGYO>      mem = chunk2mem(p);<KAIGYO>      check_malloced_chunk(ms, mem, nb);<KAIGYO>      goto postaction;<KAIGYO>    }<KAIGYO><KAIGYO>    else if (nb < ms->topsize) { /* Split top */': 1, ""/* -----------------------------------------------------------------------<KAIGYO>History:<KAIGYO>    V2.8.4 (not yet released)<KAIGYO>      * Fix bad error check in mspace_footprint<KAIGYO>      * Adaptations for ptmalloc, courtesy of Wolfram Gloger.<KAIGYO>      * Reentrant spin locks, courtesy of Earl Chew and others<KAIGYO>      * Win32 improvements, courtesy of Niall Douglas and Earl Chew<KAIGYO>      * Add NO_SEGMENT_TRAVERSAL and MAX_RELEASE_CHECK_RATE options<KAIGYO>      * Various small adjustments to reduce warnings on some compilers<KAIGYO>      * Extension hook in malloc_state<KAIGYO><KAIGYO>    V2.8.3 Thu Sep 22 11:16:32 2005  Doug Lea  (dl at gee)<KAIGYO>      * Add max_footprint functions<KAIGYO>      * Ensure all appropriate literals are size_t<KAIGYO>      * Fix conditional compilation problem for some #define settings<KAIGYO>      * Avoid concatenating segments with the one provided<KAIGYO>        in create_mspace_with_base<KAIGYO>      * Rename some variables to avoid compiler shadowing warnings<KAIGYO>      * Use explicit lock initialization.<KAIGYO>      * Better handling of sbrk interference.<KAIGYO>      * Simplify and fix segment insertion, trimming and mspace_destroy<KAIGYO>      * Reinstate REALLOC_ZERO_BYTES_FREES option from 2.7.x<KAIGYO>      * Thanks especially to Dennis Flanagan for help on these.<KAIGYO><KAIGYO>    V2.8.2 Sun Jun 12 16:01:10 2005  Doug Lea  (dl at gee)<KAIGYO>      * Fix memalign brace error.<KAIGYO><KAIGYO>    V2.8.1 Wed Jun  8 16:11:46 2005  Doug Lea  (dl at gee)<KAIGYO>      * Fix improper #endif nesting in C++<KAIGYO>      * Add explicit casts needed for C++<KAIGYO><KAIGYO>    V2.8.0 Mon May 30 14:09:02 2005  Doug Lea  (dl at gee)<KAIGYO>      * Use trees for large bins<KAIGYO>      * Support mspaces<KAIGYO>      * Use segments to unify sbrk-based and mmap-based system allocation,<KAIGYO>        removing need for emulation on most platforms without sbrk.<KAIGYO>      * Default safety checks<KAIGYO>      * Optional footer checks. Thanks to William Robertson for the idea.<KAIGYO>      * Internal code refactoring<KAIGYO>      * Incorporate suggestions and platform-specific changes.<KAIGYO>        Thanks to Dennis Flanagan, Colin Plumb, Niall Douglas,<KAIGYO>        Aaron Bachmann,  Emery Berger, and others.<KAIGYO>      * Speed up non-fastbin processing enough to remove fastbins.<KAIGYO>      * Remove useless cfree() to avoid conflicts with other apps.<KAIGYO>      * Remove internal memcpy, memset. Compilers handle builtins better.<KAIGYO>      * Remove some options that no one ever used and rename others.<KAIGYO><KAIGYO>    V2.7.2 Sat Aug 17 09:07:30 2002  Doug Lea  (dl at gee)<KAIGYO>      * Fix malloc_state bitmap array misdeclaration<KAIGYO><KAIGYO>    V2.7.1 Thu Jul 25 10:58:03 2002  Doug Lea  (dl at gee)<KAIGYO>      * Allow tuning of FIRST_SORTED_BIN_SIZE<KAIGYO>      * Use PTR_UINT as type for all ptr->int casts. Thanks to John Belmonte.<KAIGYO>      * Better detection and support for non-contiguousness of MORECORE.<KAIGYO>        Thanks to Andreas Mueller, Conal Walsh, and Wolfram Gloger<KAIGYO>      * Bypass most of malloc if no frees. Thanks To Emery Berger.<KAIGYO>      * Fix freeing of old top non-contiguous chunk im sysmalloc.<KAIGYO>      * Raised default trim and map thresholds to 256K.<KAIGYO>      * Fix mmap-related #defines. Thanks to Lubos Lunak.<KAIGYO>      * Fix copy macros; added LACKS_FCNTL_H. Thanks to Neal Walfield.<KAIGYO>      * Branch-free bin calculation<KAIGYO>      * Default trim and mmap thresholds now 256K.<KAIGYO><KAIGYO>    V2.7.0 Sun Mar 11 14:14:06 2001  Doug Lea  (dl at gee)<KAIGYO>      * Introduce independent_comalloc and independent_calloc.<KAIGYO>        Thanks to Michael Pachos for motivation and help.<KAIGYO>      * Make optional .h file available<KAIGYO>      * Allow > 2GB requests on 32bit systems.<KAIGYO>      * new WIN32 sbrk, mmap, munmap, lock code from <Walter@GeNeSys-e.de>.<KAIGYO>        Thanks also to Andreas Mueller <a.mueller at paradatec.de>,<KAIGYO>        and Anonymous.<KAIGYO>      * Allow override of MALLOC_ALIGNMENT (Thanks to Ruud Waij for<KAIGYO>        helping test this.)<KAIGYO>      * memalign: check alignment arg<KAIGYO>      * realloc: don't try to shift chunks backwards, since this<KAIGYO>        leads to  more fragmentation in some programs and doesn't<KAIGYO>        seem to help in any others.<KAIGYO>      * Collect all cases in malloc requiring system memory into sysmalloc<KAIGYO>      * Use mmap as backup to sbrk<KAIGYO>      * Place all internal state in malloc_state<KAIGYO>      * Introduce fastbins (although similar to 2.5.1)<KAIGYO>      * Many minor tunings and cosmetic improvements<KAIGYO>      * Introduce USE_PUBLIC_MALLOC_WRAPPERS, USE_MALLOC_LOCK<KAIGYO>      * Introduce MALLOC_FAILURE_ACTION, MORECORE_CONTIGUOUS<KAIGYO>        Thanks to Tony E. Bennett <tbennett@nvidia.com> and others.<KAIGYO>      * Include errno.h to support default failure action.<KAIGYO><KAIGYO>    V2.6.6 Sun Dec  5 07:42:19 1999  Doug Lea  (dl at gee)<KAIGYO>      * return null for negative arguments<KAIGYO>      * Added Several WIN32 cleanups from Martin C. Fong <mcfong at yahoo.com><KAIGYO>         * Add 'LACKS_SYS_PARAM_H' for those systems without 'sys/param.h'<KAIGYO>          (e.g. WIN32 platforms)<KAIGYO>         * Cleanup header file inclusion for WIN32 platforms<KAIGYO>         * Cleanup code to avoid Microsoft Visual C++ compiler complaints<KAIGYO>         * Add 'USE_DL_PREFIX' to quickly allow co-existence with existing<KAIGYO>           memory allocation routines<KAIGYO>         * Set 'malloc_getpagesize' for WIN32 platforms (needs more work)<KAIGYO>         * Use 'assert' rather than 'ASSERT' in WIN32 code to conform to<KAIGYO>           usage of 'assert' in non-WIN32 code<KAIGYO>         * Improve WIN32 'sbrk()' emulation's 'findRegion()' routine to<KAIGYO>           avoid infinite loop<KAIGYO>      * Always call 'fREe()' rather than 'free()'<KAIGYO><KAIGYO>    V2.6.5 Wed Jun 17 15:57:31 1998  Doug Lea  (dl at gee)<KAIGYO>      * Fixed ordering problem with boundary-stamping<KAIGYO><KAIGYO>    V2.6.3 Sun May 19 08:17:58 1996  Doug Lea  (dl at gee)<KAIGYO>      * Added pvalloc, as recommended by H.J. Liu<KAIGYO>      * Added 64bit pointer support mainly from Wolfram Gloger<KAIGYO>      * Added anonymously donated WIN32 sbrk emulation<KAIGYO>      * Malloc, calloc, getpagesize: add optimizations from Raymond Nijssen<KAIGYO>      * malloc_extend_top: fix mask error that caused wastage after<KAIGYO>        foreign sbrks<KAIGYO>      * Add linux mremap support code from HJ Liu<KAIGYO><KAIGYO>    V2.6.2 Tue Dec  5 06:52:55 1995  Doug Lea  (dl at gee)<KAIGYO>      * Integrated most documentation with the code.<KAIGYO>      * Add support for mmap, with help from<KAIGYO>        Wolfram Gloger (Gloger@lrz.uni-muenchen.de).<KAIGYO>      * Use last_remainder in more cases.<KAIGYO>      * Pack bins using idea from  colin@nyx10.cs.du.edu<KAIGYO>      * Use ordered bins instead of best-fit threshhold<KAIGYO>      * Eliminate block-local decls to simplify tracing and debugging.<KAIGYO>      * Support another case of realloc via move into top<KAIGYO>      * Fix error occuring when initial sbrk_base not word-aligned.<KAIGYO>      * Rely on page size for units instead of SBRK_UNIT to<KAIGYO>        avoid surprises about sbrk alignment conventions.<KAIGYO>      * Add mallinfo, mallopt. Thanks to Raymond Nijssen<KAIGYO>        (raymond@es.ele.tue.nl) for the suggestion.<KAIGYO>      * Add `pad' argument to malloc_trim and top_pad mallopt parameter.<KAIGYO>      * More precautions for cases where other routines call sbrk,<KAIGYO>        courtesy of Wolfram Gloger (Gloger@lrz.uni-muenchen.de).<KAIGYO>      * Added macros etc., allowing use in linux libc from<KAIGYO>        H.J. Lu (hjl@gnu.ai.mit.edu)<KAIGYO>      * Inverted this history list<KAIGYO><KAIGYO>    V2.6.1 Sat Dec  2 14:10:57 1995  Doug Lea  (dl at gee)<KAIGYO>      * Re-tuned and fixed to behave more nicely with V2.6.0 changes.<KAIGYO>      * Removed all preallocation code since under current scheme<KAIGYO>        the work required to undo bad preallocations exceeds<KAIGYO>        the work saved in good cases for most test programs.<KAIGYO>      * No longer use return list or unconsolidated bins since<KAIGYO>        no scheme using them consistently outperforms those that don't<KAIGYO>        given above changes.<KAIGYO>      * Use best fit for very large chunks to prevent some worst-cases.<KAIGYO>      * Added some support for debugging<KAIGYO><KAIGYO>    V2.6.0 Sat Nov  4 07:05:23 1995  Doug Lea  (dl at gee)<KAIGYO>      * Removed footers when chunks are in use. Thanks to<KAIGYO>        Paul Wilson (wilson@cs.texas.edu) for the suggestion.<KAIGYO><KAIGYO>    V2.5.4 Wed Nov  1 07:54:51 1995  Doug Lea  (dl at gee)<KAIGYO>      * Added malloc_trim, with help from Wolfram Gloger<KAIGYO>        (wmglo@Dent.MED.Uni-Muenchen.DE).<KAIGYO><KAIGYO>    V2.5.3 Tue Apr 26 10:16:01 1994  Doug Lea  (dl at g)<KAIGYO><KAIGYO>    V2.5.2 Tue Apr  5 16:20:40 1994  Doug Lea  (dl at g)<KAIGYO>      * realloc: try to expand in both directions<KAIGYO>      * malloc: swap order of clean-bin strategy;<KAIGYO>      * realloc: only conditionally expand backwards<KAIGYO>      * Try not to scavenge used bins<KAIGYO>      * Use bin counts as a guide to preallocation<KAIGYO>      * Occasionally bin return list chunks in first scan<KAIGYO>      * Add a few optimizations from colin@nyx10.cs.du.edu<KAIGYO><KAIGYO>    V2.5.1 Sat Aug 14 15:40:43 1993  Doug Lea  (dl at g)<KAIGYO>      * faster bin computation & slightly different binning<KAIGYO>      * merged all consolidations to one part of malloc proper<KAIGYO>         (eliminating old malloc_find_space & malloc_clean_bin)<KAIGYO>      * Scan 2 returns chunks (not just 1)<KAIGYO>      * Propagate failure in realloc if malloc returns 0<KAIGYO>      * Add stuff to allow compilation on non-ANSI compilers<KAIGYO>          from kpv@research.att.com<KAIGYO><KAIGYO>    V2.5 Sat Aug  7 07:41:59 1993  Doug Lea  (dl at g.oswego.edu)<KAIGYO>      * removed potential for odd address access in prev_chunk<KAIGYO>      * removed dependency on getpagesize.h<KAIGYO>      * misc cosmetics and a bit more internal documentation<KAIGYO>      * anticosmetics: mangled names in macros to evade debugger strangeness<KAIGYO>      * tested on sparc, hp-700, dec-mips, rs6000<KAIGYO>          with gcc & native cc (hp, dec only) allowing<KAIGYO>          Detlefs & Zorn comparison study (in SIGPLAN Notices.)<KAIGYO><KAIGYO>    Trial version Fri Aug 28 13:14:29 1992  Doug Lea  (dl at g.oswego.edu)<KAIGYO>      * Based loosely on libg++-1.2X malloc. (It retains some of the overall<KAIGYO>         structure of old version,  but most details differ.)<KAIGYO><KAIGYO>*/"": 1, '/*<KAIGYO> * TODO: optimization / better integration with malloc.c (partly done)<KAIGYO> *       malloc_{get,set}_state (probably hard to keep compatibility)<KAIGYO> *       debugging hooks<KAIGYO> *       better mstats<KAIGYO> */': 1, '/* For now, store arena in footer.  This means typically 4bytes more<KAIGYO>   overhead for each non-main-arena chunk, but is fast and easy to<KAIGYO>   compute.  Note that the pointer stored in the extra footer must be<KAIGYO>   properly aligned, though. */': 1, ""/* special because of extra overhead */<KAIGYO>#define arena_for_mmap_chunk(ptr) \\<KAIGYO> (chunk_non_main_arena(ptr) ? *(struct malloc_arena**)             \\<KAIGYO>  ((char*)(ptr) + chunksize(ptr) - sizeof(struct malloc_arena*))   \\<KAIGYO>  : &main_arena)<KAIGYO><KAIGYO>#define set_non_main_arena(mem, ar_ptr) do {                   \t\t      \\<KAIGYO>  mchunkptr P = mem2chunk(mem);                                               \\<KAIGYO>  size_t SZ = chunksize(P) - (is_mmapped(P) ? sizeof(struct malloc_arena*)    \\<KAIGYO>                              : (FOOTER_OVERHEAD - SIZE_T_SIZE));             \\<KAIGYO>  assert((unsigned long)((char*)(P) + SZ)%sizeof(struct malloc_arena*) == 0); \\<KAIGYO>  *(struct malloc_arena**)((char*)(P) + SZ) = (ar_ptr);                       \\<KAIGYO>  P->head |= NON_MAIN_ARENA;                                                  \\<KAIGYO>} while (0)<KAIGYO><KAIGYO>/* arena_get() acquires an arena and locks the corresponding mutex.<KAIGYO>   First, try the one last locked successfully by this thread.  (This<KAIGYO>   is the common case and handled with a macro for speed.)  Then, loop<KAIGYO>   once over the circularly linked list of arenas.  If no arena is<KAIGYO>   readily available, create a new one.  In this latter case, `size'<KAIGYO>   is just a hint as to how much memory will be required immediately<KAIGYO>   in the new arena. */"": 1, '/*------------------------------------------------------------------------*/<KAIGYO><KAIGYO>/* Hook mechanism for proper initialization and atfork support. */': 1, '  /* realloc of null is supposed to be same as malloc */<KAIGYO>  if (oldmem == 0)<KAIGYO>    return public_mALLOc(bytes);<KAIGYO><KAIGYO>  oldp    = mem2chunk(oldmem);<KAIGYO>  if (is_mmapped(oldp))<KAIGYO>    ar_ptr = arena_for_mmap_chunk(oldp); /* FIXME: use mmap_resize */': 1, '    while(sz > 0) ((char*)mem)[--sz] = 0; /* rather inefficient */<KAIGYO>    return mem;<KAIGYO>#endif<KAIGYO>  }<KAIGYO><KAIGYO>  arena_get(ar_ptr, bytes + FOOTER_OVERHEAD);<KAIGYO>  if(!ar_ptr)<KAIGYO>    return 0;<KAIGYO><KAIGYO>  if (ar_ptr != &main_arena)<KAIGYO>    bytes += FOOTER_OVERHEAD;<KAIGYO>  mem = mspace_calloc(arena_to_mspace(ar_ptr), bytes, 1);<KAIGYO><KAIGYO>  if (mem && ar_ptr != &main_arena)<KAIGYO>    set_non_main_arena(mem, ar_ptr);<KAIGYO>  (void)mutex_unlock(&ar_ptr->mutex);<KAIGYO>  <KAIGYO>  assert(!mem || is_mmapped(mem2chunk(mem)) ||<KAIGYO>\t ar_ptr == arena_for_chunk(mem2chunk(mem)));<KAIGYO><KAIGYO>  return mem;<KAIGYO>}<KAIGYO><KAIGYO>void**<KAIGYO>public_iCALLOc(size_t n, size_t elem_size, void* chunks[])<KAIGYO>{<KAIGYO>  struct malloc_arena* ar_ptr;<KAIGYO>  void** m;<KAIGYO><KAIGYO>  arena_get(ar_ptr, n*(elem_size + FOOTER_OVERHEAD));<KAIGYO>  if (!ar_ptr)<KAIGYO>    return 0;<KAIGYO><KAIGYO>  if (ar_ptr != &main_arena)<KAIGYO>    elem_size += FOOTER_OVERHEAD;<KAIGYO>  m = mspace_independent_calloc(arena_to_mspace(ar_ptr), n, elem_size, chunks);<KAIGYO><KAIGYO>  if (m && ar_ptr != &main_arena) {<KAIGYO>    while (n > 0)<KAIGYO>      set_non_main_arena(m[--n], ar_ptr);<KAIGYO>  }<KAIGYO>  (void)mutex_unlock(&ar_ptr->mutex);<KAIGYO>  return m;<KAIGYO>}<KAIGYO><KAIGYO>void**<KAIGYO>public_iCOMALLOc(size_t n, size_t sizes[], void* chunks[])<KAIGYO>{<KAIGYO>  struct malloc_arena* ar_ptr;<KAIGYO>  size_t* m_sizes;<KAIGYO>  size_t i;<KAIGYO>  void** m;<KAIGYO><KAIGYO>  arena_get(ar_ptr, n*sizeof(size_t));<KAIGYO>  if (!ar_ptr)<KAIGYO>    return 0;<KAIGYO><KAIGYO>  if (ar_ptr != &main_arena) {<KAIGYO>    /* Temporary m_sizes[] array is ugly but it would be surprising to<KAIGYO>       change the original sizes[]... */': 1}",1.0,{}
196,10711.0,1.0,5.0,2.0,MERGED,True,https://codereview.qt-project.org/#/c/10711,parse_build_log: be robust when fetching log over network,1.0,"{'# Work around a silly File::Fetch behavior.<KAIGYO># File::Fetch breaks if the URL ends with a `/\'.<KAIGYO># It croaks with: No \'file\' specified<KAIGYO># ...because it requires the URL to have a """" component for<KAIGYO># some reason.<KAIGYO>#<KAIGYO># Note that we can\'t 100% guarantee that silently removing this<KAIGYO># doesn\'t change the result :(': 1, '# Give up ...': 1}",1.0,"{'#<KAIGYO># Work around a silly File::Fetch behavior.<KAIGYO># File::Fetch breaks if the URL ends with a `/\'.<KAIGYO># It croaks with: No \'file\' specified<KAIGYO># ...because it requires the URL to have a """" component for<KAIGYO># some reason.<KAIGYO>#<KAIGYO># Note that we can\'t 100% guarantee that silently removing this<KAIGYO># doesn\'t change the result :(': 1}",1.0,{}
273,10954.0,5.0,10.0,3.0,MERGED,True,https://codereview.qt-project.org/#/c/10954,qtmod_test: fix PATH prepend for qtqa-tests in shadow-building,1.0,{},0.0,"{""# FIXME: at some point, we should be doing `make install'.  If that is done,<KAIGYO># the PATH used here should be the install path rather than build path."": 1, ""# Add qtbase/bin (core tools) to PATH.<KAIGYO># FIXME: at some point, we should be doing `make install'.  If that is done,<KAIGYO># the PATH used here should be the install path rather than build path."": 4}",1.0,{}
60,11123.0,2.0,4.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/11123,Don't re-parent ShaderEffect source items.,1.0,{},0.0,"{""// TODO: Find better solution.<KAIGYO>// 'item' needs a canvas to get a scenegraph node.<KAIGYO>// The easiest way to make sure it gets a canvas is to<KAIGYO>// make it a part of the same item tree as 'this'."": 1, ""// TODO: Find better solution.<KAIGYO>// 'm_sourceItem' needs a canvas to get a scenegraph node.<KAIGYO>// The easiest way to make sure it gets a canvas is to<KAIGYO>// make it a part of the same item tree as 'this'."": 1}",1.0,{}
198,11446.0,3.0,15.0,4.0,MERGED,True,https://codereview.qt-project.org/#/c/11446,Don't fetch credentials from cache following a failed proxy authentication,1.0,{},0.0,"{'// ### FIXME Tracking of successful authentications<KAIGYO>// This code is a bit broken right now for SOCKS authentication<KAIGYO>// first request: proxyAuthenticationRequired gets emitted, credentials gets saved<KAIGYO>// second request: (proxy != backend->reply->lastProxyAuthentication) does not evaluate to true,<KAIGYO>//      proxyAuthenticationRequired gets emitted again<KAIGYO>// possible solution: some tracking inside the authenticator<KAIGYO>//      or a new function proxyAuthenticationSucceeded(true|false)': 2}",1.0,{}
223,11549.0,1.0,4.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/11549,Debugger: Allow transmissions of network packets in one go,1.0,{},0.0,{'//### this is a suboptimal way to send batched messages': 1},1.0,{}
230,11580.0,1.0,2.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/11580,Minor cleanup.,1.0,{'//TODO: optimize<KAIGYO>//TODO: set loopCount in the transition function': 1},1.0,{'//TODO: set in the transition function': 1},1.0,{}
232,11592.0,1.0,3.0,1.0,MERGED,True,https://codereview.qt-project.org/#/c/11592,Remove uneccessary layout in TextInput initialization.,1.0,{'//TODO: Only update rect in selection': 1},1.0,{'//TODO: Only update rect in selection': 1},1.0,{}
374,11741.0,11.0,56.0,3.0,MERGED,True,https://codereview.qt-project.org/#/c/11741,"Removing QHttp class, its tests and its usage in examples.",1.0,{},0.0,"{'// workaround for VC++ bug': 1, '// ### it would be nice if we could specify in our testdata when to do<KAIGYO>// the abort': 1}",1.0,{}
289,11788.0,1.0,11.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/11788,Remove Symbian support from src/corelib/io/.,1.0,{},0.0,"{'//TODO: resolve this with QDir::cleanPath, without breaking the behaviour of that<KAIGYO>//function which is documented only by autotest<KAIGYO>//input: a dirty absolute path, e.g. c:/../../foo/./<KAIGYO>//output: a clean absolute path, e.g. c:/foo/': 1, '//using SkipEmptyParts flag to eliminate duplicated slashes': 1, '//TODO: error reporting, to allow user to distinguish empty directory from error condition.': 1, ""// Re-request failed notification once, but if it won't start working,<KAIGYO>// we can't do much besides just not request any more notifications."": 1, '// Check if manager thread is still alive. If this destructor is ran as part of global<KAIGYO>// static cleanup, manager thread will most likely be terminated by kernel at this point,<KAIGYO>// so trying to delete QProcessActives and QProcessMediators will panic as they<KAIGYO>// will still be active. They can also no longer be canceled as the thread is already gone.<KAIGYO>// In case manager thread has already died, we simply do nothing and let the deletion of<KAIGYO>// the main heap at process exit take care of stray objects.': 1}",1.0,{}
316,11859.0,3.0,8.0,3.0,MERGED,True,https://codereview.qt-project.org/#/c/11859,Make qDecodeDataUrl return bool.,1.0,{},0.0,{'// FIXME qDecodeDataUrl should instead be rewritten to have the QByteArray<KAIGYO>// and the mime type as an output parameter and return a bool instead': 1},1.0,{}
361,11868.0,7.0,42.0,23.0,MERGED,True,https://codereview.qt-project.org/#/c/11868,Remove thread from QFileSystemWatcherEngine implementations.,1.0,{'// perhaps a directory?': 2},1.0,{'// perhaps a directory?': 2},1.0,{}
23,12028.0,1.0,1.0,0.0,ABANDONED,False,https://codereview.qt-project.org/#/c/12028,Adapt to change in qtbase: Accessible states as vector.,1.0,{},0.0,{'// FIXME': 1},1.0,{}
29,12076.0,1.0,2.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/12076,Fix animation looping.,1.0,{},0.0,{'//TODO: set loopCount in the transition function': 1},1.0,{}
70,12141.0,5.0,30.0,2.0,MERGED,True,https://codereview.qt-project.org/#/c/12141,Accessibility: Checked state for check boxes and radio buttons.,1.0,"{'// FIXME': 3, '// FIXME when states are extended: state.checkable = true;': 5}",1.0,{'// FIXME': 3},1.0,{}
76,12161.0,5.0,13.0,4.0,MERGED,True,https://codereview.qt-project.org/#/c/12161,Fix positioning issues and change content y repositioning behaviour,1.0,{'// move down by 1 to avoid moving Item 6 up and out of view<KAIGYO>// move down by 1 to avoid moving Item 6 up and out of view': 1},1.0,"{""// Ensure we don't cause an ugly list scroll"": 1}",1.0,{}
72,12222.0,1.0,22.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/12222,Remove QtV8 library from QtBase,1.0,{},0.0,"{""// XXX Opportunity for optimization - don't invoke user callback if objects are<KAIGYO>// equal."": 1}",1.0,{}
106,12300.0,2.0,7.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/12300,"QMLTest: Fix output of file names, make output more verbose.",1.0,{},0.0,"{""// Bail out if we didn't find any test cases."": 1}",1.0,{}
124,12352.0,1.0,3.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/12352,Remove redundant class from QStringMatcher test.,1.0,{},0.0,{'// Subclass that exposes the protected functions.': 1},1.0,{}
136,12377.0,1.0,4.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/12377,Reimplement QVariant to QDebug streaming.,1.0,{},0.0,"{'//        dbg.nospace() << qvariant_cast<QCursor>(v); //FIXME': 1, '//        dbg.nospace() << qvariant_cast<QBitmap>(v); //FIXME': 1, '//        dbg.nospace() << qvariant_cast<QFont>(v);  //FIXME': 1, '//        dbg.nospace() << qvariant_cast<QPixmap>(v); //FIXME': 1, '//        dbg.nospace() << qvariant_cast<QImage>(v); //FIXME': 1, '//        dbg.nospace() << qvariant_cast<QPalette>(v); //FIXME': 1, '//        dbg.nospace() << qvariant_cast<QIcon>(v); // FIXME': 1, '//        dbg.nospace() << qvariant_cast<QSizePolicy>(v); //FIXME': 1}",1.0,{}
208,12421.0,8.0,29.0,4.0,MERGED,True,https://codereview.qt-project.org/#/c/12421,Remove all references to QAccessible::(Up|Down|Left|Right),1.0,{},0.0,{'// FIXME': 1},1.0,{}
187,12490.0,3.0,11.0,1.0,MERGED,True,https://codereview.qt-project.org/#/c/12490,Fix QQuickItemParticle timing issues,1.0,"{'//only needed because QTickAnimationProxy expects one<KAIGYO>//TODO: Cleanup items?<KAIGYO>//Refill loadables, delayed here so as to only happen once per frame max<KAIGYO>//### Constant resetting might lead to m_loadables never being populated when tick() occurs': 2}",1.0,"{""//TODO: don't leak"": 2, '//TODO: Cleanup items?': 2}",1.0,{}
202,12520.0,1.0,3.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/12520,Improve handling of QScriptEngine::ExcludeDeleteLater.,1.0,{},0.0,{'// FIXME: this is fragile and may break if signals/slots are added to/removed from QObject.<KAIGYO>// See QTBUG-23502': 1},1.0,{}
273,12720.0,1.0,2.0,0.0,ABANDONED,False,https://codereview.qt-project.org/#/c/12720,QDeclarative: Fix build break,1.0,{'// FIXME': 1},1.0,{'// FIXME': 1},1.0,{}
46,13167.0,1.0,4.0,5.0,ABANDONED,False,https://codereview.qt-project.org/#/c/13167,Qt5 QDateTime: Split QDateTimeParser into its own file,1.0,{'// no way to tell if this is am or pm so I assume am': 1},1.0,{'// no way to tell if this is am or pm so I assume am': 1},1.0,{}
61,13229.0,1.0,1.0,0.0,ABANDONED,False,https://codereview.qt-project.org/#/c/13229,Update Transition Manager for animation class changes,1.0,{},0.0,{'// ### this could potentially trigger a complete in rare circumstances': 1},1.0,{}
91,13233.0,5.0,14.0,6.0,MERGED,True,https://codereview.qt-project.org/#/c/13233,Update Transition and TransitionManager for animation changes,1.0,{},0.0,{'// ### this could potentially trigger a complete in rare circumstances': 1},1.0,{}
87,13370.0,2.0,25.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/13370,Remove unecessary asserts,1.0,{},0.0,{'//XXX: Just checking<KAIGYO>//XXX: Just checking': 1},1.0,{}
97,13384.0,2.0,15.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/13384,Per-frame Sprites patch three,1.0,{'//TODO: Proper fix(because this has happened and I just ignored it)': 1},1.0,{'//This will be the last time updateSprites was called<KAIGYO>//TODO: emit this when a psuedostate changes too(but manually in SpriteEngine)': 1},1.0,{}
145,13562.0,1.0,6.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/13562,Remove all references to QAccessible::(Covers|Covered),1.0,{},0.0,"{'// FIXME: this code looks very suspicious<KAIGYO>// why start at this index?': 1, '// FIXME: why end at index?': 1}",1.0,{}
184,13712.0,3.0,27.0,11.0,MERGED,True,https://codereview.qt-project.org/#/c/13712,Remove executive summary.,1.0,{},0.0,"{'/*<KAIGYO><KAIGYO>////////////////////////////////////////////////////////////////////<KAIGYO><KAIGYO>This benchmark serves as reality check on the idea that hashing the complete<KAIGYO>string is a good idea.<KAIGYO><KAIGYO>  Executive summary: It is not a good idea.<KAIGYO><KAIGYO>////////////////////////////////////////////////////////////////////<KAIGYO><KAIGYO>********* Start testing of tst_QHash *********<KAIGYO>Config: Using QTest library 5.0.0, Qt 5.0.0<KAIGYO>PASS   : tst_QHash::initTestCase()<KAIGYO>RESULT : tst_QHash::qhash_qt4():<KAIGYO>     0.041 msecs per iteration (total: 85, iterations: 2048)<KAIGYO>PASS   : tst_QHash::qhash_qt4()<KAIGYO>RESULT : tst_QHash::qhash_faster():<KAIGYO>     0.0122 msecs per iteration (total: 100, iterations: 8192)<KAIGYO>PASS   : tst_QHash::qhash_faster()<KAIGYO>PASS   : tst_QHash::cleanupTestCase()<KAIGYO>Totals: 4 passed, 0 failed, 0 skipped<KAIGYO><KAIGYO>////////////////////////////////////////////////////////////////////<KAIGYO><KAIGYO>*/': 1}",1.0,{}
212,13798.0,1.0,3.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/13798,Remove QJSValue::propertyFlags() function,1.0,{},0.0,{'// FIXME: No getter/setter API': 1},1.0,{}
230,13875.0,1.0,4.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/13875,Remove Symbian specific code from QtXml.,1.0,{},0.0,{'// Workaround crash in elf2e32 under Wine.': 1},1.0,{}
260,13877.0,2.0,20.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/13877,Remove Symbian specific code from QtGui.,1.0,{},0.0,"{""// Efficient path: no pixel data copying. Just duplicate. This of course<KAIGYO>// means the original bitmap's data may get modified, but that's fine<KAIGYO>// and is in accordance with the QPixmap::fromSymbianCFbsBitmap() docs."": 1, '// Symbian thinks set pixels are white/transparent, Qt thinks they are<KAIGYO>// foreground/solid. Invert mono bitmaps so that masks work correctly.': 1}",1.0,{}
254,13916.0,2.0,5.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/13916,Update item focus when the enabled property is changed.,1.0,{},0.0,{'// XXX todo - need to fixup focus': 1},1.0,{}
287,13925.0,4.0,16.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/13925,Remove QTextControl and QLineControl.,1.0,{},0.0,"{'// second half of a surrogate, check if we have the first half as well,<KAIGYO>// if yes delete both at once': 1, '/*!<KAIGYO>    \\internal<KAIGYO><KAIGYO>    Returns the cursor position of the given \\a x pixel value in relation<KAIGYO>    to the displayed text.  The given \\a betweenOrOn specified what kind<KAIGYO>    of cursor position is requested.<KAIGYO>*/': 1, ""// Except for pageup and pagedown, Mac OS X has very different behavior, we don't do it all, but<KAIGYO>// here's the breakdown:<KAIGYO>// Shift still works as an anchor, but only one of the other keys can be down Ctrl (Command),<KAIGYO>// Alt (Option), or Meta (Control).<KAIGYO>// Command/Control + Left/Right -- Move to left or right of the line<KAIGYO>//                 + Up/Down -- Move to top bottom of the file. (Control doesn't move the cursor)<KAIGYO>// Option + Left/Right -- Move one word Left/right.<KAIGYO>//        + Up/Down  -- Begin/End of Paragraph.<KAIGYO>// Home/End Top/Bottom of file. (usually don't move the cursor, but will select)"": 1}",1.0,{}
52,14179.0,2.0,5.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/14179,qtmod_test.pl: support shadow build/install for modules outside of qt5,1.0,{},0.0,"{""# XXX this does not work if Qt is configured such that `make install' needs to be<KAIGYO># done on the dependencies.  At least the path to `qmake' will be wrong."": 1, '# XXX also this is not implemented yet to work properly when shadow-build<KAIGYO># with installation is enabled.': 1, ""# XXX: this will not work for modules which aren't hosted in qt/qt5.git"": 1, ""# XXX this only works when all the module's dependencies are located in qt5.git."": 2}",1.0,{}
59,14181.0,1.0,1.0,0.0,ABANDONED,False,https://codereview.qt-project.org/#/c/14181,Fix lockup in views due to endless polish loop.,1.0,{'// Set visibility of items to eliminate cost of items outside the visible area.': 1},1.0,{'// Set visibility of items to eliminate cost of items outside the visible area.': 1},1.0,{}
120,14355.0,1.0,5.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/14355,Fix breakage due to meta-type id reordering in qtbase,1.0,{'// TODO test complex types': 1},1.0,{'// TODO test complex types': 1},1.0,{}
208,14507.0,2.0,17.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/14507,Remove Symbian and Maemo 5 code from QtWidgets.,1.0,{},0.0,"{""// The DPI value is hardcoded to 96 on Maemo5:<KAIGYO>// httpsprojects.maemo.org/bugzilla/show_bug.cgi?id=152525<KAIGYO>// This value (260) is only correct for the N900 though, but<KAIGYO>// there's no way to get the real DPI at run time."": 1}",1.0,{}
183,14508.0,2.0,12.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/14508,Remove Symbian specific code from QtGui.,1.0,{},0.0,{'// TODO: add GNU assembler instructions and support for other platforms.<KAIGYO>//       Default to C code for now': 1},1.0,{}
182,14510.0,2.0,12.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/14510,Remove Symbian specific code from qtbase.,1.0,{},0.0,{'// FIXME: use HAL': 1},1.0,{}
218,14548.0,4.0,15.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/14548,Add more element qmltestrunner cases,1.0,{},0.0,{'// TODO: remote tests that need to use http': 1},1.0,{}
301,14783.0,5.0,29.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/14783,Separate out some of the common test code,1.0,"{'// Only move forwards - flip if backwards moving': 1, '// send press, five equally spaced moves, and release.': 1}",1.0,"{'// send press, five equally spaced moves, and release.': 1, '// Only move forwards - flip if backwards moving': 1, '// Move': 1}",1.0,{}
344,14958.0,1.0,3.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/14958,Removed python support.,1.0,"{'# Try really hard to install some modules.<KAIGYO>#               installing, e.g. """"<KAIGYO>#    # Install all modules from CPAN<KAIGYO>#        name        =>  """",<KAIGYO>#        need_sub    =>  \\&missing_required_cpan_modules,<KAIGYO>#        install_sub =>  \\&run_cpan,<KAIGYO># This function is necessary because modules may, on occasion,<KAIGYO># be missing some vital dependency information which': 1}",1.0,"{'# Try really hard to install some python or perl modules.<KAIGYO>#               installing, e.g. """"<KAIGYO>#    # Install all python modules, via pip<KAIGYO>#        name        =>  """",<KAIGYO>#        need_sub    =>  \\&missing_required_python_modules,<KAIGYO>#        install_sub =>  \\&run_pip,<KAIGYO># This function is necessary because perl and python modules may,<KAIGYO># on occasion, be missing some vital dependency information which': 1, ""# we'll retry up to this many times, e.g. to recover from temporary network issues."": 1}",1.0,{}
131,15009.0,4.0,8.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/15009,Debugger: Rename QDeclarativeDebugTrace to QDeclarativeProfilerService,1.0,"{'/*<KAIGYO>    Either send the message directly, or queue up<KAIGYO>    a list of messages to send later (via sendMessages)<KAIGYO>*/': 1}",1.0,"{'/*<KAIGYO>    Either send the message directly, or queue up<KAIGYO>    a list of messages to send later (via sendMessages)<KAIGYO>*/': 1}",1.0,{}
35,15360.0,1.0,10.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/15360,Move distance field util functions to QtGui,1.0,{},0.0,"{'// Assuming 16 bits per vector component.': 1, ""// element doesn't split itself."": 1}",1.0,{}
32,15388.0,2.0,13.0,3.0,MERGED,True,https://codereview.qt-project.org/#/c/15388,Use the QNX implementation of mkdtemp for win and wince.,1.0,{},0.0,"{""// Windows' mktemp believes 26 temp files per process ought to be enough for everyone (!)<KAIGYO>// Let's add a few random chars then, before the XXXXXX template."": 2}",1.0,{}
60,15432.0,6.0,17.0,4.0,MERGED,True,https://codereview.qt-project.org/#/c/15432,QSqlTableModel::setData(): call dataChanged() before select(),1.0,{},0.0,"{'// historical bug: bad style to call updateRowInTable.<KAIGYO>// Should call submit(), but maybe the author wanted to avoid<KAIGYO>// clearing the cache on failure.': 1}",1.0,{}
76,15435.0,6.0,15.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/15435,QSqlTableModel::setRecord(): do not try to detect value changes,1.0,{},0.0,"{""// historical bug: it's a bad idea to check for change here<KAIGYO>// historical bug: should test oldValue.isNull() != value.isNull()"": 1}",1.0,{}
78,15436.0,6.0,15.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/15436,QSqlTableModel::setRecord(): emit dataChanged() consistently,1.0,{},0.0,"{""// historical bug: this could all be simple like OnManualSubmit, but isn't"": 1}",1.0,{}
61,15437.0,2.0,5.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/15437,QSqlTableModel::removeRows(): don't emit extra beforeDelete,1.0,{},0.0,{'// historical bug: emit beforeDelete for 1st row beyond end': 1},1.0,{}
190,15471.0,3.0,19.0,3.0,MERGED,True,https://codereview.qt-project.org/#/c/15471,Use Q_OS_WINCE instead of Q_WS_WINCE,1.0,{'// ### TODO: check for NotifyWinEvent in CE 6.0<KAIGYO>// Q_OS_WINCE': 1},1.0,{'// ### TODO: check for NotifyWinEvent in CE 6.0<KAIGYO>// Q_WS_WINCE': 1},1.0,{}
137,15632.0,3.0,9.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/15632,QSqlTableModel::setData(): submit() instead of updateRowInTable(),1.0,{},0.0,"{'// historical bug: bad style to call updateRowInTable.<KAIGYO>// Should call submit(), but maybe the author wanted to avoid<KAIGYO>// clearing the cache on failure.': 1}",1.0,{}
174,15761.0,1.0,4.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/15761,Remove deprecated builtin sql database API.,1.0,{},0.0,{'// XXX optimize': 1},1.0,{}
15,16013.0,4.0,8.0,4.0,ABANDONED,False,https://codereview.qt-project.org/#/c/16013,WIP: Porting QVector to QArrayData,1.0,{},0.0,{'// malloc on 32-bit platforms should return pointers that are 8-byte aligned or more<KAIGYO>// while on 64-bit platforms they should be 16-byte aligned or more': 2},1.0,{}
83,16112.0,8.0,14.0,1.0,MERGED,True,https://codereview.qt-project.org/#/c/16112,Free ShaderEffectSource FBOs when no longer needed.,1.0,{},0.0,{'// ### should we change ~QQuickItem to handle this better?<KAIGYO>// manually cleanup for the root item (item destructor only handles these when an item is parented)': 4},1.0,{}
55,16138.0,3.0,16.0,1.0,MERGED,True,https://codereview.qt-project.org/#/c/16138,Use english name to match font in windows platform,1.0,{},0.0,"{'/* Fixme: omitted for the moment<KAIGYO>    if(ttf && localizedName(familyName) && family->english_name.isEmpty())<KAIGYO>        family->english_name = getEnglishName(familyName);<KAIGYO>*/': 1, '/* Fixme: omitted for the moment<KAIGYO>    if(ttf && localizedName(faceName) && family->english_name.isEmpty())<KAIGYO>        family->english_name = getEnglishName(faceName);<KAIGYO>*/': 1}",1.0,{}
114,16358.0,1.0,4.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/16358,Remove pixmap text caching in TextEdit element,1.0,{},0.0,"{""// Nonsmooth text just ugly, so don't do that.."": 1}",1.0,{}
121,16363.0,2.0,2.0,0.0,ABANDONED,False,https://codereview.qt-project.org/#/c/16363,Update CustomParticle to ShaderEffect changes,1.0,{},0.0,"{""// TODO: Copy better solution in QQuickShaderEffect when they find it.<KAIGYO>// 'source.item' needs a canvas to get a scenegraph node.<KAIGYO>// The easiest way to make sure it gets a canvas is to<KAIGYO>// make it a part of the same item tree as 'this'."": 1}",1.0,{}
188,16502.0,5.0,31.0,6.0,MERGED,True,https://codereview.qt-project.org/#/c/16502,testrunner: add --sync-output option for parallel tests,1.0,"{""# flush so we print as much as possible if we're killed without completing"": 3}",1.0,"{""# Callback for Proc::Reliable which simply prints to the given handle (i.e. non-capturing).<KAIGYO># flush so we print as much as possible if we're killed without completing"": 3}",1.0,{}
187,16503.0,3.0,17.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/16503,Flicking a pathview with large delegate spacing is inconsistent,1.0,{},0.0,{'//XXX maybe do recursively at increasing resolution.': 1},1.0,{}
290,16778.0,9.0,13.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/16778,restore previously non-working disabled test,1.0,{},0.0,{'//TODO: For some reson setting a record using manual submit fails<KAIGYO>//model.setEditStrategy(QSqlTableModel::OnManualSubmit);': 1},1.0,{}
305,16846.0,2.0,7.0,1.0,MERGED,True,https://codereview.qt-project.org/#/c/16846,Modify helper functions to remove embedded QSKIP call and return status.,1.0,{'// TODO make it a QMimeDatabase method?': 1},1.0,{'// TODO make it a QMimeDatabase method?': 1},1.0,{}
388,16933.0,7.0,19.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/16933,Add further theme hints to QPlatformTheme.,1.0,{},0.0,{'// ## TODO: detect these': 3},1.0,{}
373,16980.0,2.0,7.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/16980,Reduce the size of QQuickTextInputPrivate.,1.0,{},0.0,{'// XXX todo - not in 4.8?': 1},1.0,{}
389,16995.0,7.0,38.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/16995,Separate view transition functionality into new file,1.0,"{'// if item is not already moving somewhere, set it to not move anywhere<KAIGYO>// so that removed items do not move to the default (0,0)': 1}",1.0,"{'// if item is not already moving somewhere, set it to not move anywhere<KAIGYO>// so that removed items do not move to the default (0,0)': 1}",1.0,{}
64,17155.0,1.0,4.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/17155,parse_build_log.pl: extract test failures during `nmake check',1.0,"{'# maybe has .exe on the end on Windows': 1, '# nmake: testrunner.BAT non-zero exit code is irrelevant, and maybe confusing to some.<KAIGYO># Only the test itself has relevant output.': 1}",1.0,"{'#                   never matches for top-level make<KAIGYO>#   errorlevel  -   the error number, e.g. """" (not always available)<KAIGYO>#   nmake probably doesn\'t work right.': 1, '# maybe has .exe on the end on Windows': 1}",1.0,{}
368,17696.0,11.0,48.0,13.0,MERGED,True,https://codereview.qt-project.org/#/c/17696,Split up base class QFileDevice for open-file operations (read/write),1.0,"{'/*!<KAIGYO>    \\enum QFileDevice::Permission<KAIGYO><KAIGYO>    This enum is used by the permission() function to report the<KAIGYO>    permissions and ownership of a file. The values may be OR-ed<KAIGYO>    together to test multiple permissions and ownership values.<KAIGYO><KAIGYO>    \\value ReadOwner The file is readable by the owner of the file.<KAIGYO>    \\value WriteOwner The file is writable by the owner of the file.<KAIGYO>    \\value ExeOwner The file is executable by the owner of the file.<KAIGYO>    \\value ReadUser The file is readable by the user.<KAIGYO>    \\value WriteUser The file is writable by the user.<KAIGYO>    \\value ExeUser The file is executable by the user.<KAIGYO>    \\value ReadGroup The file is readable by the group.<KAIGYO>    \\value WriteGroup The file is writable by the group.<KAIGYO>    \\value ExeGroup The file is executable by the group.<KAIGYO>    \\value ReadOther The file is readable by anyone.<KAIGYO>    \\value WriteOther The file is writable by anyone.<KAIGYO>    \\value ExeOther The file is executable by anyone.<KAIGYO><KAIGYO>    \\warning Because of differences in the platforms supported by Qt,<KAIGYO>    the semantics of ReadUser, WriteUser and ExeUser are<KAIGYO>    platform-dependent: On Unix, the rights of the owner of the file<KAIGYO>    are returned and on Windows the rights of the current user are<KAIGYO>    returned. This behavior might change in a future Qt version.<KAIGYO><KAIGYO>    Note that Qt does not by default check for permissions on NTFS<KAIGYO>    file systems, as this may decrease the performance of file<KAIGYO>    handling considerably. It is possible to force permission checking<KAIGYO>    on NTFS by including the following code in your source:<KAIGYO><KAIGYO>    \\snippet doc/src/snippets/ntfsp.cpp 0<KAIGYO><KAIGYO>    Permission checking is then turned on and off by incrementing and<KAIGYO>    decrementing \\c qt_ntfs_permission_lookup by 1.<KAIGYO><KAIGYO>    \\snippet doc/src/snippets/ntfsp.cpp 1<KAIGYO>*/': 1, '// If the file engine knows best, say what it says.': 1, '// Write directly to the engine if the block size is larger than<KAIGYO>// the write buffer size.': 1}",1.0,"{'/*!<KAIGYO>    \\enum QFile::Permission<KAIGYO><KAIGYO>    This enum is used by the permission() function to report the<KAIGYO>    permissions and ownership of a file. The values may be OR-ed<KAIGYO>    together to test multiple permissions and ownership values.<KAIGYO><KAIGYO>    \\value ReadOwner The file is readable by the owner of the file.<KAIGYO>    \\value WriteOwner The file is writable by the owner of the file.<KAIGYO>    \\value ExeOwner The file is executable by the owner of the file.<KAIGYO>    \\value ReadUser The file is readable by the user.<KAIGYO>    \\value WriteUser The file is writable by the user.<KAIGYO>    \\value ExeUser The file is executable by the user.<KAIGYO>    \\value ReadGroup The file is readable by the group.<KAIGYO>    \\value WriteGroup The file is writable by the group.<KAIGYO>    \\value ExeGroup The file is executable by the group.<KAIGYO>    \\value ReadOther The file is readable by anyone.<KAIGYO>    \\value WriteOther The file is writable by anyone.<KAIGYO>    \\value ExeOther The file is executable by anyone.<KAIGYO><KAIGYO>    \\warning Because of differences in the platforms supported by Qt,<KAIGYO>    the semantics of ReadUser, WriteUser and ExeUser are<KAIGYO>    platform-dependent: On Unix, the rights of the owner of the file<KAIGYO>    are returned and on Windows the rights of the current user are<KAIGYO>    returned. This behavior might change in a future Qt version.<KAIGYO><KAIGYO>    Note that Qt does not by default check for permissions on NTFS<KAIGYO>    file systems, as this may decrease the performance of file<KAIGYO>    handling considerably. It is possible to force permission checking<KAIGYO>    on NTFS by including the following code in your source:<KAIGYO><KAIGYO>    \\snippet doc/src/snippets/ntfsp.cpp 0<KAIGYO><KAIGYO>    Permission checking is then turned on and off by incrementing and<KAIGYO>    decrementing \\c qt_ntfs_permission_lookup by 1.<KAIGYO><KAIGYO>    \\snippet doc/src/snippets/ntfsp.cpp 1<KAIGYO>*/': 1, '// If the file engine knows best, say what it says.': 1, '// Write directly to the engine if the block size is larger than<KAIGYO>// the write buffer size.': 1}",1.0,{}
339,17731.0,1.0,1.0,0.0,ABANDONED,False,https://codereview.qt-project.org/#/c/17731,Add further theme hints to QPlatformTheme.,1.0,{},0.0,{'// ## TODO: detect these': 1},1.0,{}
428,17841.0,5.0,23.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/17841,"Improved transitions for Row, Column, Grid, Flow",1.0,"{""// If item is not already moving somewhere, set it to not move anywhere.<KAIGYO>// This ensures that removed targets don't transition to the default (0,0) and that<KAIGYO>// items set for other transition types only transition if they actually move somewhere."": 1, ""// just queue the item for a move-type displace - if the item hasn't<KAIGYO>// moved anywhere, it won't be transitioned anyway"": 1, '// adjust expectedDisplacedIndexes to their final values after the move': 1, '// XXX fetch from qml?': 1}",1.0,"{'// if item is not already moving somewhere, set it to not move anywhere<KAIGYO>// so that removed items do not move to the default (0,0)': 1}",1.0,{}
13,18005.0,1.0,3.0,0.0,ABANDONED,False,https://codereview.qt-project.org/#/c/18005,Moved opengl/pbuffers2 example from qtbase to qtsvg,1.0,{},0.0,"{'// rendering directly to a texture is not supported on X11 and<KAIGYO>// some Windows implementations, unfortunately': 1}",1.0,{}
41,18117.0,1.0,8.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/18117,Remove qhash_faster.,1.0,{},0.0,"{'// Faster, but probably less spread.': 1}",1.0,{}
75,18208.0,1.0,8.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/18208,Remove internal class QVolatileImage.,1.0,{},0.0,{'/*!<KAIGYO>  Access to pixel data via bits() or constBits() should be guarded by<KAIGYO>  begin/endDataAccess().<KAIGYO> */': 1},1.0,{}
221,18515.0,3.0,12.0,1.0,MERGED,True,https://codereview.qt-project.org/#/c/18515,Continue refactor of Canvas rendering.,1.0,{},0.0,{'// ?? || Coop<KAIGYO>// Add to the update list in SG<KAIGYO>// FIXME<KAIGYO>// On SG render thread': 1},1.0,{}
349,18882.0,3.0,11.0,2.0,MERGED,True,https://codereview.qt-project.org/#/c/18882,parse_build_log.pl: Ignores more gdb errors that are flagged.,1.0,{},0.0,"{'# Output any autotest failures first.<KAIGYO># FIXME: outputting these first can mean that an autotest failure is printed<KAIGYO># earlier than some other extracted message, even if in reality they appeared<KAIGYO># in the opposite order.  Should we care about this?  Or is this a better<KAIGYO># way to do it?': 1}",1.0,{}
377,18965.0,1.0,9.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/18965,Fix double click handling.,1.0,{},0.0,"{""//### there's a lot of duplicated logic here -- refactoring required!"": 1}",1.0,{}
391,18988.0,10.0,17.0,4.0,MERGED,True,https://codereview.qt-project.org/#/c/18988,QmlEngineDebugService: Rename service to QmlDebugger,1.0,{'// TODO test complex types': 1},1.0,{'// TODO test complex types': 1},1.0,{}
66,19079.0,2.0,5.0,2.0,MERGED,True,https://codereview.qt-project.org/#/c/19079,misc: Fix some random typos and grammar while reading code.,1.0,{'// In Qt5 after modularization project these types where moved to a separate module (and ids were downgraded)<KAIGYO>// and as a result these types received lower ids too<KAIGYO>// In Qt5 after modularization project these types where moved to a separate module (and ids were downgraded)<KAIGYO>// and as a result these types received lower ids too': 2},1.0,{'// In Qt5 after modularization project this types where moved to a separate module (and ids were downgraded)<KAIGYO>// and as a result this types recieved lower ids too<KAIGYO>// In Qt5 after modularization project this types where moved to a separate module (and ids were downgraded)<KAIGYO>// and as a result this types recieved lower ids too': 2},1.0,{}
82,19117.0,2.0,11.0,3.0,ABANDONED,False,https://codereview.qt-project.org/#/c/19117,Remove QJS exception API,1.0,"{'// clear exception state...<KAIGYO>// ### No way to check whether setProperty() threw an exception<KAIGYO>//    QVERIFY(eng.hasUncaughtException());<KAIGYO>//    QCOMPARE(eng.uncaughtException().toString(), QLatin1String(""""));': 1}",1.0,"{'// FIXME it should not happen (SetCaptureStackTraceForUncaughtExceptions is called).': 1, '// QEXPECT_FAIL("""", Abort);<KAIGYO>// ###FIXME: no uncahgutExceptionBacktrace: QCOMPARE(eng.uncaughtExceptionBacktrace(), backtrace);': 1, '// ###FIXME: No uncaughtExceptionBacktrace:  QCOMPARE(eng.uncaughtExceptionBacktrace(), backtrace);': 1, '// ###FIXME: No uncaughtExceptionBacktrace:  QVERIFY(eng.uncaughtExceptionBacktrace().isEmpty());': 1}",1.0,{}
99,19186.0,1.0,5.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/19186,Remove QAccessible2::TableModelChange.,1.0,{},0.0,{'// FIXME': 1},1.0,{}
108,19190.0,1.0,3.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/19190,Merge remote-tracking branch 'origin/master' into api_changes,1.0,{},0.0,"{'/*!<KAIGYO>    \\class QQmlImageProvider<KAIGYO>    \\since 4.7<KAIGYO>    \\brief The QQmlImageProvider class provides an interface for supporting pixmaps and threaded image requests in QML.<KAIGYO><KAIGYO>    QQmlImageProvider is used to provide advanced image loading features<KAIGYO>    in QML applications. It allows images in QML to be:<KAIGYO><KAIGYO>    \\list<KAIGYO>    \\o Loaded using QPixmaps rather than actual image files<KAIGYO>    \\o Loaded asynchronously in a separate thread, if imageType() is \\l{QQmlImageProvider::ImageType}{ImageType::Image}<KAIGYO>    \\endlist<KAIGYO><KAIGYO>    To specify that an image should be loaded by an image provider, use the<KAIGYO>    \\bold {""""} scheme for the URL source of the image, followed by the <KAIGYO>    identifiers of the image provider and the requested image. For example:<KAIGYO><KAIGYO>    \\qml<KAIGYO>    Image { source: """" }<KAIGYO>    \\endqml<KAIGYO><KAIGYO>    This specifies that the image should be loaded by the image provider named <KAIGYO>    """". The QML engine <KAIGYO>    invokes the appropriate image provider according to the providers that have<KAIGYO>    been registered through QQmlEngine::addImageProvider().<KAIGYO><KAIGYO>    Note that the identifiers are case-insensitive, but the rest of the URL will be passed on with<KAIGYO>    preserved case. For example, the below snippet would still specify that the image is loaded by the<KAIGYO>    image provider named """", but it would request a different image than the above snippet<KAIGYO>    ("""").<KAIGYO>    \\qml<KAIGYO>    Image { source: """" }<KAIGYO>    \\endqml<KAIGYO><KAIGYO>    If you want the rest of the URL to be case insensitive, you will have to take care<KAIGYO>    of that yourself inside your image provider.<KAIGYO><KAIGYO>    \\section2 An example<KAIGYO><KAIGYO>    Here are two images. Their \\c source values indicate they should be loaded by<KAIGYO>    an image provider named """"<KAIGYO>    and """", respectively:<KAIGYO><KAIGYO>    \\snippet examples/declarative/cppextensions/imageprovider/imageprovider-example.qml 0<KAIGYO><KAIGYO>    When these images are loaded by QML, it looks for a matching image provider<KAIGYO>    and calls its requestImage() or requestPixmap() method (depending on its<KAIGYO>    imageType()) to load the image. The method is called with the \\c id <KAIGYO>    parameter set to """" for the second.<KAIGYO><KAIGYO>    Here is an image provider implementation that can load the images <KAIGYO>    requested by the above QML. This implementation dynamically <KAIGYO>    generates QPixmap images that are filled with the requested color:<KAIGYO><KAIGYO>    \\snippet examples/declarative/cppextensions/imageprovider/imageprovider.cpp 0<KAIGYO>    \\codeline<KAIGYO>    \\snippet examples/declarative/cppextensions/imageprovider/imageprovider.cpp 1<KAIGYO><KAIGYO>    To make this provider accessible to QML, it is registered with the QML engine<KAIGYO>    with a """" identifier:<KAIGYO><KAIGYO>    \\code<KAIGYO>    int main(int argc, char *argv[]) <KAIGYO>    {<KAIGYO>        ...<KAIGYO><KAIGYO>        QQmlEngine engine;<KAIGYO>        engine->addImageProvider(QLatin1String(""""), new ColorPixmapProvider);<KAIGYO><KAIGYO>        ...<KAIGYO>    }<KAIGYO>    \\endcode<KAIGYO><KAIGYO>    Now the images can be successfully loaded in QML:<KAIGYO><KAIGYO>    \\image imageprovider.png<KAIGYO><KAIGYO>    A complete example is available in Qt\'s <KAIGYO>    \\l {declarative/cppextensions/imageprovider}{examples/declarative/cppextensions/imageprovider}<KAIGYO>    directory. Note the example registers the provider via a \\l{QQmlExtensionPlugin}{plugin}<KAIGYO>    instead of registering it in the application \\c main() function as shown above.<KAIGYO><KAIGYO><KAIGYO>    \\section2 Asynchronous image loading<KAIGYO><KAIGYO>    Image providers that support QImage loading automatically include support<KAIGYO>    for asychronous loading of images. To enable asynchronous loading for an<KAIGYO>    image source, set the \\c asynchronous property to \\c true for the relevant<KAIGYO>    \\l Image, \\l BorderImage or \\l AnimatedImage object. When this is enabled, <KAIGYO>    the image request to the provider is run in a low priority thread,<KAIGYO>    allowing image loading to be executed in the background, and reducing the<KAIGYO>    performance impact on the user interface.<KAIGYO><KAIGYO>    Asynchronous loading is not supported for image providers that provide<KAIGYO>    QPixmap rather than QImage values, as pixmaps can only be created in the<KAIGYO>    main thread. In this case, if \\l {Image::}{asynchronous} is set to <KAIGYO>    \\c true, the value is ignored and the image is loaded<KAIGYO>    synchronously.<KAIGYO><KAIGYO><KAIGYO>    \\section2 Image caching<KAIGYO><KAIGYO>    Images returned by a QQmlImageProvider are automatically cached,<KAIGYO>    similar to any image loaded by the QML engine. When an image with a<KAIGYO>    """" prefix is loaded from cache, requestImage() and requestPixmap()<KAIGYO>    will not be called for the relevant image provider. If an image should always<KAIGYO>    be fetched from the image provider, and should not be cached at all, set the<KAIGYO>    \\c cache property to \\c false for the relevant \\l Image, \\l BorderImage or<KAIGYO>    \\l AnimatedImage object.<KAIGYO><KAIGYO>    \\sa QQmlEngine::addImageProvider()<KAIGYO>*/': 1}",1.0,{}
167,19207.0,4.0,16.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/19207,Displaced items were moving unnecessarily,1.0,"{""// If item is not already moving somewhere, set it to not move anywhere.<KAIGYO>// This ensures that removed targets don't transition to the default (0,0) and that<KAIGYO>// items set for other transition types only transition if they actually move somewhere."": 1, '// longer-lasting bounce to trigger bug': 1}",1.0,"{""// If item is not already moving somewhere, set it to not move anywhere.<KAIGYO>// This ensures that removed targets don't transition to the default (0,0) and that<KAIGYO>// items set for other transition types only transition if they actually move somewhere."": 1, '// if item is not already moving somewhere, set it to not move anywhere<KAIGYO>// so that removed items do not move to the default (0,0)': 2}",1.0,{}
231,19347.0,7.0,21.0,112.0,MERGED,True,https://codereview.qt-project.org/#/c/19347,QmlProfiler: updated standalone app,1.0,{'// move to next block': 1},1.0,"{'// move to next block': 1, '// move the buffered data to the details cache': 1}",1.0,{}
330,19520.0,2.0,9.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/19520,Rename blackberry QPA plugin to QNX,1.0,{'// move the platform window to the platform screen': 1},1.0,{'// move the platform window to the platform screen': 1},1.0,{}
394,19823.0,3.0,8.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/19823,QmlEngineDebug: Simplify the utility classes,1.0,{'// TODO test complex types': 1},1.0,{'// TODO test complex types': 1},1.0,{}
399,19856.0,2.0,4.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/19856,Add active and invisible states for accessibility.,1.0,{},0.0,{'// FIXME': 1},1.0,{}
435,19876.0,7.0,11.0,3.0,MERGED,True,https://codereview.qt-project.org/#/c/19876,Fix context2d transform issues,1.0,"{'//FIXME:This function should be moved to QQuickContext2D::drawImage(...)': 4, '//FIXME:lineJoin with miterLimit test fail!<KAIGYO>//verify(Helper.comparePixel(ctx, 50,25, 0,255,0,255));': 4, '           /*FIXME: from: httpwww.w3.org/TR/2dcontext/#dom-context-2d-arc<KAIGYO>           If the anticlockwise argument is omitted or false and endAngle-startAngle is equal to or greater than 2π, or, if the anticlockwise argument is true and startAngle-endAngle is equal to or greater than 2π, then the arc is the whole circumference of this circle.<KAIGYO>           */': 5, '//FIXME:still different behavior from browsers, > 2pi span issue<KAIGYO>//verify(Helper.comparePixel(ctx, 50,20, 0,255,0,255));': 5, '//FIXME<KAIGYO>//FIXME<KAIGYO>//verify(Helper.comparePixel(ctx,  1,1, 0,255,0,255));': 6, '//FIXME<KAIGYO>//verify(Helper.comparePixel(ctx, 50,25, 0,127,191,255, 5));<KAIGYO>//FIXME<KAIGYO>//verify(Helper.comparePixel(ctx, 50,25, 0,0,0,0, 5));<KAIGYO>//FIXME<KAIGYO>//verify(Helper.comparePixel(ctx, 50,25, 0,0,0,0, 5));<KAIGYO>//FIXME<KAIGYO>//verify(Helper.comparePixel(ctx, 50,25, 0,0,0,0, 5));<KAIGYO>//FIXME<KAIGYO>//verify(Helper.comparePixel(ctx, 50,25, 0,0,0,0, 5));<KAIGYO>//FIXME<KAIGYO>//verify(Helper.comparePixel(ctx, 50,25, 0,0,0,0, 5));': 6}",1.0,"{'           /*FIXME:<KAIGYO>           actual  :[255,0,0,255]<KAIGYO>           expected:[0,255,0,255] +/- 0<KAIGYO>           */': 5}",1.0,{}
436,19958.0,2.0,15.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/19958,Improve accessibility test to handle more text events.,1.0,{'// FIXME check what extra events are around and get rid of them': 1},1.0,"{""//    QTestEventList keys;<KAIGYO>//    keys.addKeyClick('D');<KAIGYO>//    keys.addKeyClick('E');<KAIGYO>//    keys.addKeyClick(Qt::Key_Left);<KAIGYO>//    keys.addKeyClick(Qt::Key_Left);<KAIGYO>//    keys.addKeyClick('C');<KAIGYO>//    keys.addKeyClick('O');<KAIGYO>//    keys.simulate(lineEdit);<KAIGYO>//    FIXME: Test key press events..."": 1}",1.0,{}
455,19981.0,1.0,4.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/19981,Let V8 throw the exception when QML property lookup fails,1.0,{},0.0,{'// These warnings should not happen once QTBUG-21864 is fixed': 1},1.0,{}
30,20007.0,2.0,11.0,2.0,MERGED,True,https://codereview.qt-project.org/#/c/20007,"Remove the dbus build-tools, CMake config files and tests.",1.0,{},0.0,"{""/*!<KAIGYO>    \\page qdbusxml2cpp.html<KAIGYO>    \\title QtDBus XML compiler (qdbusxml2cpp)<KAIGYO>    \\keyword qdbusxml2cpp<KAIGYO><KAIGYO>    The QtDBus XML compiler is a tool that can be used to parse interface descriptions and produce<KAIGYO>    static code representing those interfaces, which can then be used to make calls to remote<KAIGYO>    objects or implement said interfaces.<KAIGYO><KAIGYO>    \\c qdbusxml2cpp has two modes of operation, that correspond to the two possible outputs it can<KAIGYO>    produce: the interface (proxy) class or the adaptor class. The latter consists of both a C++<KAIGYO>    header and a source file, which are meant to be edited and adapted to your needs.<KAIGYO><KAIGYO>    The \\c qdbusxml2cpp tool is not meant to be run every time you compile your<KAIGYO>    application. Instead, it's meant to be used when developing the code or when the interface<KAIGYO>    changes.<KAIGYO><KAIGYO>    The adaptor classes generated by \\c qdbusxml2cpp are just a skeleton that must be completed. It<KAIGYO>    generates, by default, calls to slots with the same name on the object the adaptor is attached<KAIGYO>    to. However, you may modify those slots or the property accessor functions to suit your needs.<KAIGYO>*/"": 1}",1.0,{}
8,20029.0,2.0,8.0,1.0,MERGED,True,https://codereview.qt-project.org/#/c/20029,QSharedPointer: remove two emtpy functions.,1.0,{},0.0,"{'// Qt 4.5 compatibility<KAIGYO>// this function is broken by design, so it was replaced with internalSafetyCheckAdd2<KAIGYO>//<KAIGYO>// it\'s broken because we tracked the pointers added and<KAIGYO>// removed from QSharedPointer, converted to void*.<KAIGYO>// That is, this is supposed to track the """" pointer in<KAIGYO>// case of multiple inheritance.<KAIGYO>//<KAIGYO>// However, it doesn\'t work well in some compilers:<KAIGYO>// if you create an object with a class of type A and the last reference<KAIGYO>// is dropped of type B, then the value passed to internalSafetyCheckRemove could<KAIGYO>// be different than was added. That would leave dangling addresses.<KAIGYO>//<KAIGYO>// So instead, we track the pointer by the d-pointer instead.': 1}",1.0,{}
74,20154.0,2.0,14.0,0.0,ABANDONED,False,https://codereview.qt-project.org/#/c/20154,Merge remote-tracking branch 'origin/master' into api_changes,1.0,{},0.0,"{'/*!<KAIGYO>    \\class QQmlImageProvider<KAIGYO>    \\since 4.7<KAIGYO>    \\brief The QQmlImageProvider class provides an interface for supporting pixmaps and threaded image requests in QML.<KAIGYO><KAIGYO>    QQmlImageProvider is used to provide advanced image loading features<KAIGYO>    in QML applications. It allows images in QML to be:<KAIGYO><KAIGYO>    \\list<KAIGYO>    \\li Loaded using QPixmaps rather than actual image files<KAIGYO>    \\li Loaded asynchronously in a separate thread, if imageType() is \\l{QQmlImageProvider::ImageType}{ImageType::Image}<KAIGYO>    \\endlist<KAIGYO><KAIGYO>    To specify that an image should be loaded by an image provider, use the<KAIGYO>    \\b {""""} scheme for the URL source of the image, followed by the<KAIGYO>    identifiers of the image provider and the requested image. For example:<KAIGYO><KAIGYO>    \\qml<KAIGYO>    Image { source: """" }<KAIGYO>    \\endqml<KAIGYO><KAIGYO>    This specifies that the image should be loaded by the image provider named <KAIGYO>    """". The QML engine <KAIGYO>    invokes the appropriate image provider according to the providers that have<KAIGYO>    been registered through QQmlEngine::addImageProvider().<KAIGYO><KAIGYO>    Note that the identifiers are case-insensitive, but the rest of the URL will be passed on with<KAIGYO>    preserved case. For example, the below snippet would still specify that the image is loaded by the<KAIGYO>    image provider named """", but it would request a different image than the above snippet<KAIGYO>    ("""").<KAIGYO>    \\qml<KAIGYO>    Image { source: """" }<KAIGYO>    \\endqml<KAIGYO><KAIGYO>    If you want the rest of the URL to be case insensitive, you will have to take care<KAIGYO>    of that yourself inside your image provider.<KAIGYO><KAIGYO>    \\section2 An example<KAIGYO><KAIGYO>    Here are two images. Their \\c source values indicate they should be loaded by<KAIGYO>    an image provider named """"<KAIGYO>    and """", respectively:<KAIGYO><KAIGYO>    \\snippet examples/declarative/cppextensions/imageprovider/imageprovider-example.qml 0<KAIGYO><KAIGYO>    When these images are loaded by QML, it looks for a matching image provider<KAIGYO>    and calls its requestImage() or requestPixmap() method (depending on its<KAIGYO>    imageType()) to load the image. The method is called with the \\c id <KAIGYO>    parameter set to """" for the second.<KAIGYO><KAIGYO>    Here is an image provider implementation that can load the images <KAIGYO>    requested by the above QML. This implementation dynamically <KAIGYO>    generates QPixmap images that are filled with the requested color:<KAIGYO><KAIGYO>    \\snippet examples/declarative/cppextensions/imageprovider/imageprovider.cpp 0<KAIGYO>    \\codeline<KAIGYO>    \\snippet examples/declarative/cppextensions/imageprovider/imageprovider.cpp 1<KAIGYO><KAIGYO>    To make this provider accessible to QML, it is registered with the QML engine<KAIGYO>    with a """" identifier:<KAIGYO><KAIGYO>    \\code<KAIGYO>    int main(int argc, char *argv[]) <KAIGYO>    {<KAIGYO>        ...<KAIGYO><KAIGYO>        QQmlEngine engine;<KAIGYO>        engine->addImageProvider(QLatin1String(""""), new ColorPixmapProvider);<KAIGYO><KAIGYO>        ...<KAIGYO>    }<KAIGYO>    \\endcode<KAIGYO><KAIGYO>    Now the images can be successfully loaded in QML:<KAIGYO><KAIGYO>    \\image imageprovider.png<KAIGYO><KAIGYO>    A complete example is available in Qt\'s <KAIGYO>    \\l {declarative/cppextensions/imageprovider}{examples/declarative/cppextensions/imageprovider}<KAIGYO>    directory. Note the example registers the provider via a \\l{QQmlExtensionPlugin}{plugin}<KAIGYO>    instead of registering it in the application \\c main() function as shown above.<KAIGYO><KAIGYO><KAIGYO>    \\section2 Asynchronous image loading<KAIGYO><KAIGYO>    Image providers that support QImage loading automatically include support<KAIGYO>    for asychronous loading of images. To enable asynchronous loading for an<KAIGYO>    image source, set the \\c asynchronous property to \\c true for the relevant<KAIGYO>    \\l Image, \\l BorderImage or \\l AnimatedImage object. When this is enabled, <KAIGYO>    the image request to the provider is run in a low priority thread,<KAIGYO>    allowing image loading to be executed in the background, and reducing the<KAIGYO>    performance impact on the user interface.<KAIGYO><KAIGYO>    Asynchronous loading is not supported for image providers that provide<KAIGYO>    QPixmap rather than QImage values, as pixmaps can only be created in the<KAIGYO>    main thread. In this case, if \\l {Image::}{asynchronous} is set to <KAIGYO>    \\c true, the value is ignored and the image is loaded<KAIGYO>    synchronously.<KAIGYO><KAIGYO><KAIGYO>    \\section2 Image caching<KAIGYO><KAIGYO>    Images returned by a QQmlImageProvider are automatically cached,<KAIGYO>    similar to any image loaded by the QML engine. When an image with a<KAIGYO>    """" prefix is loaded from cache, requestImage() and requestPixmap()<KAIGYO>    will not be called for the relevant image provider. If an image should always<KAIGYO>    be fetched from the image provider, and should not be cached at all, set the<KAIGYO>    \\c cache property to \\c false for the relevant \\l Image, \\l BorderImage or<KAIGYO>    \\l AnimatedImage object.<KAIGYO><KAIGYO>    \\sa QQmlEngine::addImageProvider()<KAIGYO>*/': 1}",1.0,{}
119,20164.0,4.0,10.0,6.0,ABANDONED,False,https://codereview.qt-project.org/#/c/20164,*** QItemDelegate - fix minor issue in setEditorData/setModelData ***,1.0,"{""// A needed work-around. QDateTimeEdit does have a USER (true) property,<KAIGYO>// but it is not well working with QTime and QDate<KAIGYO>// Providing QTimeEdit and QDateEdit with a new USER (true) property<KAIGYO>// might not be a good idea since they inherit QDateTimeEdit<KAIGYO>// (and it actually won't even solve everything -<KAIGYO>// since they will become incompatible with datatime)<KAIGYO>// To use and preserve the variant data type in the we do the following"": 1, '// should happen at doCloseEditor. We only test this once.': 2}",1.0,"{'// ### Qt 5: remove<KAIGYO>// A work-around for missing """" in qdatetimeedit.h for<KAIGYO>// QTimeEdit\'s time property and QDateEdit\'s date property.<KAIGYO>// It only triggers if the default user property """" is<KAIGYO>// reported for QTimeEdit and QDateEdit.': 1}",1.0,{}
93,20228.0,2.0,14.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/20228,Sprite minor fixes,1.0,{'//TODO: Implicitly size element to size of first sprite? or currentSprite?': 1},1.0,{'//TODO: Implicitly size element to size of first sprite?': 1},1.0,{}
129,20337.0,6.0,6.0,0.0,ABANDONED,False,https://codereview.qt-project.org/#/c/20337,WIP: Partial revert of mouse event synthesis in QQuickCanvas,1.0,{},0.0,{'//take care of any exits': 1},1.0,{}
185,20459.0,1.0,3.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/20459,Merge master into api_changes,1.0,{},0.0,"{'/*!<KAIGYO>    \\class QQmlImageProvider<KAIGYO>    \\since 4.7<KAIGYO>    \\brief The QQmlImageProvider class provides an interface for supporting pixmaps and threaded image requests in QML.<KAIGYO><KAIGYO>    QQmlImageProvider is used to provide advanced image loading features<KAIGYO>    in QML applications. It allows images in QML to be:<KAIGYO><KAIGYO>    \\list<KAIGYO>    \\li Loaded using QPixmaps rather than actual image files<KAIGYO>    \\li Loaded asynchronously in a separate thread, if imageType() is \\l{QQmlImageProvider::ImageType}{ImageType::Image}<KAIGYO>    \\endlist<KAIGYO><KAIGYO>    To specify that an image should be loaded by an image provider, use the<KAIGYO>    \\b {""""} scheme for the URL source of the image, followed by the<KAIGYO>    identifiers of the image provider and the requested image. For example:<KAIGYO><KAIGYO>    \\qml<KAIGYO>    Image { source: """" }<KAIGYO>    \\endqml<KAIGYO><KAIGYO>    This specifies that the image should be loaded by the image provider named <KAIGYO>    """". The QML engine <KAIGYO>    invokes the appropriate image provider according to the providers that have<KAIGYO>    been registered through QQmlEngine::addImageProvider().<KAIGYO><KAIGYO>    Note that the identifiers are case-insensitive, but the rest of the URL will be passed on with<KAIGYO>    preserved case. For example, the below snippet would still specify that the image is loaded by the<KAIGYO>    image provider named """", but it would request a different image than the above snippet<KAIGYO>    ("""").<KAIGYO>    \\qml<KAIGYO>    Image { source: """" }<KAIGYO>    \\endqml<KAIGYO><KAIGYO>    If you want the rest of the URL to be case insensitive, you will have to take care<KAIGYO>    of that yourself inside your image provider.<KAIGYO><KAIGYO>    \\section2 An example<KAIGYO><KAIGYO>    Here are two images. Their \\c source values indicate they should be loaded by<KAIGYO>    an image provider named """"<KAIGYO>    and """", respectively:<KAIGYO><KAIGYO>    \\snippet examples/declarative/cppextensions/imageprovider/imageprovider-example.qml 0<KAIGYO><KAIGYO>    When these images are loaded by QML, it looks for a matching image provider<KAIGYO>    and calls its requestImage() or requestPixmap() method (depending on its<KAIGYO>    imageType()) to load the image. The method is called with the \\c id <KAIGYO>    parameter set to """" for the second.<KAIGYO><KAIGYO>    Here is an image provider implementation that can load the images <KAIGYO>    requested by the above QML. This implementation dynamically <KAIGYO>    generates QPixmap images that are filled with the requested color:<KAIGYO><KAIGYO>    \\snippet examples/declarative/cppextensions/imageprovider/imageprovider.cpp 0<KAIGYO>    \\codeline<KAIGYO>    \\snippet examples/declarative/cppextensions/imageprovider/imageprovider.cpp 1<KAIGYO><KAIGYO>    To make this provider accessible to QML, it is registered with the QML engine<KAIGYO>    with a """" identifier:<KAIGYO><KAIGYO>    \\code<KAIGYO>    int main(int argc, char *argv[]) <KAIGYO>    {<KAIGYO>        ...<KAIGYO><KAIGYO>        QQmlEngine engine;<KAIGYO>        engine->addImageProvider(QLatin1String(""""), new ColorPixmapProvider);<KAIGYO><KAIGYO>        ...<KAIGYO>    }<KAIGYO>    \\endcode<KAIGYO><KAIGYO>    Now the images can be successfully loaded in QML:<KAIGYO><KAIGYO>    \\image imageprovider.png<KAIGYO><KAIGYO>    A complete example is available in Qt\'s <KAIGYO>    \\l {declarative/cppextensions/imageprovider}{examples/declarative/cppextensions/imageprovider}<KAIGYO>    directory. Note the example registers the provider via a \\l{QQmlExtensionPlugin}{plugin}<KAIGYO>    instead of registering it in the application \\c main() function as shown above.<KAIGYO><KAIGYO><KAIGYO>    \\section2 Asynchronous image loading<KAIGYO><KAIGYO>    Image providers that support QImage loading automatically include support<KAIGYO>    for asychronous loading of images. To enable asynchronous loading for an<KAIGYO>    image source, set the \\c asynchronous property to \\c true for the relevant<KAIGYO>    \\l Image, \\l BorderImage or \\l AnimatedImage object. When this is enabled, <KAIGYO>    the image request to the provider is run in a low priority thread,<KAIGYO>    allowing image loading to be executed in the background, and reducing the<KAIGYO>    performance impact on the user interface.<KAIGYO><KAIGYO>    Asynchronous loading is not supported for image providers that provide<KAIGYO>    QPixmap rather than QImage values, as pixmaps can only be created in the<KAIGYO>    main thread. In this case, if \\l {Image::}{asynchronous} is set to <KAIGYO>    \\c true, the value is ignored and the image is loaded<KAIGYO>    synchronously.<KAIGYO><KAIGYO><KAIGYO>    \\section2 Image caching<KAIGYO><KAIGYO>    Images returned by a QQmlImageProvider are automatically cached,<KAIGYO>    similar to any image loaded by the QML engine. When an image with a<KAIGYO>    """" prefix is loaded from cache, requestImage() and requestPixmap()<KAIGYO>    will not be called for the relevant image provider. If an image should always<KAIGYO>    be fetched from the image provider, and should not be cached at all, set the<KAIGYO>    \\c cache property to \\c false for the relevant \\l Image, \\l BorderImage or<KAIGYO>    \\l AnimatedImage object.<KAIGYO><KAIGYO>    \\sa QQmlEngine::addImageProvider()<KAIGYO>*/': 1}",1.0,{}
319,20590.0,12.0,19.0,7.0,ABANDONED,False,https://codereview.qt-project.org/#/c/20590,Allow platform specific font matching,1.0,"{'// Make defaultFont pattern matching locale language aware, because<KAIGYO>// certain FC_LANG based custom rules may happen in FcConfigSubstitute()': 11, '// Hack to get system default language until FcGetDefaultLangs()<KAIGYO>// is exported (httpsbugs.freedesktop.org/show_bug.cgi?id=32853)<KAIGYO>// or httpsbugs.freedesktop.org/show_bug.cgi?id=35482 is fixed': 11}",1.0,"{'// Hack to get system default language until FcGetDefaultLangs()<KAIGYO>// is exported (httpsbugs.freedesktop.org/show_bug.cgi?id=32853)<KAIGYO>// or httpsbugs.freedesktop.org/show_bug.cgi?id=35482 is fixed': 11, '// Make defaultFont pattern matching locale language aware, because<KAIGYO>// certain FC_LANG based custom rules may happen in FcConfigSubstitute()': 11}",1.0,{}
372,20863.0,7.0,30.0,6.0,MERGED,True,https://codereview.qt-project.org/#/c/20863,Add USER properties to QDateEdit and QTimeEdit.,1.0,{},0.0,"{'// ### Qt 5: remove<KAIGYO>// A work-around for missing """" in qdatetimeedit.h for<KAIGYO>// QTimeEdit\'s time property and QDateEdit\'s date property.<KAIGYO>// It only triggers if the default user property """" is<KAIGYO>// reported for QTimeEdit and QDateEdit.': 1}",1.0,{}
330,20870.0,1.0,1.0,0.0,ABANDONED,False,https://codereview.qt-project.org/#/c/20870,Add USER properties to QDateEdit and QTimeEdit.,1.0,{},0.0,"{'// ### Qt 5: remove<KAIGYO>// A work-around for missing """" in qdatetimeedit.h for<KAIGYO>// QTimeEdit\'s time property and QDateEdit\'s date property.<KAIGYO>// It only triggers if the default user property """" is<KAIGYO>// reported for QTimeEdit and QDateEdit.': 1}",1.0,{}
346,20908.0,2.0,8.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/20908,Fixed testplan where `check' target does a chdir,1.0,"{'# FIXME: how to accurately figure out the calling Makefile on Windows?<KAIGYO># We know $(MAKEDIR) points to the right directory, but the actual<KAIGYO># filename appears not exposed in any way.<KAIGYO>#<KAIGYO># In practice this is not thought to be a problem - even qmake assumes<KAIGYO># the makefile is always called """" in various places.<KAIGYO># It is also OK to invoke the top-level Makefile (rather than<KAIGYO># Makefile.Release etc) for our purpose, since its """" target<KAIGYO># always links back to the active test configuration anyway.<KAIGYO>#<KAIGYO># Note that it is necessary to double-escape the variable ($$),<KAIGYO># otherwise it is evaluated too early.  It\'s not entirely clear<KAIGYO># why this is necessary for nmake/jom and not for GNU make; the method<KAIGYO># which nmake uses to pass """" etc args to submakes is<KAIGYO># undocumented.': 1}",1.0,"{'# FIXME: how to accurately figure out the calling Makefile on all<KAIGYO># platforms?<KAIGYO>#<KAIGYO># For GNU make, this could be done by using the $(MAKEFILE_LIST) variable.<KAIGYO># For nmake, there doesn\'t seem a clear, generic solution.<KAIGYO># The GNU make solution is deliberately unimplemented so that, if this<KAIGYO># should ever start to cause problems, the problems will be reproducible<KAIGYO># on all platforms.<KAIGYO>#<KAIGYO># In practice this is not thought to be a problem - even qmake assumes<KAIGYO># the makefile is always called """" in various places.': 1}",1.0,{}
344,20913.0,1.0,4.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/20913,testplanner: jom compatibility fixes,1.0,{},0.0,"{'# Note that it is necessary to double-escape the variable ($$),<KAIGYO># otherwise it is evaluated too early.  It\'s not entirely clear<KAIGYO># why this is necessary for nmake/jom and not for GNU make; the method<KAIGYO># which nmake uses to pass """" etc args to submakes is<KAIGYO># undocumented.': 1}",1.0,{}
30,21038.0,2.0,12.0,1.0,MERGED,True,https://codereview.qt-project.org/#/c/21038,Move the UTF-8 data into a separate .cpp so I can use later,1.0,{'// some combinations in UTF-8 are invalid even though they have the proper bits set<KAIGYO>// these are known as overlong sequences': 1},1.0,{'// some combinations in UTF-8 are invalid even though they have the proper bits set<KAIGYO>// these are known as overlong sequences': 1},1.0,{}
36,21051.0,2.0,2.0,0.0,ABANDONED,False,https://codereview.qt-project.org/#/c/21051,Modify qt_urlRecode to keep the input pointer at the char we're processing,1.0,{},0.0,"{""// input points to the character after the one we're processing (that's why the -1 / + 1)"": 1}",1.0,{}
69,21094.0,1.0,1.0,0.0,ABANDONED,False,https://codereview.qt-project.org/#/c/21094,Move the UTF-8 data into a separate .cpp so I can use later,1.0,{'// some combinations in UTF-8 are invalid even though they have the proper bits set<KAIGYO>// these are known as overlong sequences': 1},1.0,{'// some combinations in UTF-8 are invalid even though they have the proper bits set<KAIGYO>// these are known as overlong sequences': 1},1.0,{}
85,21107.0,1.0,1.0,0.0,ABANDONED,False,https://codereview.qt-project.org/#/c/21107,Modify qt_urlRecode to keep the input pointer at the char we're processing,1.0,{},0.0,"{""// input points to the character after the one we're processing (that's why the -1 / + 1)"": 1}",1.0,{}
155,21172.0,4.0,16.0,1.0,MERGED,True,https://codereview.qt-project.org/#/c/21172,Add support for PUT & POST to qget test,1.0,{},0.0,{'//currently multiple downloads are processed in parallel.<KAIGYO>//could add an option for serial using the downloads list as a queue<KAIGYO>//which would require DownloadItem to hold a request rather than a reply': 1},1.0,{}
208,21276.0,3.0,12.0,1.0,MERGED,True,https://codereview.qt-project.org/#/c/21276,Refactoring virtual keyboard class into non-singleton,1.0,{'// TODO check if we need to do this for all screens or only the primary one': 1},1.0,"{""// TODO: What screen index should be used? I assume primaryScreen here because it works, and<KAIGYO>//       we do it for handleScreenGeometryChange elsewhere but since we have support<KAIGYO>//       for more than one screen, that's not going to always work."": 1}",1.0,{}
250,21357.0,4.0,7.0,1.0,MERGED,True,https://codereview.qt-project.org/#/c/21357,Measure offsets by rows instead of pixels,1.0,"{""// row of 3,4,5 has moved down<KAIGYO>// 1st row (it's above visible area) disappears, 0 drops down 1 row, first visible item (6) stays where it is<KAIGYO>// top row moved and shifted to below 3rd row, all items should shift down by 1 row<KAIGYO>// top two rows removed, third row is now the first visible<KAIGYO>// to minimize movement, items are added above visible area, all items move up by 1 row<KAIGYO>// 16,17,18 move to above item 0, all items move up by 1 row"": 1, ""// show 6-23<KAIGYO>// // show 6-23<KAIGYO>// show 6-23<KAIGYO>// show 6-23<KAIGYO>// show 6-23<KAIGYO>// row of 3,4,5 has moved down<KAIGYO>// show 6-23<KAIGYO>// 1st row (it's above visible area) disappears, 0 drops down 1 row, first visible item (6) stays where it is<KAIGYO>// show 6-23<KAIGYO>// top row moved and shifted to below 3rd row, all items should shift down by 1 row"": 2}",1.0,"{""// row of 3,4,5 has moved down<KAIGYO>// 1st row (it's above visible area) disappears, 0 drops down 1 row, first visible item (6) stays where it is<KAIGYO>// top row moved and shifted to below 3rd row, all items should shift down by 1 row<KAIGYO>// top two rows removed, third row is now the first visible<KAIGYO>// to minimize movement, items are added above visible area, all items move up by 1 row<KAIGYO>// 16,17,18 move to above item 0, all items move up by 1 row"": 1, ""// show 6-23<KAIGYO>// // show 6-23<KAIGYO>// show 6-23<KAIGYO>// show 6-23<KAIGYO>// show 6-23<KAIGYO>// row of 3,4,5 has moved down<KAIGYO>// show 6-23<KAIGYO>// 1st row (it's above visible area) disappears, 0 drops down 1 row, first visible item (6) stays where it is<KAIGYO>// show 6-23<KAIGYO>// top row moved and shifted to below 3rd row, all items should shift down by 1 row"": 2}",1.0,{}
261,21374.0,4.0,7.0,9.0,MERGED,True,https://codereview.qt-project.org/#/c/21374,Initial checkin for ZoomTool implementation,1.0,{},0.0,{'// TODO': 1},1.0,{}
276,21375.0,2.0,10.0,2.0,MERGED,True,https://codereview.qt-project.org/#/c/21375,Re-order imports statements to import nested imports later,1.0,{'// TODO: We should probably do this check first to avoid a lot of unnecessary file tests': 1},1.0,{'// TODO: Should this search be omitted if found == true?': 2},1.0,{}
265,21408.0,2.0,30.0,8.0,MERGED,True,https://codereview.qt-project.org/#/c/21408,QNAM: close the channel if bytesAvailable and nothing piplined,1.0,{},0.0,"{'//if (socket->bytesAvailable() > 0)<KAIGYO>//    close();<KAIGYO>//<KAIGYO>// FIXME<KAIGYO>// We do not close it anymore now, but should introduce this again after having fixed<KAIGYO>// the chunked decoder in QHttpNetworkReply to read the whitespace after the last chunk.<KAIGYO>// (Currently this is worked around by readStatus in the QHttpNetworkReply ignoring<KAIGYO>// leading whitespace.': 2}",1.0,{}
314,21475.0,3.0,28.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/21475,Remove references to QT_NO_STL from QtConcurrent,1.0,{},0.0,{'// Missing stl iterators prevent correct block size calculation.': 1},1.0,{}
335,21514.0,2.0,5.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/21514,Reduce assumptions in examples,1.0,"{'// once item is created, start moving offscreen': 1}",1.0,"{'// once item is created, start moving offscreen': 1}",1.0,{}
420,21541.0,11.0,43.0,46.0,MERGED,True,https://codereview.qt-project.org/#/c/21541,Migrate QByteArray over QArrayData.,1.0,"{'// Macro that expands into a QArrayData. The offset member is<KAIGYO>// QArrayData being defined. This calculation relies on the<KAIGYO>// QArrayData::data() implementation returning simply """".': 1}",1.0,"{'// Macro that expands into a QByteArrayData. The offset member is<KAIGYO>// QByteArrayData being defined. This calculation relies on the<KAIGYO>// QByteArrayData::data() implementation returning simply """".': 1}",1.0,{}
336,21574.0,1.0,3.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/21574,Merge master into api_changes,1.0,{},0.0,"{'/*!<KAIGYO>    \\class QQmlImageProvider<KAIGYO>    \\since 5.0<KAIGYO>    \\inmodule QtQml<KAIGYO>    \\brief The QQmlImageProvider class provides an interface for supporting pixmaps and threaded image requests in QML.<KAIGYO><KAIGYO>    QQmlImageProvider is used to provide advanced image loading features<KAIGYO>    in QML applications. It allows images in QML to be:<KAIGYO><KAIGYO>    \\list<KAIGYO>    \\li Loaded using QPixmaps rather than actual image files<KAIGYO>    \\li Loaded asynchronously in a separate thread, if imageType() is \\l{QQmlImageProvider::ImageType}{ImageType::Image}<KAIGYO>    \\endlist<KAIGYO><KAIGYO>    To specify that an image should be loaded by an image provider, use the<KAIGYO>    \\b {""""} scheme for the URL source of the image, followed by the<KAIGYO>    identifiers of the image provider and the requested image. For example:<KAIGYO><KAIGYO>    \\qml<KAIGYO>    Image { source: """" }<KAIGYO>    \\endqml<KAIGYO><KAIGYO>    This specifies that the image should be loaded by the image provider named <KAIGYO>    """". The QML engine <KAIGYO>    invokes the appropriate image provider according to the providers that have<KAIGYO>    been registered through QQmlEngine::addImageProvider().<KAIGYO><KAIGYO>    Note that the identifiers are case-insensitive, but the rest of the URL will be passed on with<KAIGYO>    preserved case. For example, the below snippet would still specify that the image is loaded by the<KAIGYO>    image provider named """", but it would request a different image than the above snippet<KAIGYO>    ("""").<KAIGYO>    \\qml<KAIGYO>    Image { source: """" }<KAIGYO>    \\endqml<KAIGYO><KAIGYO>    If you want the rest of the URL to be case insensitive, you will have to take care<KAIGYO>    of that yourself inside your image provider.<KAIGYO><KAIGYO>    \\section2 An example<KAIGYO><KAIGYO>    Here are two images. Their \\c source values indicate they should be loaded by<KAIGYO>    an image provider named """"<KAIGYO>    and """", respectively:<KAIGYO><KAIGYO>    \\snippet examples/declarative/cppextensions/imageprovider/imageprovider-example.qml 0<KAIGYO><KAIGYO>    When these images are loaded by QML, it looks for a matching image provider<KAIGYO>    and calls its requestImage() or requestPixmap() method (depending on its<KAIGYO>    imageType()) to load the image. The method is called with the \\c id <KAIGYO>    parameter set to """" for the second.<KAIGYO><KAIGYO>    Here is an image provider implementation that can load the images <KAIGYO>    requested by the above QML. This implementation dynamically <KAIGYO>    generates QPixmap images that are filled with the requested color:<KAIGYO><KAIGYO>    \\snippet examples/declarative/cppextensions/imageprovider/imageprovider.cpp 0<KAIGYO>    \\codeline<KAIGYO>    \\snippet examples/declarative/cppextensions/imageprovider/imageprovider.cpp 1<KAIGYO><KAIGYO>    To make this provider accessible to QML, it is registered with the QML engine<KAIGYO>    with a """" identifier:<KAIGYO><KAIGYO>    \\code<KAIGYO>    int main(int argc, char *argv[]) <KAIGYO>    {<KAIGYO>        ...<KAIGYO><KAIGYO>        QQmlEngine engine;<KAIGYO>        engine->addImageProvider(QLatin1String(""""), new ColorPixmapProvider);<KAIGYO><KAIGYO>        ...<KAIGYO>    }<KAIGYO>    \\endcode<KAIGYO><KAIGYO>    Now the images can be successfully loaded in QML:<KAIGYO><KAIGYO>    \\image imageprovider.png<KAIGYO><KAIGYO>    A complete example is available in Qt\'s <KAIGYO>    \\l {declarative/cppextensions/imageprovider}{examples/declarative/cppextensions/imageprovider}<KAIGYO>    directory. Note the example registers the provider via a \\l{QQmlExtensionPlugin}{plugin}<KAIGYO>    instead of registering it in the application \\c main() function as shown above.<KAIGYO><KAIGYO><KAIGYO>    \\section2 Asynchronous image loading<KAIGYO><KAIGYO>    Image providers that support QImage loading automatically include support<KAIGYO>    for asychronous loading of images. To enable asynchronous loading for an<KAIGYO>    image source, set the \\c asynchronous property to \\c true for the relevant<KAIGYO>    \\l Image, \\l BorderImage or \\l AnimatedImage object. When this is enabled, <KAIGYO>    the image request to the provider is run in a low priority thread,<KAIGYO>    allowing image loading to be executed in the background, and reducing the<KAIGYO>    performance impact on the user interface.<KAIGYO><KAIGYO>    Asynchronous loading is not supported for image providers that provide<KAIGYO>    QPixmap rather than QImage values, as pixmaps can only be created in the<KAIGYO>    main thread. In this case, if \\l {Image::}{asynchronous} is set to <KAIGYO>    \\c true, the value is ignored and the image is loaded<KAIGYO>    synchronously.<KAIGYO><KAIGYO><KAIGYO>    \\section2 Image caching<KAIGYO><KAIGYO>    Images returned by a QQmlImageProvider are automatically cached,<KAIGYO>    similar to any image loaded by the QML engine. When an image with a<KAIGYO>    """" prefix is loaded from cache, requestImage() and requestPixmap()<KAIGYO>    will not be called for the relevant image provider. If an image should always<KAIGYO>    be fetched from the image provider, and should not be cached at all, set the<KAIGYO>    \\c cache property to \\c false for the relevant \\l Image, \\l BorderImage or<KAIGYO>    \\l AnimatedImage object.<KAIGYO><KAIGYO>    The QtQuick 1 version of this class is named QDeclarativeImageProvider.<KAIGYO><KAIGYO>    \\sa QQmlEngine::addImageProvider()<KAIGYO>*/': 1}",1.0,{}
392,21668.0,4.0,11.0,5.0,MERGED,True,https://codereview.qt-project.org/#/c/21668,Move screen event processing into its own class,1.0,"{'// Convert buttons.<KAIGYO>// Some QNX header files invert \'Right Button versus ""Left Button\' (\'Right\' == 0x01). But they also offer a \'Button Swap\' bit,<KAIGYO>// so we may receive events as shown. (If this is wrong, the fix is easy.)<KAIGYO>// QNX Button mask is 8 buttons wide, with a maximum value of x080.': 1}",1.0,"{'// Convert buttons.<KAIGYO>// Some QNX header files invert \'Right Button versus ""Left Button\' (\'Right\' == 0x01). But they also offer a \'Button Swap\' bit,<KAIGYO>// so we may receive events as shown. (If this is wrong, the fix is easy.)<KAIGYO>// QNX Button mask is 8 buttons wide, with a maximum value of x080.': 1}",1.0,{}
409,21741.0,1.0,3.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/21741,Plug memory leak when gestures are grabbed but never triggered,1.0,"{'// check if a running gesture switched back to maybe state': 1, ""// check if a maybe gesture switched to canceled - reset it but don't send an event"": 1, '// new gestures in maybe state': 1, '// gestures that were in maybe state': 1}",1.0,"{'// check if a running gesture switched back to maybe state': 1, ""// check if a maybe gesture switched to canceled - reset it but don't send an event"": 1, '// new gestures in maybe state': 1, '// gestures that were in maybe state': 1}",1.0,{}
432,21796.0,2.0,9.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/21796,QDoc: Add hand-written ditamaps as children of qt.ditamap,1.0,{'// Hardcode not writing index.dita multiple times in the tree.<KAIGYO>// index.dita should only appear at the top of the ditamap.': 1},1.0,{'// Hardcode not writing index.dita multiple times in the tree.<KAIGYO>// index.dita should only appear at the top of the ditamap.': 1},1.0,{}
454,21880.0,1.0,1.0,0.0,ABANDONED,False,https://codereview.qt-project.org/#/c/21880,Fix indentation,1.0,{},0.0,{'// TODO: Add to current and only remove if exists': 1},1.0,{}
491,21961.0,3.0,5.0,2.0,ABANDONED,False,https://codereview.qt-project.org/#/c/21961,mksrc.sh: cleanup and fixes,1.0,{},0.0,"{'# Step x,  remove rest of the unnecessary files   TODO': 1}",1.0,{}
52,22010.0,4.0,11.0,5.0,MERGED,True,https://codereview.qt-project.org/#/c/22010,Fixed crash when using 'var' property in ShaderEffect.,1.0,{},0.0,"{""// TODO: Copy better solution in QQuickShaderEffect when they find it.<KAIGYO>// 'source.item' needs a canvas to get a scenegraph node.<KAIGYO>// The easiest way to make sure it gets a canvas is to<KAIGYO>// make it a part of the same item tree as 'this'."": 1, ""//TODO: Shouldn't assert"": 1}",1.0,{}
31,22098.0,2.0,3.0,1.0,ABANDONED,False,https://codereview.qt-project.org/#/c/22098,QmlDebug: Selection Tool,1.0,{},0.0,{'// todo: Show context menu': 1},1.0,{}
63,22126.0,2.0,4.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/22126,Logging: Make sure documentation shows up,1.0,"{'/*!<KAIGYO>    \\typedef QtMsgHandler<KAIGYO>    \\relates <QtGlobal><KAIGYO>    \\deprecated<KAIGYO><KAIGYO>    This is a typedef for a pointer to a function with the following<KAIGYO>    signature:<KAIGYO><KAIGYO>    \\snippet doc/src/snippets/code/src_corelib_global_qglobal.cpp 7<KAIGYO><KAIGYO>    This typedef is deprecated, you should use QMessageHandler instead.<KAIGYO>    \\sa QtMsgType, QMessageHandler, qInstallMsgHandler(), qInstallMessageHandler()<KAIGYO>*/': 1, '/*!<KAIGYO>    \\fn QtMsgHandler qInstallMsgHandler(QtMsgHandler handler)<KAIGYO>    \\relates <QtGlobal><KAIGYO>    \\deprecated<KAIGYO><KAIGYO>    Installs a Qt message \\a handler which has been defined<KAIGYO>    previously. This method is deprecated, use qInstallMessageHandler<KAIGYO>    instead.<KAIGYO>    \\sa QtMsgHandler, qInstallMessageHandler<KAIGYO>*/': 1}",1.0,"{'/*!<KAIGYO>    \\typedef QtMsgHandler<KAIGYO>    \\relates <QtGlobal><KAIGYO>    \\deprecated<KAIGYO><KAIGYO>    This is a typedef for a pointer to a function with the following<KAIGYO>    signature:<KAIGYO><KAIGYO>    \\snippet doc/src/snippets/code/src_corelib_global_qglobal.cpp 7<KAIGYO><KAIGYO>    This typedef is deprecated, you should use QMessageHandler instead.<KAIGYO>    \\sa QtMsgType, QMessageHandler, qInstallMsgHandler(), qInstallMessageHandler()<KAIGYO>*/': 1, '/*!<KAIGYO>    \\fn QtMsgHandler qInstallMsgHandler(QtMsgHandler handler)<KAIGYO>    \\relates <QtGlobal><KAIGYO>    \\deprecated<KAIGYO><KAIGYO>    Installs a Qt message \\a handler which has been defined<KAIGYO>    previously. This method is deprecated, use qInstallMessageHandler<KAIGYO>    instead.<KAIGYO>    \\sa QtMsgHandler, qInstallMessageHandler<KAIGYO>*/': 1}",1.0,{}
86,22155.0,3.0,11.0,4.0,MERGED,True,https://codereview.qt-project.org/#/c/22155,Bump some Qt 5 to-do's to Qt 6.,1.0,"{'// ### Qt 6: Maybe rename this to parentDirectory(), considering what it actually does?': 1}",1.0,"{'// ### Qt5: Maybe rename this to parentDirectory(), considering what it actually do?': 1}",1.0,{}
132,22314.0,2.0,5.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/22314,Fix QML_BINDINGS_TEST and the V4 auto tests,1.0,{},0.0,"{'    /*<KAIGYO>    //XXX TODO: QTBUG-24706<KAIGYO>            << (QStringList() << (testFileUrl("""")))<KAIGYO>            << 0            // a url like """"<KAIGYO>            << (float)0     // and the url.toString().toInt()/toDouble() of that is zero/qQNaN().<KAIGYO>            << (double)0<KAIGYO>            << (qreal)0<KAIGYO>            << QVector3D(0, 0, 0);<KAIGYO>    */': 1}",1.0,{}
130,22330.0,1.0,7.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/22330,Make QUrl handle ambiguous delimiters correctly,1.0,"{'// appendXXXX functions:<KAIGYO>// the internal value is stored in its most decoded form, so that case is easy.<KAIGYO>// DecodeUnicode and DecodeSpaces are handled by qt_urlRecode.<KAIGYO>// That leaves these functions to handle two cases related to delimiters:<KAIGYO>//  1) encoded                           encodedXXXX tables<KAIGYO>//  2) decoded                           decodedXXXX tables': 1}",1.0,"{'// when constructing the authority or user-info, we never encode the ambiguous delimiters': 1, '// appendXXXX functions:<KAIGYO>// the internal value is already encoded in PrettyDecoded, so that case is easy.<KAIGYO>// DecodeUnicode and DecodeSpaces are handled by qt_urlRecode.<KAIGYO>// That leaves these functions to handle three cases related to delimiters:<KAIGYO>//  1) encoded                           encodedXXXX tables<KAIGYO>//  2) DecodeUnambiguousDelimiters       prettyXXXX tables<KAIGYO>//  3) DecodeAllDelimiters               decodedXXXX tables': 1}",1.0,{}
182,22413.0,1.0,4.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/22413,Remove workaround for QTBUG-22919.,1.0,{},0.0,"{'// ### QTBUG-22919 The bounding rect returned by QGlyphRun appears to start on the<KAIGYO>// baseline, move it by the ascent so all bounding rects are at baseline - ascent.': 1}",1.0,{}
235,22426.0,3.0,3.0,0.0,ABANDONED,False,https://codereview.qt-project.org/#/c/22426,WIP: optimize imports and type resolution,1.0,"{'//XXX TODO: handle windows hostnames: """"<KAIGYO>// magic for drives on windows """"': 1, '// XXX is this correct?': 1}",1.0,{'// XXX is this correct?': 1},1.0,{}
214,22454.0,4.0,9.0,8.0,MERGED,True,https://codereview.qt-project.org/#/c/22454,QmlDebug: Combine Selection and Zoom Tools,1.0,{'// todo: Show context menu': 1},1.0,{'// todo: Show context menu': 1},1.0,{}
200,22455.0,3.0,7.0,1.0,MERGED,True,https://codereview.qt-project.org/#/c/22455,QmlDebug: Inspect Tool,1.0,{},0.0,{'// todo: Show context menu': 1},1.0,{}
268,22478.0,10.0,29.0,17.0,MERGED,True,https://codereview.qt-project.org/#/c/22478,Add implementation of virtual keyboard based on BPS events,1.0,{'// TODO check if we need to do this for all screens or only the primary one': 1},1.0,"{'// TODO check if we need to do this for all screens or only the primary one': 1, '// should probably be moved to QQnxIntegration::createDisplays<KAIGYO>// ideally refactoring the navigator event handler into a common part and reuse that here<KAIGYO>// similar to how screen event handling is delegated': 3}",1.0,{}
215,22485.0,1.0,3.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/22485,Remove obsolete code,1.0,{},0.0,{'// XXX not applicable in v8': 1},1.0,{}
231,22502.0,2.0,6.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/22502,QmlDebug: Remove Color Tool,1.0,{},0.0,{'// TODO': 1},1.0,{}
250,22530.0,1.0,9.0,1.0,MERGED,True,https://codereview.qt-project.org/#/c/22530,Add Proxy Auto Config support (PAC) on Mac,1.0,{},0.0,{'// ### TODO: Use PAC somehow': 1},1.0,{}
387,22780.0,5.0,17.0,7.0,MERGED,True,https://codereview.qt-project.org/#/c/22780,Respect the DontUseNativeDialog flag.,1.0,{},0.0,{'// ### fixme: Call helper': 1},1.0,{}
437,22903.0,1.0,14.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/22903,Merge remote-tracking branch 'origin/master' into api_changes,1.0,{},0.0,"{""// TODO: Copy better solution in QQuickShaderEffect when they find it.<KAIGYO>// 'source.item' needs a canvas to get a scenegraph node.<KAIGYO>// The easiest way to make sure it gets a canvas is to<KAIGYO>// make it a part of the same item tree as 'this'."": 1, ""//TODO: Shouldn't assert"": 1}",1.0,{}
14,23034.0,2.0,16.0,2.0,MERGED,True,https://codereview.qt-project.org/#/c/23034,Use the new udev based framework for detecting graphics cards.,1.0,{},0.0,"{'//Return a list addresses of DRM supported devices<KAIGYO>//Hardcoded now, but could use udev to return a list<KAIGYO>//of multiple devices.': 1}",1.0,{}
46,23115.0,1.0,2.0,0.0,ABANDONED,False,https://codereview.qt-project.org/#/c/23115,Support keyboards on KMS.,1.0,{'// TODO: LED support is a bit flaky so detecting the correct<KAIGYO>// state of caps lock takes some more thinking.': 1},1.0,{'// TODO: handle keyboard': 1},1.0,{}
74,23201.0,1.0,6.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/23201,Remove QVariant constructor taking Qt::GlobalColor.,1.0,{},0.0,"{""// small 'trick' to let a QVariant(Qt::blue) create a variant<KAIGYO>// of type QColor<KAIGYO>// TODO Get rid of this hack."": 1}",1.0,{}
94,23247.0,1.0,6.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/23247,Fold qpaintdevice_qpa.cpp into qpaintdevice.cpp,1.0,{'// FIXME: does this need to be a real value?': 1},1.0,{'// FIXME: does this need to be a real value?': 1},1.0,{}
164,23392.0,2.0,9.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/23392,Make failures in QTimeLine autotest more stable.,1.0,{},0.0,"{'// Probably 10': 1, '// Probably 1': 1}",1.0,{}
179,23401.0,1.0,2.0,0.0,ABANDONED,False,https://codereview.qt-project.org/#/c/23401,WIP: Fix geometry handling.,1.0,{'// ### Fix properly for 5.3': 1},1.0,"{'// ### Fix properly for 4.3': 1, '// XXX': 1}",1.0,{}
186,23450.0,2.0,5.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/23450,Clean up test,1.0,{},0.0,{'// XXX fetch from qml?': 1},1.0,{}
214,23510.0,3.0,11.0,4.0,MERGED,True,https://codereview.qt-project.org/#/c/23510,Remove todo comments that are no longer relevant.,1.0,{},0.0,"{'// ### Qt5: should we keep or remove this method?<KAIGYO>// SC solution would be to install a callback form QtWidgets, but ugly.': 1}",1.0,{}
438,23567.0,12.0,55.0,5.0,MERGED,True,https://codereview.qt-project.org/#/c/23567,Improve widget geometry.,1.0,"{'// ### Fix properly for 5.3': 1, '// Parameters to XCreateWindow() are frame corner + inner size.<KAIGYO>// This fits in case position policy is frame inclusive. There is<KAIGYO>// currently no way to implement it for frame-exclusive geometries.': 3}",1.0,"{'// ### Fix properly for 4.3': 1, '// XXX': 1}",1.0,{}
263,23607.0,3.0,19.0,14.0,ABANDONED,False,https://codereview.qt-project.org/#/c/23607,WIP: Fix unicode related bugs in the QODBC driver,1.0,"{""// workaround for Drivermanagers that don't return SQL_NO_DATA"": 1}",1.0,"{""// workaround for Drivermanagers that don't return SQL_NO_DATA"": 1}",1.0,{}
333,23793.0,1.0,4.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/23793,Provide a way to make fatal errors parseable by parse_build_log.pl,1.0,"{""# no, we're not done.<KAIGYO># shall we give up?"": 1}",1.0,"{""# no, we're not done.<KAIGYO># shall we give up?"": 1, '# Output any autotest failures first.<KAIGYO># FIXME: outputting these first can mean that an autotest failure is printed<KAIGYO># earlier than some other extracted message, even if in reality they appeared<KAIGYO># in the opposite order.  Should we care about this?  Or is this a better<KAIGYO># way to do it?': 1}",1.0,{}
345,23833.0,2.0,11.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/23833,Remove Q_WS macros from qwidget-test.,1.0,{},0.0,{'//glib workaround': 1},1.0,{}
404,23902.0,3.0,4.0,0.0,ABANDONED,False,https://codereview.qt-project.org/#/c/23902,move loading specs to Option,1.0,"{'// hack to get the Option stuff in there': 1, '// The spec extends the feature search path, so invalidate the cache.': 1}",1.0,"{'// hack to get the Option stuff in there': 1, '// The spec extends the feature search path, so invalidate the cache.': 1}",1.0,{}
431,23939.0,4.0,13.0,2.0,MERGED,True,https://codereview.qt-project.org/#/c/23939,Remove relative directory elements in import paths,1.0,{},0.0,{'//XXX Find out why this broke with new QUrl.': 1},1.0,{}
437,24189.0,63.0,144.0,84.0,MERGED,True,https://codereview.qt-project.org/#/c/24189,Propagate synthesized mouse events in parallel with touch.,1.0,"{""// no grabber, check if we care about mose hover<KAIGYO>// FIXME: this should only happen once, not recursively... I'll ignore it just ignore hover now.<KAIGYO>// hover for touch???<KAIGYO>// currently handled point was released"": 1, '// we cannot really know when compression and grabbing happens': 1, ""// I don't give a damn how much, but move!"": 1, ""// FIXME<KAIGYO>// Da hum. We don't get a cancel or anything, cause that would be toooooo nice. yeah.<KAIGYO>// let's go get drunk"": 1, '// we cannot really know when the events get grabbed away': 2, ""// no grabber, check if we care about mose hover<KAIGYO>// FIXME: this should only happen once, not recursively... I'll ignore it just ignore hover now.<KAIGYO>// hover for touch???"": 15, '// probably redundant, we check bounds in the calling function (matchingNewPoints)': 18, ""// no grabber, check if we care about mouse hover<KAIGYO>// FIXME: this should only happen once, not recursively... I'll ignore it just ignore hover now.<KAIGYO>// hover for touch???"": 18, '// FIXME if (itemForTouchPointId[tp.id()] == target) {': 25, ""// FIXME: Comment from Laszlo:<KAIGYO>// Is it is safe to reset it to -1 before the finger gets lifted? I'm not sure right now. Maybe it is."": 25, '// move or stationary': 25, '// TODO': 29, '// The item should have received a mouse press, move, and release.': 33, '// TODO this function and touchEventWithPoints are similar; try to get some code reuse': 37, '// TODO Is it a bug if a QTouchEvent comes here?': 37}",1.0,{'// XXX todo - should sendEvent be doing this?  how does it relate to forwarded events?': 25},1.0,{}
95,24233.0,1.0,3.0,1.0,MERGED,True,https://codereview.qt-project.org/#/c/24233,Remove obsolete compilerwarnings autotest,1.0,{},0.0,{'// +w or +w2 outputs too much bogus': 1},1.0,{}
100,24260.0,2.0,4.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/24260,don't make $$TEMPLATE_PREFIX available any more,1.0,{},0.0,{'// hack to get the Option stuff in there': 1},1.0,{}
172,24313.0,5.0,12.0,10.0,MERGED,True,https://codereview.qt-project.org/#/c/24313,Debugger: Change name and protocol of QDeclarativeObserverMode,1.0,{},0.0,{'// TODO': 1},1.0,{}
162,24314.0,6.0,17.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/24314,qtmod_test.pl: add support for revdep (reverse dependency) testing.,1.0,"{'# Run init-repository for the given @modules.<KAIGYO># This may be safely run more than once to incrementally clone additional modules.<KAIGYO># @modules may be omitted to imply _all_ modules.': 1, ""# FIXME how do we guarantee we have this SHA1?<KAIGYO># If it's not reachable from a branch obtained from a default `clone', it could be missing.<KAIGYO># Is a SHA1, else is a ref and may need to be fetched"": 4}",1.0,"{""# FIXME how do we guarantee we have this SHA1?<KAIGYO># If it's not reachable from a branch obtained from a default `clone', it could be missing.<KAIGYO># Is a SHA1, else is a ref and may need to be fetched"": 4}",1.0,{}
213,24506.0,1.0,7.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/24506,Change QStringBuilder to use UTF-8 too,1.0,{},0.0,"{'// now test with codec for C strings set<KAIGYO>// TODO: to be re-enabled once strings default to utf8, in place of the<KAIGYO>// latin1 code above.': 1, '// TODO: this relies on strings defaulting to utf8, so disable this for now.': 1}",1.0,{}
345,24536.0,8.0,18.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/24536,More robust tracking of signal handler expression ownership.,1.0,{},0.0,{'// TODO: refactor the ownership impl.': 4},1.0,{}
249,24605.0,1.0,5.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/24605,"Revert ""Harfbuzz-shaper - fix incorrect logClusters being set in HB_OpenTypePosition""",1.0,{},0.0,"{""//FIXME - Shouldn't we otherwise set this to true, rather than leaving it?<KAIGYO>// #### the reconstruction of the logclusters currently does not work if the original string<KAIGYO>// contains surrogate pairs"": 1}",1.0,{}
248,24619.0,1.0,4.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/24619,Fix typos.,1.0,{'// We replay the mouse press but the grabber we had might not be interested in the event (e.g. overlay)<KAIGYO>// Use the event handler that will take care of finding the proper item to propagate the event': 1},1.0,{'// We replay the mouse press but the grabber we had might not be interessted by the event (e.g. overlay)<KAIGYO>//Use the event handler that will take care of finding the proper item to propagate the event': 1},1.0,{}
274,24671.0,2.0,7.0,1.0,MERGED,True,https://codereview.qt-project.org/#/c/24671,Set ptr to zero after freeing memory,1.0,{'// Probably being deleted': 1},1.0,{'// Probably being deleted': 1},1.0,{}
289,24701.0,1.0,8.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/24701,Change QStringBuilder to use UTF-8 too,1.0,{},0.0,"{'// now test with codec for C strings set<KAIGYO>// TODO: to be re-enabled once strings default to utf8, in place of the<KAIGYO>// latin1 code above.': 1, '// TODO: this relies on strings defaulting to utf8, so disable this for now.': 1}",1.0,{}
418,24755.0,15.0,50.0,37.0,MERGED,True,https://codereview.qt-project.org/#/c/24755,Implement QVector with QArrayData interface.,1.0,{'// malloc on 32-bit platforms should return pointers that are 8-byte aligned or more<KAIGYO>// while on 64-bit platforms they should be 16-byte aligned or more': 15},1.0,"{'// malloc on 32-bit platforms should return pointers that are 8-byte aligned or more<KAIGYO>// while on 64-bit platforms they should be 16-byte aligned or more': 1, '// ::reserve() is really hard to think of tests for, so not doing it.<KAIGYO>// ::resize() is tested in ::capacity().': 1, '// ::reserve() is really hard to think of tests for, so not doing it.<KAIGYO>// ::resize() is tested in ::capacity().<KAIGYO>// total size': 2}",1.0,{'// malloc on 32-bit platforms should return pointers that are 8-byte aligned or more<KAIGYO>// while on 64-bit platforms they should be 16-byte aligned or more': '15-1'}
327,24785.0,5.0,10.0,3.0,ABANDONED,False,https://codereview.qt-project.org/#/c/24785,Cocoa: Fix QTabWidget Accessibility on Mac.,1.0,{},0.0,{'// FIXME this looks broken': 3},1.0,{}
420,24976.0,1.0,3.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/24976,testrunner: fixed another mkpath() race with concurrent testrunners,1.0,{'# $path could be created by another process in parallel; this is why we need<KAIGYO># a check both before and after the mkpath().': 1},1.0,{'# $logdir could be created by another process in parallel; this is why we need<KAIGYO># a check both before and after the mkpath().': 1},1.0,{}
433,24977.0,1.0,4.0,2.0,MERGED,True,https://codereview.qt-project.org/#/c/24977,Remove QJS exception API,1.0,"{'// clear exception state...<KAIGYO>// ### No way to check whether setProperty() threw an exception<KAIGYO>//    QVERIFY(eng.hasUncaughtException());<KAIGYO>//    QCOMPARE(eng.uncaughtException().toString(), QLatin1String(""""));': 1}",1.0,"{'// FIXME it should not happen (SetCaptureStackTraceForUncaughtExceptions is called).': 1, '// QEXPECT_FAIL("""", Abort);<KAIGYO>// ###FIXME: no uncahgutExceptionBacktrace: QCOMPARE(eng.uncaughtExceptionBacktrace(), backtrace);': 1, '// ###FIXME: No uncaughtExceptionBacktrace:  QCOMPARE(eng.uncaughtExceptionBacktrace(), backtrace);': 1, '// ###FIXME: No uncaughtExceptionBacktrace:  QVERIFY(eng.uncaughtExceptionBacktrace().isEmpty());': 1}",1.0,{}
431,24993.0,1.0,4.0,0.0,ABANDONED,False,https://codereview.qt-project.org/#/c/24993,Merge remote-tracking branch 'origin/api_changes',1.0,{},0.0,"{'/*!<KAIGYO>    \\typedef QtMsgHandler<KAIGYO>    \\relates <QtGlobal><KAIGYO>    \\deprecated<KAIGYO><KAIGYO>    This is a typedef for a pointer to a function with the following<KAIGYO>    signature:<KAIGYO><KAIGYO>    \\snippet doc/src/snippets/code/src_corelib_global_qglobal.cpp 7<KAIGYO><KAIGYO>    This typedef is deprecated, you should use QtMessageHandler instead.<KAIGYO>    \\sa QtMsgType, QtMessageHandler, qInstallMsgHandler(), qInstallMessageHandler()<KAIGYO>*/': 1, '/*!<KAIGYO>    \\fn QtMsgHandler qInstallMsgHandler(QtMsgHandler handler)<KAIGYO>    \\relates <QtGlobal><KAIGYO>    \\deprecated<KAIGYO><KAIGYO>    Installs a Qt message \\a handler which has been defined<KAIGYO>    previously. This method is deprecated, use qInstallMessageHandler<KAIGYO>    instead.<KAIGYO>    \\sa QtMsgHandler, qInstallMessageHandler<KAIGYO>>>>>>>> BRANCH (c0d249 Allow qDebug output to be configured by qSetMessagePattern())<KAIGYO>*/': 1}",1.0,{}
69,25084.0,2.0,9.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/25084,Remove QSGEngine,1.0,{},0.0,{'// ### TODO: remove QSGEngine': 1},1.0,{}
189,25109.0,2.0,4.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/25109,Refactor canvas item unit tests,1.0,"{'//TODO: Enable the followings later<KAIGYO>//{ tag:"""", properties:{width:100, height:100, renderTarget:Canvas.Image, renderStrategy:Canvas.Cooperative}},<KAIGYO>//{ tag:"""", properties:{width:100, height:100, renderTarget:Canvas.Image, renderStrategy:Canvas.Immediate}},<KAIGYO>//{ tag:"""", properties:{width:100, height:100, renderTarget:Canvas.FramebufferObject, renderStrategy:Canvas.Cooperative}},<KAIGYO>//{ tag:"""", properties:{width:100, height:100, renderTarget:Canvas.FramebufferObject, renderStrategy:Canvas.Immediate}},<KAIGYO>//{ tag:"""", properties:{width:100, height:100, renderTarget:Canvas.FramebufferObject, renderStrategy:Canvas.Threaded}}': 1, '//FIXME<KAIGYO>//comparePixel(ctx,  0,0, 0,255,0,255);<KAIGYO>//comparePixel(ctx,  50,0, 0,255,0,255);<KAIGYO>//comparePixel(ctx,  99,0, 0,255,0,255);<KAIGYO>//comparePixel(ctx,  0,25, 0,255,0,255);<KAIGYO>//comparePixel(ctx,  50,25, 0,255,0,255);<KAIGYO>//comparePixel(ctx,  99,25, 0,255,0,255);<KAIGYO>//comparePixel(ctx,  0,49, 0,255,0,255);<KAIGYO>//comparePixel(ctx,  50,49, 0,255,0,255);<KAIGYO>//comparePixel(ctx,  99,49, 0,255,0,255);': 1, '//FIXME:broken for Canvas.FramebufferObject': 1, '//FIXME<KAIGYO>//comparePixel(ctx,  1,1, 0,255,0,255);<KAIGYO>//comparePixel(ctx,  1,48, 0,255,0,255);<KAIGYO>//comparePixel(ctx,  50,25, 0,255,0,255);<KAIGYO>//comparePixel(ctx,  98,1, 0,255,0,255);<KAIGYO>//comparePixel(ctx,  98,48, 0,255,0,255);': 1, '// might not be exactly 0.5, if it is rounded/quantised, so remember for future comparisons': 1, ""//       qt does not support lighter...<KAIGYO>//       ctx.reset();<KAIGYO>//       ctx.fillStyle = 'rgba(0, 255, 0, 0.5)';<KAIGYO>//       ctx.fillRect(0, 0, 100, 50);<KAIGYO>//       ctx.globalCompositeOperation = 'lighter';<KAIGYO>//       ctx.fillStyle = 'rgba(0, 0, 255, 0.75)';<KAIGYO>//       ctx.fillRect(0, 0, 100, 50);<KAIGYO>//FIXME<KAIGYO>//comparePixel(ctx, 50,25, 0,127,191,255, 5);"": 1, '//FIXME<KAIGYO>//comparePixel(ctx, 50,25, 0,0,0,0, 5);': 1, '//FIXME:broken on FramebufferObject': 1, '//TODO': 1, '//FIXME: broken for Canvas.FramebufferObject': 1, '//FIXME:!!!<KAIGYO>//comparePixel(ctx, 1,1, 0,255,0,255);<KAIGYO>//comparePixel(ctx, 48,1, 0,255,0,255);<KAIGYO>//comparePixel(ctx, 48,48, 0,255,0,255);<KAIGYO>//comparePixel(ctx, 1,48, 0,255,0,255);': 1, '       /*<KAIGYO>        //FIXME:<KAIGYO>       comparePixel(ctx,  21,11, 0,255,0,255);<KAIGYO>       comparePixel(ctx,  79,11, 0,255,0,255);<KAIGYO>       comparePixel(ctx,  21,39, 0,255,0,255);<KAIGYO>       comparePixel(ctx,  79,39, 0,255,0,255);<KAIGYO>       comparePixel(ctx,  39,19, 0,255,0,255);<KAIGYO>       comparePixel(ctx,  61,19, 0,255,0,255);<KAIGYO>       comparePixel(ctx,  39,31, 0,255,0,255);<KAIGYO>       comparePixel(ctx,  61,31, 0,255,0,255);<KAIGYO>       */': 1, '       /*<KAIGYO>         //FIXME:<KAIGYO>       comparePixel(ctx,  21,11, 0,255,0,255);<KAIGYO>       comparePixel(ctx,  79,11, 0,255,0,255);<KAIGYO>       comparePixel(ctx,  21,39, 0,255,0,255);<KAIGYO>       comparePixel(ctx,  79,39, 0,255,0,255);<KAIGYO>       comparePixel(ctx,  39,19, 0,255,0,255);<KAIGYO>       comparePixel(ctx,  61,19, 0,255,0,255);<KAIGYO>       comparePixel(ctx,  39,31, 0,255,0,255);<KAIGYO>       comparePixel(ctx,  61,31, 0,255,0,255);<KAIGYO>       */': 1}",1.0,"{'//FIXME<KAIGYO>//verify(Helper.comparePixel(ctx,  0,0, 0,255,0,255));<KAIGYO>//verify(Helper.comparePixel(ctx,  50,0, 0,255,0,255));<KAIGYO>//verify(Helper.comparePixel(ctx,  99,0, 0,255,0,255));<KAIGYO>//verify(Helper.comparePixel(ctx,  0,25, 0,255,0,255));<KAIGYO>//verify(Helper.comparePixel(ctx,  50,25, 0,255,0,255));<KAIGYO>//verify(Helper.comparePixel(ctx,  99,25, 0,255,0,255));<KAIGYO>//verify(Helper.comparePixel(ctx,  0,49, 0,255,0,255));<KAIGYO>//verify(Helper.comparePixel(ctx,  50,49, 0,255,0,255));<KAIGYO>//verify(Helper.comparePixel(ctx,  99,49, 0,255,0,255));': 1, '//FIXME<KAIGYO>//verify(Helper.comparePixel(ctx,  1,1, 0,255,0,255));<KAIGYO>//verify(Helper.comparePixel(ctx,  1,48, 0,255,0,255));<KAIGYO>//verify(Helper.comparePixel(ctx,  50,25, 0,255,0,255));<KAIGYO>//verify(Helper.comparePixel(ctx,  98,1, 0,255,0,255));<KAIGYO>//verify(Helper.comparePixel(ctx,  98,48, 0,255,0,255));': 1, '// might not be exactly 0.5, if it is rounded/quantised, so remember for future comparisons': 1, '//FIXME<KAIGYO>//verify(Helper.comparePixel(ctx, 50,25, 0,127,191,255, 5));': 1, '//FIXME<KAIGYO>//verify(Helper.comparePixel(ctx, 50,25, 0,0,0,0, 5));': 1, '//TODO': 1, '//FIXME:!!!<KAIGYO>//verify(Helper.comparePixel(ctx, 1,1, 0,255,0,255));<KAIGYO>//verify(Helper.comparePixel(ctx, 48,1, 0,255,0,255));<KAIGYO>//verify(Helper.comparePixel(ctx, 48,48, 0,255,0,255));<KAIGYO>//verify(Helper.comparePixel(ctx, 1,48, 0,255,0,255));': 1, '           /*<KAIGYO>            //FIXME:<KAIGYO>           verify(Helper.comparePixel(ctx,  21,11, 0,255,0,255));<KAIGYO>           verify(Helper.comparePixel(ctx,  79,11, 0,255,0,255));<KAIGYO>           verify(Helper.comparePixel(ctx,  21,39, 0,255,0,255));<KAIGYO>           verify(Helper.comparePixel(ctx,  79,39, 0,255,0,255));<KAIGYO>           verify(Helper.comparePixel(ctx,  39,19, 0,255,0,255));<KAIGYO>           verify(Helper.comparePixel(ctx,  61,19, 0,255,0,255));<KAIGYO>           verify(Helper.comparePixel(ctx,  39,31, 0,255,0,255));<KAIGYO>           verify(Helper.comparePixel(ctx,  61,31, 0,255,0,255));<KAIGYO>           */': 1, '           /*<KAIGYO>             //FIXME:<KAIGYO>           verify(Helper.comparePixel(ctx,  21,11, 0,255,0,255));<KAIGYO>           verify(Helper.comparePixel(ctx,  79,11, 0,255,0,255));<KAIGYO>           verify(Helper.comparePixel(ctx,  21,39, 0,255,0,255));<KAIGYO>           verify(Helper.comparePixel(ctx,  79,39, 0,255,0,255));<KAIGYO>           verify(Helper.comparePixel(ctx,  39,19, 0,255,0,255));<KAIGYO>           verify(Helper.comparePixel(ctx,  61,19, 0,255,0,255));<KAIGYO>           verify(Helper.comparePixel(ctx,  39,31, 0,255,0,255));<KAIGYO>           verify(Helper.comparePixel(ctx,  61,31, 0,255,0,255));<KAIGYO>           */': 1}",1.0,{}
59,25114.0,1.0,4.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/25114,"testplanner: really fix the ""ambiguous makefile on windows"" problem.",1.0,"{""# Worst case scenario - we can't figure out the makefile at all.<KAIGYO># Give up."": 1}",1.0,"{'# If we found multiple makefiles, sort them by length (and then name, if there<KAIGYO># are multiple of the same length).  The shortest one is considered the """"<KAIGYO># makefile.  However, we\'ll warn about this, since there is some risk we\'ve<KAIGYO># picked the wrong one.': 1}",1.0,{}
105,25216.0,1.0,1.0,0.0,ABANDONED,False,https://codereview.qt-project.org/#/c/25216,Enable Threaded and Immediate rendering on FBO target,1.0,{},0.0,{'// XXX: change this method': 1},1.0,{}
124,25276.0,1.0,3.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/25276,Add more warnings,1.0,{},0.0,{'// target not changeable once context is active<KAIGYO>// Render strategy not changeable once context is active': 1},1.0,{}
170,25346.0,2.0,5.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/25346,qdoc: Fixed minor version number in DITA XML,1.0,{},0.0,"{'/*!<KAIGYO>#if 0<KAIGYO>    if (result)<KAIGYO>        qDebug() << """" << path << Node::nodeTypeString(type)<KAIGYO>                 << Node::nodeSubtypeString(subtype);<KAIGYO>    else<KAIGYO>        qDebug() << """" << path << Node::nodeTypeString(type)<KAIGYO>                 << Node::nodeSubtypeString(subtype);<KAIGYO>#endif<KAIGYO><KAIGYO>      to a QML element. If yes, that reference identifies a<KAIGYO>      QML class node.<KAIGYO>        QmlClassNode* qcn = QmlClassNode::moduleMap.value(path[0]+ """" +path[1]);<KAIGYO><KAIGYO>#if 0<KAIGYO>const Node* Tree::findNodeXXX(const QStringList& path, bool qml) const<KAIGYO>{<KAIGYO>    const Node* current = root();<KAIGYO>    do {<KAIGYO>        const Node* node = current;<KAIGYO>        int i;<KAIGYO>        int start_idx = 0;<KAIGYO><KAIGYO>        /*<KAIGYO>          If the path contains one or two double colons (""""),<KAIGYO>          check first to see if the first two path strings refer<KAIGYO>          to a QML element. If yes, that reference identifies a<KAIGYO>          QML class node.<KAIGYO>        */': 1}",1.0,{}
235,25452.0,5.0,31.0,6.0,MERGED,True,https://codereview.qt-project.org/#/c/25452,QNetworkReply::setReadBufferSize fix for threaded http,1.0,{},0.0,"{'// FIXME, unsupported right now': 1}",1.0,{}
212,25521.0,2.0,10.0,1.0,MERGED,True,https://codereview.qt-project.org/#/c/25521,QTextEngine: simplify the code a bit,1.0,{},0.0,"{""// XXX what about making this 4096, so we don't have to extend it ever."": 1}",1.0,{}
397,25578.0,14.0,25.0,24.0,ABANDONED,False,https://codereview.qt-project.org/#/c/25578,Handle multiple touch points with parallel event propagation,1.0,"{'// FIXME if (itemForTouchPointId[tp.id()] == target) {': 1, '// FIXME': 1, ""// FIXME: Comment from Laszlo:<KAIGYO>// Is it is safe to reset it to -1 before the finger gets lifted? I'm not sure right now. Maybe it is."": 2, '// move or stationary': 5}",1.0,{'// XXX todo - should sendEvent be doing this?  how does it relate to forwarded events?': 1},1.0,{}
310,25687.0,3.0,9.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/25687,End the deprecation period of SpriteImage,1.0,{},0.0,"{'//TODO: Implicitly size element to size of first sprite? or currentSprite?': 1, '//TODO: delay until component complete': 1}",1.0,{}
344,25797.0,4.0,8.0,5.0,MERGED,True,https://codereview.qt-project.org/#/c/25797,Restart a drag when the item canvas changes.,1.0,{},0.0,{'// Once a drag is started the proposed actions are locked in for future events.': 2},1.0,{}
358,25861.0,2.0,7.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/25861,Remove the test generator for the test qscriptvaluegenerated.,1.0,{},0.0,"{""// toInteger shouldn't return NaN, so it would be nice to catch the case."": 1, '// Data tags for values that return true in isXXX call': 1, '// List of pairs data tag and value returned from toXXX call': 1}",1.0,{}
346,25876.0,1.0,3.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/25876,Move a common IoError processing to the SerialPortPrivate class.,1.0,{},0.0,{'// FIXME: Here need call errno<KAIGYO>// and set error type?': 1},1.0,{}
363,25893.0,3.0,16.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/25893,Support specifying fallbacks in font request on QPA,1.0,{},0.0,"{'// Note, we have to QSKIP rather than QEXPECT_FAIL because font lookup is broken<KAIGYO>// such that it may work or not work depending on the order in which fonts were<KAIGYO>// loaded from disk: ### fixme: Check platforms': 2}",1.0,{}
398,25977.0,3.0,10.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/25977,Replace twitter demo with new tweetsearch demo,1.0,"{'// 2x time spent each side to wiggle away before shrinking in<KAIGYO>// Size on each side it moves away before shrinking during the transition<KAIGYO>// More give a greater squeeze during transition (0.0 for none)': 1, '//TODO: Are the items ever actually visible?': 1}",1.0,"{""//TODO: Could also get the user's color scheme, timezone and a few other things"": 1, '//Workaround for bug 260266': 1, '//anchors.bottom: parent.bottom;<KAIGYO>//TODO: Use anchor changes instead of hard coding': 1}",1.0,{}
29,26080.0,1.0,1.0,0.0,ABANDONED,False,https://codereview.qt-project.org/#/c/26080,Enforce function assignment semantics,1.0,{},0.0,"{'// XXX TODO: uncomment the following lines<KAIGYO>//QString error = QLatin1String("""") +<KAIGYO>//                QLatin1String(QMetaType::typeName(property->propType));<KAIGYO>//v8::ThrowException(v8::Exception::Error(engine->toString(error)));<KAIGYO>//return;<KAIGYO>// XXX TODO: remove the following transition behaviour<KAIGYO>// Temporarily allow assignment of functions to non-var properties<KAIGYO>// to mean binding assignment (as per old behaviour).': 1}",1.0,{}
41,26083.0,2.0,7.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/26083,"Revert ""Allow function assignment to cause binding for non-var props""",1.0,{},0.0,"{'// XXX TODO: uncomment the following lines<KAIGYO>//QString error = QLatin1String("""") +<KAIGYO>//                QLatin1String(QMetaType::typeName(property->propType));<KAIGYO>//v8::ThrowException(v8::Exception::Error(engine->toString(error)));<KAIGYO>//return;<KAIGYO>// XXX TODO: remove the following transition behaviour<KAIGYO>// Temporarily allow assignment of functions to non-var properties<KAIGYO>// to mean binding assignment (as per old behaviour).': 1}",1.0,{}
40,26104.0,1.0,4.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/26104,testplanner: avoid duplicate test labels,1.0,{'## no critic (ProhibitStringyEval) - no way around it': 1},1.0,"{'# currently does not actually modify the test plan in any way,<KAIGYO># just does a basic sanity check that it exists, can be parsed,<KAIGYO># and summarizes it.<KAIGYO>## no critic (ProhibitStringyEval) - no way around it': 1}",1.0,{}
54,26136.0,1.0,1.0,0.0,ABANDONED,False,https://codereview.qt-project.org/#/c/26136,Prevent Qt signal emissions if the object has been deleted,1.0,{'// Probably being deleted': 1},1.0,{'// Probably being deleted': 1},1.0,{}
55,26143.0,1.0,3.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/26143,"On *nix, fix getting count of bytes in the input/output queue.",1.0,{},0.0,{'// FIXME: FIONWRITE (or analogy) is exists?': 1},1.0,{}
85,26165.0,6.0,16.0,2.0,MERGED,True,https://codereview.qt-project.org/#/c/26165,Fix font printing on Windows using the native engine.,1.0,{},0.0,{'//  ### TODO<KAIGYO>//    QFontEngineWin *winfe = (fe->type() == QFontEngine::Win) ? static_cast<QFontEngineWin *>(fe) : 0;': 1},1.0,{}
142,26167.0,10.0,52.0,6.0,MERGED,True,https://codereview.qt-project.org/#/c/26167,Only quit if there are no visible widgets or windows.,1.0,{'// Should be around 10 if closing caused the quit': 4},1.0,{'// Should be around 10 if closing caused the quit': 2},1.0,{'// Should be around 10 if closing caused the quit': '4-2'}
82,26235.0,1.0,6.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/26235,QNetworkReplyHttpImplPrivate::migrateBackend,1.0,{},0.0,"{'//pauseNotificationHandling();<KAIGYO>//pauseNotificationHandling();<KAIGYO>// FIXME why should it be 0<KAIGYO>//resumeNotificationHandling();<KAIGYO>//resumeNotificationHandling();<KAIGYO>//pendingNotifications.clear();': 1, '//pauseNotificationHandling();<KAIGYO>//resumeNotificationHandling();<KAIGYO>// note: might not be a good idea, since users could decide to delete us<KAIGYO>// which would delete the backend too...<KAIGYO>// maybe we should protect the backend<KAIGYO>//pauseNotificationHandling();<KAIGYO>//resumeNotificationHandling();<KAIGYO>//    if (backend) {<KAIGYO>//        delete backend;<KAIGYO>//        backend = 0;<KAIGYO>//    }': 1, '// FIXME': 1, '// What probably needs to be done is an abort and then re-send?': 1}",1.0,{}
164,26323.0,4.0,12.0,3.0,MERGED,True,https://codereview.qt-project.org/#/c/26323,Optimize type resolution,1.0,{'// XXX is this correct?': 1},1.0,{'// XXX is this correct?': 1},1.0,{}
137,26370.0,2.0,6.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/26370,Accessibility: Implement invisible and checkable state,1.0,{},0.0,{'// FIXME when states are extended: state.checkable = true;': 1},1.0,{}
146,26373.0,4.0,7.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/26373,Qml : Resetting binding corrected,1.0,{},0.0,"{""// QCOMPARE(widthPropertyRef.value(), QVariant(0)); // TODO: Shouldn't this work?"": 3}",1.0,{}
224,26442.0,7.0,25.0,7.0,MERGED,True,https://codereview.qt-project.org/#/c/26442,Add completeToBeginning()/completeToEnd() to animation controller,1.0,{'//TODO: update this code so it is valid to delete the animation in animationFinished': 4},1.0,{'//TODO: update this code so it is valid to delete the animation in animationFinished': 4},1.0,{}
177,26479.0,1.0,3.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/26479,eglfs: Add support for cursor hotspots,1.0,{},0.0,{'// ## be smarter': 1},1.0,{}
347,26628.0,11.0,40.0,4.0,MERGED,True,https://codereview.qt-project.org/#/c/26628,SIC: QtPrintSupport - Remove QAbstractPageSetupDialog,1.0,{},0.0,{'// hack': 3},1.0,{}
271,26675.0,2.0,9.0,4.0,MERGED,True,https://codereview.qt-project.org/#/c/26675,QNX: Implement the QPlatformScreen::orientation() function,1.0,{},0.0,"{'// TODO: use ORIENTATION environment variable?': 1, '// TODO: use ORIENTATION environment variable?<KAIGYO>// TODO: use WIDTH and HEIGHT environment variables?': 2}",1.0,{}
330,26759.0,2.0,9.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/26759,Replace (un)checkAction with toggleAction (3/3),1.0,{},0.0,{'// FIXME<KAIGYO>//                QCheckBox *cb = qobject_cast<QCheckBox*>(object());<KAIGYO>//                if (!cb || !cb->isTristate() || cb->checkState() == Qt::PartiallyChecked)': 1},1.0,{}
353,26828.0,2.0,2.0,0.0,ABANDONED,False,https://codereview.qt-project.org/#/c/26828,WIP: Do not leave destroyed items in the item-touchpoint mapping table,1.0,{},0.0,"{""// FIXME: Comment from Laszlo:<KAIGYO>// Is it is safe to reset it to -1 before the finger gets lifted? I'm not sure right now. Maybe it is."": 2}",1.0,{}
388,26923.0,1.0,12.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/26923,QNetworkReplyHttpImpl: code cleanup,1.0,{},0.0,"{'// FIXME?<KAIGYO>//redirectionRequested(url);<KAIGYO>//setDownloadBuffer(db, contentLength);': 1, '//            handleNotifications();<KAIGYO>// FIXME': 1}",1.0,{}
16,27038.0,1.0,5.0,0.0,ABANDONED,False,https://codereview.qt-project.org/#/c/27038,Reduce size of QV8Bindings::Binding,1.0,"{'// The binding was not compiled.  There are some exceptional cases which the<KAIGYO>// expression rewriter does not rewrite properly (e.g., \\r-terminated lines<KAIGYO>// are not rewritten correctly but this bug is demed out-of-scope to fix for<KAIGYO>// performance reasons; see QTBUG-24064).': 1}",1.0,"{'// The binding was not compiled.  There are some exceptional cases which the<KAIGYO>// expression rewriter does not rewrite properly (e.g., \\r-terminated lines<KAIGYO>// are not rewritten correctly but this bug is demed out-of-scope to fix for<KAIGYO>// performance reasons; see QTBUG-24064).': 1}",1.0,{}
90,27085.0,3.0,8.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/27085,Don't parent (QObject) delegate items to views.,1.0,{},0.0,"{""// Clear the guard before deleting the object so it doesn't decrement scriptRef and<KAIGYO>// potentially delete the cacheItem itself."": 1}",1.0,{}
59,27133.0,1.0,4.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/27133,Store QQmlMetaObject in V4,1.0,{},0.0,{'// XXX - firstCppMetaObject': 1},1.0,{}
96,27204.0,1.0,3.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/27204,Removed unused expression like: if (!ret) {...},1.0,{},0.0,"{'// FIXME: Here need call errno<KAIGYO>// and set error type.': 1, '// FIXME: Here need call ::GetLastError()<KAIGYO>// and set error type.': 1}",1.0,{}
122,27247.0,1.0,6.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/27247,Fix scaling of svgz images.,1.0,{},0.0,{'// QSvgPlugin::capabilities bug QTBUG-9053': 1},1.0,{}
148,27287.0,1.0,1.0,0.0,ABANDONED,False,https://codereview.qt-project.org/#/c/27287,Don't set QObject parent when assigning to the data/resources lists.,1.0,{'// XXX todo': 1},1.0,{'// XXX todo - do we really want this behavior?': 1},1.0,{}
170,27306.0,3.0,9.0,1.0,MERGED,True,https://codereview.qt-project.org/#/c/27306,Clean up QJSValue tests.,1.0,{},0.0,"{'// FIXME: No c-style callbacks currently': 1, '// FIXME: No automatic sequence conversion<KAIGYO>// array': 1, '// FIXME: No setters/getters right now': 1, '// FIXME: No setters/getters right now<KAIGYO>// getter/setter that throws an error': 1, '// FIXME: No c-style functions right now<KAIGYO>// attempt to install getter+setter on built-in (native) property': 1, ""// FIXME: No c-style functions right now<KAIGYO>// global property that's a getter+setter"": 1, '// FIXME: No setters/getters API right now<KAIGYO>// """" an existing property to become a getter+setter': 1, '// FIXME: No setters/getters API right now<KAIGYO>//removing unexisting Setter or Getter should not crash.': 1, '// FIXME: no setProperty API with flags<KAIGYO>// ReadOnly': 1, '// FIXME: No c-style functions': 1, '// FIXME: No QJSValue::scope': 1, '// FIXME: no setData/data API': 1, '// FIXME: no QScriptClass': 1, '// FIXME: No c-style callbacks': 1, '// FIXME: The feature of interpreting a passed array as argument list has been removed from the API': 1, '// FIXME: No c-style callbacks<KAIGYO>// test that invalid arguments are handled gracefully': 1, '// FIXME: No c-style callbacks<KAIGYO>// test that invalid return value is handled gracefully': 1, '// FIXME: The feature of interpreting an array as argument list has been removed from the API': 1, '// FIXME: no c-style callbacks': 1, '// FIXME: The feature of interpreting an array as argument list has been removed from the API<KAIGYO>// construct(QJSValue)': 1, '// FIXME: No QJSValue::lessThan': 1, '//    qDebug() << actual << expected;<KAIGYO>//        qDebug() << i << actual.at(i) << expected.at(i);<KAIGYO>// FIXME: no objectId()': 1, '// FIXME: No automatic sequence conversion': 3}",1.0,{}
194,27352.0,1.0,10.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/27352,Fixed KMS y-invertedness.,1.0,{},0.0,"{'//TODO: Handle more senarios than assuming at least 2 buffers': 1, '//After flush, the current render target should be moved to<KAIGYO>//latest complete': 1, '//TODO: Do something with return value here': 1}",1.0,{}
191,27355.0,4.0,12.0,0.0,ABANDONED,False,https://codereview.qt-project.org/#/c/27355,WIP: Make QQuickItemView and the items in its model accessible.,1.0,{},0.0,{'// FIXME can this happen?': 1},1.0,{}
406,27477.0,7.0,22.0,11.0,MERGED,True,https://codereview.qt-project.org/#/c/27477,Adapt to connection-related changes in qtbase,1.0,"{'// TODO<KAIGYO>// TODO<KAIGYO>//return QMetaObjectPrivate::connect(sender, signal_index, receiver, method_index, type, types);': 3}",1.0,"{""//### doing two string-based lookups isn't ideal"": 1}",1.0,{}
260,27486.0,5.0,24.0,16.0,MERGED,True,https://codereview.qt-project.org/#/c/27486,QtNetwork: remove double buffering on sockets,1.0,{'// no socket engine is probably EOF': 4},1.0,"{'// for QTcpSocket this is already done because it uses the readBuffer/writeBuffer<KAIGYO>// if the QIODevice it is based on<KAIGYO>// ### FIXME QSslSocket should probably do similar instead of having<KAIGYO>// its own readBuffer/writeBuffer': 1, '// no socket engine is probably EOF': 4}",1.0,{}
359,27687.0,2.0,5.0,3.0,MERGED,True,https://codereview.qt-project.org/#/c/27687,Update SDK/Installer creation python scripts,1.0,"{'# todo, is needed?': 1, '# sanity check, duplicate template should not exist to avoid<KAIGYO># problems!': 1}",1.0,"{'# TODO, check if target_install_dir is needed at all': 1}",1.0,{}
376,27766.0,5.0,22.0,2.0,MERGED,True,https://codereview.qt-project.org/#/c/27766,Implement WindowTransparentForInput flag in Windows platform.,1.0,{'// maybe needs revisit WS_EX_LAYERED': 4},1.0,{'// maybe needs revisit WS_EX_LAYERED': 4},1.0,{}
454,27985.0,1.0,3.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/27985,mksrc.sh: cleanup and fixes,1.0,{},0.0,"{'#------------------------------------------------------------------<KAIGYO># Step x,  remove rest of the unnecessary files   TODO<KAIGYO>#------------------------------------------------------------------<KAIGYO># Step x,  replace version strings with correct version, and': 1, '# Step x,  generate docs TODO': 1}",1.0,{}
39,28100.0,1.0,7.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/28100,Remove particles examples launcher,1.0,{},0.0,"{'//TODO: Augment with PARTICLES': 1, '//TODO: Transitions between modes (and a second mode...)': 1}",1.0,{}
65,28185.0,1.0,7.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/28185,Logging: Remove outdated QMessageHandler,1.0,{},0.0,{'// TODO: Remove before Qt5.0 beta': 1},1.0,{}
87,28240.0,2.0,9.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/28240,Fix a crash when calling effectiveWinId() on parentless widgets.,1.0,{},0.0,"{""// In transitional state. This is really just a workaround. The real problem<KAIGYO>// is that QWidgetPrivate::setParent_sys (platform specific code) first sets<KAIGYO>// the window id to 0 (setWinId(0)) before it sets the Qt::WA_WState_Created<KAIGYO>// attribute to false. The correct way is to do it the other way around, and<KAIGYO>// in that case the Qt::WA_WState_Created logic above will kick in and<KAIGYO>// return 0 whenever the widget is in a transitional state. However, changing<KAIGYO>// the original logic for all platforms is far more intrusive and might<KAIGYO>// break existing applications.<KAIGYO>// Note: The widget can only be in a transitional state when changing its<KAIGYO>// parent -- everything else is an internal error -- hence explicitly checking<KAIGYO>// against 'inSetParent' rather than doing an unconditional return whenever<KAIGYO>// 'realParent' is 0 (which may cause strange artifacts and headache later)."": 2}",1.0,{}
128,28261.0,2.0,8.0,10.0,MERGED,True,https://codereview.qt-project.org/#/c/28261,Evaluate bindings more intelligently during construction,1.0,{'// TODO: avoid construction of name and name-based lookup': 2},1.0,{'//TODO: avoid construction of name and name-based lookup': 2},1.0,{}
122,28331.0,1.0,2.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/28331,Make the create_installer.py to locate ifw tools automaticly,1.0,{},0.0,"{'# todo, hard coded path used...': 1}",1.0,{}
140,28336.0,6.0,27.0,8.0,MERGED,True,https://codereview.qt-project.org/#/c/28336,implement Qt::TranslucentBackground for Windows,1.0,{},0.0,{'// TODO: Prepare paint for translucent windows.': 1},1.0,{}
229,28542.0,3.0,11.0,4.0,MERGED,True,https://codereview.qt-project.org/#/c/28542,Make testrunner/testscheduler output unambiguous.,1.0,"{""# no, we're not done.<KAIGYO># shall we give up?"": 3}",1.0,"{""# no, we're not done.<KAIGYO># shall we give up?"": 3}",1.0,{}
284,28702.0,1.0,1.0,0.0,ABANDONED,False,https://codereview.qt-project.org/#/c/28702,Allow platform specific font matching,1.0,"{'// Make defaultFont pattern matching locale language aware, because<KAIGYO>// certain FC_LANG based custom rules may happen in FcConfigSubstitute()': 1, '// Hack to get system default language until FcGetDefaultLangs()<KAIGYO>// is exported (httpsbugs.freedesktop.org/show_bug.cgi?id=32853)<KAIGYO>// or httpsbugs.freedesktop.org/show_bug.cgi?id=35482 is fixed': 1}",1.0,"{'// Hack to get system default language until FcGetDefaultLangs()<KAIGYO>// is exported (httpsbugs.freedesktop.org/show_bug.cgi?id=32853)<KAIGYO>// or httpsbugs.freedesktop.org/show_bug.cgi?id=35482 is fixed': 1, '// Make defaultFont pattern matching locale language aware, because<KAIGYO>// certain FC_LANG based custom rules may happen in FcConfigSubstitute()': 1}",1.0,{}
323,28748.0,3.0,8.0,1.0,MERGED,True,https://codereview.qt-project.org/#/c/28748,Cleanup/simplify tweetsearch example,1.0,{},0.0,{'// 2x time spent each side to wiggle away before shrinking in<KAIGYO>// Size on each side it moves away before shrinking during the transition<KAIGYO>// More give a greater squeeze during transition (0.0 for none)': 1},1.0,{}
348,28768.0,8.0,28.0,4.0,MERGED,True,https://codereview.qt-project.org/#/c/28768,Fix configure.exe to build qmake before tests,1.0,{'//TODO actually wrong.': 4},1.0,{'//TODO actually wrong.': 4},1.0,{}
336,28804.0,4.0,6.0,3.0,MERGED,True,https://codereview.qt-project.org/#/c/28804,Optimization autodetect serial ports using libudev,1.0,"{""// PNP bus type<KAIGYO>// Append this devices.<KAIGYO>// FIXME: How to get additional information about serial devices<KAIGYO>// with this subsystem?<KAIGYO>// Platform 'pseudo' bus for legacy devices.<KAIGYO>// Skip this devices because this type of subsystem does<KAIGYO>// not include a real physical serial devices.<KAIGYO>// Others types of subsystems.<KAIGYO>// Append this devices because we believe that any other types of<KAIGYO>// subsystems provide a real serial devices. For example, for devices<KAIGYO>// such as ttyGSx, its driver provide an empty subsystem name, but it<KAIGYO>//devices is a real physical serial devices.<KAIGYO>// FIXME: How to get additional information about serial devices<KAIGYO>// with this subsystems?"": 1, ""// PNP bus type<KAIGYO>// Append this devices.<KAIGYO>// FIXME: How to get additional information about serial devices<KAIGYO>// with this subsystem?<KAIGYO>// Platform 'pseudo' bus for legacy devices.<KAIGYO>// Skip this devices because this type of subsystem does<KAIGYO>// not include a real physical serial devices.<KAIGYO>// Others types of subsystems.<KAIGYO>// Append this devices because we believe that any other types of<KAIGYO>// subsystems provide a real serial devices. For example, for devices<KAIGYO>// such as ttyGSx, its driver provide an empty subsystem name, but it<KAIGYO>// devices is a real physical serial devices.<KAIGYO>// FIXME: How to get additional information about serial devices<KAIGYO>// with this subsystems?"": 2, ""// PNP bus type<KAIGYO>// Append this device.<KAIGYO>// FIXME: How to get additional information about serial devices<KAIGYO>// with this subsystem?<KAIGYO>// Platform 'pseudo' bus for legacy device.<KAIGYO>// Skip this devices because this type of subsystem does<KAIGYO>// not include a real physical serial device.<KAIGYO>// Others types of subsystems.<KAIGYO>// Append this devices because we believe that any other types of<KAIGYO>// subsystems provide a real serial devices. For example, for devices<KAIGYO>// such as ttyGSx, its driver provide an empty subsystem name, but it<KAIGYO>// devices is a real physical serial devices.<KAIGYO>// FIXME: How to get additional information about serial devices<KAIGYO>// with this subsystems?"": 4}",1.0,"{'// FIXME: How can I get a additional info about standard serial devices?': 1, '// FIXME: How to get additional information about serial devices with empty subsystem, like gadget serial devices ?': 1}",1.0,{}
397,28943.0,1.0,5.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/28943,Fix non inheritable socket creation on old windows versions,1.0,{'// make non inheritable the old way': 1},1.0,{'// make non inheritable the old way': 1},1.0,{}
429,28998.0,3.0,11.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/28998,Remove stale demos,1.0,{},0.0,"{""//Workaround: Doesn't work below lines"": 1, '// TODO: Use qrc path once QTBUG-21129 is fixed': 1, '//TODO: calculate hit and damage at target, which must be a Ship': 1, '//TODO: Actual targetVariation': 1, '//TODO: Add particles to this component too': 1, '//TODO: Ship abstraction': 1, ""//TODO: Cooler would be an 'orbiting' affector<KAIGYO>//TODO: On the subject, opacity and size should be grouped type 'overLife' if we can cram that in the particles"": 1, '//TODO: Hardpoint abstraction': 1, '            /*<KAIGYO>            Flickable {<KAIGYO>                y: 60<KAIGYO>                width: 360<KAIGYO>                height: 500<KAIGYO>                contentHeight: txt1.height<KAIGYO>                contentWidth: 360//TODO: Less magic numbers?<KAIGYO>                */': 1, '//TODO: Less magic numbers?': 1, '//Really effective against unregistered vessels': 1, '//Misses with Lasers are really rare': 1, '//XXX: Terrible hack': 1, '//TODO: Somehow get particles into this?': 1, '//TODO: Not a magic number': 1, '//TODO: Particle Text?': 1, '//TODO: Better error handling?': 1, '// move the head': 1}",1.0,{}
44,29081.0,1.0,1.0,0.0,ABANDONED,False,https://codereview.qt-project.org/#/c/29081,Get rid of activeWindow hack in menu,1.0,{},0.0,{'// ### activeWindow hack': 1},1.0,{}
63,29113.0,1.0,2.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/29113,Get rid of activeWindow hack in menu,1.0,{},0.0,{'// ### activeWindow hack': 1},1.0,{}
75,29127.0,1.0,2.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/29127,Remove mac specific hack,1.0,{},0.0,{'// WS_MAC: Qt 4-only workaround': 1},1.0,{}
133,29238.0,1.0,15.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/29238,Make QRegion not need to be friends with QVector,1.0,{},0.0,{'// hw: modify the vector size directly to avoid reallocation': 1},1.0,{}
234,29423.0,2.0,9.0,2.0,MERGED,True,https://codereview.qt-project.org/#/c/29423,Call QObject::disconnectNotify() when receiver is destroyed,1.0,{},0.0,"{'// disconnectNotify() is not called, but it probably should be.': 1}",1.0,{}
343,29714.0,1.0,3.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/29714,Updates to jenkins build scripts,1.0,{},0.0,{'# Remove this once we have webkit building nicely in mac.<KAIGYO># install all': 1},1.0,{}
385,29816.0,2.0,13.0,1.0,MERGED,True,https://codereview.qt-project.org/#/c/29816,A step out from Harfbuzz (reduce dependency),1.0,{},0.0,"{""// ### what's the proper value?"": 1}",1.0,{}
368,29817.0,4.0,40.0,2.0,MERGED,True,https://codereview.qt-project.org/#/c/29817,Remove QToolButton's protected constructor,1.0,{},0.0,{'//workaround for task 177850': 1},1.0,{}
411,29856.0,4.0,6.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/29856,Make Behaviors work correctly with value types.,1.0,{'// XXX We should evaluate all methods in a single big script block to': 1},1.0,{'// XXX We should evaluate all methods in a single big script block to ': 1},1.0,{}
467,29924.0,1.0,1.0,0.0,ABANDONED,False,https://codereview.qt-project.org/#/c/29924,Merge branch 'master' into qt5,1.0,"{'//        _dialog->setParent(canvas(), Qt::Dialog);<KAIGYO>// FIXME': 1}",1.0,{'// Note this really messes up things for scrollbar<KAIGYO>// if (Math.abs(newX - fakeHandle.x) > handleLoader.width / 2)': 1},1.0,{}
468,29930.0,1.0,5.0,2.0,ABANDONED,False,https://codereview.qt-project.org/#/c/29930,Merge branch 'master' into qt5,1.0,"{'//        _dialog->setParent(canvas(), Qt::Dialog);<KAIGYO>// FIXME': 1}",1.0,{'// Note this really messes up things for scrollbar<KAIGYO>// if (Math.abs(newX - fakeHandle.x) > handleLoader.width / 2)': 1},1.0,{}
28,30108.0,1.0,2.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/30108,Fix Splitters to use new API,1.0,"{""// Why doesn't X-axis work?"": 1}",1.0,"{""// Why doesn't X-axis work?"": 1}",1.0,{}
103,30438.0,3.0,10.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/30438,QQuickRenderThreadSingleContextWindowManager in separate files,1.0,"{'/*<KAIGYO>  Threaded Rendering<KAIGYO><KAIGYO>  The threaded rendering uses a number of different variables to track potential<KAIGYO>  states used to handle resizing, initial paint, grabbing and driving animations<KAIGYO>  while ALWAYS keeping the GL context in the rendering thread and keeping the<KAIGYO>  overhead of normal one-shot paints and vblank driven animations at a minimum.<KAIGYO><KAIGYO>  Resize, initial show and grab suffer slightly in this model as they are locked<KAIGYO>  to the rendering in the rendering thread, but this is a necessary evil for<KAIGYO>  the system to work.<KAIGYO><KAIGYO>  Variables that are used:<KAIGYO><KAIGYO>  Private::animationRunning: This is true while the animations are running, and only<KAIGYO>  written to inside locks.<KAIGYO><KAIGYO>  RenderThread::isGuiLocked: This is used to indicate that the GUI thread owns the<KAIGYO>  lock. This variable is an integer to allow for recursive calls to lockInGui()<KAIGYO>  without using a recursive mutex. See isPostingSyncEvent.<KAIGYO><KAIGYO>  RenderThread::isPostingSyncEvent: This variable is set in the render thread just<KAIGYO>  before the sync event is sent to the GUI thread. It is used to avoid deadlocks<KAIGYO>  in the case where render thread waits while waiting for GUI to pick up the sync<KAIGYO>  event and GUI thread gets a resizeEvent, the initial paintEvent or a grab.<KAIGYO>  When this happens, we use the<KAIGYO>  exhaustSyncEvent() function to do the sync right there and mark the coming<KAIGYO>  sync event to be discarded. There can only ever be one sync incoming.<KAIGYO><KAIGYO>  RenderThread::isRenderBlock: This variable is true when animations are not<KAIGYO>  running and the render thread has gone to sleep, waiting for more to do.<KAIGYO><KAIGYO>  RenderThread::isExternalUpdatePending: This variable is set to false when<KAIGYO>  a new render pass is started and to true in maybeUpdate(). It is an<KAIGYO>  indication to the render thread that another render pass needs to take<KAIGYO>  place, rather than the render thread going to sleep after completing its swap.<KAIGYO><KAIGYO>  RenderThread::doGrab: This variable is set by the grab() function and<KAIGYO>  tells the renderer to do a grab after rendering is complete and before<KAIGYO>  swapping happens.<KAIGYO><KAIGYO>  RenderThread::shouldExit: This variable is used to determine if the render<KAIGYO>  thread should do a nother pass. It is typically set as a result of show()<KAIGYO>  and unset as a result of hide() or during shutdown()<KAIGYO><KAIGYO>  RenderThread::hasExited: Used by the GUI thread to synchronize the shutdown<KAIGYO>  after shouldExit has been set to true.<KAIGYO> */': 1}",1.0,"{'/*<KAIGYO>  Threaded Rendering<KAIGYO><KAIGYO>  The threaded rendering uses a number of different variables to track potential<KAIGYO>  states used to handle resizing, initial paint, grabbing and driving animations<KAIGYO>  while ALWAYS keeping the GL context in the rendering thread and keeping the<KAIGYO>  overhead of normal one-shot paints and vblank driven animations at a minimum.<KAIGYO><KAIGYO>  Resize, initial show and grab suffer slightly in this model as they are locked<KAIGYO>  to the rendering in the rendering thread, but this is a necessary evil for<KAIGYO>  the system to work.<KAIGYO><KAIGYO>  Variables that are used:<KAIGYO><KAIGYO>  Private::animationRunning: This is true while the animations are running, and only<KAIGYO>  written to inside locks.<KAIGYO><KAIGYO>  RenderThread::isGuiLocked: This is used to indicate that the GUI thread owns the<KAIGYO>  lock. This variable is an integer to allow for recursive calls to lockInGui()<KAIGYO>  without using a recursive mutex. See isPostingSyncEvent.<KAIGYO><KAIGYO>  RenderThread::isPostingSyncEvent: This variable is set in the render thread just<KAIGYO>  before the sync event is sent to the GUI thread. It is used to avoid deadlocks<KAIGYO>  in the case where render thread waits while waiting for GUI to pick up the sync<KAIGYO>  event and GUI thread gets a resizeEvent, the initial paintEvent or a grab.<KAIGYO>  When this happens, we use the<KAIGYO>  exhaustSyncEvent() function to do the sync right there and mark the coming<KAIGYO>  sync event to be discarded. There can only ever be one sync incoming.<KAIGYO><KAIGYO>  RenderThread::isRenderBlock: This variable is true when animations are not<KAIGYO>  running and the render thread has gone to sleep, waiting for more to do.<KAIGYO><KAIGYO>  RenderThread::isExternalUpdatePending: This variable is set to false when<KAIGYO>  a new render pass is started and to true in maybeUpdate(). It is an<KAIGYO>  indication to the render thread that another render pass needs to take<KAIGYO>  place, rather than the render thread going to sleep after completing its swap.<KAIGYO><KAIGYO>  RenderThread::doGrab: This variable is set by the grab() function and<KAIGYO>  tells the renderer to do a grab after rendering is complete and before<KAIGYO>  swapping happens.<KAIGYO><KAIGYO>  RenderThread::shouldExit: This variable is used to determine if the render<KAIGYO>  thread should do a nother pass. It is typically set as a result of show()<KAIGYO>  and unset as a result of hide() or during shutdown()<KAIGYO><KAIGYO>  RenderThread::hasExited: Used by the GUI thread to synchronize the shutdown<KAIGYO>  after shouldExit has been set to true.<KAIGYO> */': 1}",1.0,{}
107,30503.0,2.0,7.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/30503,Fix QScriptContextInfo::functionMetaIndex() for overloaded slots,1.0,{'// ### fixme<KAIGYO>//#ifndef Q_SCRIPT_NO_EVENT_NOTIFY<KAIGYO>//            engine->notifyFunctionEntry(context);<KAIGYO>//#endif': 2},1.0,{'// ### fixme<KAIGYO>//#ifndef Q_SCRIPT_NO_EVENT_NOTIFY<KAIGYO>//            engine->notifyFunctionEntry(context);<KAIGYO>//#endif': 2},1.0,{}
159,30641.0,7.0,15.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/30641,Change antialiasing method for QML2.,1.0,{},0.0,"{'// For stretch this algorithm could be simplified to use less vertices<KAIGYO>// as more vertices could be reused then, but I doubt its where our main<KAIGYO>// problem will lie. This way, we at least share the algorithm between all': 7, '// Fill in the vertices.. The loop below is pretty much an exact replica<KAIGYO>// of the one inside fillRow.': 7}",1.0,{}
150,30818.0,2.0,6.0,2.0,MERGED,True,https://codereview.qt-project.org/#/c/30818,parse_build_log: replace File::Fetch with AnyEvent::HTTP,1.0,{'# Give up ...': 2},1.0,"{'# Work around a silly File::Fetch behavior.<KAIGYO># File::Fetch breaks if the URL ends with a `/\'.<KAIGYO># It croaks with: No \'file\' specified<KAIGYO># ...because it requires the URL to have a """" component for<KAIGYO># some reason.<KAIGYO>#<KAIGYO># Note that we can\'t 100% guarantee that silently removing this<KAIGYO># doesn\'t change the result :(': 1, '# Give up ...': 2}",1.0,{}
167,30905.0,3.0,9.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/30905,Particle example restyling,1.0,{'//A bit of turbulence makes the smoke look better': 1},1.0,{'//A bit of turbulence makes the smoke look better': 1},1.0,{}
50,31339.0,1.0,3.0,4.0,ABANDONED,False,https://codereview.qt-project.org/#/c/31339,Runtime alias resolution,1.0,{'// TODO: avoid construction of name and name-based lookup': 1},1.0,{'//TODO: avoid construction of name and name-based lookup': 1},1.0,{}
142,31541.0,6.0,24.0,12.0,MERGED,True,https://codereview.qt-project.org/#/c/31541,Implement strict mode for qmldir modules,1.0,{},0.0,{'// XXX thread this code should probably be protected with a mutex.': 1},1.0,{}
79,31711.0,2.0,17.0,26.0,ABANDONED,False,https://codereview.qt-project.org/#/c/31711,Unix engine refactoring.,1.0,{},0.0,"{'// yes, speed is really custom': 1}",1.0,{}
145,31871.0,6.0,18.0,6.0,MERGED,True,https://codereview.qt-project.org/#/c/31871,Permit value types with metatype IDs >= QMetaType::User,1.0,{'// TODO: Investigate the performance/memory characteristics of<KAIGYO>// removing the preallocated array': 1},1.0,{'// XXX threadsafe?': 1},1.0,{}
113,31875.0,2.0,10.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/31875,jenkins: add log synchronization support,1.0,"{'# We need to know the pid, but note the caller might have asked for it too.': 1, '# something bad happened': 1, '# any other kind of error is considered fatal': 1}",1.0,{'# FIXME: support testresults.qt-project.org logs': 1},1.0,{}
20,32039.0,1.0,5.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/32039,Prepare QtHelp library for modularized documentation.,1.0,{},0.0,"{'// TODO: For some reason the url to load is already wrong (passed from webkit)<KAIGYO>// though the css file and the references inside should work that way. One <KAIGYO>// possible problem might be that the css is loaded at the same level as the<KAIGYO>// html, thus a path inside the css like (../images/foo.png) might cd out of<KAIGYO>// the virtual folder': 1}",1.0,{}
42,32148.0,6.0,10.0,1.0,MERGED,True,https://codereview.qt-project.org/#/c/32148,Fixes and fine tuning of the Qt5 build script.,1.0,"{""#print_wrap(make_def_line)<KAIGYO>#TODO: check if there is more than one line in Makefile<KAIGYO>#change 'module-qtbase-make_first' to 'qtbase'"": 1}",1.0,"{""#TODO: check if there is more than one line in Makefile<KAIGYO>#change 'module-qtbase-make_default' to 'qtbase'"": 1, ""#    if bldinstallercommon.is_mac_platform():   #TODO<KAIGYO>#        print '    mac'<KAIGYO>#restore pri files to each submodule and to the chunk of all modules"": 5}",1.0,{}
59,32240.0,2.0,13.0,10.0,MERGED,True,https://codereview.qt-project.org/#/c/32240,Moving WinCe implementation to the separate module.,1.0,"{'// FIXME:': 1, '/*!<KAIGYO>    Restores or suspend character transmission and places the<KAIGYO>    transmission line in a nonbreak or break state,<KAIGYO>    depending on the parameter \\a set.<KAIGYO><KAIGYO>    If successful, returns true; otherwise returns false.<KAIGYO>*/': 1, '// FIXME: Process emulate policy.': 1, '// FIXME: Forward checking available data for read.<KAIGYO>// This is a bad decision, because call bytesAvailable() automatically<KAIGYO>// clears the error parity, frame, etc. That is, then in the future,<KAIGYO>// it is impossible to identify them in the process of reading the data.': 1, '// FIXME: Here the situation is not properly handled with zero timeout:<KAIGYO>// breaker can work out before you call a method WaitCommEvent()<KAIGYO>// and so it will loop forever!': 1, '// FIXME: Here call the bytesAvailable() to protect against false positives<KAIGYO>// WaitForSingleObject(), for example, when manually pulling USB/Serial<KAIGYO>// converter from system, ie when devices are in fact not.<KAIGYO>// While it may be possible to make additional checks - to catch an event EV_ERR,<KAIGYO>// adding (in the code above) extra bits in the mask currEventMask.': 1, '//FIXME: This is why it does not work?': 1}",1.0,"{'// FIXME: Here the situation is not properly handled with zero timeout:<KAIGYO>// breaker can work out before you call a method WaitCommEvent()<KAIGYO>// and so it will loop forever!': 1, '//FIXME: This is why it does not work?': 1}",1.0,{}
84,32258.0,5.0,20.0,4.0,MERGED,True,https://codereview.qt-project.org/#/c/32258,SerialPortInfo optimization of the internal struct,1.0,"{""// PNP bus type<KAIGYO>// Append this device.<KAIGYO>// FIXME: How to get additional information about serial devices<KAIGYO>// with this subsystem?<KAIGYO>// Platform 'pseudo' bus for legacy device.<KAIGYO>// Skip this devices because this type of subsystem does<KAIGYO>// not include a real physical serial device."": 1, '// Others types of subsystems.<KAIGYO>// Append this devices because we believe that any other types of<KAIGYO>// subsystems provide a real serial devices. For example, for devices<KAIGYO>// such as ttyGSx, its driver provide an empty subsystem name, but it<KAIGYO>// devices is a real physical serial devices.<KAIGYO>// FIXME: How to get additional information about serial devices<KAIGYO>// with this subsystems?': 1}",1.0,"{""// PNP bus type<KAIGYO>// Append this device.<KAIGYO>// FIXME: How to get additional information about serial devices<KAIGYO>// with this subsystem?<KAIGYO>// Platform 'pseudo' bus for legacy device.<KAIGYO>// Skip this devices because this type of subsystem does<KAIGYO>// not include a real physical serial device."": 1, '// Others types of subsystems.<KAIGYO>// Append this devices because we believe that any other types of<KAIGYO>// subsystems provide a real serial devices. For example, for devices<KAIGYO>// such as ttyGSx, its driver provide an empty subsystem name, but it<KAIGYO>// devices is a real physical serial devices.<KAIGYO>// FIXME: How to get additional information about serial devices<KAIGYO>// with this subsystems?': 1, '// TODO: Implement me.<KAIGYO>//': 1}",1.0,{}
94,32544.0,3.0,6.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/32544,Move docs closer to the members that they document,1.0,"{'/*!<KAIGYO>    \\qmltype Scale<KAIGYO>    \\instantiates QQuickScale<KAIGYO>    \\inqmlmodule QtQuick 2<KAIGYO>    \\ingroup qtquick-visual-transforms<KAIGYO>    \\brief Provides a way to scale an Item<KAIGYO><KAIGYO>    The Scale type provides a way to scale an \\l Item through a scale-type<KAIGYO>    transform.<KAIGYO><KAIGYO>    It allows different scaling values for the x and y axes, and allows the<KAIGYO>    scale to be relative to an arbitrary point. This gives more control over<KAIGYO>    item scaling than the \\l{Item::}{scale} property.<KAIGYO><KAIGYO>    The following example scales the X axis of the Rectangle, relative to<KAIGYO>    its interior point (25, 25):<KAIGYO><KAIGYO>    \\qml<KAIGYO>    Rectangle {<KAIGYO>        width: 100; height: 100<KAIGYO>        color: """"<KAIGYO>        transform: Scale { origin.x: 25; origin.y: 25; xScale: 3}<KAIGYO>    }<KAIGYO>    \\endqml<KAIGYO><KAIGYO>    \\sa Rotation, Translate<KAIGYO>*/': 1}",1.0,{'/*!<KAIGYO>    \\enum QQuickItem::TransformOrigin<KAIGYO><KAIGYO>    Controls the point about which simple transforms like scale apply.<KAIGYO><KAIGYO>    \\value TopLeft The top-left corner of the item.<KAIGYO>    \\value Top The center point of the top of the item.<KAIGYO>    \\value TopRight The top-right corner of the item.<KAIGYO>    \\value Left The left most point of the vertical middle.<KAIGYO>    \\value Center The center of the item.<KAIGYO>    \\value Right The right most point of the vertical middle.<KAIGYO>    \\value BottomLeft The bottom-left corner of the item.<KAIGYO>    \\value Bottom The center point of the bottom of the item.<KAIGYO>    \\value BottomRight The bottom-right corner of the item.<KAIGYO>*/': 1},1.0,{}
142,32943.0,4.0,8.0,1.0,MERGED,True,https://codereview.qt-project.org/#/c/32943,Ensure we are using the correct SHA-1 in submodule checkout,1.0,{},0.0,"{'# FIXME how do we guarantee we have this SHA1?<KAIGYO># Is a SHA1, else is a ref and may need to be fetched': 1}",1.0,{}
99,33919.0,1.0,2.0,0.0,ABANDONED,False,https://codereview.qt-project.org/#/c/33919,WIP: Docs move,1.0,{},0.0,"{'/*!<KAIGYO>    \\title QtQuick Examples - Local Storage<KAIGYO>    \\example localstorage<KAIGYO>    \\brief This is a collection of QML local storage examples<KAIGYO>    \\image qml-localstorage-example.png<KAIGYO><KAIGYO>    This is a collection of small QML examples relating to local storage functionality.<KAIGYO><KAIGYO>    Hello World demos creating a simple SQL table and how to do inserting/selecting operations.<KAIGYO><KAIGYO>*/': 1, '/*!<KAIGYO>    \\title QtQuick.Particles Examples - Affectors<KAIGYO>    \\example particles/affectors<KAIGYO>    \\brief This is a collection of examples using Affectors in the QML particle system.<KAIGYO>    \\image qml-affectors-example.png<KAIGYO><KAIGYO>    This is a collection of small QML examples relating to using Affectors in the particle system.<KAIGYO>    Each example is a small QML file emphasizing a particular element or feature.<KAIGYO><KAIGYO>    Age demonstrates using an Age affector to prematurely end the lives of particles.<KAIGYO>    \\snippet examples/particles/affectors/content/age.qml 0<KAIGYO><KAIGYO>    As you move the affector around the screen, the particles inside it<KAIGYO>    (which haven\'t already been affected) jump to a period near the end<KAIGYO>    of their life. This gives them a short period to finish fading out,<KAIGYO>    but changing lifeLeft to 0 (the default), would cause them to reach<KAIGYO>    the end of their life instantly.<KAIGYO><KAIGYO>    Attractor demonstrates using an Attractor affector to simulate a black hole<KAIGYO>    \\snippet examples/particles/affectors/content/attractor.qml 0<KAIGYO><KAIGYO>    All particles in the scene, including the rocket ship\'s exhaust and pellets, are pulled<KAIGYO>    towards the black hole. This effect is stronger closer to the black hole, so the<KAIGYO>    asteroids near the top of the screen are barely affected at all, while the ones<KAIGYO>    towards the middle sometimes curve drastically. To complete the effect, an Age<KAIGYO>    affector covers the black hole to destroy particles which come in contact with it.<KAIGYO><KAIGYO>    Custom Affector manipulates the properties of the particles directly in javascript.<KAIGYO>    One Affector is used to make the leaves rock back and forth as they fall, looking more<KAIGYO>    leaf-like than just spinning in circles:<KAIGYO>    \\snippet examples/particles/affectors/content/customaffector.qml 0<KAIGYO>    Another is used to provide a slightly varying friction to the leaves as they \'land\',<KAIGYO>    to look more natural:<KAIGYO>    \\snippet examples/particles/affectors/content/customaffector.qml 1<KAIGYO><KAIGYO>    Friction is similar to the falling leaves in the custom affector, except that it uses a<KAIGYO>    flat friction the whole way down instead of custom affectors.<KAIGYO>    \\snippet examples/particles/affectors/content/friction.qml 0<KAIGYO><KAIGYO>    Gravity is a convenience affector for applying a constant acceleration to particles inside it<KAIGYO>    \\snippet examples/particles/affectors/content/gravity.qml 0<KAIGYO><KAIGYO>    GroupGoal sets up two particle groups for flaming and non-flaming balls, and gives you various<KAIGYO>    ways to transition between them.<KAIGYO>    \\snippet examples/particles/affectors/content/groupgoal.qml unlit<KAIGYO>    The non-flaming balls have a one in a hundred chance of lighting on their own each second, but they also<KAIGYO>    have a GroupGoal set on the whole group. This affector affects all particles of the unlit group, when colliding<KAIGYO>    with particles in the lit group, and cause them to move to the lighting group.<KAIGYO>    \\snippet examples/particles/affectors/content/groupgoal.qml lighting<KAIGYO>    lighting is an intermediate group so that the glow builds up and the transition is less jarring. So it automatically<KAIGYO>    moves into the lit group after 100ms.<KAIGYO>    \\snippet examples/particles/affectors/content/groupgoal.qml lit<KAIGYO>    The lit group also has TrailEmitters on it for additional fire and smoke, but does not transition anywhere.<KAIGYO>    There are two more GroupGoal elements that allow particles in the unlit group to transition to the lighting group<KAIGYO>    (and then to the lit group).<KAIGYO>    \\snippet examples/particles/affectors/content/groupgoal.qml groupgoal-pilot<KAIGYO>    The first is just an area bound to the location of an image of a pilot flame. When unlit balls pass through the flame,<KAIGYO>    they go straight to lit because the pilot flame is so hot.<KAIGYO>    \\snippet examples/particles/affectors/content/groupgoal.qml groupgoal-ma<KAIGYO>    The second is bound to the location of the last pointer interaction, so that touching or clicking on unlit balls (which<KAIGYO>    is hard due to their constant movement) causes them to move to the lighting group.<KAIGYO><KAIGYO>    Move shows some simple effects you can get by altering trajectory midway.<KAIGYO>    The red particles have an affector that affects their position, jumping them forwards by 120px.<KAIGYO>    \\snippet examples/particles/affectors/content/move.qml A<KAIGYO>    The green particles have an affector that affects their velocity, but with some angle variation. By adding some random direction<KAIGYO>    velocity to their existing forwards velocity, they begin to spray off in a cone.<KAIGYO>    \\snippet examples/particles/affectors/content/move.qml B<KAIGYO>    The blue particles have an affector that affects their acceleration, and because it sets relative to false this resets the acceleration instead of<KAIGYO>    adding to it. Once the blue particles reach the affector, their horizontal velocity stops increasing as their vertical velocity decreases.<KAIGYO>    \\snippet examples/particles/affectors/content/move.qml C<KAIGYO><KAIGYO>    SpriteGoal has an affector which interacts with the sprite engine of particles, if they are being drawn as sprites by ImageParticle.<KAIGYO>    \\snippet examples/particles/affectors/content/spritegoal.qml 0<KAIGYO>    The SpriteGoal follows the image of the rocket ship on screen, and when it interacts with particles drawn by ImageParticle as sprites,<KAIGYO>    it instructs them to move immediately to the """" state, which in this case is the animation of the asteroid breaking into many pieces.<KAIGYO><KAIGYO>    Turbulence has a flame with smoke, and both sets of particles being affected by a Turbulence affector. This gives a faint wind effect.<KAIGYO>    \\snippet examples/particles/affectors/content/turbulence.qml 0<KAIGYO>    To make the wind change direction, subsitute a black and white noise image in the noiseSource parameter (it currently uses a default noise source).<KAIGYO><KAIGYO>    Wander uses a Wander affector to add some horizontal drift to snowflakes as they fall down.<KAIGYO>    \\snippet examples/particles/affectors/content/wander.qml 0<KAIGYO>    There are different movements given by applying the Wander to different attributes of the trajectory, so the example makes it easy to play around and see the difference.<KAIGYO>*/': 1, ""/*!<KAIGYO>    \\title QtQuick.Particles Examples - Affectors<KAIGYO>    \\example particles/imageparticle<KAIGYO>    \\brief This is a collection of examples using Affectors in the QML particle system.<KAIGYO>    \\image qml-imageparticle-example.png<KAIGYO><KAIGYO>    This is a collection of small QML examples relating to using Affectors in the particle system.<KAIGYO>    Each example is a small QML file emphasizing a particular element or feature.<KAIGYO><KAIGYO>    All at once shows off several of the features of ImageParticle at the same time.<KAIGYO>    \\snippet examples/particles/imageparticle/content/allatonce.qml 0<KAIGYO><KAIGYO>    Colored shows a simple ImageParticle with some color variation.<KAIGYO>    \\snippet examples/particles/imageparticle/content/colored.qml 0<KAIGYO><KAIGYO>    Color Table sets the color over life on the particles to provide a fixed rainbow effect.<KAIGYO>    \\snippet examples/particles/imageparticle/content/colortable.qml 0<KAIGYO><KAIGYO>    Deformation spins and squishes a starfish particle.<KAIGYO>    \\snippet examples/particles/imageparticle/content/colortable.qml spin<KAIGYO>    \\snippet examples/particles/imageparticle/content/colortable.qml deform<KAIGYO><KAIGYO>    Rotation demonstrates the autoRotate property, so that particles rotate in the direction that they travel.<KAIGYO><KAIGYO>    Sharing demonstrates what happens when multiple ImageParticles try to render the same particle.<KAIGYO>    The following ImageParticle renders the particles inside the ListView:<KAIGYO>    \\snippet examples/particles/imageparticle/content/sharing.qml 0<KAIGYO>    The following ImageParticle is placed inside the list highlight, and renders the particles above the other ImageParticle.<KAIGYO>    \\snippet examples/particles/imageparticle/content/sharing.qml 1<KAIGYO>    Note that because it sets the color and alpha in this ImageParticle, it renders the particles in a different color.<KAIGYO>    Since it doesn't specify anything about the rotation, it shares the rotation with the other ImageParticle so that the flowers are rotated the same way in both.<KAIGYO>    Note that you can undo rotation in another ImageParticle, you just need to explicity set rotationVariation to 0.<KAIGYO><KAIGYO>    Sprites demonstrates using an image particle to render animated sprites instead of static images for each particle.<KAIGYO>*/"": 1, '/*!<KAIGYO>    \\title QtQuick.Particles Examples - Affectors<KAIGYO>    \\example particles/system<KAIGYO>    \\brief This is a collection of examples using Affectors in the QML particle system.<KAIGYO>    \\image qml-system-example.png<KAIGYO><KAIGYO>    This is a collection of small QML examples relating to using Affectors in the particle system.<KAIGYO>    Each example is a small QML file emphasizing a particular element or feature.<KAIGYO><KAIGYO>    Dynamic comparison compares using the particle system to getting a similar effect with the following code that dynamically instantiates Image elements.<KAIGYO>    \\snippet examples/particles/system/content/dynamiccomparison.qml fake<KAIGYO>    Note how the Image elements are not able to be randomly colorized.<KAIGYO><KAIGYO>    Start and Stop simply sets the running and paused states of a ParticleSystem. While the system does not perform any simulation when stopped or paused, a restart restarts the simulation from the beginning, while unpausing resumes the simulation from where it was.<KAIGYO><KAIGYO>    Timed group changes is an example that highlights the ParticleGroup element. While normally referring to groups with a string name is sufficent, additional effects can be<KAIGYO>    done by setting properties on groups.<KAIGYO>    The first group has a variable duration on it, but always transitions to the second group.<KAIGYO>    \\snippet examples/particles/system/content/timedgroupchanges.qml 0<KAIGYO>    The second group has a TrailEmitter on it, and a fixed duration for emitting into the third group. By placing the TrailEmitter as a direct child of the ParticleGroup, it automatically selects that group to follow.<KAIGYO>    \\snippet examples/particles/system/content/timedgroupchanges.qml 1<KAIGYO>    The third group has an Affector as a direct child, which makes the affector automatically target this group. The affector means that as soon as particles enter this group, a burst function can be called on another emitter, using the x,y positions of this particle.<KAIGYO>    \\snippet examples/particles/system/content/timedgroupchanges.qml 2<KAIGYO><KAIGYO>    If TrailEmitter does not suit your needs for multiple emitters, you can also dynamically create Emitters while still using the same ParticleSystem and image particle<KAIGYO>    \\snippet examples/particles/system/content/dynamicemitters.qml 0<KAIGYO>    Note that this effect, a flurry of flying rainbow spears, would be better served with TrailEmitter. It is only done with dynamic emitters in this example to show the concept more simply.<KAIGYO><KAIGYO>    Multiple Painters shows how to control paint ordering of individual particles. While the paint ordering of particles within one ImagePainter is not strictly defined, ImageParticle elements follow the normal Z-ordering rules for QtQuick items. This example allow you to paint the inside of the particles above the black borders using a pair of ImageParticles each painting different parts of the same logical particle.<KAIGYO><KAIGYO>*/': 1}",1.0,{}
10,34162.0,1.0,3.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/34162,Cleanup and new commandline options to mkqt5bld script.,1.0,{},0.0,"{'#TODO: At the moment, it seems that installing to default location is necessary<KAIGYO>#to be able to install to INSTALL_ROOT, so remove here the installation from default location': 1}",1.0,{}
137,34371.0,6.0,23.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/34371,update qmake evaluator to newest version from qt creator,1.0,"{'// XXX optimize ... somehow': 1, '// FIXME: Qt really should have the option to set forwarding per channel': 1, ""// This is stupid, but qmake doesn't propagate deletions"": 1, '// FIXME: this should not build new strings for direct sections.<KAIGYO>// Note that the E_SPRINTF and E_LIST implementations rely on the deep copy.': 1, '// stupid, but qmake is like that': 1, '// FIXME: add check+warning about accidental value removal.<KAIGYO>// This may be a bit too noisy, though.': 1, '// The spec extends the feature search path, so rebuild the cache.': 1, '// MSVC doesn\'t seem to know the semantics of """" ...': 1, '// just gcc being stupid': 1, ""// FIXME: Qt's line end conversion on sequential files should really be fixed"": 4}",1.0,"{'// VariableName must be us-ascii, the content however can be non-us-ascii.<KAIGYO>// Temporaries for efficient toQString': 1, '// FIXME: this should not build new strings for direct sections.<KAIGYO>// Note that the E_SPRINTF and E_LIST implementations rely on the deep copy.': 1, '// stupid, but qmake is like that': 1, '//### FIXME': 1, '// The (QChar*)current->constData() constructs below avoid pointless detach() calls<KAIGYO>// FIXME: This is inefficient. Should not make new string if it is a straight subsegment': 1, '// FIXME: ret.reserve(ret.size() + replacement.size() - 2);': 1, ""// This is stupid, but qmake doesn't propagate deletions"": 1, '// XXX ignore_error unused': 1, '// Way too dangerous to enable.': 1, '// FIXME: could/should expand this immediately': 1}",1.0,{}
136,34402.0,2.0,4.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/34402,doc: fix some typos in .cpp files,1.0,"{'// XXX TODO: optimize?': 1, '//TODO: caching instead of excessively redoing iterative deepening (which was chosen arbitrarily anyways)': 1}",1.0,"{'// XXX TODO: optimise?': 1, '//TODO: caching instead of excessively redoing iterative deepening (which was chosen arbitarily anyways)': 1}",1.0,{}
139,34659.0,19.0,48.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/34659,New Jenkins<->Gerrit integrator.,1.0,"{""# Since the protocol itself doesn't provide any way to track our own build request,<KAIGYO># we include a request ID parameter"": 1, '# We need to know the pid, but note the caller might have asked for it too.': 1, '# something bad happened': 1, '# any other kind of error is considered fatal': 1, ""# Jenkins build data contains a lot of stuff we don't need, which can bloat our state file<KAIGYO># and api/json output; this list is used to limit the data to only the important parts for us.<KAIGYO># Feel free to expand this whenever you need it."": 1, '# TODO: post a comment back into gerrit?': 1, '# TODO: this is entirely blocking and not Coro/AnyEvent-aware, so<KAIGYO># no CI can make progress while SMTP negotations are slow': 4, '# autorestart on any kind of unexpected errors or hangs which occur during the main<KAIGYO># loop. $self->exit() is the only normal way to exit.': 5, '# autorestart on any kind of unexpected errors or hangs which occur during the main<KAIGYO># loop. $self->loop_exit() is the only normal way to exit.': 7, '# Returns true iff it seems a Jenkins build should be retried.<KAIGYO># $parsed_build should be the parsed output of summarize-jenkins-build.pl': 7, '# TODO: should we post a comment back into gerrit mentioning why the testing<KAIGYO># is taking longer than usual? Or would that just be confusing / noisy?': 7, '# State machine main loop for a given project.<KAIGYO>#<KAIGYO># This should be called once, from within a Coro.<KAIGYO># It runs an infinite loop.': 7, '# TODO: add a helpful top-level page?': 7, ""# Returns the logger object (Log::Dispatch).<KAIGYO># Example usage:<KAIGYO>#<KAIGYO>#   $self->logger()->warning( 'something bad happened!' );<KAIGYO>#"": 7}",1.0,"{'# We need to know the pid, but note the caller might have asked for it too.': 2, ""# Run a command, robustly.<KAIGYO>#<KAIGYO># The command may be retried several times, depending on the exit code.<KAIGYO>#<KAIGYO># Dies if the command doesn't eventually succeed.<KAIGYO>#<KAIGYO># Named parameter include:<KAIGYO>#<KAIGYO>#   stdin => some data to send to the stdin of the process (e.g. for staging-approve)<KAIGYO>#   stdout => scalar ref to receive stdout of the process<KAIGYO>#   cmd => arrayref specifying the command to run<KAIGYO>#   retry_exitcodes => arrayref specifying exit codes on which to retry<KAIGYO>#"": 2, '# something bad happened': 2, '# any other kind of error is considered fatal': 2, '# Maybe somebody else removed it?': 2}",1.0,"{'# We need to know the pid, but note the caller might have asked for it too.': '1-2', '# something bad happened': '1-2', '# any other kind of error is considered fatal': '1-2'}"
134,34999.0,3.0,5.0,1.0,MERGED,True,https://codereview.qt-project.org/#/c/34999,Add proper logging to QDoc bot,1.0,{'#TODO for know you need to have qt/qtbase checkout ready': 1},1.0,{'#TODO for know you need to have qt/qtbase checkout ready': 1},1.0,{}
64,35721.0,1.0,3.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/35721,qdoc-bot: Little fix to make it more maintainable,1.0,{'# TODO for now we care only about qtbase': 1},1.0,{'# TODO for now we care only about qtbase': 1},1.0,{}
73,35837.0,2.0,6.0,2.0,MERGED,True,https://codereview.qt-project.org/#/c/35837,Qt QDoc bot: Automatically initialize unknown projects.,1.0,{},0.0,{'#TODO for know you need to have qt/qtbase checkout ready': 1},1.0,{}
73,36360.0,1.0,3.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/36360,release-tools: The tools were moved to qtsdk.git,1.0,{},0.0,"{'# TODO, nasty hack, beucause of a bug in python ConfigParser module, loses trailing white spaces!!': 1, '#TODO, the returned values should be in config file, not return it here!': 1, '# filter out some files from search, TODO': 1, '# TODO, windows hack, on windows path+filename > 255 causes error, so truncate temp path as much as possible': 1, '# move archive in temporary path': 1, ""#TODO: check if there is more than one line in Makefile<KAIGYO>#change 'module-qtbase-make_first' to 'qtbase'"": 1, '#TODO: there probably is a better way to fix the delimeters, but this is working atm': 1, '#tag the master repo, maybe': 1, '#tag me, maybe': 1, '#------------------------------------------------------------------<KAIGYO># Step 6,  create zip file and tar files<KAIGYO>#------------------------------------------------------------------<KAIGYO># list text file regexp keywords, if you find something obvious missing, feel free to add': 1, '# todo, is needed?': 1, '# sanity check, duplicate template should not exist to avoid<KAIGYO># problems!': 1}",1.0,{}
41,36609.0,1.0,6.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/36609,parse_build_log: hoist consts out of inner loop,1.0,"{'# The max amount of characters permitted in a line;<KAIGYO># any more than this and we will truncate the line.<KAIGYO># Longer lines could trigger bad performance in some regexes, and it is<KAIGYO># not user-friendly to present such long lines to the reader.': 1, '# The max amount of lines to search around any interesting line for<KAIGYO># related text (for example, if a compiler failure message is seen for<KAIGYO># foo.cpp, look up to $RECENT_MAX lines in the past for other messages<KAIGYO># relating to .cpp).': 1}",1.0,"{'# The max amount of characters permitted in a line;<KAIGYO># any more than this and we will truncate the line.<KAIGYO># Longer lines could trigger bad performance in some regexes, and it is<KAIGYO># not user-friendly to present such long lines to the reader.': 1}",1.0,{}
43,36610.0,1.0,5.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/36610,parse_build_log: fixed performance of various regular expressions,1.0,{},0.0,"{'#   According to NYTProf, this regex is unusually slow ... why??<KAIGYO>#': 1}",1.0,{}
47,36612.0,1.0,4.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/36612,parse_build_log: remove pulse-specific code,1.0,{},0.0,"{""# the kind of timestamp prefix used by Pulse.<KAIGYO># example:<KAIGYO>#<KAIGYO>#  8/29/11 7:03:33 PM EST: Hi there<KAIGYO>#<KAIGYO># matches up to and including the `: '<KAIGYO>#<KAIGYO># Captures:<KAIGYO>#   date    -   the date string<KAIGYO>#   time    -   the time string (incl. AM/PM, and timezone)<KAIGYO>#"": 1, ""# Info about some pulse property.<KAIGYO>#<KAIGYO># Note that these lines come from our pulseconfig/test.pl script,<KAIGYO># and not from Pulse itself.  Pulse itself does not put the values<KAIGYO># of properties directly into the build logs.<KAIGYO>#<KAIGYO># Example:<KAIGYO>#<KAIGYO>#  PULSE_STAGE='linux-g++-32 Ubuntu 10.04 x86'<KAIGYO>#<KAIGYO># Captures:<KAIGYO>#   property    -   the property name (all in uppercase and _ instead of .,<KAIGYO>#                   e.g. QT_TESTS_ENABLED rather than qt.tests.enabled)<KAIGYO>#   value       -   the value of the property<KAIGYO>#"": 1}",1.0,{}
55,36794.0,1.0,3.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/36794,Fix QMenu coordinates when showing popup,1.0,{'// map coordinates from focusWidget rather than activeWindow since<KAIGYO>// QML items are commonly presented through a QWidget-derived view<KAIGYO>// still a hack': 1},1.0,{'// ### activeWindow hack': 1},1.0,{}
80,37211.0,1.0,3.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/37211,Merge branch 'qt5',1.0,{},0.0,"{'//  ToDo: adjust margins so that selected popup label<KAIGYO>//    centers directly above button label when<KAIGYO>//    popup.centerOnSelectedText === true': 1, '// XXX: since desktop uses int instead of real, the progressbar<KAIGYO>// range [0..1] must be stretched to a good precision': 1, ""// Why doesn't X-axis work?"": 1, '// This gives more native styling, but might be less performant': 1, '# XXX: Avoid call the linker': 1, '// Note this really messes up things for scrollbar<KAIGYO>// if (Math.abs(newX - fakeHandle.x) > handleLoader.width / 2)': 1, '        /*<KAIGYO>          Do a trial distribution and calculate how much it is off.<KAIGYO>          If there are more deficit pixels than surplus pixels, give<KAIGYO>          the minimum size items what they need, and repeat.<KAIGYO>          Otherwise give to the maximum size items, and repeat.<KAIGYO><KAIGYO>          Paul Olav Tvete has a wonderful mathematical proof of the<KAIGYO>          correctness of this principle, but unfortunately this<KAIGYO>          comment is too small to contain it.<KAIGYO>        */': 1, '// map coordinates from focusWidget rather than activeWindow since<KAIGYO>// QML items are commonly presented through a QWidget-derived view<KAIGYO>// still a hack': 1}",1.0,{}
13,37229.0,2.0,15.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/37229,Fix list functions for the data property,1.0,{},0.0,{'// XXX todo': 1},1.0,{}
53,37694.0,1.0,3.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/37694,qt_update_submodules: use QtQA::Gerrit to simplify code,1.0,{},0.0,"{""# Returns the Change-Id used for gerrit.<KAIGYO>#<KAIGYO># Technically, the value here does not really matter.<KAIGYO># However, it is nice to use the same Change-Id for contiguous update attempts,<KAIGYO># if the previous update attempt failed.<KAIGYO>#<KAIGYO># For example, consider this scenario:<KAIGYO>#<KAIGYO>#  - on Monday morning, this script attempts an update of qt5.git and pushes<KAIGYO>#    it to gerrit.  It is staged, but rejected due to a regression.<KAIGYO>#<KAIGYO>#  - during the day, someone fixes the problem.<KAIGYO>#<KAIGYO>#  - on Tuesday morning, the script again attempts an update of qt5.git.<KAIGYO>#<KAIGYO>#    This time, it should succeed as the regression is allegedly fixed.<KAIGYO>#<KAIGYO>#    It is preferable to update the gerrit change from yesterday with a second<KAIGYO>#    attempt (patch set 2), rather than creating a whole new gerrit change<KAIGYO>#    (which would make the prior change useless and require someone to abandon<KAIGYO>#    it).<KAIGYO>#<KAIGYO># To accomplish this, the Change-Id is based on the SHA1 of the last successful<KAIGYO># update from this script.  Note there's a race condition: we could make use<KAIGYO># of a Change-Id which is in INTEGRATING state.  We choose not to care about<KAIGYO># this for now.<KAIGYO>#"": 1}",1.0,{}
82,37764.0,6.0,15.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/37764,"All QWindow properties that have ""window"" in them have been renamed.",1.0,{},0.0,{'/*!<KAIGYO>    \\qmlproperty color QtQuick.Window2::Window::color<KAIGYO><KAIGYO>    The background color for the window.<KAIGYO><KAIGYO>    Setting this property is more efficient than using a separate Rectangle.<KAIGYO>*/': 3},1.0,{}
56,37793.0,1.0,35.0,15.0,ABANDONED,False,https://codereview.qt-project.org/#/c/37793,"*nix added the support for standard ""platform"" pseudo serial ports",1.0,{},0.0,{'// Append this device.<KAIGYO>// FIXME: How to get additional information about serial devices<KAIGYO>// with this subsystem?<KAIGYO>// Skip this devices because this type of subsystem does<KAIGYO>// not include a real physical serial device.': 1},1.0,{}
79,37887.0,4.0,14.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/37887,Examples and fixes for QML Window properties,1.0,"{""// Bug: doesn't work"": 2}",1.0,{'/*!<KAIGYO>    \\qmlproperty color QtQuick.Window2::Window::color<KAIGYO><KAIGYO>    The background color for the window.<KAIGYO><KAIGYO>    Setting this property is more efficient than using a separate Rectangle.<KAIGYO>*/': 1},1.0,{}
28,38140.0,1.0,2.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/38140,Update after porting Qt Assistant.,1.0,{},0.0,{'// ### hackety hack': 1},1.0,{}
73,38726.0,1.0,2.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/38726,Remove some kde related workarounds,1.0,{},0.0,{'//        opt->palette = widget()->palette();<KAIGYO>// ### fixme - workaround for KDE inverted dial': 1},1.0,{}
106,38823.0,2.0,4.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/38823,Some tweaks,1.0,{},0.0,"{'//    ### hack - With even heights, the text baseline is off on mac<KAIGYO>//    if (size.height() %2 == 0)<KAIGYO>//        size.setHeight(size.height() + 1);': 1}",1.0,{}
51,40399.0,1.0,2.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/40399,QXN Adding service info,1.0,{},0.0,{'//TODO Security flags?': 1},1.0,{}
82,40680.0,2.0,13.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/40680,Fixed line terminators to handle LS/PS and CR+LF correctly.,1.0,{},0.0,{'// ### TODO: insert it before the optional \\r sequence.': 1},1.0,{}
35,41087.0,2.0,7.0,3.0,MERGED,True,https://codereview.qt-project.org/#/c/41087,Fix mouse event distribution for Flickable with pressDelay,1.0,"{'// A move beyond the threshold replays the press to give nested Flickables<KAIGYO>// the opportunity to grab the gesture.': 1, '// Use the event handler that will take care of finding the proper item to propagate the event': 1, '// But, it should occur eventually': 1}",1.0,"{'// Use the event handler that will take care of finding the proper item to propagate the event': 1, '// A move beyond the threshold replays the press to give nested Flickables<KAIGYO>// the opportunity to grab the gesture.': 1}",1.0,{}
95,41601.0,1.0,1.0,0.0,ABANDONED,False,https://codereview.qt-project.org/#/c/41601,qttools: test,1.0,{'# TODO: the src directory contains both libs and tools parts': 1},1.0,{'# FIXME: the src directory contains both libs and tools parts': 1},1.0,{}
173,41860.0,20.0,76.0,1.0,MERGED,True,https://codereview.qt-project.org/#/c/41860,Complete rewrite of threaded render loop.,1.0,"{'// Workaround for broken expose logic... We should not get an<KAIGYO>// expose when the size of a window is invalid, but we sometimes do.<KAIGYO>// On Mac this leads to harmless, yet annoying, console warnings': 1, '/*!<KAIGYO> * Shutdown is a bit tricky as we would like to block the GUI with a clean mutex<KAIGYO> * until render thread has exited and cleaned up, but because wayland can enter<KAIGYO> * a deadlock when we block GUI while doing a swapBuffer in Render, we need<KAIGYO> * to do this rather ugly thing<KAIGYO> */': 1, '// Passed by the RL to the RT to free up maybe release SG and GL contexts<KAIGYO>// if no windows are rendering.': 5, '// This test tries to mimick a bug triggered in the qquickanimatedimage test<KAIGYO>// A window is shown, then removed again before it is exposed. This left<KAIGYO>// traces in the render loop which prevent other animations from running<KAIGYO>// later on.': 13}",1.0,"{'/*<KAIGYO>  Threaded Rendering<KAIGYO><KAIGYO>  The threaded rendering uses a number of different variables to track potential<KAIGYO>  states used to handle resizing, initial paint, grabbing and driving animations<KAIGYO>  while ALWAYS keeping the GL context in the rendering thread and keeping the<KAIGYO>  overhead of normal one-shot paints and vblank driven animations at a minimum.<KAIGYO><KAIGYO>  Resize, initial show and grab suffer slightly in this model as they are locked<KAIGYO>  to the rendering in the rendering thread, but this is a necessary evil for<KAIGYO>  the system to work.<KAIGYO><KAIGYO>  Variables that are used:<KAIGYO><KAIGYO>  Private::animationRunning: This is true while the animations are running, and only<KAIGYO>  written to inside locks.<KAIGYO><KAIGYO>  RenderThread::isGuiLocked: This is used to indicate that the GUI thread owns the<KAIGYO>  lock. This variable is an integer to allow for recursive calls to lockInGui()<KAIGYO>  without using a recursive mutex. See isPostingSyncEvent.<KAIGYO><KAIGYO>  RenderThread::isPostingSyncEvent: This variable is set in the render thread just<KAIGYO>  before the sync event is sent to the GUI thread. It is used to avoid deadlocks<KAIGYO>  in the case where render thread waits while waiting for GUI to pick up the sync<KAIGYO>  event and GUI thread gets a resizeEvent, the initial paintEvent or a grab.<KAIGYO>  When this happens, we use the<KAIGYO>  exhaustSyncEvent() function to do the sync right there and mark the coming<KAIGYO>  sync event to be discarded. There can only ever be one sync incoming.<KAIGYO><KAIGYO>  RenderThread::isRenderBlock: This variable is true when animations are not<KAIGYO>  running and the render thread has gone to sleep, waiting for more to do.<KAIGYO><KAIGYO>  RenderThread::isExternalUpdatePending: This variable is set to false when<KAIGYO>  a new render pass is started and to true in maybeUpdate(). It is an<KAIGYO>  indication to the render thread that another render pass needs to take<KAIGYO>  place, rather than the render thread going to sleep after completing its swap.<KAIGYO><KAIGYO>  RenderThread::doGrab: This variable is set by the grab() function and<KAIGYO>  tells the renderer to do a grab after rendering is complete and before<KAIGYO>  swapping happens.<KAIGYO><KAIGYO>  RenderThread::shouldExit: This variable is used to determine if the render<KAIGYO>  thread should do a nother pass. It is typically set as a result of show()<KAIGYO>  and unset as a result of hide() or during shutdown()<KAIGYO><KAIGYO>  RenderThread::hasExited: Used by the GUI thread to synchronize the shutdown<KAIGYO>  after shouldExit has been set to true.<KAIGYO> */': 1}",1.0,{}
148,41866.0,1.0,3.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/41866,[Qt][Mac] QWebView disappears when the system tries to hide the scrollbars. https://bugs.webkit.org/show_bug.cgi?id=104116,1.0,{'// FIXME: Disable transient scrollbar animations on OSX to avoid hiding the whole webview with the scrollbar fade out animation.': 1},1.0,"{""// FIXME: We also need to check the widget style but today ScrollbarTheme is not aware of the page so we<KAIGYO>// can't get the widget."": 1}",1.0,{}
187,42321.0,4.0,12.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/42321,Fix the test suite,1.0,"{'//# note: this should really be only \\015.<KAIGYO>// # like ctrl, but without tab': 1}",1.0,"{'//# note: this should really be only \\015.<KAIGYO>// # like ctrl, but without tab': 1}",1.0,{}
99,42548.0,3.0,12.0,7.0,MERGED,True,https://codereview.qt-project.org/#/c/42548,Accessibility: Work with QQuickWindow,1.0,{},0.0,{'// FIXME': 1},1.0,{}
111,42557.0,2.0,16.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/42557,Added parsing for getter/setter definitions in property assignments.,1.0,{'// ### TODO: AST for initializer': 1},1.0,{'// ### TODO: AST for initializer': 1},1.0,{}
174,42883.0,4.0,14.0,2.0,MERGED,True,https://codereview.qt-project.org/#/c/42883,Revert r136231 to fix overlay size due to incorrect visible rect,1.0,{},0.0,{'// Put the width and height to the viewport width and height. In css units however.<KAIGYO>// FIXME: This should be in scaled units but this currently affects viewport attributes calculation.': 1},1.0,{}
186,42889.0,12.0,24.0,3.0,MERGED,True,https://codereview.qt-project.org/#/c/42889,StyleItem: use a SG texture node to avoid render thread issues,1.0,{},0.0,{'// Unfortunately animations do not work on mac without this hack': 6},1.0,{}
182,42981.0,2.0,7.0,1.0,MERGED,True,https://codereview.qt-project.org/#/c/42981,Refactor QQmlTypePrivate,1.0,{'// Setup extended meta object<KAIGYO>// XXX - very inefficient': 1},1.0,{'// singleton type without metaobject information<KAIGYO>// Setup extended meta object<KAIGYO>// XXX - very inefficient': 1},1.0,{}
58,43376.0,5.0,12.0,5.0,MERGED,True,https://codereview.qt-project.org/#/c/43376,Added documentation to Button,1.0,"{'/*!<KAIGYO>     \\qmltype Button<KAIGYO>     \\inqmlmodule QtDesktop 1.0<KAIGYO>     \\brief A normal button<KAIGYO><KAIGYO>     A normal command button. Similar to the QPushButton widget.<KAIGYO><KAIGYO>     The push button is perhaps the most commonly used widget in any graphical user interface.<KAIGYO>     Push (click) a button to command the computer to perform some action, or to answer a question.<KAIGYO>     Typical buttons are OK, Apply, Cancel, Close, Yes, No and Help.<KAIGYO><KAIGYO>     The Button component is part of the \\l {QtDesktop} module.<KAIGYO><KAIGYO>     This documentation is part of the \\l{componentset}{QtDesktop} example.<KAIGYO> */': 1}",1.0,"{'// ## TODO: move to style implementation<KAIGYO>//    label: Item {<KAIGYO>//        // Used as a fallback since I can\'t pass the imageURL<KAIGYO>//        // directly to the style object<KAIGYO>//        visible: button.iconSource === """"<KAIGYO>//        Row {<KAIGYO>//            id: row<KAIGYO>//            anchors.centerIn: parent<KAIGYO>//            spacing: 4<KAIGYO>//            Image {<KAIGYO>//                source: iconSource<KAIGYO>//                anchors.verticalCenter: parent.verticalCenter<KAIGYO>//                fillMode: Image.Stretch //mm Image should shrink if button is too small, depends on QTBUG-14957<KAIGYO>//            }<KAIGYO>//            Text {<KAIGYO>//                id:text<KAIGYO>//                color: textColor<KAIGYO>//                anchors.verticalCenter: parent.verticalCenter<KAIGYO>//                text: button.text<KAIGYO>//                horizontalAlignment: Text.Center<KAIGYO>//            }<KAIGYO>//        }<KAIGYO>//    }': 1}",1.0,{}
122,43744.0,2.0,4.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/43744,Remove broken Browser example,1.0,{},0.0,{'// workaround to force webview repaint': 1},1.0,{}
149,44887.0,4.0,15.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/44887,Make custom filter render in Wk1 mode,1.0,{},0.0,{'// FIXME: This path is not working yet as GraphicsContext3D fails to initialize.<KAIGYO>// httpsbugs.webkit.org/show_bug.cgi?id=101532': 1},1.0,{}
170,44906.0,4.0,8.0,8.0,MERGED,True,https://codereview.qt-project.org/#/c/44906,QNX: Adding ndef registration over the invocation framework,1.0,"{'//TODO add the rest': 1, '//TODO handle all the events': 2, '//TODO handle the target types': 2}",1.0,"{'//TODO add the rest': 1, '//TODO handle all the events': 2, '//TODO handle the target types': 2}",1.0,{}
32,45012.0,1.0,4.0,0.0,ABANDONED,False,https://codereview.qt-project.org/#/c/45012,refactor QQuickControl out of Item,1.0,{},0.0,"{'// If style item contains a property """" that points<KAIGYO>// to an item, reparent all children into it. This is helpful<KAIGYO>// when styling controls such as Frame, where a border should be<KAIGYO>// drawn around and/or underneath the children:': 1}",1.0,{}
154,45162.0,9.0,9.0,0.0,ABANDONED,False,https://codereview.qt-project.org/#/c/45162,WIP: Test new style syntax,1.0,"{'// XXX: since desktop uses int instead of real, the progressbar<KAIGYO>// range [0..1] must be stretched to a good precision': 3}",1.0,"{'// XXX: since desktop uses int instead of real, the progressbar<KAIGYO>// range [0..1] must be stretched to a good precision': 3}",1.0,{}
123,45775.0,6.0,13.0,2.0,MERGED,True,https://codereview.qt-project.org/#/c/45775,Add qmlRegisterType for Composite Types,1.0,{},0.0,{'//TODO: Replace this with public API version when added': 4},1.0,{}
143,45909.0,1.0,17.0,0.0,ABANDONED,False,https://codereview.qt-project.org/#/c/45909,Doc: Fix module name format,1.0,{'// or too essential for Qt WebKit that we can not allow a user configuration to potentially override it.': 1},1.0,{'// or too essential for QtWebKit that we can not allow a user configuration to potentially override it.': 1},1.0,{}
147,45995.0,1.0,7.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/45995,Debugger: Remove symbian specific plugin,1.0,{},0.0,"{'//TODO does it matter this is emitted synchronously?<KAIGYO>//qDebug("""", ptr.Size());': 1, ""// This is necessary to clean up the scheduler as you're not supposed to bypass it like this"": 1}",1.0,{}
32,46130.0,4.0,36.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/46130,Flickable: Use increased default flick parameters on BB10,1.0,{},0.0,{'// How much faster to decelerate when overshooting': 4},1.0,{}
33,46291.0,2.0,10.0,2.0,ABANDONED,False,https://codereview.qt-project.org/#/c/46291,Unix: set PortError property when write(2) fails.,1.0,{},0.0,{'// TODO: set error?': 1},1.0,{}
41,46326.0,2.0,13.0,3.0,MERGED,True,https://codereview.qt-project.org/#/c/46326,"Remove the TODOs, and set the errors properly.",1.0,{},0.0,"{'// TODO: set error ?<KAIGYO>// TODO: set error ?<KAIGYO>// TODO: set error?': 1, '// TODO: set error ?<KAIGYO>// This is occur timeout or another error<KAIGYO>// TODO: set error ?': 1, '// TODO: set error ?<KAIGYO>// TODO: set error ?': 2, '// TODO: set error?': 2}",1.0,{}
61,46409.0,1.0,3.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/46409,Merge branch 'release' into stable,1.0,{},0.0,{'// Perhaps shpw entire example for getting debugger up with script': 1},1.0,{}
153,46602.0,8.0,56.0,89.0,MERGED,True,https://codereview.qt-project.org/#/c/46602,Introduce new I/O errors and enhanced it implementation,1.0,{},0.0,"{'// FIXME:': 1, ""// FIXME: Here 'errno' codes for sockets.<KAIGYO>// You need to replace the codes for the serial port."": 1}",1.0,{}
134,46904.0,3.0,10.0,1.0,MERGED,True,https://codereview.qt-project.org/#/c/46904,"QQuickItem::childAt(x, y) takes child transformations into account",1.0,{},0.0,{'// XXX todo - should this include transform etc.?': 1},1.0,{}
87,47799.0,1.0,3.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/47799,StyleItem: Add menu icons,1.0,{},0.0,{'// XXX TODO: icon': 1},1.0,{}
94,47934.0,1.0,4.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/47934,Doc: Removed reference to deprecated \badcode command.,1.0,{},0.0,"{""//XXX does not work! Can't repeat QtObject as it doesn't derive from Item."": 1}",1.0,{}
16,48065.0,3.0,12.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/48065,Refactoring in testbench,1.0,{},0.0,{'// All model properties must be the same type<KAIGYO>// We should do a proper sort instead': 1},1.0,{}
76,48077.0,6.0,20.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/48077,Use QLineEdit's clear button feature in in Qt Designer.,1.0,{},0.0,{'// Note isDown should really use the active state but in most styles<KAIGYO>// this has no proper feedback': 2},1.0,{}
74,48383.0,1.0,5.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/48383,Update tests and tools according to Splitter changes,1.0,{},0.0,"{""// Why doesn't X-axis work?"": 1}",1.0,{}
129,48603.0,2.0,4.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/48603,ComboBox: Get rid of 'effectivePressed' binding loop,1.0,{},0.0,{'//  ToDo: adjust margins so that selected popup label<KAIGYO>//    centers directly above button label when<KAIGYO>//    popup.centerOnSelectedText === true': 2},1.0,{}
145,48719.0,1.0,5.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/48719,"ASSERTION FAILED: !object || object->isBox(), UNKNOWN in WebCore::RenderListItem::positionListMarker",1.0,"{'// FIXME: Tables, RenderButtons, and RenderListItems all do special management<KAIGYO>// of their children that breaks when the flow is split through them. Disabling<KAIGYO>// multi-column for them to avoid this problem.': 1}",1.0,"{'// FIXME: Table manages its own table parts, most of which are RenderBoxes.<KAIGYO>// Multi-column code cannot handle splitting the flow in table. Disabling it<KAIGYO>// to prevent crashes.<KAIGYO>// Similarly, RenderButton maintains an anonymous block child and overrides<KAIGYO>// addChild() to prevent itself from having additional direct children. This<KAIGYO>// causes problems for split flows.': 1}",1.0,{}
165,48805.0,3.0,8.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/48805,"Menu: Enable ""click-select-release"" behavior",1.0,{},0.0,{'// TODO Test for any submenu open': 1},1.0,{}
172,48948.0,1.0,4.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/48948,Accessibility: don't bind to the text property.,1.0,{},0.0,{'// FIXME: probably implement text interface': 1},1.0,{}
55,49322.0,1.0,3.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/49322,Regression(r131539): Heap-use-after-free in WebCore::RenderBlock::willBeDestroyed,1.0,"{'// that a positioned child got yanked). We also repaint, so that the area exposed when the child<KAIGYO>// disappears gets repainted properly.': 1}",1.0,"{""// We repaint, so that the area exposed when this object disappears gets repainted properly.<KAIGYO>// FIXME: A RenderObject with RenderLayer should probably repaint through it as getting the<KAIGYO>// repaint rects is O(1) through a RenderLayer (assuming it's up-to-date)."": 1}",1.0,{}
69,49405.0,7.0,45.0,6.0,MERGED,True,https://codereview.qt-project.org/#/c/49405,*nix: Fix unexpected clear errno when I/O failed,1.0,"{'//force sending already buffered data, because updateTermios() cleares buffers<KAIGYO>//todo: add receiving buffered data!!!': 1}",1.0,"{'//force sending already buffered data, because updateTermios() cleares buffers<KAIGYO>//todo: add receiving buffered data!!!': 1}",1.0,{}
76,49412.0,3.0,5.0,0.0,ABANDONED,False,https://codereview.qt-project.org/#/c/49412,WIP: Provide ability to add QWidgets to QtMacUnifiedToolBar.,1.0,"{'// TODO: Should this have a parent?': 1, ""// For some reason, setting the maxSize is necessary despite the documentation claiming:<KAIGYO>// Note: As of OS X v10.5, if you call setView: on an NSToolbarItem object without also<KAIGYO>// calling setMinSize: or setMaxSize:, the toolbar item sets its minimum and maximum size<KAIGYO>// equal to the view's frame.<KAIGYO>// TODO: This might cause issues for some controls, for example if a button's text changes<KAIGYO>// its sizeHint will change and thus we'll probably have to update the max size here<KAIGYO>// TODO: Showing customization sheet == invisible widget, that needs fixing"": 1, ""// TODO: App won't exit on close, how do we properly delete these widgets?<KAIGYO>// TODO: QComboBox widgets behave somewhat oddly when in an NSToolbar<KAIGYO>// TODO: Can't focus QLineEdits (and presumably other controls)<KAIGYO>// TODO: src/gui/widgets/qmainwindowlayout_mac.mm essentially does the same<KAIGYO>// thing we're doing here but with none of the listed problems... hints from there?"": 1, '// TODO: Under some conditions, icons on tool buttons become corrupted': 1}",1.0,"{""// TODO: add the QToolBar's QWidgets to the Mac toolbar once it supports this"": 1}",1.0,{}
68,49420.0,1.0,2.0,0.0,ABANDONED,False,https://codereview.qt-project.org/#/c/49420,TextArea: Add inactive color group to the palette,1.0,{},0.0,{'// FIXME: take into account if the window is active': 1},1.0,{}
196,49662.0,14.0,50.0,2.0,MERGED,True,https://codereview.qt-project.org/#/c/49662,Create common base class for declarative dialogs,1.0,"{'// For a pure QML implementation, there is no helper.<KAIGYO>// But m_implementation is probably either an Item or a Window at this point.': 3, '// If the platform does not support multiple windows, but the dialog is<KAIGYO>// implemented as an Item, then just reparent it and make it visible.<KAIGYO>// TODO QTBUG-29818: put it into a fake Item-based window, when we have a reusable self-decorated one.': 3, '// TODO': 3, '// TODO: find the directory by searching rather than assuming a relative path': 6}",1.0,"{'// For a pure QML implementation, there is no helper.<KAIGYO>// But m_implementation is probably either an Item or a Window at this point.': 3, '// If the platform does not support multiple windows, but the dialog is<KAIGYO>// implemented as an Item, then just reparent it and make it visible.<KAIGYO>// TODO QTBUG-29818: put it into a fake Item-based window, when we have a reusable self-decorated one.': 3, '// returns -1 unless we omit the module from qmldir, because otherwise<KAIGYO>// QtQuick.Dialogs is already a protected namespace<KAIGYO>// after the qmldir having been parsed.  (QQmlImportDatabase::importPlugin)<KAIGYO>// But omitting the module from qmldir results in this warning:<KAIGYO>// ""Module \'QtQuick.Dialogs\' does not contain a module identifier directive -<KAIGYO>// it cannot be protected from external registrations.""<KAIGYO>// TODO register all types in registerTypes, to avoid the warning<KAIGYO>// But, in that case we cannot check for existence by trying to instantiate the component.<KAIGYO>// So it will have to just look for a file (qmldir?) and assume<KAIGYO>// that whatever modules are installed are also in working order.': 6}",1.0,{}
198,49663.0,20.0,25.0,1.0,MERGED,True,https://codereview.qt-project.org/#/c/49663,Add ColorDialog to QtQuick.Dialogs,1.0,"{'// For a pure QML implementation, there is no helper.<KAIGYO>// But m_implementation is probably either an Item or a Window at this point.': 1, '// If the platform does not support multiple windows, but the dialog is<KAIGYO>// implemented as an Item, then just reparent it and make it visible.<KAIGYO>// TODO QTBUG-29818: put it into a fake Item-based window, when we have a reusable self-decorated one.': 1, '// TODO: find the directory by searching rather than assuming a relative path': 3, '// TODO if we constrain the movement here, can avoid the containsMouse test': 5}",1.0,"{'// returns -1 unless we omit the module from qmldir, because otherwise<KAIGYO>// QtQuick.Dialogs is already a protected namespace<KAIGYO>// after the qmldir having been parsed.  (QQmlImportDatabase::importPlugin)<KAIGYO>// But omitting the module from qmldir results in this warning:<KAIGYO>// ""Module \'QtQuick.Dialogs\' does not contain a module identifier directive -<KAIGYO>// it cannot be protected from external registrations.""<KAIGYO>// TODO register all types in registerTypes, to avoid the warning<KAIGYO>// But, in that case we cannot check for existence by trying to instantiate the component.<KAIGYO>// So it will have to just look for a file (qmldir?) and assume<KAIGYO>// that whatever modules are installed are also in working order.': 3}",1.0,{}
169,49888.0,1.0,18.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/49888,Aero-Style-QWizard: Remove special handling in Qt Designer.,1.0,{},0.0,"{'// Prevent the wizard from emulating the Windows Vista Theme.<KAIGYO>// This theme (in both Aero and Basic mode) is tricky to<KAIGYO>// emulate properly in designer due to 1) the manipulation of the non-client area of<KAIGYO>// the top-level window, and 2) the upper-right location of the Back button.<KAIGYO>// The wizard falls back to QWizard::ModernStyle whenever the Vista theme<KAIGYO>// would normally apply.': 1}",1.0,{}
34,50171.0,1.0,3.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/50171,purge TS 1.1 support,1.0,{},0.0,"{'// FIXME: Factor is sensible only for latin scripts, probably.': 1}",1.0,{}
103,50173.0,1.0,3.0,1.0,MERGED,True,https://codereview.qt-project.org/#/c/50173,purge CODECFORTR & -codecfortr support,1.0,{},0.0,{'//utf8 = false; // Maybe use //%% or something like that': 1},1.0,{}
59,50310.0,1.0,7.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/50310,Create the sg render thread's opengl context on the GUI thread,1.0,{},0.0,"{'// Workaround for broken expose logic... We should not get an<KAIGYO>// expose when the size of a window is invalid, but we sometimes do.<KAIGYO>// On Mac this leads to harmless, yet annoying, console warnings': 1}",1.0,{}
74,50598.0,2.0,4.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/50598,Examples - tableview: Fix example,1.0,{'// Initialize text editor lazily to improve performance': 1},1.0,{'// Initialize text editor lazily to improve performance': 1},1.0,{}
101,50754.0,1.0,1.0,0.0,ABANDONED,False,https://codereview.qt-project.org/#/c/50754,Create common base class for declarative dialogs,1.0,"{'// TODO: find the directory by searching rather than assuming a relative path': 1, '// For a pure QML implementation, there is no helper.<KAIGYO>// But m_implementation is probably either an Item or a Window at this point.': 1, '// If the platform does not support multiple windows, but the dialog is<KAIGYO>// implemented as an Item, then just reparent it and make it visible.<KAIGYO>// TODO QTBUG-29818: put it into a fake Item-based window, when we have a reusable self-decorated one.': 1, '// TODO': 1}",1.0,"{'// returns -1 unless we omit the module from qmldir, because otherwise<KAIGYO>// QtQuick.Dialogs is already a protected namespace<KAIGYO>// after the qmldir having been parsed.  (QQmlImportDatabase::importPlugin)<KAIGYO>// But omitting the module from qmldir results in this warning:<KAIGYO>// ""Module \'QtQuick.Dialogs\' does not contain a module identifier directive -<KAIGYO>// it cannot be protected from external registrations.""<KAIGYO>// TODO register all types in registerTypes, to avoid the warning<KAIGYO>// But, in that case we cannot check for existence by trying to instantiate the component.<KAIGYO>// So it will have to just look for a file (qmldir?) and assume<KAIGYO>// that whatever modules are installed are also in working order.': 1, '// For a pure QML implementation, there is no helper.<KAIGYO>// But m_implementation is probably either an Item or a Window at this point.': 1, '// If the platform does not support multiple windows, but the dialog is<KAIGYO>// implemented as an Item, then just reparent it and make it visible.<KAIGYO>// TODO QTBUG-29818: put it into a fake Item-based window, when we have a reusable self-decorated one.': 1}",1.0,{}
109,50794.0,1.0,2.0,0.0,ABANDONED,False,https://codereview.qt-project.org/#/c/50794,ComboBox: Use SpawningPool,1.0,{},0.0,{'// TODO Update when model patch is in<KAIGYO>// Menu { MenuItemRepeater { model: testcase.itemsText MenuItem { text: modelData } }': 1},1.0,{}
100,51518.0,1.0,11.0,1.0,ABANDONED,False,https://codereview.qt-project.org/#/c/51518,"WIP: *nix added the support for standard ""platform"" pseudo serial ports",1.0,{},0.0,{'// Append this device.<KAIGYO>// FIXME: How to get additional information about serial devices<KAIGYO>// with this subsystem?<KAIGYO>// Skip this devices because this type of subsystem does<KAIGYO>// not include a real physical serial device.': 1},1.0,{}
49,52236.0,4.0,10.0,2.0,MERGED,True,https://codereview.qt-project.org/#/c/52236,TextEdit: Better support of QTextTable and inline images,1.0,{},0.0,"{'// last node that needed replacing or last block of the last frame<KAIGYO>// text block grouping across text frames might not be a good idea, split it.': 1}",1.0,{}
212,53454.0,12.0,28.0,9.0,MERGED,True,https://codereview.qt-project.org/#/c/53454,Remove StyleItem dependencies from controls,1.0,"{'// This gives more native styling, but might be less performant': 2}",1.0,"{'// This gives more native styling, but might be less performant': 2}",1.0,{}
139,53674.0,1.0,3.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/53674,Apply our MSVC 2012 optimizer bug workaround to all minor releases,1.0,"{'// Workaround for a bug in the VS2012 Update1 and Update2 optimizer, remove once the fix is released.<KAIGYO>// httpsconnect.microsoft.com/VisualStudio/feedback/details/781189/vs2012-update-ctp4-c-optimizing-bug': 1}",1.0,"{'// Workaround for a bug in the VS2012 Update 1 optimizer, remove once the fix is released.<KAIGYO>// httpsconnect.microsoft.com/VisualStudio/feedback/details/777533/vs2012-c-optimizing-bug-when-using-inline-and-char-return-type-x86-target-only': 1}",1.0,{}
193,53880.0,1.0,13.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/53880,Remove dead code.,1.0,{},0.0,{'// Change to be applied after the visibility property is integrated in qtbase:<KAIGYO>//    return visibility != QWindow::Hidden || (renderWithoutShowing && platformWindow);<KAIGYO>// Temporary version which is implementation-agnostic but slightly less efficient:': 1},1.0,{}
210,53932.0,3.0,12.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/53932,"Doc: Moved ""QML Application Developer Resources"" to qtdoc repository.",1.0,{},0.0,"{""// Anchored to 20px off the top center corner of the parent.<KAIGYO>// Notice the different group property syntax for 'anchors' compared to<KAIGYO>// the previous Rectangle. Both are valid."": 2, '// StyledText format supports fewer tags, but is more efficient than RichText': 2}",1.0,{}
71,54075.0,7.0,8.0,3.0,ABANDONED,False,https://codereview.qt-project.org/#/c/54075,WIP: Declarative dialog improvements for the non-Window use case,1.0,{'// TODO: QTBUG-29817 geometry from AbstractFileDialog': 6},1.0,"{'// qDebug() << """" << parentItem;<KAIGYO>// implemented as an Item, then just reparent it and make it visible.<KAIGYO>// TODO QTBUG-29818: put it into a fake Item-based window, when we have a reusable self-decorated one.': 2, '// TODO: QTBUG-29817 geometry from AbstractFileDialog': 6}",1.0,{}
84,54365.0,1.0,2.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/54365,Convert a few more things to v4,1.0,{},0.0,{'// FIXME Newer v8 have API for this function': 1},1.0,{}
87,54379.0,1.0,2.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/54379,Change variant conversion methods to use V4 API,1.0,{},0.0,"{""// TODO: Only object's own property names. Include non-enumerable properties."": 1}",1.0,{}
125,54584.0,5.0,15.0,0.0,ABANDONED,False,https://codereview.qt-project.org/#/c/54584,Stabilize and re-enable constantUpdatesOnWindow test,1.0,{},0.0,"{""// We should expect 60, but under loaded conditions we could be skipping<KAIGYO>// frames, so don't expect too much."": 1}",1.0,{}
186,54722.0,8.0,51.0,15.0,MERGED,True,https://codereview.qt-project.org/#/c/54722,The resources property should be independent from QObject,1.0,{},0.0,{'// XXX todo - do we really want this behavior?': 2},1.0,{}
179,54824.0,1.0,3.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/54824,Optimize particle mask extruder,1.0,{},0.0,"{""//Else LSB, but I think that's easier<KAIGYO>//TODO: Do they need aspect ratio stuff? Or tiling?"": 1, '//Direct bit manipulation is presumably more efficient': 1}",1.0,{}
201,54865.0,1.0,7.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/54865,"adjust to new ""configure -nomake tools"" semantics",1.0,{},0.0,{'# FIXME: the src directory contains both libs and tools parts': 1},1.0,{}
251,54963.0,2.0,3.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/54963,Move more methods on QV8Engine over to use v4 based syntax,1.0,{},0.0,"{'// This is possible on syntax errors like { a:12, b:21 } <- missing """" around expression.': 1, ""// TODO: figure out why v8 doesn't always produce an exception value<KAIGYO>//Q_ASSERT(!exception.IsEmpty());"": 1, ""// TODO: Why don't we get the exception, as with Script::Compile()?<KAIGYO>// Q_ASSERT(tryCatch.HasCaught());"": 1}",1.0,{}
63,55133.0,1.0,2.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/55133,Move QV8Engine::to/fromVariant over to a v4 based API,1.0,{'// why -1 instead of callType?': 1},1.0,{'// why -1 instead of callType?': 1},1.0,{}
93,55378.0,1.0,2.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/55378,Fix keywords test,1.0,{},0.0,{'// this should probably be allowed (see task 162567)': 1},1.0,{}
286,55543.0,1.0,2.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/55543,More steps towards eliminating the v8 layer,1.0,{},0.0,"{""// Calculating the destination address of a null jump/branch instruction is tricky<KAIGYO>// so instead we simply don't compare that part of those instructions."": 1}",1.0,{}
162,55653.0,2.0,3.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/55653,Convert qv8qobjectwrapper to use QV4::PersistentValue,1.0,"{'// Hack to allow us to identify these functions': 1, '// ### FIXME<KAIGYO>//            (*iter)->v8object.MakeWeak((*iter), WeakQObjectInstanceCallback);': 1}",1.0,{'// Hack to allow us to identify these functions': 1},1.0,{}
208,55779.0,3.0,4.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/55779,Port the of qml locale getters to V4 accessors,1.0,{},0.0,{'//XXX detect locale object properly': 3},1.0,{}
216,55829.0,2.0,3.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/55829,Remove unused engine pointer in QQmlLocaleData,1.0,{},0.0,"{'// ### compat, remove once unused': 1}",1.0,{}
290,55875.0,19.0,27.0,11.0,MERGED,True,https://codereview.qt-project.org/#/c/55875,Introducing SSA.,1.0,"{'// TODO: verify this!': 1, '// ### TODO': 1, '// TODO: add Temp+Const variation on the topic.': 3, '/*<KAIGYO> * Do edge-splitting for basic-blocks.<KAIGYO> *<KAIGYO> * If there is an edge between a basic block with multiple outgoing edges pointing to a block with<KAIGYO> * multiple incoming edges, then split that edge and insert an empty basic block in between. This is<KAIGYO> * used, for example, when converting out of SSA form where the phi functions are converted into<KAIGYO> * move operations that get inserted at the block from where the edge came in.<KAIGYO> *<KAIGYO> * TODO: check if we need this when register allocation when transforming out of SSA.<KAIGYO> */': 3, '// TODO: check if this can be moved to IR building.': 3, '// TODO: see if we can have subscript accesses without side effect': 3, '// TODO: see if we can have member accesses without side effect': 3, '// TODO: there are built-in functions that have no side effect.': 3, '// TODO: clone the replacement!': 3, '// TODO: the worklist handling looks a bit inefficient... check if there is something better': 3, '// TODO: VERIFY THIS!': 3, '// TODO: for QML, try to do a static lookup': 3, '// TODO: check & double check the next condition!': 3, '/*<KAIGYO> * Quick function to convert out of SSA, so we can put the stuff through the ISel phases. This<KAIGYO> * has to be replaced by a phase in the specific ISel back-ends and do register allocation at the<KAIGYO> * same time. That way the huge number of redundant moves generated by this function are eliminated.<KAIGYO> */': 3, '// TODO: verify the rest of the function for when op == OpInvalid': 3, '// TODO: check if we need to run a pass to collect phi nodes that are only used by other phi nodes.': 3, '    virtual void visitTry(Try *s) { /* this should never happen */ }<KAIGYO><KAIGYO>    virtual void visitConst(Const *) {}<KAIGYO>    virtual void visitString(String *) {}<KAIGYO>    virtual void visitRegExp(RegExp *) {}<KAIGYO>    virtual void visitName(Name *) {}<KAIGYO>    virtual void visitClosure(Closure *) {}<KAIGYO>    virtual void visitUnop(Unop *e) { e->expr->accept(this); }<KAIGYO>    virtual void visitBinop(Binop *e) { e->left->accept(this); e->right->accept(this); }<KAIGYO>    virtual void visitCall(Call *e) {<KAIGYO>        e->base->accept(this);<KAIGYO>        for (ExprList *it = e->args; it; it = it->next)<KAIGYO>            it->expr->accept(this);<KAIGYO>    }<KAIGYO><KAIGYO>    virtual void visitNew(New *e) {<KAIGYO>        e->base->accept(this);<KAIGYO>        for (ExprList *it = e->args; it; it = it->next)<KAIGYO>            it->expr->accept(this);<KAIGYO>    }<KAIGYO><KAIGYO>    virtual void visitSubscript(Subscript *e) {<KAIGYO>        e->base->accept(this);<KAIGYO>        e->index->accept(this);<KAIGYO>    }<KAIGYO><KAIGYO>    virtual void visitMember(Member *e) {<KAIGYO>        e->base->accept(this);<KAIGYO>    }<KAIGYO>};<KAIGYO><KAIGYO>QHash<int, int> convertToSSA(Function *function)<KAIGYO>{<KAIGYO>#ifdef SHOW_SSA<KAIGYO>    qout << """";<KAIGYO>    if (function->name)<KAIGYO>        qout << *function->name;<KAIGYO>    else<KAIGYO>        qout << """";<KAIGYO>    qout << """" << endl;<KAIGYO>#endif // SHOW_SSA<KAIGYO><KAIGYO>    QVector<BasicBlock *> &nodes = function->basicBlocks;<KAIGYO><KAIGYO>    // Calculate the dominator tree:<KAIGYO>    DominatorTree df(nodes);<KAIGYO><KAIGYO>    // Collect all applicable variables:<KAIGYO>    VariableCollector variables(function);<KAIGYO><KAIGYO>    // Place phi functions:<KAIGYO>    QHash<BasicBlock *, QSet<int> > A_phi;<KAIGYO>    foreach (int a, variables.vars()) {<KAIGYO>        if (!variables.isNonLocal(a))<KAIGYO>            continue; // for semi-pruned SSA<KAIGYO><KAIGYO>        QList<BasicBlock *> W = QList<BasicBlock *>::fromSet(variables.defsite(a));<KAIGYO>        while (!W.isEmpty()) {<KAIGYO>            BasicBlock *n = W.first();<KAIGYO>            W.removeFirst();<KAIGYO>            foreach (BasicBlock *y, df[n]) {<KAIGYO>                if (!A_phi[y].contains(a)) {<KAIGYO>                    insertPhiNode(a, y, function);<KAIGYO>                    A_phi[y].insert(a);<KAIGYO>                    if (!variables.inBlock(y).contains(a))<KAIGYO>                        W.append(y);<KAIGYO>                }<KAIGYO>            }<KAIGYO>        }<KAIGYO>    }<KAIGYO><KAIGYO>    // Rename variables:<KAIGYO>    return VariableRenamer(function).run();<KAIGYO>}<KAIGYO><KAIGYO>class DefUsesCalculator: public StmtVisitor, public ExprVisitor {<KAIGYO>public:<KAIGYO>    struct DefUse {<KAIGYO>        Stmt *defStmt;<KAIGYO>        BasicBlock *blockOfStatement;<KAIGYO>        QList<Stmt *> uses;<KAIGYO>    };<KAIGYO><KAIGYO>private:<KAIGYO>    QHash<int, DefUse> _defUses;<KAIGYO>    QHash<Stmt *, QList<int> > _usesPerStatement;<KAIGYO><KAIGYO>    BasicBlock *_block;<KAIGYO>    Stmt *_stmt;<KAIGYO><KAIGYO>    void addUse(Temp *t) {<KAIGYO>        Q_ASSERT(t);<KAIGYO><KAIGYO>        _defUses[t->index].uses.append(_stmt);<KAIGYO>        _usesPerStatement[_stmt].append(t->index);<KAIGYO>    }<KAIGYO><KAIGYO>    void addDef(Temp *t) {<KAIGYO>        DefUse &defUse = _defUses[t->index];<KAIGYO>        defUse.defStmt = _stmt;<KAIGYO>        defUse.blockOfStatement = _block;<KAIGYO>    }<KAIGYO><KAIGYO>public:<KAIGYO>    DefUsesCalculator(const QVector<BasicBlock *> &bbs) {<KAIGYO>        foreach (BasicBlock *bb, bbs) {<KAIGYO>            _block = bb;<KAIGYO>            foreach (Stmt *stmt, bb->statements) {<KAIGYO>                _stmt = stmt;<KAIGYO>                stmt->accept(this);<KAIGYO>            }<KAIGYO>        }<KAIGYO><KAIGYO>        QMutableHashIterator<int, DefUse> it(_defUses);<KAIGYO>        while (it.hasNext()) {<KAIGYO>            it.next();<KAIGYO>            if (!it.value().defStmt)<KAIGYO>                it.remove();<KAIGYO>        }<KAIGYO>    }<KAIGYO><KAIGYO>    QList<int> defs() const {<KAIGYO>        return _defUses.keys();<KAIGYO>    }<KAIGYO><KAIGYO>    void removeDef(int var) {<KAIGYO>        _defUses.remove(var);<KAIGYO>    }<KAIGYO><KAIGYO>    void addUses(int variable, QList<Stmt *>newUses)<KAIGYO>    { _defUses[variable].uses.append(newUses); }<KAIGYO><KAIGYO>    int useCount(int variable) const<KAIGYO>    { return _defUses[variable].uses.size(); }<KAIGYO><KAIGYO>    Stmt *defStmt(int variable) const<KAIGYO>    { return _defUses[variable].defStmt; }<KAIGYO><KAIGYO>    BasicBlock *defStmtBlock(int variable) const<KAIGYO>    { return _defUses[variable].blockOfStatement; }<KAIGYO><KAIGYO>    void removeUse(Stmt *usingStmt, int var)<KAIGYO>    { _defUses[var].uses.removeAll(usingStmt); }<KAIGYO><KAIGYO>    QList<int> usedVars(Stmt *s) const<KAIGYO>    { return _usesPerStatement[s]; }<KAIGYO><KAIGYO>    QList<Stmt *> uses(int var) const<KAIGYO>    { return _defUses[var].uses; }<KAIGYO><KAIGYO>    void dump() const<KAIGYO>    {<KAIGYO>        foreach (int var, _defUses.keys()) {<KAIGYO>            const DefUse &du = _defUses[var];<KAIGYO>            qout<<var<<"""";<KAIGYO>            du.defStmt->dump(qout);<KAIGYO>            qout<<endl<<""""<<endl;<KAIGYO>            foreach (Stmt *s, du.uses) {<KAIGYO>                qout<<"""";s->dump(qout);qout<<endl;<KAIGYO>            }<KAIGYO>        }<KAIGYO>    }<KAIGYO><KAIGYO>protected:<KAIGYO>    virtual void visitExp(Exp *s) { s->expr->accept(this); }<KAIGYO>    virtual void visitEnter(Enter *) {}<KAIGYO>    virtual void visitLeave(Leave *) {}<KAIGYO>    virtual void visitJump(Jump *) {}<KAIGYO>    virtual void visitCJump(CJump *s) { s->cond->accept(this); }<KAIGYO>    virtual void visitRet(Ret *s) { s->expr->accept(this); }<KAIGYO>    virtual void visitTry(Try *) {}<KAIGYO><KAIGYO>    virtual void visitPhi(Phi *s) {<KAIGYO>        addDef(s->targetTemp);<KAIGYO>        foreach (Expr *e, s->incoming)<KAIGYO>            addUse(e->asTemp());<KAIGYO>    }<KAIGYO><KAIGYO>    virtual void visitMove(Move *s) {<KAIGYO>        if (Temp *t = s->target->asTemp())<KAIGYO>            addDef(t);<KAIGYO>        else<KAIGYO>            s->target->accept(this);<KAIGYO><KAIGYO>        s->source->accept(this);<KAIGYO>    }<KAIGYO><KAIGYO>    virtual void visitTemp(Temp *e) { addUse(e); }<KAIGYO><KAIGYO>    virtual void visitConst(Const *) {}<KAIGYO>    virtual void visitString(String *) {}<KAIGYO>    virtual void visitRegExp(RegExp *) {}<KAIGYO>    virtual void visitName(Name *) {}<KAIGYO>    virtual void visitClosure(Closure *) {}<KAIGYO>    virtual void visitUnop(Unop *e) { e->expr->accept(this); }<KAIGYO>    virtual void visitBinop(Binop *e) { e->left->accept(this); e->right->accept(this); }<KAIGYO>    virtual void visitSubscript(Subscript *e) { e->base->accept(this); e->index->accept(this); }<KAIGYO>    virtual void visitMember(Member *e) { e->base->accept(this); }<KAIGYO>    virtual void visitCall(Call *e) {<KAIGYO>        e->base->accept(this);<KAIGYO>        for (ExprList *it = e->args; it; it = it->next)<KAIGYO>            it->expr->accept(this);<KAIGYO>    }<KAIGYO><KAIGYO>    virtual void visitNew(New *e) {<KAIGYO>        e->base->accept(this);<KAIGYO>        for (ExprList *it = e->args; it; it = it->next)<KAIGYO>            it->expr->accept(this);<KAIGYO>    }<KAIGYO>};<KAIGYO><KAIGYO>bool hasPhiOnlyUses(Phi *phi, const DefUsesCalculator &defUses, QSet<Phi *> &collectedPhis)<KAIGYO>{<KAIGYO>    collectedPhis.insert(phi);<KAIGYO>    foreach (Stmt *use, defUses.uses(phi->targetTemp->index)) {<KAIGYO>        if (Phi *dependentPhi = use->asPhi()) {<KAIGYO>            if (!collectedPhis.contains(dependentPhi)) {<KAIGYO>                if (!hasPhiOnlyUses(dependentPhi, defUses, collectedPhis))<KAIGYO>                    return false;<KAIGYO>            }<KAIGYO>        } else {<KAIGYO>            return false;<KAIGYO>        }<KAIGYO>    }<KAIGYO>    return true;<KAIGYO>}<KAIGYO><KAIGYO>void cleanupPhis(DefUsesCalculator &defUses)<KAIGYO>{<KAIGYO>    QLinkedList<Phi *> phis;<KAIGYO>    foreach (int def, defUses.defs())<KAIGYO>        if (Phi *phi = defUses.defStmt(def)->asPhi())<KAIGYO>            phis.append(phi);<KAIGYO><KAIGYO>    QSet<Phi *> toRemove;<KAIGYO>    while (!phis.isEmpty()) {<KAIGYO>        Phi *phi = phis.first();<KAIGYO>        phis.removeFirst();<KAIGYO>        if (toRemove.contains(phi))<KAIGYO>            continue;<KAIGYO>        QSet<Phi *> collectedPhis;<KAIGYO>        if (hasPhiOnlyUses(phi, defUses, collectedPhis))<KAIGYO>            toRemove.unite(collectedPhis);<KAIGYO>    }<KAIGYO><KAIGYO>    foreach (Phi *phi, toRemove) {<KAIGYO>        int targetVar = phi->targetTemp->index;<KAIGYO><KAIGYO>        BasicBlock *bb = defUses.defStmtBlock(targetVar);<KAIGYO>        int idx = bb->statements.indexOf(phi);<KAIGYO>        bb->statements.remove(idx);<KAIGYO><KAIGYO>        foreach (int usedVar, defUses.usedVars(phi))<KAIGYO>            defUses.removeUse(phi, usedVar);<KAIGYO>        defUses.removeDef(targetVar);<KAIGYO>    }<KAIGYO>}<KAIGYO><KAIGYO>class DeadCodeElimination: public ExprVisitor {<KAIGYO>    int _lastUncollectible;<KAIGYO>    DefUsesCalculator &_defUses;<KAIGYO>    QVector<int> _worklist;<KAIGYO><KAIGYO>public:<KAIGYO>    DeadCodeElimination(DefUsesCalculator &defUses, Function *function)<KAIGYO>        : _defUses(defUses)<KAIGYO>    {<KAIGYO>        _worklist = QVector<int>::fromList(_defUses.defs());<KAIGYO><KAIGYO>        if (function->variablesCanEscape())<KAIGYO>            _lastUncollectible = function->locals.size() - 1;<KAIGYO>        else<KAIGYO>            _lastUncollectible = INT_MIN;<KAIGYO>    }<KAIGYO><KAIGYO>    void run() {<KAIGYO>        while (!_worklist.isEmpty()) {<KAIGYO>            const int v = _worklist.first();<KAIGYO>            _worklist.removeFirst();<KAIGYO><KAIGYO>            if (_defUses.useCount(v) == 0) {<KAIGYO>//                qDebug()<<"""";<KAIGYO>                Stmt *s = _defUses.defStmt(v);<KAIGYO>                if (!s) {<KAIGYO>                    _defUses.removeDef(v);<KAIGYO>                } else if (!hasSideEffect(s)) {<KAIGYO>//                    qDebug()<<"""";<KAIGYO>                    QVector<Stmt *> &stmts = _defUses.defStmtBlock(v)->statements;<KAIGYO>                    int idx = stmts.indexOf(s);<KAIGYO>                    if (idx != -1)<KAIGYO>                        stmts.remove(idx);<KAIGYO>                    foreach (int usedVar, _defUses.usedVars(s)) {<KAIGYO>                        _defUses.removeUse(s, usedVar);<KAIGYO>                        _worklist.append(usedVar);<KAIGYO>                    }<KAIGYO>                    _defUses.removeDef(v);<KAIGYO>                }<KAIGYO>            }<KAIGYO>        }<KAIGYO><KAIGYO>#ifdef SHOW_SSA<KAIGYO>        qout<<"""";<KAIGYO>        _defUses.dump();<KAIGYO>#endif<KAIGYO>    }<KAIGYO><KAIGYO>private:<KAIGYO>    bool _sideEffect;<KAIGYO><KAIGYO>    bool hasSideEffect(Stmt *s) {<KAIGYO>        // TODO: check if this can be moved to IR building.<KAIGYO>        _sideEffect = false;<KAIGYO>        if (Move *move = s->asMove()) {<KAIGYO>            if (Temp *t = move->target->asTemp())<KAIGYO>                if (_lastUncollectible >= t->index || t->scope)<KAIGYO>                    return true;<KAIGYO>            move->source->accept(this);<KAIGYO>        }<KAIGYO>        return _sideEffect;<KAIGYO>    }<KAIGYO><KAIGYO>protected:<KAIGYO>    virtual void visitConst(Const *) {}<KAIGYO>    virtual void visitString(String *) {}<KAIGYO>    virtual void visitRegExp(RegExp *) {}<KAIGYO>    virtual void visitName(Name *e) {<KAIGYO>        // TODO: maybe we can distinguish between built-ins of which we know that they do not have<KAIGYO>        // a side-effect.<KAIGYO>        if (e->builtin == Name::builtin_invalid || (e->id && *e->id != QStringLiteral("""")))<KAIGYO>            _sideEffect = true;<KAIGYO>    }<KAIGYO>    virtual void visitTemp(Temp *) {}<KAIGYO>    virtual void visitClosure(Closure *) {}<KAIGYO>    virtual void visitUnop(Unop *e) {<KAIGYO>        switch (e->op) {<KAIGYO>        case V4IR::OpIncrement:<KAIGYO>        case V4IR::OpDecrement:<KAIGYO>            _sideEffect = true;<KAIGYO>            break;<KAIGYO><KAIGYO>        default:<KAIGYO>            break;<KAIGYO>        }<KAIGYO><KAIGYO>        if (!_sideEffect) e->expr->accept(this);<KAIGYO>    }<KAIGYO>    virtual void visitBinop(Binop *e) { if (!_sideEffect) e->left->accept(this); if (!_sideEffect) e->right->accept(this); }<KAIGYO>    virtual void visitSubscript(Subscript *e) {<KAIGYO>        // TODO: see if we can have subscript accesses without side effect<KAIGYO>        _sideEffect = true;<KAIGYO>    }<KAIGYO>    virtual void visitMember(Member *e) {<KAIGYO>        // TODO: see if we can have member accesses without side effect<KAIGYO>        _sideEffect = true;<KAIGYO>    }<KAIGYO>    virtual void visitCall(Call *e) {<KAIGYO>        _sideEffect = true; // TODO: there are built-in functions that have no side effect.<KAIGYO>    }<KAIGYO>    virtual void visitNew(New *e) {<KAIGYO>        if (!_sideEffect) e->base->accept(this);<KAIGYO>        for (ExprList *it = e->args; it && !_sideEffect; it = it->next)<KAIGYO>            it->expr->accept(this);<KAIGYO>    }<KAIGYO>};<KAIGYO><KAIGYO>Const *isConstPhi(Phi *phi)<KAIGYO>{<KAIGYO>    if (Const *c = phi->incoming[0]->asConst()) {<KAIGYO>        for (int i = 1, ei = phi->incoming.size(); i != ei; ++i) {<KAIGYO>            if (Const *cc = phi->incoming[i]->asConst()) {<KAIGYO>                if (c->value != cc->value)<KAIGYO>                    return 0;<KAIGYO>                if (!(c->type == cc->type || (c->type & NumberType && cc->type & NumberType)))<KAIGYO>                    return 0;<KAIGYO>            } else {<KAIGYO>                return 0;<KAIGYO>            }<KAIGYO>        }<KAIGYO>        return c;<KAIGYO>    }<KAIGYO>    return 0;<KAIGYO>}<KAIGYO><KAIGYO>Temp *isSameTempPhi(Phi *phi)<KAIGYO>{<KAIGYO>    if (Temp *t = phi->incoming[0]->asTemp()) {<KAIGYO>        for (int i = 1, ei = phi->incoming.size(); i != ei; ++i) {<KAIGYO>            if (Temp *tt = phi->incoming[i]->asTemp())<KAIGYO>                if (t->index == tt->index)<KAIGYO>                    continue;<KAIGYO>            return 0;<KAIGYO>        }<KAIGYO>        return t;<KAIGYO>    }<KAIGYO>    return 0;<KAIGYO>}<KAIGYO><KAIGYO>class ExprReplacer: public StmtVisitor, public ExprVisitor<KAIGYO>{<KAIGYO>    DefUsesCalculator &_defUses;<KAIGYO>    Temp *_toReplace;<KAIGYO>    Expr *_replacement;<KAIGYO><KAIGYO>public:<KAIGYO>    ExprReplacer(DefUsesCalculator &defUses)<KAIGYO>        : _defUses(defUses)<KAIGYO>        , _toReplace(0)<KAIGYO>        , _replacement(0)<KAIGYO>    {}<KAIGYO><KAIGYO>    QVector<Stmt *> operator()(Temp *toReplace, Expr *replacement)<KAIGYO>    {<KAIGYO>        Q_ASSERT(replacement->asTemp() || replacement->asConst() || replacement->asName());<KAIGYO><KAIGYO>        qSwap(_toReplace, toReplace);<KAIGYO>        qSwap(_replacement, replacement);<KAIGYO><KAIGYO>        QList<Stmt *> uses = _defUses.uses(_toReplace->index);<KAIGYO>        QVector<Stmt *> result;<KAIGYO>        result.reserve(uses.size());<KAIGYO>        foreach (Stmt *use, uses) {<KAIGYO>            qout<<"""";<KAIGYO>            use->accept(this);<KAIGYO>            qout<<"""";<KAIGYO>            result.append(use);<KAIGYO>        }<KAIGYO><KAIGYO>        qSwap(_replacement, replacement);<KAIGYO>        qSwap(_toReplace, toReplace);<KAIGYO>        return result;<KAIGYO>    }<KAIGYO><KAIGYO>protected:<KAIGYO>    virtual void visitConst(Const *) {}<KAIGYO>    virtual void visitString(String *) {}<KAIGYO>    virtual void visitRegExp(RegExp *) {}<KAIGYO>    virtual void visitName(Name *) {}<KAIGYO>    virtual void visitTemp(Temp *) {}<KAIGYO>    virtual void visitClosure(Closure *) {}<KAIGYO>    virtual void visitUnop(Unop *e) { check(e->expr); }<KAIGYO>    virtual void visitBinop(Binop *e) { check(e->left); check(e->right); }<KAIGYO>    virtual void visitCall(Call *e) {<KAIGYO>        check(e->base);<KAIGYO>        for (ExprList *it = e->args; it; it = it->next)<KAIGYO>            check(it->expr);<KAIGYO>    }<KAIGYO>    virtual void visitNew(New *e) {<KAIGYO>        check(e->base);<KAIGYO>        for (ExprList *it = e->args; it; it = it->next)<KAIGYO>            check(it->expr);<KAIGYO>    }<KAIGYO>    virtual void visitSubscript(Subscript *e) { check(e->base); check(e->index); }<KAIGYO>    virtual void visitMember(Member *e) { check(e->base); }<KAIGYO>    virtual void visitExp(Exp *s) { check(s->expr); }<KAIGYO>    virtual void visitEnter(Enter *s) { check(s->expr); }<KAIGYO>    virtual void visitLeave(Leave *) {}<KAIGYO>    virtual void visitMove(Move *s) { check(s->target); check(s->source); }<KAIGYO>    virtual void visitJump(Jump *) {}<KAIGYO>    virtual void visitCJump(CJump *s) { check(s->cond); }<KAIGYO>    virtual void visitRet(Ret *s) { check(s->expr); }<KAIGYO>    virtual void visitTry(Try *) {}<KAIGYO>    virtual void visitPhi(Phi *s) {<KAIGYO>        for (int i = 0, ei = s->incoming.size(); i != ei; ++i)<KAIGYO>            check(s->incoming[i]);<KAIGYO>    }<KAIGYO><KAIGYO>private:<KAIGYO>    void check(Expr *&e) {<KAIGYO>        if (equals(e, _toReplace))<KAIGYO>            // TODO: clone the replacement!<KAIGYO>            e = _replacement;<KAIGYO>        else<KAIGYO>            e->accept(this);<KAIGYO>    }<KAIGYO><KAIGYO>    // This only calculates equality for everything needed by constant propagation<KAIGYO>    bool equals(Expr *e1, Expr *e2) const {<KAIGYO>        if (e1 == e2)<KAIGYO>            return true;<KAIGYO><KAIGYO>        if (Const *c1 = e1->asConst()) {<KAIGYO>            if (Const *c2 = e2->asConst())<KAIGYO>                return c1->value == c2->value && (c1->type == c2->type || (c1->type & NumberType && c2->type & NumberType));<KAIGYO>        } else if (Temp *t1 = e1->asTemp()) {<KAIGYO>            if (Temp *t2 = e2->asTemp())<KAIGYO>                return t1->index == t2->index;<KAIGYO>        } else if (Name *n1 = e1->asName()) {<KAIGYO>            if (Name *n2 = e2->asName()) {<KAIGYO>                if (n1->id) {<KAIGYO>                    if (n2->id)<KAIGYO>                        return *n1->id == *n2->id;<KAIGYO>                } else {<KAIGYO>                    return n1->builtin == n2->builtin;<KAIGYO>                }<KAIGYO>            }<KAIGYO>        }<KAIGYO><KAIGYO>        return false;<KAIGYO>    }<KAIGYO>};<KAIGYO><KAIGYO>void optimizeSSA(Function *function, DefUsesCalculator &defUses)<KAIGYO>{<KAIGYO>    // FIXME: if an assignment to a local occurs that can escape through closures, it cannot be optimised out.<KAIGYO><KAIGYO>    QHash<Stmt*,Stmt**> ref;<KAIGYO>    QVector<Stmt *> W;<KAIGYO>    foreach (BasicBlock *bb, function->basicBlocks) {<KAIGYO>        for (int i = 0, ei = bb->statements.size(); i != ei; ++i) {<KAIGYO>            Stmt **s = &bb->statements[i];<KAIGYO>            W.append(*s);<KAIGYO>            ref.insert(*s, s);<KAIGYO>        }<KAIGYO>    }<KAIGYO><KAIGYO>    ExprReplacer replaceUses(defUses);<KAIGYO><KAIGYO>    while (!W.isEmpty()) {<KAIGYO>        Stmt *s = W.last();<KAIGYO>        W.removeLast();<KAIGYO><KAIGYO>        if (Phi *phi = s->asPhi()) {<KAIGYO>            // constant propagation:<KAIGYO>            if (Const *c = isConstPhi(phi)) {<KAIGYO>                W += replaceUses(phi->targetTemp, c);<KAIGYO>                defUses.removeDef(phi->targetTemp->index);<KAIGYO>                *ref[s] = 0;<KAIGYO>                continue;<KAIGYO>            }<KAIGYO><KAIGYO>            // copy propagation:<KAIGYO>            if (phi->incoming.size() == 1) {<KAIGYO>                Temp *t = phi->targetTemp;<KAIGYO>                Expr *e = phi->incoming.first();<KAIGYO><KAIGYO>                QVector<Stmt *> newT2Uses = replaceUses(t, e);<KAIGYO>                W += newT2Uses;<KAIGYO>                if (Temp *t2 = e->asTemp()) {<KAIGYO>                    defUses.removeUse(s, t2->index);<KAIGYO>                    defUses.addUses(t2->index, QList<Stmt*>::fromVector(newT2Uses));<KAIGYO>                }<KAIGYO>                defUses.removeDef(t->index);<KAIGYO>                *ref[s] = 0;<KAIGYO>                continue;<KAIGYO>            }<KAIGYO><KAIGYO>        }<KAIGYO><KAIGYO>        if (Move *m = s->asMove()) {<KAIGYO>            if (Temp *t = m->target->asTemp()) {<KAIGYO>                if (t->index >= 0) {<KAIGYO>                    // constant propagation:<KAIGYO>                    if (Const *c = m->source->asConst()) {<KAIGYO>//                        qout<<""""<<endl;<KAIGYO>                        W += replaceUses(t, c);<KAIGYO>                        defUses.removeDef(t->index);<KAIGYO>                        *ref[s] = 0;<KAIGYO>                        continue;<KAIGYO>                    }<KAIGYO>#if PROPAGATE_THIS<KAIGYO>                    if (Name *n = m->source->asName()) {<KAIGYO>                        qout<<""""<<endl;<KAIGYO>                        W += replaceUses(t, n);<KAIGYO>                        defUses.removeDef(t->index);<KAIGYO>                        *ref[s] = 0;<KAIGYO>                        continue;<KAIGYO>                    }<KAIGYO>#endif<KAIGYO>                    // copy propagation:<KAIGYO>                    if (Temp *t2 = m->source->asTemp()) {<KAIGYO>                        QVector<Stmt *> newT2Uses = replaceUses(t, t2);<KAIGYO>                        W += newT2Uses;<KAIGYO>                        defUses.removeUse(s, t2->index);<KAIGYO>                        defUses.addUses(t2->index, QList<Stmt*>::fromVector(newT2Uses));<KAIGYO>                        defUses.removeDef(t->index);<KAIGYO>                        *ref[s] = 0;<KAIGYO>                        continue;<KAIGYO>                    }<KAIGYO>                }<KAIGYO>            }<KAIGYO>        }<KAIGYO>    }<KAIGYO><KAIGYO>    foreach (BasicBlock *bb, function->basicBlocks) {<KAIGYO>        for (int i = 0; i < bb->statements.size();) {<KAIGYO>            if (bb->statements[i])<KAIGYO>                ++i;<KAIGYO>            else<KAIGYO>                bb->statements.remove(i);<KAIGYO>        }<KAIGYO>    }<KAIGYO>}<KAIGYO><KAIGYO>class TypeInference: public StmtVisitor, public ExprVisitor {<KAIGYO>    const DefUsesCalculator &_defUses;<KAIGYO>    QHash<int, int> _tempTypes;<KAIGYO>    QSet<Stmt *> _worklist;<KAIGYO>    struct TypingResult {<KAIGYO>        int type;<KAIGYO>        bool fullyTyped;<KAIGYO><KAIGYO>        TypingResult(int type, bool fullyTyped): type(type), fullyTyped(fullyTyped) {}<KAIGYO>        explicit TypingResult(int type = UnknownType): type(type), fullyTyped(type != UnknownType) {}<KAIGYO>    };<KAIGYO>    TypingResult _ty;<KAIGYO>    int _localCount;<KAIGYO><KAIGYO>public:<KAIGYO>    TypeInference(const DefUsesCalculator &defUses): _defUses(defUses), _ty(UnknownType) {}<KAIGYO><KAIGYO>    void run(Function *function) {<KAIGYO>        _localCount = function->variablesCanEscape() ? function->locals.size() : 0;<KAIGYO><KAIGYO>        // TODO: the worklist handling looks a bit inefficient... check if there is something better<KAIGYO>        _worklist.clear();<KAIGYO>        for (int i = 0, ei = function->basicBlocks.size(); i != ei; ++i) {<KAIGYO>            BasicBlock *bb = function->basicBlocks[i];<KAIGYO>            if (i == 0 || !bb->in.isEmpty())<KAIGYO>                foreach (Stmt *s, bb->statements)<KAIGYO>                    _worklist.insert(s);<KAIGYO>        }<KAIGYO><KAIGYO>        while (!_worklist.isEmpty()) {<KAIGYO>            QList<Stmt *> worklist = _worklist.values();<KAIGYO>            _worklist.clear();<KAIGYO>            while (!worklist.isEmpty()) {<KAIGYO>                Stmt *s = worklist.first();<KAIGYO>                worklist.removeFirst();<KAIGYO>#if defined(SHOW_SSA)<KAIGYO>                qout<<"""";s->dump(qout);qout<<endl;<KAIGYO>#endif<KAIGYO><KAIGYO>                if (!run(s)) {<KAIGYO>                    _worklist.insert(s);<KAIGYO>#if defined(SHOW_SSA)<KAIGYO>                    qout<<"""";<KAIGYO>                    s->dump(qout);qout<<endl;<KAIGYO>                } else {<KAIGYO>                    qout<<"""";<KAIGYO>                    s->dump(qout);qout<<endl;<KAIGYO>#endif<KAIGYO>                }<KAIGYO>            }<KAIGYO>        }<KAIGYO>    }<KAIGYO><KAIGYO>private:<KAIGYO>    bool run(Stmt *s) {<KAIGYO>        TypingResult ty;<KAIGYO>        std::swap(_ty, ty);<KAIGYO>        s->accept(this);<KAIGYO>        std::swap(_ty, ty);<KAIGYO>        return ty.fullyTyped;<KAIGYO>    }<KAIGYO><KAIGYO>    TypingResult run(Expr *e) {<KAIGYO>        TypingResult ty;<KAIGYO>        std::swap(_ty, ty);<KAIGYO>        e->accept(this);<KAIGYO>        std::swap(_ty, ty);<KAIGYO><KAIGYO>        if (ty.type != UnknownType)<KAIGYO>            setType(e, ty.type);<KAIGYO>        return ty;<KAIGYO>    }<KAIGYO><KAIGYO>    void setType(Expr *e, int ty) {<KAIGYO>        if (Temp *t = e->asTemp()) {<KAIGYO>            if (t->scope || t->index < _localCount)<KAIGYO>                ty = ObjectType;<KAIGYO>            e->type = (Type) ty;<KAIGYO><KAIGYO>            if (_tempTypes[t->index] != ty) {<KAIGYO>                _tempTypes[t->index] = ty;<KAIGYO><KAIGYO>#if defined(SHOW_SSA)<KAIGYO>                qout<<"""" << endl;<KAIGYO>                foreach (Stmt *s, _defUses.uses(t->index)) {<KAIGYO>                    qout << """";<KAIGYO>                    s->dump(qout);<KAIGYO>                    qout << endl;<KAIGYO>                }<KAIGYO>#endif<KAIGYO><KAIGYO>                _worklist += QSet<Stmt *>::fromList(_defUses.uses(t->index));<KAIGYO>            }<KAIGYO>        } else {<KAIGYO>            e->type = (Type) ty;<KAIGYO>        }<KAIGYO>    }<KAIGYO><KAIGYO>protected:<KAIGYO>    virtual void visitConst(Const *e) { _ty = TypingResult(e->type); }<KAIGYO>    virtual void visitString(String *) { _ty = TypingResult(StringType); }<KAIGYO>    virtual void visitRegExp(RegExp *) { _ty = TypingResult(ObjectType); }<KAIGYO>    virtual void visitName(Name *) { _ty = TypingResult(ObjectType); }<KAIGYO>    virtual void visitTemp(Temp *e) {<KAIGYO>        if (e->scope)<KAIGYO>            _ty = TypingResult(ObjectType);<KAIGYO>        else if (e->index < _localCount)<KAIGYO>            _ty = TypingResult(ObjectType);<KAIGYO>        else<KAIGYO>            _ty = TypingResult(_tempTypes.value(e->index, UnknownType));<KAIGYO>        setType(e, _ty.type);<KAIGYO>    }<KAIGYO>    virtual void visitClosure(Closure *) { _ty = TypingResult(ObjectType); } // TODO: VERIFY THIS!<KAIGYO>    virtual void visitUnop(Unop *e) {<KAIGYO>        _ty = run(e->expr);<KAIGYO>        switch (e->op) {<KAIGYO>        case OpUPlus: _ty.type = DoubleType; return;<KAIGYO>        case OpUMinus: _ty.type = DoubleType; return;<KAIGYO>        case OpCompl: _ty.type = SInt32Type; return;<KAIGYO>        case OpNot: _ty.type = BoolType; return;<KAIGYO><KAIGYO>        case OpIncrement:<KAIGYO>        case OpDecrement:<KAIGYO>            Q_ASSERT(!"""");<KAIGYO>        default:<KAIGYO>            Q_UNIMPLEMENTED();<KAIGYO>            Q_UNREACHABLE();<KAIGYO>        }<KAIGYO>    }<KAIGYO><KAIGYO>    virtual void visitBinop(Binop *e) {<KAIGYO>        TypingResult leftTy = run(e->left);<KAIGYO>        TypingResult rightTy = run(e->right);<KAIGYO>        _ty.fullyTyped = leftTy.fullyTyped && rightTy.fullyTyped;<KAIGYO><KAIGYO>        switch (e->op) {<KAIGYO>        case OpAdd:<KAIGYO>            if (leftTy.type & StringType || rightTy.type & StringType)<KAIGYO>                _ty.type = StringType;<KAIGYO>            else if (leftTy.type != UnknownType && rightTy.type != UnknownType)<KAIGYO>                _ty.type = DoubleType;<KAIGYO>            else<KAIGYO>                _ty.type = UnknownType;<KAIGYO>            break;<KAIGYO>        case OpSub:<KAIGYO>            _ty.type = DoubleType;<KAIGYO>            break;<KAIGYO><KAIGYO>        case OpMul:<KAIGYO>        case OpDiv:<KAIGYO>        case OpMod:<KAIGYO>            _ty.type = DoubleType;<KAIGYO>            break;<KAIGYO><KAIGYO>        case OpBitAnd:<KAIGYO>        case OpBitOr:<KAIGYO>        case OpBitXor:<KAIGYO>        case OpLShift:<KAIGYO>        case OpRShift:<KAIGYO>            _ty.type = SInt32Type;<KAIGYO>            break;<KAIGYO>        case OpURShift:<KAIGYO>            _ty.type = UInt32Type;<KAIGYO>            break;<KAIGYO><KAIGYO>        case OpGt:<KAIGYO>        case OpLt:<KAIGYO>        case OpGe:<KAIGYO>        case OpLe:<KAIGYO>        case OpEqual:<KAIGYO>        case OpNotEqual:<KAIGYO>        case OpStrictEqual:<KAIGYO>        case OpStrictNotEqual:<KAIGYO>        case OpAnd:<KAIGYO>        case OpOr:<KAIGYO>        case OpInstanceof:<KAIGYO>        case OpIn:<KAIGYO>            _ty.type = BoolType;<KAIGYO>            break;<KAIGYO><KAIGYO>        default:<KAIGYO>            Q_UNIMPLEMENTED();<KAIGYO>            Q_UNREACHABLE();<KAIGYO>        }<KAIGYO>    }<KAIGYO><KAIGYO>    virtual void visitCall(Call *e) {<KAIGYO>        _ty = run(e->base);<KAIGYO>        for (ExprList *it = e->args; it; it = it->next)<KAIGYO>            _ty.fullyTyped &= run(it->expr).fullyTyped;<KAIGYO>        _ty.type = ObjectType;<KAIGYO>    }<KAIGYO>    virtual void visitNew(New *e) {<KAIGYO>        _ty = run(e->base);<KAIGYO>        for (ExprList *it = e->args; it; it = it->next)<KAIGYO>            _ty.fullyTyped &= run(it->expr).fullyTyped;<KAIGYO>        _ty.type = ObjectType;<KAIGYO>    }<KAIGYO>    virtual void visitSubscript(Subscript *e) {<KAIGYO>        _ty.fullyTyped = run(e->base).fullyTyped && run(e->index).fullyTyped;<KAIGYO>        _ty.type = ObjectType;<KAIGYO>    }<KAIGYO><KAIGYO>    virtual void visitMember(Member *e) {<KAIGYO>        // TODO: for QML, try to do a static lookup<KAIGYO>        _ty = run(e->base);<KAIGYO>        _ty.type = ObjectType;<KAIGYO>    }<KAIGYO><KAIGYO>    virtual void visitExp(Exp *s) { _ty = run(s->expr); }<KAIGYO>    virtual void visitEnter(Enter *s) { _ty = run(s->expr); }<KAIGYO>    virtual void visitLeave(Leave *) { _ty = TypingResult(MissingType); }<KAIGYO>    virtual void visitMove(Move *s) {<KAIGYO>        TypingResult sourceTy = run(s->source);<KAIGYO>        Q_ASSERT(s->op == OpInvalid);<KAIGYO>        if (Temp *t = s->target->asTemp()) {<KAIGYO>            setType(t, sourceTy.type);<KAIGYO>            _ty = sourceTy;<KAIGYO>            return;<KAIGYO>        }<KAIGYO><KAIGYO>        _ty = run(s->target);<KAIGYO>        _ty.fullyTyped &= sourceTy.fullyTyped;<KAIGYO>    }<KAIGYO><KAIGYO>    virtual void visitJump(Jump *) { _ty = TypingResult(MissingType); }<KAIGYO>    virtual void visitCJump(CJump *s) { _ty = run(s->cond); }<KAIGYO>    virtual void visitRet(Ret *s) { _ty = run(s->expr); }<KAIGYO>    virtual void visitTry(Try *s) { setType(s->exceptionVar, ObjectType); _ty = TypingResult(MissingType); }<KAIGYO>    virtual void visitPhi(Phi *s) {<KAIGYO>        _ty = run(s->incoming[0]);<KAIGYO>        for (int i = 1, ei = s->incoming.size(); i != ei; ++i) {<KAIGYO>            TypingResult ty = run(s->incoming[i]);<KAIGYO>            _ty.type |= ty.type;<KAIGYO>            _ty.fullyTyped &= ty.fullyTyped;<KAIGYO>        }<KAIGYO><KAIGYO>        // TODO: check & double check the next condition!<KAIGYO>        if (_ty.type & ObjectType || _ty.type & UndefinedType || _ty.type & NullType)<KAIGYO>            _ty.type = ObjectType;<KAIGYO>        else if (_ty.type & NumberType)<KAIGYO>            _ty.type = DoubleType;<KAIGYO><KAIGYO>        setType(s->targetTemp, _ty.type);<KAIGYO>    }<KAIGYO>};<KAIGYO><KAIGYO>class TypePropagation: public StmtVisitor, public ExprVisitor {<KAIGYO>    Type _ty;<KAIGYO><KAIGYO>    void run(Expr *e, Type requestedType = UnknownType) {<KAIGYO>        qSwap(_ty, requestedType);<KAIGYO>        e->accept(this);<KAIGYO>        qSwap(_ty, requestedType);<KAIGYO>    }<KAIGYO><KAIGYO>public:<KAIGYO>    TypePropagation() : _ty(UnknownType) {}<KAIGYO><KAIGYO>    void run(Function *f) {<KAIGYO>        foreach (BasicBlock *bb, f->basicBlocks)<KAIGYO>            foreach (Stmt *s, bb->statements)<KAIGYO>                s->accept(this);<KAIGYO>    }<KAIGYO><KAIGYO>protected:<KAIGYO>    virtual void visitConst(Const *c) {<KAIGYO>        if (_ty & NumberType && c->type & NumberType) {<KAIGYO>            c->type = _ty;<KAIGYO>        }<KAIGYO>    }<KAIGYO><KAIGYO>    virtual void visitString(String *) {}<KAIGYO>    virtual void visitRegExp(RegExp *) {}<KAIGYO>    virtual void visitName(Name *) {}<KAIGYO>    virtual void visitTemp(Temp *) {}<KAIGYO>    virtual void visitClosure(Closure *) {}<KAIGYO>    virtual void visitUnop(Unop *e) { run(e->expr, e->type); }<KAIGYO>    virtual void visitBinop(Binop *e) { run(e->left, e->type); run(e->right, e->type); }<KAIGYO>    virtual void visitCall(Call *e) {<KAIGYO>        run(e->base);<KAIGYO>        for (ExprList *it = e->args; it; it = it->next)<KAIGYO>            run(it->expr);<KAIGYO>    }<KAIGYO>    virtual void visitNew(New *e) {<KAIGYO>        run(e->base);<KAIGYO>        for (ExprList *it = e->args; it; it = it->next)<KAIGYO>            run(it->expr);<KAIGYO>    }<KAIGYO>    virtual void visitSubscript(Subscript *e) { run(e->base); run(e->index); }<KAIGYO>    virtual void visitMember(Member *e) { run(e->base); }<KAIGYO>    virtual void visitExp(Exp *s) { run(s->expr); }<KAIGYO>    virtual void visitEnter(Enter *s) { run(s->expr); }<KAIGYO>    virtual void visitLeave(Leave *) {}<KAIGYO>    virtual void visitMove(Move *s) {<KAIGYO>        run(s->target);<KAIGYO>        run(s->source, s->target->type);<KAIGYO>    }<KAIGYO>    virtual void visitJump(Jump *) {}<KAIGYO>    virtual void visitCJump(CJump *s) {<KAIGYO>        run(s->cond, BoolType);<KAIGYO>    }<KAIGYO>    virtual void visitRet(Ret *s) { run(s->expr); }<KAIGYO>    virtual void visitTry(Try *) {}<KAIGYO>    virtual void visitPhi(Phi *s) {<KAIGYO>        Type ty = s->targetTemp->type;<KAIGYO>        foreach (Expr *e, s->incoming)<KAIGYO>            run(e, ty);<KAIGYO>    }<KAIGYO>};<KAIGYO><KAIGYO>void insertMove(Function *function, BasicBlock *basicBlock, Temp *target, Expr *source) {<KAIGYO>    Move *s = function->New<Move>();<KAIGYO>    s->init(target, source, OpInvalid);<KAIGYO>    basicBlock->statements.insert(basicBlock->statements.size() - 1, s);<KAIGYO>}<KAIGYO><KAIGYO>bool doEdgeSplitting(Function *f)<KAIGYO>{<KAIGYO>    const QVector<BasicBlock *> oldBBs = f->basicBlocks;<KAIGYO><KAIGYO>    foreach (BasicBlock *bb, oldBBs) {<KAIGYO>        if (bb->in.size() > 1) {<KAIGYO>            for (int inIdx = 0, eInIdx = bb->in.size(); inIdx != eInIdx; ++inIdx) {<KAIGYO>                BasicBlock *inBB = bb->in[inIdx];<KAIGYO>                if (inBB->out.size() > 1) { // this should have been split!<KAIGYO>#if defined(SHOW_SSA)<KAIGYO>                    qDebug() << """" << bb->index;<KAIGYO>#endif<KAIGYO><KAIGYO>                    // create the basic block:<KAIGYO>                    BasicBlock *newBB = new BasicBlock(f);<KAIGYO>                    newBB->index = f->basicBlocks.last()->index + 1;<KAIGYO>                    f->basicBlocks.append(newBB);<KAIGYO>                    Jump *s = f->New<Jump>();<KAIGYO>                    s->init(bb);<KAIGYO>                    newBB->statements.append(s);<KAIGYO><KAIGYO>                    // rewire the old outgoing edge<KAIGYO>                    int outIdx = inBB->out.indexOf(bb);<KAIGYO>                    inBB->out[outIdx] = newBB;<KAIGYO>                    newBB->in.append(inBB);<KAIGYO><KAIGYO>                    // rewire the old incoming edge<KAIGYO>                    bb->in[inIdx] = newBB;<KAIGYO>                    newBB->out.append(bb);<KAIGYO><KAIGYO>                    // patch the terminator<KAIGYO>                    Stmt *terminator = inBB->terminator();<KAIGYO>                    if (Jump *j = terminator->asJump()) {<KAIGYO>                        Q_ASSERT(outIdx == 0);<KAIGYO>                        j->target = newBB;<KAIGYO>                    } else if (CJump *j = terminator->asCJump()) {<KAIGYO>                        if (outIdx == 0)<KAIGYO>                            j->iftrue = newBB;<KAIGYO>                        else if (outIdx == 1)<KAIGYO>                            j->iffalse = newBB;<KAIGYO>                        else<KAIGYO>                            Q_ASSERT(!"""");<KAIGYO>                    } else {<KAIGYO>                        Q_ASSERT(!"""");<KAIGYO>                    }<KAIGYO>                }<KAIGYO>            }<KAIGYO>        }<KAIGYO>    }<KAIGYO>}<KAIGYO><KAIGYO>void scheduleBlocks(QVector<BasicBlock *> &basicBlocks)<KAIGYO>{<KAIGYO>    // FIXME: this should not do DFS scheduling.<KAIGYO>    struct I {<KAIGYO>        QSet<BasicBlock *> visited;<KAIGYO>        QVector<BasicBlock *> &sequence;<KAIGYO><KAIGYO>        I(QVector<BasicBlock *> &sequence): sequence(sequence) {}<KAIGYO><KAIGYO>        void DFS(BasicBlock *bb) {<KAIGYO>            if (visited.contains(bb))<KAIGYO>                return;<KAIGYO>            visited.insert(bb);<KAIGYO>            sequence.append(bb);<KAIGYO>            if (Stmt *terminator = bb->terminator()) {<KAIGYO>                if (Jump *j = terminator->asJump()) {<KAIGYO>                    Q_ASSERT(bb->out.size() == 1);<KAIGYO>                    DFS(j->target);<KAIGYO>                } else if (CJump *cj = terminator->asCJump()) {<KAIGYO>                    Q_ASSERT(bb->out.size() == 2);<KAIGYO>                    DFS(cj->iftrue);<KAIGYO>                    DFS(cj->iffalse);<KAIGYO>                } else if (terminator->asRet()) {<KAIGYO>                    Q_ASSERT(bb->out.size() == 0);<KAIGYO>                    // nothing to do.<KAIGYO>                } else {<KAIGYO>                    Q_UNREACHABLE();<KAIGYO>                }<KAIGYO>            } else {<KAIGYO>                Q_UNREACHABLE();<KAIGYO>            }<KAIGYO>        }<KAIGYO>    };<KAIGYO><KAIGYO>    QVector<BasicBlock *> sequence;<KAIGYO>    sequence.reserve(basicBlocks.size());<KAIGYO>    I(sequence).DFS(basicBlocks.first());<KAIGYO>    qSwap(basicBlocks, sequence);<KAIGYO>}<KAIGYO><KAIGYO>/*<KAIGYO> * Quick function to convert out of SSA, so we can put the stuff through the ISel phases. This<KAIGYO> * has to be replaced by a phase in the specific ISel back-ends and do register allocation at the<KAIGYO> * same time. That way the huge number of redundant moves generated by this function are eliminated.<KAIGYO> */': 4, '// TODO: check if we need to run a pass to collect phi nodes that are only used by other phi nodes.<KAIGYO>//    showMeTheCode(function);': 4, '// TODO: maybe we should move this somewhere else?': 5, '    virtual void visitTry(Try *s) { /* this should never happen */ }<KAIGYO><KAIGYO>    virtual void visitConst(Const *) {}<KAIGYO>    virtual void visitString(String *) {}<KAIGYO>    virtual void visitRegExp(RegExp *) {}<KAIGYO>    virtual void visitName(Name *) {}<KAIGYO>    virtual void visitClosure(Closure *) {}<KAIGYO>    virtual void visitUnop(Unop *e) { e->expr->accept(this); }<KAIGYO>    virtual void visitBinop(Binop *e) { e->left->accept(this); e->right->accept(this); }<KAIGYO>    virtual void visitCall(Call *e) {<KAIGYO>        e->base->accept(this);<KAIGYO>        for (ExprList *it = e->args; it; it = it->next)<KAIGYO>            it->expr->accept(this);<KAIGYO>    }<KAIGYO><KAIGYO>    virtual void visitNew(New *e) {<KAIGYO>        e->base->accept(this);<KAIGYO>        for (ExprList *it = e->args; it; it = it->next)<KAIGYO>            it->expr->accept(this);<KAIGYO>    }<KAIGYO><KAIGYO>    virtual void visitSubscript(Subscript *e) {<KAIGYO>        e->base->accept(this);<KAIGYO>        e->index->accept(this);<KAIGYO>    }<KAIGYO><KAIGYO>    virtual void visitMember(Member *e) {<KAIGYO>        e->base->accept(this);<KAIGYO>    }<KAIGYO>};<KAIGYO><KAIGYO>QHash<int, int> convertToSSA(Function *function)<KAIGYO>{<KAIGYO>#ifdef SHOW_SSA<KAIGYO>    qout << """";<KAIGYO>    if (function->name)<KAIGYO>        qout << *function->name;<KAIGYO>    else<KAIGYO>        qout << """";<KAIGYO>    qout << """" << endl;<KAIGYO>#endif // SHOW_SSA<KAIGYO><KAIGYO>    QVector<BasicBlock *> &nodes = function->basicBlocks;<KAIGYO><KAIGYO>    // Calculate the dominator tree:<KAIGYO>    DominatorTree df(nodes);<KAIGYO><KAIGYO>    // Collect all applicable variables:<KAIGYO>    VariableCollector variables(function);<KAIGYO><KAIGYO>    // Place phi functions:<KAIGYO>    QHash<BasicBlock *, QSet<int> > A_phi;<KAIGYO>    foreach (int a, variables.vars()) {<KAIGYO>        if (!variables.isNonLocal(a))<KAIGYO>            continue; // for semi-pruned SSA<KAIGYO><KAIGYO>        QList<BasicBlock *> W = QList<BasicBlock *>::fromSet(variables.defsite(a));<KAIGYO>        while (!W.isEmpty()) {<KAIGYO>            BasicBlock *n = W.first();<KAIGYO>            W.removeFirst();<KAIGYO>            foreach (BasicBlock *y, df[n]) {<KAIGYO>                if (!A_phi[y].contains(a)) {<KAIGYO>                    insertPhiNode(a, y, function);<KAIGYO>                    A_phi[y].insert(a);<KAIGYO>                    if (!variables.inBlock(y).contains(a))<KAIGYO>                        W.append(y);<KAIGYO>                }<KAIGYO>            }<KAIGYO>        }<KAIGYO>    }<KAIGYO><KAIGYO>    // Rename variables:<KAIGYO>    return VariableRenamer(function).run();<KAIGYO>}<KAIGYO><KAIGYO>class DefUsesCalculator: public StmtVisitor, public ExprVisitor {<KAIGYO>public:<KAIGYO>    struct DefUse {<KAIGYO>        Stmt *defStmt;<KAIGYO>        BasicBlock *blockOfStatement;<KAIGYO>        QList<Stmt *> uses;<KAIGYO>    };<KAIGYO><KAIGYO>private:<KAIGYO>    QHash<int, DefUse> _defUses;<KAIGYO>    QHash<Stmt *, QList<int> > _usesPerStatement;<KAIGYO><KAIGYO>    BasicBlock *_block;<KAIGYO>    Stmt *_stmt;<KAIGYO><KAIGYO>    void addUse(Temp *t) {<KAIGYO>        Q_ASSERT(t);<KAIGYO><KAIGYO>        _defUses[t->index].uses.append(_stmt);<KAIGYO>        _usesPerStatement[_stmt].append(t->index);<KAIGYO>    }<KAIGYO><KAIGYO>    void addDef(Temp *t) {<KAIGYO>        DefUse &defUse = _defUses[t->index];<KAIGYO>        defUse.defStmt = _stmt;<KAIGYO>        defUse.blockOfStatement = _block;<KAIGYO>    }<KAIGYO><KAIGYO>public:<KAIGYO>    DefUsesCalculator(const QVector<BasicBlock *> &bbs) {<KAIGYO>        foreach (BasicBlock *bb, bbs) {<KAIGYO>            _block = bb;<KAIGYO>            foreach (Stmt *stmt, bb->statements) {<KAIGYO>                _stmt = stmt;<KAIGYO>                stmt->accept(this);<KAIGYO>            }<KAIGYO>        }<KAIGYO><KAIGYO>        QMutableHashIterator<int, DefUse> it(_defUses);<KAIGYO>        while (it.hasNext()) {<KAIGYO>            it.next();<KAIGYO>            if (!it.value().defStmt)<KAIGYO>                it.remove();<KAIGYO>        }<KAIGYO>    }<KAIGYO><KAIGYO>    QList<int> defs() const {<KAIGYO>        return _defUses.keys();<KAIGYO>    }<KAIGYO><KAIGYO>    void removeDef(int var) {<KAIGYO>        _defUses.remove(var);<KAIGYO>    }<KAIGYO><KAIGYO>    void addUses(int variable, QList<Stmt *>newUses)<KAIGYO>    { _defUses[variable].uses.append(newUses); }<KAIGYO><KAIGYO>    int useCount(int variable) const<KAIGYO>    { return _defUses[variable].uses.size(); }<KAIGYO><KAIGYO>    Stmt *defStmt(int variable) const<KAIGYO>    { return _defUses[variable].defStmt; }<KAIGYO><KAIGYO>    BasicBlock *defStmtBlock(int variable) const<KAIGYO>    { return _defUses[variable].blockOfStatement; }<KAIGYO><KAIGYO>    void removeUse(Stmt *usingStmt, int var)<KAIGYO>    { _defUses[var].uses.removeAll(usingStmt); }<KAIGYO><KAIGYO>    QList<int> usedVars(Stmt *s) const<KAIGYO>    { return _usesPerStatement[s]; }<KAIGYO><KAIGYO>    QList<Stmt *> uses(int var) const<KAIGYO>    { return _defUses[var].uses; }<KAIGYO><KAIGYO>    void dump() const<KAIGYO>    {<KAIGYO>        foreach (int var, _defUses.keys()) {<KAIGYO>            const DefUse &du = _defUses[var];<KAIGYO>            qout<<var<<"""";<KAIGYO>            du.defStmt->dump(qout);<KAIGYO>            qout<<endl<<""""<<endl;<KAIGYO>            foreach (Stmt *s, du.uses) {<KAIGYO>                qout<<"""";s->dump(qout);qout<<endl;<KAIGYO>            }<KAIGYO>        }<KAIGYO>    }<KAIGYO><KAIGYO>protected:<KAIGYO>    virtual void visitExp(Exp *s) { s->expr->accept(this); }<KAIGYO>    virtual void visitEnter(Enter *) {}<KAIGYO>    virtual void visitLeave(Leave *) {}<KAIGYO>    virtual void visitJump(Jump *) {}<KAIGYO>    virtual void visitCJump(CJump *s) { s->cond->accept(this); }<KAIGYO>    virtual void visitRet(Ret *s) { s->expr->accept(this); }<KAIGYO>    virtual void visitTry(Try *) {}<KAIGYO><KAIGYO>    virtual void visitPhi(Phi *s) {<KAIGYO>        addDef(s->targetTemp);<KAIGYO>        foreach (Expr *e, s->incoming)<KAIGYO>            addUse(e->asTemp());<KAIGYO>    }<KAIGYO><KAIGYO>    virtual void visitMove(Move *s) {<KAIGYO>        if (Temp *t = s->target->asTemp())<KAIGYO>            addDef(t);<KAIGYO>        else<KAIGYO>            s->target->accept(this);<KAIGYO><KAIGYO>        s->source->accept(this);<KAIGYO>    }<KAIGYO><KAIGYO>    virtual void visitTemp(Temp *e) { addUse(e); }<KAIGYO><KAIGYO>    virtual void visitConst(Const *) {}<KAIGYO>    virtual void visitString(String *) {}<KAIGYO>    virtual void visitRegExp(RegExp *) {}<KAIGYO>    virtual void visitName(Name *) {}<KAIGYO>    virtual void visitClosure(Closure *) {}<KAIGYO>    virtual void visitUnop(Unop *e) { e->expr->accept(this); }<KAIGYO>    virtual void visitBinop(Binop *e) { e->left->accept(this); e->right->accept(this); }<KAIGYO>    virtual void visitSubscript(Subscript *e) { e->base->accept(this); e->index->accept(this); }<KAIGYO>    virtual void visitMember(Member *e) { e->base->accept(this); }<KAIGYO>    virtual void visitCall(Call *e) {<KAIGYO>        e->base->accept(this);<KAIGYO>        for (ExprList *it = e->args; it; it = it->next)<KAIGYO>            it->expr->accept(this);<KAIGYO>    }<KAIGYO><KAIGYO>    virtual void visitNew(New *e) {<KAIGYO>        e->base->accept(this);<KAIGYO>        for (ExprList *it = e->args; it; it = it->next)<KAIGYO>            it->expr->accept(this);<KAIGYO>    }<KAIGYO>};<KAIGYO><KAIGYO>bool hasPhiOnlyUses(Phi *phi, const DefUsesCalculator &defUses, QSet<Phi *> &collectedPhis)<KAIGYO>{<KAIGYO>    collectedPhis.insert(phi);<KAIGYO>    foreach (Stmt *use, defUses.uses(phi->targetTemp->index)) {<KAIGYO>        if (Phi *dependentPhi = use->asPhi()) {<KAIGYO>            if (!collectedPhis.contains(dependentPhi)) {<KAIGYO>                if (!hasPhiOnlyUses(dependentPhi, defUses, collectedPhis))<KAIGYO>                    return false;<KAIGYO>            }<KAIGYO>        } else {<KAIGYO>            return false;<KAIGYO>        }<KAIGYO>    }<KAIGYO>    return true;<KAIGYO>}<KAIGYO><KAIGYO>void cleanupPhis(DefUsesCalculator &defUses)<KAIGYO>{<KAIGYO>    QLinkedList<Phi *> phis;<KAIGYO>    foreach (int def, defUses.defs())<KAIGYO>        if (Phi *phi = defUses.defStmt(def)->asPhi())<KAIGYO>            phis.append(phi);<KAIGYO><KAIGYO>    QSet<Phi *> toRemove;<KAIGYO>    while (!phis.isEmpty()) {<KAIGYO>        Phi *phi = phis.first();<KAIGYO>        phis.removeFirst();<KAIGYO>        if (toRemove.contains(phi))<KAIGYO>            continue;<KAIGYO>        QSet<Phi *> collectedPhis;<KAIGYO>        if (hasPhiOnlyUses(phi, defUses, collectedPhis))<KAIGYO>            toRemove.unite(collectedPhis);<KAIGYO>    }<KAIGYO><KAIGYO>    foreach (Phi *phi, toRemove) {<KAIGYO>        int targetVar = phi->targetTemp->index;<KAIGYO><KAIGYO>        BasicBlock *bb = defUses.defStmtBlock(targetVar);<KAIGYO>        int idx = bb->statements.indexOf(phi);<KAIGYO>        bb->statements.remove(idx);<KAIGYO><KAIGYO>        foreach (int usedVar, defUses.usedVars(phi))<KAIGYO>            defUses.removeUse(phi, usedVar);<KAIGYO>        defUses.removeDef(targetVar);<KAIGYO>    }<KAIGYO>}<KAIGYO><KAIGYO>class DeadCodeElimination: public ExprVisitor {<KAIGYO>    int _lastUncollectible;<KAIGYO>    DefUsesCalculator &_defUses;<KAIGYO>    QVector<int> _worklist;<KAIGYO><KAIGYO>public:<KAIGYO>    DeadCodeElimination(DefUsesCalculator &defUses, Function *function)<KAIGYO>        : _defUses(defUses)<KAIGYO>    {<KAIGYO>        _worklist = QVector<int>::fromList(_defUses.defs());<KAIGYO><KAIGYO>        if (function->variablesCanEscape())<KAIGYO>            _lastUncollectible = function->locals.size() - 1;<KAIGYO>        else<KAIGYO>            _lastUncollectible = INT_MIN;<KAIGYO>    }<KAIGYO><KAIGYO>    void run() {<KAIGYO>        while (!_worklist.isEmpty()) {<KAIGYO>            const int v = _worklist.first();<KAIGYO>            _worklist.removeFirst();<KAIGYO><KAIGYO>            if (_defUses.useCount(v) == 0) {<KAIGYO>//                qDebug()<<"""";<KAIGYO>                Stmt *s = _defUses.defStmt(v);<KAIGYO>                if (!s) {<KAIGYO>                    _defUses.removeDef(v);<KAIGYO>                } else if (!hasSideEffect(s)) {<KAIGYO>//                    qDebug()<<"""";<KAIGYO>                    QVector<Stmt *> &stmts = _defUses.defStmtBlock(v)->statements;<KAIGYO>                    int idx = stmts.indexOf(s);<KAIGYO>                    if (idx != -1)<KAIGYO>                        stmts.remove(idx);<KAIGYO>                    foreach (int usedVar, _defUses.usedVars(s)) {<KAIGYO>                        _defUses.removeUse(s, usedVar);<KAIGYO>                        _worklist.append(usedVar);<KAIGYO>                    }<KAIGYO>                    _defUses.removeDef(v);<KAIGYO>                }<KAIGYO>            }<KAIGYO>        }<KAIGYO><KAIGYO>#ifdef SHOW_SSA<KAIGYO>        qout<<"""";<KAIGYO>        _defUses.dump();<KAIGYO>#endif<KAIGYO>    }<KAIGYO><KAIGYO>private:<KAIGYO>    bool _sideEffect;<KAIGYO><KAIGYO>    bool hasSideEffect(Stmt *s) {<KAIGYO>        // TODO: check if this can be moved to IR building.<KAIGYO>        _sideEffect = false;<KAIGYO>        if (Move *move = s->asMove()) {<KAIGYO>            if (Temp *t = move->target->asTemp())<KAIGYO>                if (_lastUncollectible >= t->index || t->scope)<KAIGYO>                    return true;<KAIGYO>            move->source->accept(this);<KAIGYO>        }<KAIGYO>        return _sideEffect;<KAIGYO>    }<KAIGYO><KAIGYO>protected:<KAIGYO>    virtual void visitConst(Const *) {}<KAIGYO>    virtual void visitString(String *) {}<KAIGYO>    virtual void visitRegExp(RegExp *) {}<KAIGYO>    virtual void visitName(Name *e) {<KAIGYO>        // TODO: maybe we can distinguish between built-ins of which we know that they do not have<KAIGYO>        // a side-effect.<KAIGYO>        if (e->builtin == Name::builtin_invalid || (e->id && *e->id != QStringLiteral("""")))<KAIGYO>            _sideEffect = true;<KAIGYO>    }<KAIGYO>    virtual void visitTemp(Temp *) {}<KAIGYO>    virtual void visitClosure(Closure *) {}<KAIGYO>    virtual void visitUnop(Unop *e) {<KAIGYO>        switch (e->op) {<KAIGYO>        case V4IR::OpIncrement:<KAIGYO>        case V4IR::OpDecrement:<KAIGYO>            _sideEffect = true;<KAIGYO>            break;<KAIGYO><KAIGYO>        default:<KAIGYO>            break;<KAIGYO>        }<KAIGYO><KAIGYO>        if (!_sideEffect) e->expr->accept(this);<KAIGYO>    }<KAIGYO>    virtual void visitBinop(Binop *e) { if (!_sideEffect) e->left->accept(this); if (!_sideEffect) e->right->accept(this); }<KAIGYO>    virtual void visitSubscript(Subscript *e) {<KAIGYO>        // TODO: see if we can have subscript accesses without side effect<KAIGYO>        _sideEffect = true;<KAIGYO>    }<KAIGYO>    virtual void visitMember(Member *e) {<KAIGYO>        // TODO: see if we can have member accesses without side effect<KAIGYO>        _sideEffect = true;<KAIGYO>    }<KAIGYO>    virtual void visitCall(Call *e) {<KAIGYO>        _sideEffect = true; // TODO: there are built-in functions that have no side effect.<KAIGYO>    }<KAIGYO>    virtual void visitNew(New *e) {<KAIGYO>        if (!_sideEffect) e->base->accept(this);<KAIGYO>        for (ExprList *it = e->args; it && !_sideEffect; it = it->next)<KAIGYO>            it->expr->accept(this);<KAIGYO>    }<KAIGYO>};<KAIGYO><KAIGYO>Const *isConstPhi(Phi *phi)<KAIGYO>{<KAIGYO>    if (Const *c = phi->incoming[0]->asConst()) {<KAIGYO>        for (int i = 1, ei = phi->incoming.size(); i != ei; ++i) {<KAIGYO>            if (Const *cc = phi->incoming[i]->asConst()) {<KAIGYO>                if (c->value != cc->value)<KAIGYO>                    return 0;<KAIGYO>                if (!(c->type == cc->type || (c->type & NumberType && cc->type & NumberType)))<KAIGYO>                    return 0;<KAIGYO>            } else {<KAIGYO>                return 0;<KAIGYO>            }<KAIGYO>        }<KAIGYO>        return c;<KAIGYO>    }<KAIGYO>    return 0;<KAIGYO>}<KAIGYO><KAIGYO>Temp *isSameTempPhi(Phi *phi)<KAIGYO>{<KAIGYO>    if (Temp *t = phi->incoming[0]->asTemp()) {<KAIGYO>        for (int i = 1, ei = phi->incoming.size(); i != ei; ++i) {<KAIGYO>            if (Temp *tt = phi->incoming[i]->asTemp())<KAIGYO>                if (t->index == tt->index)<KAIGYO>                    continue;<KAIGYO>            return 0;<KAIGYO>        }<KAIGYO>        return t;<KAIGYO>    }<KAIGYO>    return 0;<KAIGYO>}<KAIGYO><KAIGYO>class ExprReplacer: public StmtVisitor, public ExprVisitor<KAIGYO>{<KAIGYO>    DefUsesCalculator &_defUses;<KAIGYO>    Temp *_toReplace;<KAIGYO>    Expr *_replacement;<KAIGYO><KAIGYO>public:<KAIGYO>    ExprReplacer(DefUsesCalculator &defUses)<KAIGYO>        : _defUses(defUses)<KAIGYO>        , _toReplace(0)<KAIGYO>        , _replacement(0)<KAIGYO>    {}<KAIGYO><KAIGYO>    QVector<Stmt *> operator()(Temp *toReplace, Expr *replacement)<KAIGYO>    {<KAIGYO>        Q_ASSERT(replacement->asTemp() || replacement->asConst() || replacement->asName());<KAIGYO><KAIGYO>        qSwap(_toReplace, toReplace);<KAIGYO>        qSwap(_replacement, replacement);<KAIGYO><KAIGYO>        QList<Stmt *> uses = _defUses.uses(_toReplace->index);<KAIGYO>        QVector<Stmt *> result;<KAIGYO>        result.reserve(uses.size());<KAIGYO>        foreach (Stmt *use, uses) {<KAIGYO>//            qout<<"""";<KAIGYO>            use->accept(this);<KAIGYO>//            qout<<"""";<KAIGYO>            result.append(use);<KAIGYO>        }<KAIGYO><KAIGYO>        qSwap(_replacement, replacement);<KAIGYO>        qSwap(_toReplace, toReplace);<KAIGYO>        return result;<KAIGYO>    }<KAIGYO><KAIGYO>protected:<KAIGYO>    virtual void visitConst(Const *) {}<KAIGYO>    virtual void visitString(String *) {}<KAIGYO>    virtual void visitRegExp(RegExp *) {}<KAIGYO>    virtual void visitName(Name *) {}<KAIGYO>    virtual void visitTemp(Temp *) {}<KAIGYO>    virtual void visitClosure(Closure *) {}<KAIGYO>    virtual void visitUnop(Unop *e) { check(e->expr); }<KAIGYO>    virtual void visitBinop(Binop *e) { check(e->left); check(e->right); }<KAIGYO>    virtual void visitCall(Call *e) {<KAIGYO>        check(e->base);<KAIGYO>        for (ExprList *it = e->args; it; it = it->next)<KAIGYO>            check(it->expr);<KAIGYO>    }<KAIGYO>    virtual void visitNew(New *e) {<KAIGYO>        check(e->base);<KAIGYO>        for (ExprList *it = e->args; it; it = it->next)<KAIGYO>            check(it->expr);<KAIGYO>    }<KAIGYO>    virtual void visitSubscript(Subscript *e) { check(e->base); check(e->index); }<KAIGYO>    virtual void visitMember(Member *e) { check(e->base); }<KAIGYO>    virtual void visitExp(Exp *s) { check(s->expr); }<KAIGYO>    virtual void visitEnter(Enter *s) { check(s->expr); }<KAIGYO>    virtual void visitLeave(Leave *) {}<KAIGYO>    virtual void visitMove(Move *s) { check(s->target); check(s->source); }<KAIGYO>    virtual void visitJump(Jump *) {}<KAIGYO>    virtual void visitCJump(CJump *s) { check(s->cond); }<KAIGYO>    virtual void visitRet(Ret *s) { check(s->expr); }<KAIGYO>    virtual void visitTry(Try *) {}<KAIGYO>    virtual void visitPhi(Phi *s) {<KAIGYO>        for (int i = 0, ei = s->incoming.size(); i != ei; ++i)<KAIGYO>            check(s->incoming[i]);<KAIGYO>    }<KAIGYO><KAIGYO>private:<KAIGYO>    void check(Expr *&e) {<KAIGYO>        if (equals(e, _toReplace))<KAIGYO>            // TODO: clone the replacement!<KAIGYO>            e = _replacement;<KAIGYO>        else<KAIGYO>            e->accept(this);<KAIGYO>    }<KAIGYO><KAIGYO>    // This only calculates equality for everything needed by constant propagation<KAIGYO>    bool equals(Expr *e1, Expr *e2) const {<KAIGYO>        if (e1 == e2)<KAIGYO>            return true;<KAIGYO><KAIGYO>        if (Const *c1 = e1->asConst()) {<KAIGYO>            if (Const *c2 = e2->asConst())<KAIGYO>                return c1->value == c2->value && (c1->type == c2->type || (c1->type & NumberType && c2->type & NumberType));<KAIGYO>        } else if (Temp *t1 = e1->asTemp()) {<KAIGYO>            if (Temp *t2 = e2->asTemp())<KAIGYO>                return t1->index == t2->index;<KAIGYO>        } else if (Name *n1 = e1->asName()) {<KAIGYO>            if (Name *n2 = e2->asName()) {<KAIGYO>                if (n1->id) {<KAIGYO>                    if (n2->id)<KAIGYO>                        return *n1->id == *n2->id;<KAIGYO>                } else {<KAIGYO>                    return n1->builtin == n2->builtin;<KAIGYO>                }<KAIGYO>            }<KAIGYO>        }<KAIGYO><KAIGYO>        return false;<KAIGYO>    }<KAIGYO>};<KAIGYO><KAIGYO>void optimizeSSA(Function *function, DefUsesCalculator &defUses)<KAIGYO>{<KAIGYO>    // FIXME: if an assignment to a local occurs that can escape through closures, it cannot be optimised out.<KAIGYO><KAIGYO>    QHash<Stmt*,Stmt**> ref;<KAIGYO>    QVector<Stmt *> W;<KAIGYO>    foreach (BasicBlock *bb, function->basicBlocks) {<KAIGYO>        for (int i = 0, ei = bb->statements.size(); i != ei; ++i) {<KAIGYO>            Stmt **s = &bb->statements[i];<KAIGYO>            W.append(*s);<KAIGYO>            ref.insert(*s, s);<KAIGYO>        }<KAIGYO>    }<KAIGYO><KAIGYO>    ExprReplacer replaceUses(defUses);<KAIGYO><KAIGYO>    while (!W.isEmpty()) {<KAIGYO>        Stmt *s = W.last();<KAIGYO>        W.removeLast();<KAIGYO><KAIGYO>        if (Phi *phi = s->asPhi()) {<KAIGYO>            // constant propagation:<KAIGYO>            if (Const *c = isConstPhi(phi)) {<KAIGYO>                W += replaceUses(phi->targetTemp, c);<KAIGYO>                defUses.removeDef(phi->targetTemp->index);<KAIGYO>                *ref[s] = 0;<KAIGYO>                continue;<KAIGYO>            }<KAIGYO><KAIGYO>            // copy propagation:<KAIGYO>            if (phi->incoming.size() == 1) {<KAIGYO>                Temp *t = phi->targetTemp;<KAIGYO>                Expr *e = phi->incoming.first();<KAIGYO><KAIGYO>                QVector<Stmt *> newT2Uses = replaceUses(t, e);<KAIGYO>                W += newT2Uses;<KAIGYO>                if (Temp *t2 = e->asTemp()) {<KAIGYO>                    defUses.removeUse(s, t2->index);<KAIGYO>                    defUses.addUses(t2->index, QList<Stmt*>::fromVector(newT2Uses));<KAIGYO>                }<KAIGYO>                defUses.removeDef(t->index);<KAIGYO>                *ref[s] = 0;<KAIGYO>                continue;<KAIGYO>            }<KAIGYO><KAIGYO>        }<KAIGYO><KAIGYO>        if (Move *m = s->asMove()) {<KAIGYO>            if (Temp *t = m->target->asTemp()) {<KAIGYO>                if (t->index >= 0) {<KAIGYO>                    // constant propagation:<KAIGYO>                    if (Const *c = m->source->asConst()) {<KAIGYO>//                        qout<<""""<<endl;<KAIGYO>                        W += replaceUses(t, c);<KAIGYO>                        defUses.removeDef(t->index);<KAIGYO>                        *ref[s] = 0;<KAIGYO>                        continue;<KAIGYO>                    }<KAIGYO>#if PROPAGATE_THIS<KAIGYO>                    if (Name *n = m->source->asName()) {<KAIGYO>                        qout<<""""<<endl;<KAIGYO>                        W += replaceUses(t, n);<KAIGYO>                        defUses.removeDef(t->index);<KAIGYO>                        *ref[s] = 0;<KAIGYO>                        continue;<KAIGYO>                    }<KAIGYO>#endif<KAIGYO>                    // copy propagation:<KAIGYO>                    if (Temp *t2 = m->source->asTemp()) {<KAIGYO>                        QVector<Stmt *> newT2Uses = replaceUses(t, t2);<KAIGYO>                        W += newT2Uses;<KAIGYO>                        defUses.removeUse(s, t2->index);<KAIGYO>                        defUses.addUses(t2->index, QList<Stmt*>::fromVector(newT2Uses));<KAIGYO>                        defUses.removeDef(t->index);<KAIGYO>                        *ref[s] = 0;<KAIGYO>                        continue;<KAIGYO>                    }<KAIGYO>                }<KAIGYO>            }<KAIGYO>        }<KAIGYO>    }<KAIGYO><KAIGYO>    foreach (BasicBlock *bb, function->basicBlocks) {<KAIGYO>        for (int i = 0; i < bb->statements.size();) {<KAIGYO>            if (bb->statements[i])<KAIGYO>                ++i;<KAIGYO>            else<KAIGYO>                bb->statements.remove(i);<KAIGYO>        }<KAIGYO>    }<KAIGYO>}<KAIGYO><KAIGYO>class TypeInference: public StmtVisitor, public ExprVisitor {<KAIGYO>    const DefUsesCalculator &_defUses;<KAIGYO>    QHash<int, int> _tempTypes;<KAIGYO>    QSet<Stmt *> _worklist;<KAIGYO>    struct TypingResult {<KAIGYO>        int type;<KAIGYO>        bool fullyTyped;<KAIGYO><KAIGYO>        TypingResult(int type, bool fullyTyped): type(type), fullyTyped(fullyTyped) {}<KAIGYO>        explicit TypingResult(int type = UnknownType): type(type), fullyTyped(type != UnknownType) {}<KAIGYO>    };<KAIGYO>    TypingResult _ty;<KAIGYO>    int _localCount;<KAIGYO><KAIGYO>public:<KAIGYO>    TypeInference(const DefUsesCalculator &defUses): _defUses(defUses), _ty(UnknownType) {}<KAIGYO><KAIGYO>    void run(Function *function) {<KAIGYO>        _localCount = function->variablesCanEscape() ? function->locals.size() : 0;<KAIGYO><KAIGYO>        // TODO: the worklist handling looks a bit inefficient... check if there is something better<KAIGYO>        _worklist.clear();<KAIGYO>        for (int i = 0, ei = function->basicBlocks.size(); i != ei; ++i) {<KAIGYO>            BasicBlock *bb = function->basicBlocks[i];<KAIGYO>            if (i == 0 || !bb->in.isEmpty())<KAIGYO>                foreach (Stmt *s, bb->statements)<KAIGYO>                    _worklist.insert(s);<KAIGYO>        }<KAIGYO><KAIGYO>        while (!_worklist.isEmpty()) {<KAIGYO>            QList<Stmt *> worklist = _worklist.values();<KAIGYO>            _worklist.clear();<KAIGYO>            while (!worklist.isEmpty()) {<KAIGYO>                Stmt *s = worklist.first();<KAIGYO>                worklist.removeFirst();<KAIGYO>#if defined(SHOW_SSA)<KAIGYO>                qout<<"""";s->dump(qout);qout<<endl;<KAIGYO>#endif<KAIGYO><KAIGYO>                if (!run(s)) {<KAIGYO>                    _worklist.insert(s);<KAIGYO>#if defined(SHOW_SSA)<KAIGYO>                    qout<<"""";<KAIGYO>                    s->dump(qout);qout<<endl;<KAIGYO>                } else {<KAIGYO>                    qout<<"""";<KAIGYO>                    s->dump(qout);qout<<endl;<KAIGYO>#endif<KAIGYO>                }<KAIGYO>            }<KAIGYO>        }<KAIGYO>    }<KAIGYO><KAIGYO>private:<KAIGYO>    bool run(Stmt *s) {<KAIGYO>        TypingResult ty;<KAIGYO>        std::swap(_ty, ty);<KAIGYO>        s->accept(this);<KAIGYO>        std::swap(_ty, ty);<KAIGYO>        return ty.fullyTyped;<KAIGYO>    }<KAIGYO><KAIGYO>    TypingResult run(Expr *e) {<KAIGYO>        TypingResult ty;<KAIGYO>        std::swap(_ty, ty);<KAIGYO>        e->accept(this);<KAIGYO>        std::swap(_ty, ty);<KAIGYO><KAIGYO>        if (ty.type != UnknownType)<KAIGYO>            setType(e, ty.type);<KAIGYO>        return ty;<KAIGYO>    }<KAIGYO><KAIGYO>    void setType(Expr *e, int ty) {<KAIGYO>        if (Temp *t = e->asTemp()) {<KAIGYO>            if (t->scope || t->index < _localCount)<KAIGYO>                ty = ObjectType;<KAIGYO>            e->type = (Type) ty;<KAIGYO><KAIGYO>            if (_tempTypes[t->index] != ty) {<KAIGYO>                _tempTypes[t->index] = ty;<KAIGYO><KAIGYO>#if defined(SHOW_SSA)<KAIGYO>                qout<<"""" << endl;<KAIGYO>                foreach (Stmt *s, _defUses.uses(t->index)) {<KAIGYO>                    qout << """";<KAIGYO>                    s->dump(qout);<KAIGYO>                    qout << endl;<KAIGYO>                }<KAIGYO>#endif<KAIGYO><KAIGYO>                _worklist += QSet<Stmt *>::fromList(_defUses.uses(t->index));<KAIGYO>            }<KAIGYO>        } else {<KAIGYO>            e->type = (Type) ty;<KAIGYO>        }<KAIGYO>    }<KAIGYO><KAIGYO>protected:<KAIGYO>    virtual void visitConst(Const *e) { _ty = TypingResult(e->type); }<KAIGYO>    virtual void visitString(String *) { _ty = TypingResult(StringType); }<KAIGYO>    virtual void visitRegExp(RegExp *) { _ty = TypingResult(ObjectType); }<KAIGYO>    virtual void visitName(Name *) { _ty = TypingResult(ObjectType); }<KAIGYO>    virtual void visitTemp(Temp *e) {<KAIGYO>        if (e->scope)<KAIGYO>            _ty = TypingResult(ObjectType);<KAIGYO>        else if (e->index < _localCount)<KAIGYO>            _ty = TypingResult(ObjectType);<KAIGYO>        else<KAIGYO>            _ty = TypingResult(_tempTypes.value(e->index, UnknownType));<KAIGYO>        setType(e, _ty.type);<KAIGYO>    }<KAIGYO>    virtual void visitClosure(Closure *) { _ty = TypingResult(ObjectType); } // TODO: VERIFY THIS!<KAIGYO>    virtual void visitUnop(Unop *e) {<KAIGYO>        _ty = run(e->expr);<KAIGYO>        switch (e->op) {<KAIGYO>        case OpUPlus: _ty.type = DoubleType; return;<KAIGYO>        case OpUMinus: _ty.type = DoubleType; return;<KAIGYO>        case OpCompl: _ty.type = SInt32Type; return;<KAIGYO>        case OpNot: _ty.type = BoolType; return;<KAIGYO><KAIGYO>        case OpIncrement:<KAIGYO>        case OpDecrement:<KAIGYO>            Q_ASSERT(!"""");<KAIGYO>        default:<KAIGYO>            Q_UNIMPLEMENTED();<KAIGYO>            Q_UNREACHABLE();<KAIGYO>        }<KAIGYO>    }<KAIGYO><KAIGYO>    virtual void visitBinop(Binop *e) {<KAIGYO>        TypingResult leftTy = run(e->left);<KAIGYO>        TypingResult rightTy = run(e->right);<KAIGYO>        _ty.fullyTyped = leftTy.fullyTyped && rightTy.fullyTyped;<KAIGYO><KAIGYO>        switch (e->op) {<KAIGYO>        case OpAdd:<KAIGYO>            if (leftTy.type & StringType || rightTy.type & StringType)<KAIGYO>                _ty.type = StringType;<KAIGYO>            else if (leftTy.type != UnknownType && rightTy.type != UnknownType)<KAIGYO>                _ty.type = DoubleType;<KAIGYO>            else<KAIGYO>                _ty.type = UnknownType;<KAIGYO>            break;<KAIGYO>        case OpSub:<KAIGYO>            _ty.type = DoubleType;<KAIGYO>            break;<KAIGYO><KAIGYO>        case OpMul:<KAIGYO>        case OpDiv:<KAIGYO>        case OpMod:<KAIGYO>            _ty.type = DoubleType;<KAIGYO>            break;<KAIGYO><KAIGYO>        case OpBitAnd:<KAIGYO>        case OpBitOr:<KAIGYO>        case OpBitXor:<KAIGYO>        case OpLShift:<KAIGYO>        case OpRShift:<KAIGYO>            _ty.type = SInt32Type;<KAIGYO>            break;<KAIGYO>        case OpURShift:<KAIGYO>            _ty.type = UInt32Type;<KAIGYO>            break;<KAIGYO><KAIGYO>        case OpGt:<KAIGYO>        case OpLt:<KAIGYO>        case OpGe:<KAIGYO>        case OpLe:<KAIGYO>        case OpEqual:<KAIGYO>        case OpNotEqual:<KAIGYO>        case OpStrictEqual:<KAIGYO>        case OpStrictNotEqual:<KAIGYO>        case OpAnd:<KAIGYO>        case OpOr:<KAIGYO>        case OpInstanceof:<KAIGYO>        case OpIn:<KAIGYO>            _ty.type = BoolType;<KAIGYO>            break;<KAIGYO><KAIGYO>        default:<KAIGYO>            Q_UNIMPLEMENTED();<KAIGYO>            Q_UNREACHABLE();<KAIGYO>        }<KAIGYO>    }<KAIGYO><KAIGYO>    virtual void visitCall(Call *e) {<KAIGYO>        _ty = run(e->base);<KAIGYO>        for (ExprList *it = e->args; it; it = it->next)<KAIGYO>            _ty.fullyTyped &= run(it->expr).fullyTyped;<KAIGYO>        _ty.type = ObjectType;<KAIGYO>    }<KAIGYO>    virtual void visitNew(New *e) {<KAIGYO>        _ty = run(e->base);<KAIGYO>        for (ExprList *it = e->args; it; it = it->next)<KAIGYO>            _ty.fullyTyped &= run(it->expr).fullyTyped;<KAIGYO>        _ty.type = ObjectType;<KAIGYO>    }<KAIGYO>    virtual void visitSubscript(Subscript *e) {<KAIGYO>        _ty.fullyTyped = run(e->base).fullyTyped && run(e->index).fullyTyped;<KAIGYO>        _ty.type = ObjectType;<KAIGYO>    }<KAIGYO><KAIGYO>    virtual void visitMember(Member *e) {<KAIGYO>        // TODO: for QML, try to do a static lookup<KAIGYO>        _ty = run(e->base);<KAIGYO>        _ty.type = ObjectType;<KAIGYO>    }<KAIGYO><KAIGYO>    virtual void visitExp(Exp *s) { _ty = run(s->expr); }<KAIGYO>    virtual void visitEnter(Enter *s) { _ty = run(s->expr); }<KAIGYO>    virtual void visitLeave(Leave *) { _ty = TypingResult(MissingType); }<KAIGYO>    virtual void visitMove(Move *s) {<KAIGYO>        TypingResult sourceTy = run(s->source);<KAIGYO>        Q_ASSERT(s->op == OpInvalid);<KAIGYO>        if (Temp *t = s->target->asTemp()) {<KAIGYO>            setType(t, sourceTy.type);<KAIGYO>            _ty = sourceTy;<KAIGYO>            return;<KAIGYO>        }<KAIGYO><KAIGYO>        _ty = run(s->target);<KAIGYO>        _ty.fullyTyped &= sourceTy.fullyTyped;<KAIGYO>    }<KAIGYO><KAIGYO>    virtual void visitJump(Jump *) { _ty = TypingResult(MissingType); }<KAIGYO>    virtual void visitCJump(CJump *s) { _ty = run(s->cond); }<KAIGYO>    virtual void visitRet(Ret *s) { _ty = run(s->expr); }<KAIGYO>    virtual void visitTry(Try *s) { setType(s->exceptionVar, ObjectType); _ty = TypingResult(MissingType); }<KAIGYO>    virtual void visitPhi(Phi *s) {<KAIGYO>        _ty = run(s->incoming[0]);<KAIGYO>        for (int i = 1, ei = s->incoming.size(); i != ei; ++i) {<KAIGYO>            TypingResult ty = run(s->incoming[i]);<KAIGYO>            _ty.type |= ty.type;<KAIGYO>            _ty.fullyTyped &= ty.fullyTyped;<KAIGYO>        }<KAIGYO><KAIGYO>        // TODO: check & double check the next condition!<KAIGYO>        if (_ty.type & ObjectType || _ty.type & UndefinedType || _ty.type & NullType)<KAIGYO>            _ty.type = ObjectType;<KAIGYO>        else if (_ty.type & NumberType)<KAIGYO>            _ty.type = DoubleType;<KAIGYO><KAIGYO>        setType(s->targetTemp, _ty.type);<KAIGYO>    }<KAIGYO>};<KAIGYO><KAIGYO>class TypePropagation: public StmtVisitor, public ExprVisitor {<KAIGYO>    Type _ty;<KAIGYO><KAIGYO>    void run(Expr *e, Type requestedType = UnknownType) {<KAIGYO>        qSwap(_ty, requestedType);<KAIGYO>        e->accept(this);<KAIGYO>        qSwap(_ty, requestedType);<KAIGYO>    }<KAIGYO><KAIGYO>public:<KAIGYO>    TypePropagation() : _ty(UnknownType) {}<KAIGYO><KAIGYO>    void run(Function *f) {<KAIGYO>        foreach (BasicBlock *bb, f->basicBlocks)<KAIGYO>            foreach (Stmt *s, bb->statements)<KAIGYO>                s->accept(this);<KAIGYO>    }<KAIGYO><KAIGYO>protected:<KAIGYO>    virtual void visitConst(Const *c) {<KAIGYO>        if (_ty & NumberType && c->type & NumberType) {<KAIGYO>            c->type = _ty;<KAIGYO>        }<KAIGYO>    }<KAIGYO><KAIGYO>    virtual void visitString(String *) {}<KAIGYO>    virtual void visitRegExp(RegExp *) {}<KAIGYO>    virtual void visitName(Name *) {}<KAIGYO>    virtual void visitTemp(Temp *) {}<KAIGYO>    virtual void visitClosure(Closure *) {}<KAIGYO>    virtual void visitUnop(Unop *e) { run(e->expr, e->type); }<KAIGYO>    virtual void visitBinop(Binop *e) { run(e->left, e->type); run(e->right, e->type); }<KAIGYO>    virtual void visitCall(Call *e) {<KAIGYO>        run(e->base);<KAIGYO>        for (ExprList *it = e->args; it; it = it->next)<KAIGYO>            run(it->expr);<KAIGYO>    }<KAIGYO>    virtual void visitNew(New *e) {<KAIGYO>        run(e->base);<KAIGYO>        for (ExprList *it = e->args; it; it = it->next)<KAIGYO>            run(it->expr);<KAIGYO>    }<KAIGYO>    virtual void visitSubscript(Subscript *e) { run(e->base); run(e->index); }<KAIGYO>    virtual void visitMember(Member *e) { run(e->base); }<KAIGYO>    virtual void visitExp(Exp *s) { run(s->expr); }<KAIGYO>    virtual void visitEnter(Enter *s) { run(s->expr); }<KAIGYO>    virtual void visitLeave(Leave *) {}<KAIGYO>    virtual void visitMove(Move *s) {<KAIGYO>        run(s->target);<KAIGYO>        run(s->source, s->target->type);<KAIGYO>    }<KAIGYO>    virtual void visitJump(Jump *) {}<KAIGYO>    virtual void visitCJump(CJump *s) {<KAIGYO>        run(s->cond, BoolType);<KAIGYO>    }<KAIGYO>    virtual void visitRet(Ret *s) { run(s->expr); }<KAIGYO>    virtual void visitTry(Try *) {}<KAIGYO>    virtual void visitPhi(Phi *s) {<KAIGYO>        Type ty = s->targetTemp->type;<KAIGYO>        foreach (Expr *e, s->incoming)<KAIGYO>            run(e, ty);<KAIGYO>    }<KAIGYO>};<KAIGYO><KAIGYO>void insertMove(Function *function, BasicBlock *basicBlock, Temp *target, Expr *source) {<KAIGYO>    Move *s = function->New<Move>();<KAIGYO>    s->init(target, source, OpInvalid);<KAIGYO>    basicBlock->statements.insert(basicBlock->statements.size() - 1, s);<KAIGYO>}<KAIGYO><KAIGYO>bool doEdgeSplitting(Function *f)<KAIGYO>{<KAIGYO>    const QVector<BasicBlock *> oldBBs = f->basicBlocks;<KAIGYO><KAIGYO>    foreach (BasicBlock *bb, oldBBs) {<KAIGYO>        if (bb->in.size() > 1) {<KAIGYO>            for (int inIdx = 0, eInIdx = bb->in.size(); inIdx != eInIdx; ++inIdx) {<KAIGYO>                BasicBlock *inBB = bb->in[inIdx];<KAIGYO>                if (inBB->out.size() > 1) { // this should have been split!<KAIGYO>#if defined(SHOW_SSA)<KAIGYO>                    qDebug() << """" << bb->index;<KAIGYO>#endif<KAIGYO><KAIGYO>                    // create the basic block:<KAIGYO>                    BasicBlock *newBB = new BasicBlock(f);<KAIGYO>                    newBB->index = f->basicBlocks.last()->index + 1;<KAIGYO>                    f->basicBlocks.append(newBB);<KAIGYO>                    Jump *s = f->New<Jump>();<KAIGYO>                    s->init(bb);<KAIGYO>                    newBB->statements.append(s);<KAIGYO><KAIGYO>                    // rewire the old outgoing edge<KAIGYO>                    int outIdx = inBB->out.indexOf(bb);<KAIGYO>                    inBB->out[outIdx] = newBB;<KAIGYO>                    newBB->in.append(inBB);<KAIGYO><KAIGYO>                    // rewire the old incoming edge<KAIGYO>                    bb->in[inIdx] = newBB;<KAIGYO>                    newBB->out.append(bb);<KAIGYO><KAIGYO>                    // patch the terminator<KAIGYO>                    Stmt *terminator = inBB->terminator();<KAIGYO>                    if (Jump *j = terminator->asJump()) {<KAIGYO>                        Q_ASSERT(outIdx == 0);<KAIGYO>                        j->target = newBB;<KAIGYO>                    } else if (CJump *j = terminator->asCJump()) {<KAIGYO>                        if (outIdx == 0)<KAIGYO>                            j->iftrue = newBB;<KAIGYO>                        else if (outIdx == 1)<KAIGYO>                            j->iffalse = newBB;<KAIGYO>                        else<KAIGYO>                            Q_ASSERT(!"""");<KAIGYO>                    } else {<KAIGYO>                        Q_ASSERT(!"""");<KAIGYO>                    }<KAIGYO>                }<KAIGYO>            }<KAIGYO>        }<KAIGYO>    }<KAIGYO>}<KAIGYO><KAIGYO>void scheduleBlocks(QVector<BasicBlock *> &basicBlocks)<KAIGYO>{<KAIGYO>    // FIXME: this should not do DFS scheduling.<KAIGYO>    struct I {<KAIGYO>        QSet<BasicBlock *> visited;<KAIGYO>        QVector<BasicBlock *> &sequence;<KAIGYO><KAIGYO>        I(QVector<BasicBlock *> &sequence): sequence(sequence) {}<KAIGYO><KAIGYO>        void DFS(BasicBlock *bb) {<KAIGYO>            if (visited.contains(bb))<KAIGYO>                return;<KAIGYO>            visited.insert(bb);<KAIGYO>            sequence.append(bb);<KAIGYO>            if (Stmt *terminator = bb->terminator()) {<KAIGYO>                if (Jump *j = terminator->asJump()) {<KAIGYO>                    Q_ASSERT(bb->out.size() == 1);<KAIGYO>                    DFS(j->target);<KAIGYO>                } else if (CJump *cj = terminator->asCJump()) {<KAIGYO>                    Q_ASSERT(bb->out.size() == 2);<KAIGYO>                    DFS(cj->iftrue);<KAIGYO>                    DFS(cj->iffalse);<KAIGYO>                } else if (terminator->asRet()) {<KAIGYO>                    Q_ASSERT(bb->out.size() == 0);<KAIGYO>                    // nothing to do.<KAIGYO>                } else {<KAIGYO>                    Q_UNREACHABLE();<KAIGYO>                }<KAIGYO>            } else {<KAIGYO>                Q_UNREACHABLE();<KAIGYO>            }<KAIGYO>        }<KAIGYO>    };<KAIGYO><KAIGYO>    QVector<BasicBlock *> sequence;<KAIGYO>    sequence.reserve(basicBlocks.size());<KAIGYO>    I(sequence).DFS(basicBlocks.first());<KAIGYO>    qSwap(basicBlocks, sequence);<KAIGYO>}<KAIGYO><KAIGYO>/*<KAIGYO> * Quick function to convert out of SSA, so we can put the stuff through the ISel phases. This<KAIGYO> * has to be replaced by a phase in the specific ISel back-ends and do register allocation at the<KAIGYO> * same time. That way the huge number of redundant moves generated by this function are eliminated.<KAIGYO> */': 6, '// TODO: merge 2 basic blocks A and B if A has one outgoing edge (to B), B has one incoming<KAIGYO>// edge (from A), but not when A has more than 1 incoming edge and B has more than one<KAIGYO>// outgoing edge.': 6, '// TODO: remove blocks that only have a JUMP statement, and re-wire their predecessor/successor.': 6, '//    if (current->index + 1 != target->index)<KAIGYO>// FIXME: the previous condition is wrong, but now we get a whole lot of unneeded jumps.<KAIGYO>// TODO: test with ch10/10.4/10.4.3/10.4.3-1-103': 7, '            if (n && s->asCJump() /*&& s->asCJump()->iffalse != leader.value(n)*/) {<KAIGYO>                qout << """" << endl;<KAIGYO>            }<KAIGYO>        }<KAIGYO><KAIGYO>        qout << """" << endl<KAIGYO>             << endl;<KAIGYO>    }<KAIGYO>}<KAIGYO><KAIGYO>using namespace V4IR;<KAIGYO><KAIGYO>/*<KAIGYO> * Do edge-splitting for basic-blocks.<KAIGYO> *<KAIGYO> * If there is an edge between a basic block with multiple outgoing edges pointing to a block with<KAIGYO> * multiple incoming edges, then split that edge and insert an empty basic block in between. This is<KAIGYO> * used, for example, when converting out of SSA form where the phi functions are converted into<KAIGYO> * move operations that get inserted at the block from where the edge came in.<KAIGYO> *<KAIGYO> * TODO: check if we need this when register allocation when transforming out of SSA.<KAIGYO> */': 7, '    virtual void visitTry(Try *s) { /* this should never happen */ }<KAIGYO><KAIGYO>    virtual void visitConst(Const *) {}<KAIGYO>    virtual void visitString(String *) {}<KAIGYO>    virtual void visitRegExp(RegExp *) {}<KAIGYO>    virtual void visitName(Name *) {}<KAIGYO>    virtual void visitClosure(Closure *) {}<KAIGYO>    virtual void visitUnop(Unop *e) { e->expr->accept(this); }<KAIGYO>    virtual void visitBinop(Binop *e) { e->left->accept(this); e->right->accept(this); }<KAIGYO>    virtual void visitCall(Call *e) {<KAIGYO>        e->base->accept(this);<KAIGYO>        for (ExprList *it = e->args; it; it = it->next)<KAIGYO>            it->expr->accept(this);<KAIGYO>    }<KAIGYO><KAIGYO>    virtual void visitNew(New *e) {<KAIGYO>        e->base->accept(this);<KAIGYO>        for (ExprList *it = e->args; it; it = it->next)<KAIGYO>            it->expr->accept(this);<KAIGYO>    }<KAIGYO><KAIGYO>    virtual void visitSubscript(Subscript *e) {<KAIGYO>        e->base->accept(this);<KAIGYO>        e->index->accept(this);<KAIGYO>    }<KAIGYO><KAIGYO>    virtual void visitMember(Member *e) {<KAIGYO>        e->base->accept(this);<KAIGYO>    }<KAIGYO>};<KAIGYO><KAIGYO>QHash<int, int> convertToSSA(Function *function)<KAIGYO>{<KAIGYO>#ifdef SHOW_SSA<KAIGYO>    qout << """";<KAIGYO>    if (function->name)<KAIGYO>        qout << *function->name;<KAIGYO>    else<KAIGYO>        qout << """";<KAIGYO>    qout << """" << endl;<KAIGYO>#endif // SHOW_SSA<KAIGYO><KAIGYO>    QVector<BasicBlock *> &nodes = function->basicBlocks;<KAIGYO><KAIGYO>    // Calculate the dominator tree:<KAIGYO>    DominatorTree df(nodes);<KAIGYO><KAIGYO>    // Collect all applicable variables:<KAIGYO>    VariableCollector variables(function);<KAIGYO><KAIGYO>    // Place phi functions:<KAIGYO>    QHash<BasicBlock *, QSet<int> > A_phi;<KAIGYO>    foreach (int a, variables.vars()) {<KAIGYO>        if (!variables.isNonLocal(a))<KAIGYO>            continue; // for semi-pruned SSA<KAIGYO><KAIGYO>        QList<BasicBlock *> W = QList<BasicBlock *>::fromSet(variables.defsite(a));<KAIGYO>        while (!W.isEmpty()) {<KAIGYO>            BasicBlock *n = W.first();<KAIGYO>            W.removeFirst();<KAIGYO>            foreach (BasicBlock *y, df[n]) {<KAIGYO>                if (!A_phi[y].contains(a)) {<KAIGYO>                    insertPhiNode(a, y, function);<KAIGYO>                    A_phi[y].insert(a);<KAIGYO>                    if (!variables.inBlock(y).contains(a))<KAIGYO>                        W.append(y);<KAIGYO>                }<KAIGYO>            }<KAIGYO>        }<KAIGYO>    }<KAIGYO><KAIGYO>    // Rename variables:<KAIGYO>    return VariableRenamer(function).run();<KAIGYO>}<KAIGYO><KAIGYO>class DefUsesCalculator: public StmtVisitor, public ExprVisitor {<KAIGYO>public:<KAIGYO>    struct DefUse {<KAIGYO>        Stmt *defStmt;<KAIGYO>        BasicBlock *blockOfStatement;<KAIGYO>        QList<Stmt *> uses;<KAIGYO>    };<KAIGYO><KAIGYO>private:<KAIGYO>    QHash<int, DefUse> _defUses;<KAIGYO>    QHash<Stmt *, QList<int> > _usesPerStatement;<KAIGYO><KAIGYO>    BasicBlock *_block;<KAIGYO>    Stmt *_stmt;<KAIGYO><KAIGYO>    void addUse(Temp *t) {<KAIGYO>        Q_ASSERT(t);<KAIGYO><KAIGYO>        _defUses[t->index].uses.append(_stmt);<KAIGYO>        _usesPerStatement[_stmt].append(t->index);<KAIGYO>    }<KAIGYO><KAIGYO>    void addDef(Temp *t) {<KAIGYO>        DefUse &defUse = _defUses[t->index];<KAIGYO>        defUse.defStmt = _stmt;<KAIGYO>        defUse.blockOfStatement = _block;<KAIGYO>    }<KAIGYO><KAIGYO>public:<KAIGYO>    DefUsesCalculator(const QVector<BasicBlock *> &bbs) {<KAIGYO>        foreach (BasicBlock *bb, bbs) {<KAIGYO>            _block = bb;<KAIGYO>            foreach (Stmt *stmt, bb->statements) {<KAIGYO>                _stmt = stmt;<KAIGYO>                stmt->accept(this);<KAIGYO>            }<KAIGYO>        }<KAIGYO><KAIGYO>        QMutableHashIterator<int, DefUse> it(_defUses);<KAIGYO>        while (it.hasNext()) {<KAIGYO>            it.next();<KAIGYO>            if (!it.value().defStmt)<KAIGYO>                it.remove();<KAIGYO>        }<KAIGYO>    }<KAIGYO><KAIGYO>    QList<int> defs() const {<KAIGYO>        return _defUses.keys();<KAIGYO>    }<KAIGYO><KAIGYO>    void removeDef(int var) {<KAIGYO>        _defUses.remove(var);<KAIGYO>    }<KAIGYO><KAIGYO>    void addUses(int variable, QList<Stmt *>newUses)<KAIGYO>    { _defUses[variable].uses.append(newUses); }<KAIGYO><KAIGYO>    int useCount(int variable) const<KAIGYO>    { return _defUses[variable].uses.size(); }<KAIGYO><KAIGYO>    Stmt *defStmt(int variable) const<KAIGYO>    { return _defUses[variable].defStmt; }<KAIGYO><KAIGYO>    BasicBlock *defStmtBlock(int variable) const<KAIGYO>    { return _defUses[variable].blockOfStatement; }<KAIGYO><KAIGYO>    void removeUse(Stmt *usingStmt, int var)<KAIGYO>    { _defUses[var].uses.removeAll(usingStmt); }<KAIGYO><KAIGYO>    QList<int> usedVars(Stmt *s) const<KAIGYO>    { return _usesPerStatement[s]; }<KAIGYO><KAIGYO>    QList<Stmt *> uses(int var) const<KAIGYO>    { return _defUses[var].uses; }<KAIGYO><KAIGYO>    void dump() const<KAIGYO>    {<KAIGYO>        foreach (int var, _defUses.keys()) {<KAIGYO>            const DefUse &du = _defUses[var];<KAIGYO>            qout<<var<<"""";<KAIGYO>            du.defStmt->dump(qout);<KAIGYO>            qout<<endl<<""""<<endl;<KAIGYO>            foreach (Stmt *s, du.uses) {<KAIGYO>                qout<<"""";s->dump(qout);qout<<endl;<KAIGYO>            }<KAIGYO>        }<KAIGYO>    }<KAIGYO><KAIGYO>protected:<KAIGYO>    virtual void visitExp(Exp *s) { s->expr->accept(this); }<KAIGYO>    virtual void visitEnter(Enter *) {}<KAIGYO>    virtual void visitLeave(Leave *) {}<KAIGYO>    virtual void visitJump(Jump *) {}<KAIGYO>    virtual void visitCJump(CJump *s) { s->cond->accept(this); }<KAIGYO>    virtual void visitRet(Ret *s) { s->expr->accept(this); }<KAIGYO>    virtual void visitTry(Try *) {}<KAIGYO><KAIGYO>    virtual void visitPhi(Phi *s) {<KAIGYO>        addDef(s->targetTemp);<KAIGYO>        foreach (Expr *e, s->incoming)<KAIGYO>            addUse(e->asTemp());<KAIGYO>    }<KAIGYO><KAIGYO>    virtual void visitMove(Move *s) {<KAIGYO>        if (Temp *t = s->target->asTemp())<KAIGYO>            addDef(t);<KAIGYO>        else<KAIGYO>            s->target->accept(this);<KAIGYO><KAIGYO>        s->source->accept(this);<KAIGYO>    }<KAIGYO><KAIGYO>    virtual void visitTemp(Temp *e) { addUse(e); }<KAIGYO><KAIGYO>    virtual void visitConst(Const *) {}<KAIGYO>    virtual void visitString(String *) {}<KAIGYO>    virtual void visitRegExp(RegExp *) {}<KAIGYO>    virtual void visitName(Name *) {}<KAIGYO>    virtual void visitClosure(Closure *) {}<KAIGYO>    virtual void visitUnop(Unop *e) { e->expr->accept(this); }<KAIGYO>    virtual void visitBinop(Binop *e) { e->left->accept(this); e->right->accept(this); }<KAIGYO>    virtual void visitSubscript(Subscript *e) { e->base->accept(this); e->index->accept(this); }<KAIGYO>    virtual void visitMember(Member *e) { e->base->accept(this); }<KAIGYO>    virtual void visitCall(Call *e) {<KAIGYO>        e->base->accept(this);<KAIGYO>        for (ExprList *it = e->args; it; it = it->next)<KAIGYO>            it->expr->accept(this);<KAIGYO>    }<KAIGYO><KAIGYO>    virtual void visitNew(New *e) {<KAIGYO>        e->base->accept(this);<KAIGYO>        for (ExprList *it = e->args; it; it = it->next)<KAIGYO>            it->expr->accept(this);<KAIGYO>    }<KAIGYO>};<KAIGYO><KAIGYO>bool hasPhiOnlyUses(Phi *phi, const DefUsesCalculator &defUses, QSet<Phi *> &collectedPhis)<KAIGYO>{<KAIGYO>    collectedPhis.insert(phi);<KAIGYO>    foreach (Stmt *use, defUses.uses(phi->targetTemp->index)) {<KAIGYO>        if (Phi *dependentPhi = use->asPhi()) {<KAIGYO>            if (!collectedPhis.contains(dependentPhi)) {<KAIGYO>                if (!hasPhiOnlyUses(dependentPhi, defUses, collectedPhis))<KAIGYO>                    return false;<KAIGYO>            }<KAIGYO>        } else {<KAIGYO>            return false;<KAIGYO>        }<KAIGYO>    }<KAIGYO>    return true;<KAIGYO>}<KAIGYO><KAIGYO>void cleanupPhis(DefUsesCalculator &defUses)<KAIGYO>{<KAIGYO>    QLinkedList<Phi *> phis;<KAIGYO>    foreach (int def, defUses.defs())<KAIGYO>        if (Phi *phi = defUses.defStmt(def)->asPhi())<KAIGYO>            phis.append(phi);<KAIGYO><KAIGYO>    QSet<Phi *> toRemove;<KAIGYO>    while (!phis.isEmpty()) {<KAIGYO>        Phi *phi = phis.first();<KAIGYO>        phis.removeFirst();<KAIGYO>        if (toRemove.contains(phi))<KAIGYO>            continue;<KAIGYO>        QSet<Phi *> collectedPhis;<KAIGYO>        if (hasPhiOnlyUses(phi, defUses, collectedPhis))<KAIGYO>            toRemove.unite(collectedPhis);<KAIGYO>    }<KAIGYO><KAIGYO>    foreach (Phi *phi, toRemove) {<KAIGYO>        int targetVar = phi->targetTemp->index;<KAIGYO><KAIGYO>        BasicBlock *bb = defUses.defStmtBlock(targetVar);<KAIGYO>        int idx = bb->statements.indexOf(phi);<KAIGYO>        bb->statements.remove(idx);<KAIGYO><KAIGYO>        foreach (int usedVar, defUses.usedVars(phi))<KAIGYO>            defUses.removeUse(phi, usedVar);<KAIGYO>        defUses.removeDef(targetVar);<KAIGYO>    }<KAIGYO>}<KAIGYO><KAIGYO>class DeadCodeElimination: public ExprVisitor {<KAIGYO>    int _lastUncollectible;<KAIGYO>    DefUsesCalculator &_defUses;<KAIGYO>    QVector<int> _worklist;<KAIGYO><KAIGYO>public:<KAIGYO>    DeadCodeElimination(DefUsesCalculator &defUses, Function *function)<KAIGYO>        : _defUses(defUses)<KAIGYO>    {<KAIGYO>        _worklist = QVector<int>::fromList(_defUses.defs());<KAIGYO><KAIGYO>        if (function->variablesCanEscape())<KAIGYO>            _lastUncollectible = function->locals.size() - 1;<KAIGYO>        else<KAIGYO>            _lastUncollectible = -1;<KAIGYO>    }<KAIGYO><KAIGYO>    void run() {<KAIGYO>        while (!_worklist.isEmpty()) {<KAIGYO>            const int v = _worklist.first();<KAIGYO>            _worklist.removeFirst();<KAIGYO><KAIGYO>            if (_defUses.useCount(v) == 0) {<KAIGYO>//                qDebug()<<"""";<KAIGYO>                Stmt *s = _defUses.defStmt(v);<KAIGYO>                if (!s) {<KAIGYO>                    _defUses.removeDef(v);<KAIGYO>                } else if (!hasSideEffect(s)) {<KAIGYO>//                    qDebug()<<"""";<KAIGYO>                    QVector<Stmt *> &stmts = _defUses.defStmtBlock(v)->statements;<KAIGYO>                    int idx = stmts.indexOf(s);<KAIGYO>                    if (idx != -1)<KAIGYO>                        stmts.remove(idx);<KAIGYO>                    foreach (int usedVar, _defUses.usedVars(s)) {<KAIGYO>                        _defUses.removeUse(s, usedVar);<KAIGYO>                        _worklist.append(usedVar);<KAIGYO>                    }<KAIGYO>                    _defUses.removeDef(v);<KAIGYO>                }<KAIGYO>            }<KAIGYO>        }<KAIGYO><KAIGYO>#ifdef SHOW_SSA<KAIGYO>        qout<<"""";<KAIGYO>        _defUses.dump();<KAIGYO>#endif<KAIGYO>    }<KAIGYO><KAIGYO>private:<KAIGYO>    bool _sideEffect;<KAIGYO><KAIGYO>    bool hasSideEffect(Stmt *s) {<KAIGYO>        // TODO: check if this can be moved to IR building.<KAIGYO>        _sideEffect = false;<KAIGYO>        if (Move *move = s->asMove()) {<KAIGYO>            if (Temp *t = move->target->asTemp())<KAIGYO>                if (_lastUncollectible >= t->index || t->scope)<KAIGYO>                    return true;<KAIGYO>            move->source->accept(this);<KAIGYO>        }<KAIGYO>        return _sideEffect;<KAIGYO>    }<KAIGYO><KAIGYO>protected:<KAIGYO>    virtual void visitConst(Const *) {}<KAIGYO>    virtual void visitString(String *) {}<KAIGYO>    virtual void visitRegExp(RegExp *) {}<KAIGYO>    virtual void visitName(Name *e) {<KAIGYO>        // TODO: maybe we can distinguish between built-ins of which we know that they do not have<KAIGYO>        // a side-effect.<KAIGYO>        if (e->builtin == Name::builtin_invalid || (e->id && *e->id != QStringLiteral("""")))<KAIGYO>            _sideEffect = true;<KAIGYO>    }<KAIGYO>    virtual void visitTemp(Temp *e) {<KAIGYO>        _sideEffect = e->index < 0;<KAIGYO>    }<KAIGYO>    virtual void visitClosure(Closure *) {}<KAIGYO>    virtual void visitUnop(Unop *e) {<KAIGYO>        switch (e->op) {<KAIGYO>        case V4IR::OpIncrement:<KAIGYO>        case V4IR::OpDecrement:<KAIGYO>            _sideEffect = true;<KAIGYO>            break;<KAIGYO><KAIGYO>        default:<KAIGYO>            break;<KAIGYO>        }<KAIGYO><KAIGYO>        if (!_sideEffect) e->expr->accept(this);<KAIGYO>    }<KAIGYO>    virtual void visitBinop(Binop *e) { if (!_sideEffect) e->left->accept(this); if (!_sideEffect) e->right->accept(this); }<KAIGYO>    virtual void visitSubscript(Subscript *e) {<KAIGYO>        // TODO: see if we can have subscript accesses without side effect<KAIGYO>        _sideEffect = true;<KAIGYO>    }<KAIGYO>    virtual void visitMember(Member *e) {<KAIGYO>        // TODO: see if we can have member accesses without side effect<KAIGYO>        _sideEffect = true;<KAIGYO>    }<KAIGYO>    virtual void visitCall(Call *e) {<KAIGYO>        _sideEffect = true; // TODO: there are built-in functions that have no side effect.<KAIGYO>    }<KAIGYO>    virtual void visitNew(New *e) {<KAIGYO>        if (!_sideEffect) e->base->accept(this);<KAIGYO>        for (ExprList *it = e->args; it && !_sideEffect; it = it->next)<KAIGYO>            it->expr->accept(this);<KAIGYO>    }<KAIGYO>};<KAIGYO><KAIGYO>Const *isConstPhi(Phi *phi)<KAIGYO>{<KAIGYO>    if (Const *c = phi->incoming[0]->asConst()) {<KAIGYO>        for (int i = 1, ei = phi->incoming.size(); i != ei; ++i) {<KAIGYO>            if (Const *cc = phi->incoming[i]->asConst()) {<KAIGYO>                if (c->value != cc->value)<KAIGYO>                    return 0;<KAIGYO>                if (!(c->type == cc->type || (c->type & NumberType && cc->type & NumberType)))<KAIGYO>                    return 0;<KAIGYO>            } else {<KAIGYO>                return 0;<KAIGYO>            }<KAIGYO>        }<KAIGYO>        return c;<KAIGYO>    }<KAIGYO>    return 0;<KAIGYO>}<KAIGYO><KAIGYO>Temp *isSameTempPhi(Phi *phi)<KAIGYO>{<KAIGYO>    if (Temp *t = phi->incoming[0]->asTemp()) {<KAIGYO>        for (int i = 1, ei = phi->incoming.size(); i != ei; ++i) {<KAIGYO>            if (Temp *tt = phi->incoming[i]->asTemp())<KAIGYO>                if (t->index == tt->index)<KAIGYO>                    continue;<KAIGYO>            return 0;<KAIGYO>        }<KAIGYO>        return t;<KAIGYO>    }<KAIGYO>    return 0;<KAIGYO>}<KAIGYO><KAIGYO>class ExprReplacer: public StmtVisitor, public ExprVisitor<KAIGYO>{<KAIGYO>    DefUsesCalculator &_defUses;<KAIGYO>    Temp *_toReplace;<KAIGYO>    Expr *_replacement;<KAIGYO><KAIGYO>public:<KAIGYO>    ExprReplacer(DefUsesCalculator &defUses)<KAIGYO>        : _defUses(defUses)<KAIGYO>        , _toReplace(0)<KAIGYO>        , _replacement(0)<KAIGYO>    {}<KAIGYO><KAIGYO>    QVector<Stmt *> operator()(Temp *toReplace, Expr *replacement)<KAIGYO>    {<KAIGYO>        Q_ASSERT(replacement->asTemp() || replacement->asConst() || replacement->asName());<KAIGYO><KAIGYO>        qSwap(_toReplace, toReplace);<KAIGYO>        qSwap(_replacement, replacement);<KAIGYO><KAIGYO>        QList<Stmt *> uses = _defUses.uses(_toReplace->index);<KAIGYO>        QVector<Stmt *> result;<KAIGYO>        result.reserve(uses.size());<KAIGYO>        foreach (Stmt *use, uses) {<KAIGYO>//            qout<<"""";<KAIGYO>            use->accept(this);<KAIGYO>//            qout<<"""";<KAIGYO>            result.append(use);<KAIGYO>        }<KAIGYO><KAIGYO>        qSwap(_replacement, replacement);<KAIGYO>        qSwap(_toReplace, toReplace);<KAIGYO>        return result;<KAIGYO>    }<KAIGYO><KAIGYO>protected:<KAIGYO>    virtual void visitConst(Const *) {}<KAIGYO>    virtual void visitString(String *) {}<KAIGYO>    virtual void visitRegExp(RegExp *) {}<KAIGYO>    virtual void visitName(Name *) {}<KAIGYO>    virtual void visitTemp(Temp *) {}<KAIGYO>    virtual void visitClosure(Closure *) {}<KAIGYO>    virtual void visitUnop(Unop *e) { check(e->expr); }<KAIGYO>    virtual void visitBinop(Binop *e) { check(e->left); check(e->right); }<KAIGYO>    virtual void visitCall(Call *e) {<KAIGYO>        check(e->base);<KAIGYO>        for (ExprList *it = e->args; it; it = it->next)<KAIGYO>            check(it->expr);<KAIGYO>    }<KAIGYO>    virtual void visitNew(New *e) {<KAIGYO>        check(e->base);<KAIGYO>        for (ExprList *it = e->args; it; it = it->next)<KAIGYO>            check(it->expr);<KAIGYO>    }<KAIGYO>    virtual void visitSubscript(Subscript *e) { check(e->base); check(e->index); }<KAIGYO>    virtual void visitMember(Member *e) { check(e->base); }<KAIGYO>    virtual void visitExp(Exp *s) { check(s->expr); }<KAIGYO>    virtual void visitEnter(Enter *s) { check(s->expr); }<KAIGYO>    virtual void visitLeave(Leave *) {}<KAIGYO>    virtual void visitMove(Move *s) { check(s->target); check(s->source); }<KAIGYO>    virtual void visitJump(Jump *) {}<KAIGYO>    virtual void visitCJump(CJump *s) { check(s->cond); }<KAIGYO>    virtual void visitRet(Ret *s) { check(s->expr); }<KAIGYO>    virtual void visitTry(Try *) {}<KAIGYO>    virtual void visitPhi(Phi *s) {<KAIGYO>        for (int i = 0, ei = s->incoming.size(); i != ei; ++i)<KAIGYO>            check(s->incoming[i]);<KAIGYO>    }<KAIGYO><KAIGYO>private:<KAIGYO>    void check(Expr *&e) {<KAIGYO>        if (equals(e, _toReplace))<KAIGYO>            // TODO: clone the replacement!<KAIGYO>            e = _replacement;<KAIGYO>        else<KAIGYO>            e->accept(this);<KAIGYO>    }<KAIGYO><KAIGYO>    // This only calculates equality for everything needed by constant propagation<KAIGYO>    bool equals(Expr *e1, Expr *e2) const {<KAIGYO>        if (e1 == e2)<KAIGYO>            return true;<KAIGYO><KAIGYO>        if (Const *c1 = e1->asConst()) {<KAIGYO>            if (Const *c2 = e2->asConst())<KAIGYO>                return c1->value == c2->value && (c1->type == c2->type || (c1->type & NumberType && c2->type & NumberType));<KAIGYO>        } else if (Temp *t1 = e1->asTemp()) {<KAIGYO>            if (Temp *t2 = e2->asTemp())<KAIGYO>                return t1->index == t2->index;<KAIGYO>        } else if (Name *n1 = e1->asName()) {<KAIGYO>            if (Name *n2 = e2->asName()) {<KAIGYO>                if (n1->id) {<KAIGYO>                    if (n2->id)<KAIGYO>                        return *n1->id == *n2->id;<KAIGYO>                } else {<KAIGYO>                    return n1->builtin == n2->builtin;<KAIGYO>                }<KAIGYO>            }<KAIGYO>        }<KAIGYO><KAIGYO>        return false;<KAIGYO>    }<KAIGYO>};<KAIGYO><KAIGYO>void optimizeSSA(Function *function, DefUsesCalculator &defUses)<KAIGYO>{<KAIGYO>    // FIXME: if an assignment to a local occurs that can escape through closures, it cannot be optimised out.<KAIGYO><KAIGYO>    QHash<Stmt*,Stmt**> ref;<KAIGYO>    QVector<Stmt *> W;<KAIGYO>    foreach (BasicBlock *bb, function->basicBlocks) {<KAIGYO>        for (int i = 0, ei = bb->statements.size(); i != ei; ++i) {<KAIGYO>            Stmt **s = &bb->statements[i];<KAIGYO>            W.append(*s);<KAIGYO>            ref.insert(*s, s);<KAIGYO>        }<KAIGYO>    }<KAIGYO><KAIGYO>    ExprReplacer replaceUses(defUses);<KAIGYO><KAIGYO>    while (!W.isEmpty()) {<KAIGYO>        Stmt *s = W.last();<KAIGYO>        W.removeLast();<KAIGYO><KAIGYO>        if (Phi *phi = s->asPhi()) {<KAIGYO>            // constant propagation:<KAIGYO>            if (Const *c = isConstPhi(phi)) {<KAIGYO>                W += replaceUses(phi->targetTemp, c);<KAIGYO>                defUses.removeDef(phi->targetTemp->index);<KAIGYO>                *ref[s] = 0;<KAIGYO>                continue;<KAIGYO>            }<KAIGYO><KAIGYO>            // copy propagation:<KAIGYO>            if (phi->incoming.size() == 1) {<KAIGYO>                Temp *t = phi->targetTemp;<KAIGYO>                Expr *e = phi->incoming.first();<KAIGYO><KAIGYO>                QVector<Stmt *> newT2Uses = replaceUses(t, e);<KAIGYO>                W += newT2Uses;<KAIGYO>                if (Temp *t2 = e->asTemp()) {<KAIGYO>                    defUses.removeUse(s, t2->index);<KAIGYO>                    defUses.addUses(t2->index, QList<Stmt*>::fromVector(newT2Uses));<KAIGYO>                }<KAIGYO>                defUses.removeDef(t->index);<KAIGYO>                *ref[s] = 0;<KAIGYO>                continue;<KAIGYO>            }<KAIGYO><KAIGYO>        }<KAIGYO><KAIGYO>        if (Move *m = s->asMove()) {<KAIGYO>            if (Temp *t = m->target->asTemp()) {<KAIGYO>                if (t->index >= 0) {<KAIGYO>                    // constant propagation:<KAIGYO>                    if (Const *c = m->source->asConst()) {<KAIGYO>//                        qout<<""""<<endl;<KAIGYO>                        W += replaceUses(t, c);<KAIGYO>                        defUses.removeDef(t->index);<KAIGYO>                        *ref[s] = 0;<KAIGYO>                        continue;<KAIGYO>                    }<KAIGYO>#if PROPAGATE_THIS<KAIGYO>                    if (Name *n = m->source->asName()) {<KAIGYO>                        qout<<""""<<endl;<KAIGYO>                        W += replaceUses(t, n);<KAIGYO>                        defUses.removeDef(t->index);<KAIGYO>                        *ref[s] = 0;<KAIGYO>                        continue;<KAIGYO>                    }<KAIGYO>#endif<KAIGYO>                    // copy propagation:<KAIGYO>                    if (Temp *t2 = m->source->asTemp()) {<KAIGYO>                        QVector<Stmt *> newT2Uses = replaceUses(t, t2);<KAIGYO>                        W += newT2Uses;<KAIGYO>                        defUses.removeUse(s, t2->index);<KAIGYO>                        defUses.addUses(t2->index, QList<Stmt*>::fromVector(newT2Uses));<KAIGYO>                        defUses.removeDef(t->index);<KAIGYO>                        *ref[s] = 0;<KAIGYO>                        continue;<KAIGYO>                    }<KAIGYO>                }<KAIGYO>            }<KAIGYO>        }<KAIGYO>    }<KAIGYO><KAIGYO>    foreach (BasicBlock *bb, function->basicBlocks) {<KAIGYO>        for (int i = 0; i < bb->statements.size();) {<KAIGYO>            if (bb->statements[i])<KAIGYO>                ++i;<KAIGYO>            else<KAIGYO>                bb->statements.remove(i);<KAIGYO>        }<KAIGYO>    }<KAIGYO>}<KAIGYO><KAIGYO>class TypeInference: public StmtVisitor, public ExprVisitor {<KAIGYO>    const DefUsesCalculator &_defUses;<KAIGYO>    QHash<int, int> _tempTypes;<KAIGYO>    QSet<Stmt *> _worklist;<KAIGYO>    struct TypingResult {<KAIGYO>        int type;<KAIGYO>        bool fullyTyped;<KAIGYO><KAIGYO>        TypingResult(int type, bool fullyTyped): type(type), fullyTyped(fullyTyped) {}<KAIGYO>        explicit TypingResult(int type = UnknownType): type(type), fullyTyped(type != UnknownType) {}<KAIGYO>    };<KAIGYO>    TypingResult _ty;<KAIGYO>    int _localCount;<KAIGYO><KAIGYO>public:<KAIGYO>    TypeInference(const DefUsesCalculator &defUses): _defUses(defUses), _ty(UnknownType) {}<KAIGYO><KAIGYO>    void run(Function *function) {<KAIGYO>        _localCount = function->variablesCanEscape() ? function->locals.size() : 0;<KAIGYO><KAIGYO>        // TODO: the worklist handling looks a bit inefficient... check if there is something better<KAIGYO>        _worklist.clear();<KAIGYO>        for (int i = 0, ei = function->basicBlocks.size(); i != ei; ++i) {<KAIGYO>            BasicBlock *bb = function->basicBlocks[i];<KAIGYO>            if (i == 0 || !bb->in.isEmpty())<KAIGYO>                foreach (Stmt *s, bb->statements)<KAIGYO>                    _worklist.insert(s);<KAIGYO>        }<KAIGYO><KAIGYO>        while (!_worklist.isEmpty()) {<KAIGYO>            QList<Stmt *> worklist = _worklist.values();<KAIGYO>            _worklist.clear();<KAIGYO>            while (!worklist.isEmpty()) {<KAIGYO>                Stmt *s = worklist.first();<KAIGYO>                worklist.removeFirst();<KAIGYO>#if defined(SHOW_SSA)<KAIGYO>                qout<<"""";s->dump(qout);qout<<endl;<KAIGYO>#endif<KAIGYO><KAIGYO>                if (!run(s)) {<KAIGYO>                    _worklist.insert(s);<KAIGYO>#if defined(SHOW_SSA)<KAIGYO>                    qout<<"""";<KAIGYO>                    s->dump(qout);qout<<endl;<KAIGYO>                } else {<KAIGYO>                    qout<<"""";<KAIGYO>                    s->dump(qout);qout<<endl;<KAIGYO>#endif<KAIGYO>                }<KAIGYO>            }<KAIGYO>        }<KAIGYO>    }<KAIGYO><KAIGYO>private:<KAIGYO>    bool run(Stmt *s) {<KAIGYO>        TypingResult ty;<KAIGYO>        std::swap(_ty, ty);<KAIGYO>        s->accept(this);<KAIGYO>        std::swap(_ty, ty);<KAIGYO>        return ty.fullyTyped;<KAIGYO>    }<KAIGYO><KAIGYO>    TypingResult run(Expr *e) {<KAIGYO>        TypingResult ty;<KAIGYO>        std::swap(_ty, ty);<KAIGYO>        e->accept(this);<KAIGYO>        std::swap(_ty, ty);<KAIGYO><KAIGYO>        if (ty.type != UnknownType)<KAIGYO>            setType(e, ty.type);<KAIGYO>        return ty;<KAIGYO>    }<KAIGYO><KAIGYO>    void setType(Expr *e, int ty) {<KAIGYO>        if (Temp *t = e->asTemp()) {<KAIGYO>            if (t->scope || t->index < _localCount)<KAIGYO>                ty = ObjectType;<KAIGYO>            e->type = (Type) ty;<KAIGYO><KAIGYO>            if (_tempTypes[t->index] != ty) {<KAIGYO>                _tempTypes[t->index] = ty;<KAIGYO><KAIGYO>#if defined(SHOW_SSA)<KAIGYO>                qout<<"""" << endl;<KAIGYO>                foreach (Stmt *s, _defUses.uses(t->index)) {<KAIGYO>                    qout << """";<KAIGYO>                    s->dump(qout);<KAIGYO>                    qout << endl;<KAIGYO>                }<KAIGYO>#endif<KAIGYO><KAIGYO>                _worklist += QSet<Stmt *>::fromList(_defUses.uses(t->index));<KAIGYO>            }<KAIGYO>        } else {<KAIGYO>            e->type = (Type) ty;<KAIGYO>        }<KAIGYO>    }<KAIGYO><KAIGYO>protected:<KAIGYO>    virtual void visitConst(Const *e) { _ty = TypingResult(e->type); }<KAIGYO>    virtual void visitString(String *) { _ty = TypingResult(StringType); }<KAIGYO>    virtual void visitRegExp(RegExp *) { _ty = TypingResult(ObjectType); }<KAIGYO>    virtual void visitName(Name *) { _ty = TypingResult(ObjectType); }<KAIGYO>    virtual void visitTemp(Temp *e) {<KAIGYO>        if (e->scope)<KAIGYO>            _ty = TypingResult(ObjectType);<KAIGYO>        else if (e->index < _localCount)<KAIGYO>            _ty = TypingResult(ObjectType);<KAIGYO>        else<KAIGYO>            _ty = TypingResult(_tempTypes.value(e->index, UnknownType));<KAIGYO>        setType(e, _ty.type);<KAIGYO>    }<KAIGYO>    virtual void visitClosure(Closure *) { _ty = TypingResult(ObjectType); } // TODO: VERIFY THIS!<KAIGYO>    virtual void visitUnop(Unop *e) {<KAIGYO>        _ty = run(e->expr);<KAIGYO>        switch (e->op) {<KAIGYO>        case OpUPlus: _ty.type = DoubleType; return;<KAIGYO>        case OpUMinus: _ty.type = DoubleType; return;<KAIGYO>        case OpCompl: _ty.type = SInt32Type; return;<KAIGYO>        case OpNot: _ty.type = BoolType; return;<KAIGYO><KAIGYO>        case OpIncrement:<KAIGYO>        case OpDecrement:<KAIGYO>            Q_ASSERT(!"""");<KAIGYO>        default:<KAIGYO>            Q_UNIMPLEMENTED();<KAIGYO>            Q_UNREACHABLE();<KAIGYO>        }<KAIGYO>    }<KAIGYO><KAIGYO>    virtual void visitBinop(Binop *e) {<KAIGYO>        TypingResult leftTy = run(e->left);<KAIGYO>        TypingResult rightTy = run(e->right);<KAIGYO>        _ty.fullyTyped = leftTy.fullyTyped && rightTy.fullyTyped;<KAIGYO><KAIGYO>        switch (e->op) {<KAIGYO>        case OpAdd:<KAIGYO>            if (leftTy.type & StringType || rightTy.type & StringType)<KAIGYO>                _ty.type = StringType;<KAIGYO>            else if (leftTy.type != UnknownType && rightTy.type != UnknownType)<KAIGYO>                _ty.type = DoubleType;<KAIGYO>            else<KAIGYO>                _ty.type = UnknownType;<KAIGYO>            break;<KAIGYO>        case OpSub:<KAIGYO>            _ty.type = DoubleType;<KAIGYO>            break;<KAIGYO><KAIGYO>        case OpMul:<KAIGYO>        case OpDiv:<KAIGYO>        case OpMod:<KAIGYO>            _ty.type = DoubleType;<KAIGYO>            break;<KAIGYO><KAIGYO>        case OpBitAnd:<KAIGYO>        case OpBitOr:<KAIGYO>        case OpBitXor:<KAIGYO>        case OpLShift:<KAIGYO>        case OpRShift:<KAIGYO>            _ty.type = SInt32Type;<KAIGYO>            break;<KAIGYO>        case OpURShift:<KAIGYO>            _ty.type = UInt32Type;<KAIGYO>            break;<KAIGYO><KAIGYO>        case OpGt:<KAIGYO>        case OpLt:<KAIGYO>        case OpGe:<KAIGYO>        case OpLe:<KAIGYO>        case OpEqual:<KAIGYO>        case OpNotEqual:<KAIGYO>        case OpStrictEqual:<KAIGYO>        case OpStrictNotEqual:<KAIGYO>        case OpAnd:<KAIGYO>        case OpOr:<KAIGYO>        case OpInstanceof:<KAIGYO>        case OpIn:<KAIGYO>            _ty.type = BoolType;<KAIGYO>            break;<KAIGYO><KAIGYO>        default:<KAIGYO>            Q_UNIMPLEMENTED();<KAIGYO>            Q_UNREACHABLE();<KAIGYO>        }<KAIGYO>    }<KAIGYO><KAIGYO>    virtual void visitCall(Call *e) {<KAIGYO>        _ty = run(e->base);<KAIGYO>        for (ExprList *it = e->args; it; it = it->next)<KAIGYO>            _ty.fullyTyped &= run(it->expr).fullyTyped;<KAIGYO>        _ty.type = ObjectType;<KAIGYO>    }<KAIGYO>    virtual void visitNew(New *e) {<KAIGYO>        _ty = run(e->base);<KAIGYO>        for (ExprList *it = e->args; it; it = it->next)<KAIGYO>            _ty.fullyTyped &= run(it->expr).fullyTyped;<KAIGYO>        _ty.type = ObjectType;<KAIGYO>    }<KAIGYO>    virtual void visitSubscript(Subscript *e) {<KAIGYO>        _ty.fullyTyped = run(e->base).fullyTyped && run(e->index).fullyTyped;<KAIGYO>        _ty.type = ObjectType;<KAIGYO>    }<KAIGYO><KAIGYO>    virtual void visitMember(Member *e) {<KAIGYO>        // TODO: for QML, try to do a static lookup<KAIGYO>        _ty = run(e->base);<KAIGYO>        _ty.type = ObjectType;<KAIGYO>    }<KAIGYO><KAIGYO>    virtual void visitExp(Exp *s) { _ty = run(s->expr); }<KAIGYO>    virtual void visitEnter(Enter *s) { _ty = run(s->expr); }<KAIGYO>    virtual void visitLeave(Leave *) { _ty = TypingResult(MissingType); }<KAIGYO>    virtual void visitMove(Move *s) {<KAIGYO>        TypingResult sourceTy = run(s->source);<KAIGYO>        Q_ASSERT(s->op == OpInvalid);<KAIGYO>        if (Temp *t = s->target->asTemp()) {<KAIGYO>            setType(t, sourceTy.type);<KAIGYO>            _ty = sourceTy;<KAIGYO>            return;<KAIGYO>        }<KAIGYO><KAIGYO>        _ty = run(s->target);<KAIGYO>        _ty.fullyTyped &= sourceTy.fullyTyped;<KAIGYO>    }<KAIGYO><KAIGYO>    virtual void visitJump(Jump *) { _ty = TypingResult(MissingType); }<KAIGYO>    virtual void visitCJump(CJump *s) { _ty = run(s->cond); }<KAIGYO>    virtual void visitRet(Ret *s) { _ty = run(s->expr); }<KAIGYO>    virtual void visitTry(Try *s) { setType(s->exceptionVar, ObjectType); _ty = TypingResult(MissingType); }<KAIGYO>    virtual void visitPhi(Phi *s) {<KAIGYO>        _ty = run(s->incoming[0]);<KAIGYO>        for (int i = 1, ei = s->incoming.size(); i != ei; ++i) {<KAIGYO>            TypingResult ty = run(s->incoming[i]);<KAIGYO>            _ty.type |= ty.type;<KAIGYO>            _ty.fullyTyped &= ty.fullyTyped;<KAIGYO>        }<KAIGYO><KAIGYO>        // TODO: check & double check the next condition!<KAIGYO>        if (_ty.type & ObjectType || _ty.type & UndefinedType || _ty.type & NullType)<KAIGYO>            _ty.type = ObjectType;<KAIGYO>        else if (_ty.type & NumberType)<KAIGYO>            _ty.type = DoubleType;<KAIGYO><KAIGYO>        setType(s->targetTemp, _ty.type);<KAIGYO>    }<KAIGYO>};<KAIGYO><KAIGYO>class TypePropagation: public StmtVisitor, public ExprVisitor {<KAIGYO>    Type _ty;<KAIGYO><KAIGYO>    void run(Expr *e, Type requestedType = UnknownType) {<KAIGYO>        qSwap(_ty, requestedType);<KAIGYO>        e->accept(this);<KAIGYO>        qSwap(_ty, requestedType);<KAIGYO>    }<KAIGYO><KAIGYO>public:<KAIGYO>    TypePropagation() : _ty(UnknownType) {}<KAIGYO><KAIGYO>    void run(Function *f) {<KAIGYO>        foreach (BasicBlock *bb, f->basicBlocks)<KAIGYO>            foreach (Stmt *s, bb->statements)<KAIGYO>                s->accept(this);<KAIGYO>    }<KAIGYO><KAIGYO>protected:<KAIGYO>    virtual void visitConst(Const *c) {<KAIGYO>        if (_ty & NumberType && c->type & NumberType) {<KAIGYO>            c->type = _ty;<KAIGYO>        }<KAIGYO>    }<KAIGYO><KAIGYO>    virtual void visitString(String *) {}<KAIGYO>    virtual void visitRegExp(RegExp *) {}<KAIGYO>    virtual void visitName(Name *) {}<KAIGYO>    virtual void visitTemp(Temp *) {}<KAIGYO>    virtual void visitClosure(Closure *) {}<KAIGYO>    virtual void visitUnop(Unop *e) { run(e->expr, e->type); }<KAIGYO>    virtual void visitBinop(Binop *e) { run(e->left, e->type); run(e->right, e->type); }<KAIGYO>    virtual void visitCall(Call *e) {<KAIGYO>        run(e->base);<KAIGYO>        for (ExprList *it = e->args; it; it = it->next)<KAIGYO>            run(it->expr);<KAIGYO>    }<KAIGYO>    virtual void visitNew(New *e) {<KAIGYO>        run(e->base);<KAIGYO>        for (ExprList *it = e->args; it; it = it->next)<KAIGYO>            run(it->expr);<KAIGYO>    }<KAIGYO>    virtual void visitSubscript(Subscript *e) { run(e->base); run(e->index); }<KAIGYO>    virtual void visitMember(Member *e) { run(e->base); }<KAIGYO>    virtual void visitExp(Exp *s) { run(s->expr); }<KAIGYO>    virtual void visitEnter(Enter *s) { run(s->expr); }<KAIGYO>    virtual void visitLeave(Leave *) {}<KAIGYO>    virtual void visitMove(Move *s) {<KAIGYO>        run(s->target);<KAIGYO>        run(s->source, s->target->type);<KAIGYO>    }<KAIGYO>    virtual void visitJump(Jump *) {}<KAIGYO>    virtual void visitCJump(CJump *s) {<KAIGYO>        run(s->cond, BoolType);<KAIGYO>    }<KAIGYO>    virtual void visitRet(Ret *s) { run(s->expr); }<KAIGYO>    virtual void visitTry(Try *) {}<KAIGYO>    virtual void visitPhi(Phi *s) {<KAIGYO>        Type ty = s->targetTemp->type;<KAIGYO>        foreach (Expr *e, s->incoming)<KAIGYO>            run(e, ty);<KAIGYO>    }<KAIGYO>};<KAIGYO><KAIGYO>void insertMove(Function *function, BasicBlock *basicBlock, Temp *target, Expr *source) {<KAIGYO>    Move *s = function->New<Move>();<KAIGYO>    s->init(target, source, OpInvalid);<KAIGYO>    basicBlock->statements.insert(basicBlock->statements.size() - 1, s);<KAIGYO>}<KAIGYO><KAIGYO>bool doEdgeSplitting(Function *f)<KAIGYO>{<KAIGYO>    const QVector<BasicBlock *> oldBBs = f->basicBlocks;<KAIGYO><KAIGYO>    foreach (BasicBlock *bb, oldBBs) {<KAIGYO>        if (bb->in.size() > 1) {<KAIGYO>            for (int inIdx = 0, eInIdx = bb->in.size(); inIdx != eInIdx; ++inIdx) {<KAIGYO>                BasicBlock *inBB = bb->in[inIdx];<KAIGYO>                if (inBB->out.size() > 1) { // this should have been split!<KAIGYO>#if defined(SHOW_SSA)<KAIGYO>                    qDebug() << """" << bb->index;<KAIGYO>#endif<KAIGYO><KAIGYO>                    // create the basic block:<KAIGYO>                    BasicBlock *newBB = new BasicBlock(f);<KAIGYO>                    newBB->index = f->basicBlocks.last()->index + 1;<KAIGYO>                    f->basicBlocks.append(newBB);<KAIGYO>                    Jump *s = f->New<Jump>();<KAIGYO>                    s->init(bb);<KAIGYO>                    newBB->statements.append(s);<KAIGYO><KAIGYO>                    // rewire the old outgoing edge<KAIGYO>                    int outIdx = inBB->out.indexOf(bb);<KAIGYO>                    inBB->out[outIdx] = newBB;<KAIGYO>                    newBB->in.append(inBB);<KAIGYO><KAIGYO>                    // rewire the old incoming edge<KAIGYO>                    bb->in[inIdx] = newBB;<KAIGYO>                    newBB->out.append(bb);<KAIGYO><KAIGYO>                    // patch the terminator<KAIGYO>                    Stmt *terminator = inBB->terminator();<KAIGYO>                    if (Jump *j = terminator->asJump()) {<KAIGYO>                        Q_ASSERT(outIdx == 0);<KAIGYO>                        j->target = newBB;<KAIGYO>                    } else if (CJump *j = terminator->asCJump()) {<KAIGYO>                        if (outIdx == 0)<KAIGYO>                            j->iftrue = newBB;<KAIGYO>                        else if (outIdx == 1)<KAIGYO>                            j->iffalse = newBB;<KAIGYO>                        else<KAIGYO>                            Q_ASSERT(!"""");<KAIGYO>                    } else {<KAIGYO>                        Q_ASSERT(!"""");<KAIGYO>                    }<KAIGYO>                }<KAIGYO>            }<KAIGYO>        }<KAIGYO>    }<KAIGYO>}<KAIGYO><KAIGYO>void scheduleBlocks(QVector<BasicBlock *> &basicBlocks)<KAIGYO>{<KAIGYO>    // FIXME: this should not do DFS scheduling.<KAIGYO>    struct I {<KAIGYO>        QSet<BasicBlock *> visited;<KAIGYO>        QVector<BasicBlock *> &sequence;<KAIGYO><KAIGYO>        I(QVector<BasicBlock *> &sequence): sequence(sequence) {}<KAIGYO><KAIGYO>        void DFS(BasicBlock *bb) {<KAIGYO>            if (visited.contains(bb))<KAIGYO>                return;<KAIGYO>            visited.insert(bb);<KAIGYO>            sequence.append(bb);<KAIGYO>            if (Stmt *terminator = bb->terminator()) {<KAIGYO>                if (Jump *j = terminator->asJump()) {<KAIGYO>                    Q_ASSERT(bb->out.size() == 1);<KAIGYO>                    DFS(j->target);<KAIGYO>                } else if (CJump *cj = terminator->asCJump()) {<KAIGYO>                    Q_ASSERT(bb->out.size() == 2);<KAIGYO>                    DFS(cj->iftrue);<KAIGYO>                    DFS(cj->iffalse);<KAIGYO>                } else if (terminator->asRet()) {<KAIGYO>                    Q_ASSERT(bb->out.size() == 0);<KAIGYO>                    // nothing to do.<KAIGYO>                } else {<KAIGYO>                    Q_UNREACHABLE();<KAIGYO>                }<KAIGYO>            } else {<KAIGYO>                Q_UNREACHABLE();<KAIGYO>            }<KAIGYO>        }<KAIGYO>    };<KAIGYO><KAIGYO>    QVector<BasicBlock *> sequence;<KAIGYO>    sequence.reserve(basicBlocks.size());<KAIGYO>    I(sequence).DFS(basicBlocks.first());<KAIGYO>    qSwap(basicBlocks, sequence);<KAIGYO>}<KAIGYO><KAIGYO>/*<KAIGYO> * Quick function to convert out of SSA, so we can put the stuff through the ISel phases. This<KAIGYO> * has to be replaced by a phase in the specific ISel back-ends and do register allocation at the<KAIGYO> * same time. That way the huge number of redundant moves generated by this function are eliminated.<KAIGYO> */': 7, '    virtual void visitTry(Try *s) { /* this should never happen */ }<KAIGYO><KAIGYO>    virtual void visitConst(Const *) {}<KAIGYO>    virtual void visitString(String *) {}<KAIGYO>    virtual void visitRegExp(RegExp *) {}<KAIGYO>    virtual void visitName(Name *) {}<KAIGYO>    virtual void visitClosure(Closure *) {}<KAIGYO>    virtual void visitUnop(Unop *e) { e->expr->accept(this); }<KAIGYO>    virtual void visitBinop(Binop *e) { e->left->accept(this); e->right->accept(this); }<KAIGYO>    virtual void visitCall(Call *e) {<KAIGYO>        e->base->accept(this);<KAIGYO>        for (ExprList *it = e->args; it; it = it->next)<KAIGYO>            it->expr->accept(this);<KAIGYO>    }<KAIGYO><KAIGYO>    virtual void visitNew(New *e) {<KAIGYO>        e->base->accept(this);<KAIGYO>        for (ExprList *it = e->args; it; it = it->next)<KAIGYO>            it->expr->accept(this);<KAIGYO>    }<KAIGYO><KAIGYO>    virtual void visitSubscript(Subscript *e) {<KAIGYO>        e->base->accept(this);<KAIGYO>        e->index->accept(this);<KAIGYO>    }<KAIGYO><KAIGYO>    virtual void visitMember(Member *e) {<KAIGYO>        e->base->accept(this);<KAIGYO>    }<KAIGYO>};<KAIGYO><KAIGYO>QHash<int, int> convertToSSA(Function *function)<KAIGYO>{<KAIGYO>#ifdef SHOW_SSA<KAIGYO>    qout << """";<KAIGYO>    if (function->name)<KAIGYO>        qout << *function->name;<KAIGYO>    else<KAIGYO>        qout << """";<KAIGYO>    qout << """" << endl;<KAIGYO>#endif // SHOW_SSA<KAIGYO><KAIGYO>    QVector<BasicBlock *> &nodes = function->basicBlocks;<KAIGYO><KAIGYO>    // Calculate the dominator tree:<KAIGYO>    DominatorTree df(nodes);<KAIGYO><KAIGYO>    // Collect all applicable variables:<KAIGYO>    VariableCollector variables(function);<KAIGYO><KAIGYO>    // Place phi functions:<KAIGYO>    QHash<BasicBlock *, QSet<int> > A_phi;<KAIGYO>    foreach (int a, variables.vars()) {<KAIGYO>        if (!variables.isNonLocal(a))<KAIGYO>            continue; // for semi-pruned SSA<KAIGYO><KAIGYO>        QList<BasicBlock *> W = QList<BasicBlock *>::fromSet(variables.defsite(a));<KAIGYO>        while (!W.isEmpty()) {<KAIGYO>            BasicBlock *n = W.first();<KAIGYO>            W.removeFirst();<KAIGYO>            foreach (BasicBlock *y, df[n]) {<KAIGYO>                if (!A_phi[y].contains(a)) {<KAIGYO>                    insertPhiNode(a, y, function);<KAIGYO>                    A_phi[y].insert(a);<KAIGYO>                    if (!variables.inBlock(y).contains(a))<KAIGYO>                        W.append(y);<KAIGYO>                }<KAIGYO>            }<KAIGYO>        }<KAIGYO>    }<KAIGYO><KAIGYO>    // Rename variables:<KAIGYO>    return VariableRenamer(function).run();<KAIGYO>}<KAIGYO><KAIGYO>class DefUsesCalculator: public StmtVisitor, public ExprVisitor {<KAIGYO>public:<KAIGYO>    struct DefUse {<KAIGYO>        Stmt *defStmt;<KAIGYO>        BasicBlock *blockOfStatement;<KAIGYO>        QList<Stmt *> uses;<KAIGYO>    };<KAIGYO><KAIGYO>private:<KAIGYO>    QHash<int, DefUse> _defUses;<KAIGYO>    QHash<Stmt *, QList<int> > _usesPerStatement;<KAIGYO><KAIGYO>    BasicBlock *_block;<KAIGYO>    Stmt *_stmt;<KAIGYO><KAIGYO>    void addUse(Temp *t) {<KAIGYO>        Q_ASSERT(t);<KAIGYO><KAIGYO>        _defUses[t->index].uses.append(_stmt);<KAIGYO>        _usesPerStatement[_stmt].append(t->index);<KAIGYO>    }<KAIGYO><KAIGYO>    void addDef(Temp *t) {<KAIGYO>        DefUse &defUse = _defUses[t->index];<KAIGYO>        defUse.defStmt = _stmt;<KAIGYO>        defUse.blockOfStatement = _block;<KAIGYO>    }<KAIGYO><KAIGYO>public:<KAIGYO>    DefUsesCalculator(const QVector<BasicBlock *> &bbs) {<KAIGYO>        foreach (BasicBlock *bb, bbs) {<KAIGYO>            _block = bb;<KAIGYO>            foreach (Stmt *stmt, bb->statements) {<KAIGYO>                _stmt = stmt;<KAIGYO>                stmt->accept(this);<KAIGYO>            }<KAIGYO>        }<KAIGYO><KAIGYO>        QMutableHashIterator<int, DefUse> it(_defUses);<KAIGYO>        while (it.hasNext()) {<KAIGYO>            it.next();<KAIGYO>            if (!it.value().defStmt)<KAIGYO>                it.remove();<KAIGYO>        }<KAIGYO>    }<KAIGYO><KAIGYO>    QList<int> defs() const {<KAIGYO>        return _defUses.keys();<KAIGYO>    }<KAIGYO><KAIGYO>    void removeDef(int var) {<KAIGYO>        _defUses.remove(var);<KAIGYO>    }<KAIGYO><KAIGYO>    void addUses(int variable, QList<Stmt *>newUses)<KAIGYO>    { _defUses[variable].uses.append(newUses); }<KAIGYO><KAIGYO>    int useCount(int variable) const<KAIGYO>    { return _defUses[variable].uses.size(); }<KAIGYO><KAIGYO>    Stmt *defStmt(int variable) const<KAIGYO>    { return _defUses[variable].defStmt; }<KAIGYO><KAIGYO>    BasicBlock *defStmtBlock(int variable) const<KAIGYO>    { return _defUses[variable].blockOfStatement; }<KAIGYO><KAIGYO>    void removeUse(Stmt *usingStmt, int var)<KAIGYO>    { _defUses[var].uses.removeAll(usingStmt); }<KAIGYO><KAIGYO>    QList<int> usedVars(Stmt *s) const<KAIGYO>    { return _usesPerStatement[s]; }<KAIGYO><KAIGYO>    QList<Stmt *> uses(int var) const<KAIGYO>    { return _defUses[var].uses; }<KAIGYO><KAIGYO>    void dump() const<KAIGYO>    {<KAIGYO>        foreach (int var, _defUses.keys()) {<KAIGYO>            const DefUse &du = _defUses[var];<KAIGYO>            qout<<var<<"""";<KAIGYO>            du.defStmt->dump(qout);<KAIGYO>            qout<<endl<<""""<<endl;<KAIGYO>            foreach (Stmt *s, du.uses) {<KAIGYO>                qout<<"""";s->dump(qout);qout<<endl;<KAIGYO>            }<KAIGYO>        }<KAIGYO>    }<KAIGYO><KAIGYO>protected:<KAIGYO>    virtual void visitExp(Exp *s) { s->expr->accept(this); }<KAIGYO>    virtual void visitEnter(Enter *) {}<KAIGYO>    virtual void visitLeave(Leave *) {}<KAIGYO>    virtual void visitJump(Jump *) {}<KAIGYO>    virtual void visitCJump(CJump *s) { s->cond->accept(this); }<KAIGYO>    virtual void visitRet(Ret *s) { s->expr->accept(this); }<KAIGYO>    virtual void visitTry(Try *) {}<KAIGYO><KAIGYO>    virtual void visitPhi(Phi *s) {<KAIGYO>        addDef(s->targetTemp);<KAIGYO>        foreach (Expr *e, s->incoming)<KAIGYO>            addUse(e->asTemp());<KAIGYO>    }<KAIGYO><KAIGYO>    virtual void visitMove(Move *s) {<KAIGYO>        if (Temp *t = s->target->asTemp())<KAIGYO>            addDef(t);<KAIGYO>        else<KAIGYO>            s->target->accept(this);<KAIGYO><KAIGYO>        s->source->accept(this);<KAIGYO>    }<KAIGYO><KAIGYO>    virtual void visitTemp(Temp *e) { addUse(e); }<KAIGYO><KAIGYO>    virtual void visitConst(Const *) {}<KAIGYO>    virtual void visitString(String *) {}<KAIGYO>    virtual void visitRegExp(RegExp *) {}<KAIGYO>    virtual void visitName(Name *) {}<KAIGYO>    virtual void visitClosure(Closure *) {}<KAIGYO>    virtual void visitUnop(Unop *e) { e->expr->accept(this); }<KAIGYO>    virtual void visitBinop(Binop *e) { e->left->accept(this); e->right->accept(this); }<KAIGYO>    virtual void visitSubscript(Subscript *e) { e->base->accept(this); e->index->accept(this); }<KAIGYO>    virtual void visitMember(Member *e) { e->base->accept(this); }<KAIGYO>    virtual void visitCall(Call *e) {<KAIGYO>        e->base->accept(this);<KAIGYO>        for (ExprList *it = e->args; it; it = it->next)<KAIGYO>            it->expr->accept(this);<KAIGYO>    }<KAIGYO><KAIGYO>    virtual void visitNew(New *e) {<KAIGYO>        e->base->accept(this);<KAIGYO>        for (ExprList *it = e->args; it; it = it->next)<KAIGYO>            it->expr->accept(this);<KAIGYO>    }<KAIGYO>};<KAIGYO><KAIGYO>bool hasPhiOnlyUses(Phi *phi, const DefUsesCalculator &defUses, QSet<Phi *> &collectedPhis)<KAIGYO>{<KAIGYO>    collectedPhis.insert(phi);<KAIGYO>    foreach (Stmt *use, defUses.uses(phi->targetTemp->index)) {<KAIGYO>        if (Phi *dependentPhi = use->asPhi()) {<KAIGYO>            if (!collectedPhis.contains(dependentPhi)) {<KAIGYO>                if (!hasPhiOnlyUses(dependentPhi, defUses, collectedPhis))<KAIGYO>                    return false;<KAIGYO>            }<KAIGYO>        } else {<KAIGYO>            return false;<KAIGYO>        }<KAIGYO>    }<KAIGYO>    return true;<KAIGYO>}<KAIGYO><KAIGYO>void cleanupPhis(DefUsesCalculator &defUses)<KAIGYO>{<KAIGYO>    QLinkedList<Phi *> phis;<KAIGYO>    foreach (int def, defUses.defs())<KAIGYO>        if (Phi *phi = defUses.defStmt(def)->asPhi())<KAIGYO>            phis.append(phi);<KAIGYO><KAIGYO>    QSet<Phi *> toRemove;<KAIGYO>    while (!phis.isEmpty()) {<KAIGYO>        Phi *phi = phis.first();<KAIGYO>        phis.removeFirst();<KAIGYO>        if (toRemove.contains(phi))<KAIGYO>            continue;<KAIGYO>        QSet<Phi *> collectedPhis;<KAIGYO>        if (hasPhiOnlyUses(phi, defUses, collectedPhis))<KAIGYO>            toRemove.unite(collectedPhis);<KAIGYO>    }<KAIGYO><KAIGYO>    foreach (Phi *phi, toRemove) {<KAIGYO>        int targetVar = phi->targetTemp->index;<KAIGYO><KAIGYO>        BasicBlock *bb = defUses.defStmtBlock(targetVar);<KAIGYO>        int idx = bb->statements.indexOf(phi);<KAIGYO>        bb->statements.remove(idx);<KAIGYO><KAIGYO>        foreach (int usedVar, defUses.usedVars(phi))<KAIGYO>            defUses.removeUse(phi, usedVar);<KAIGYO>        defUses.removeDef(targetVar);<KAIGYO>    }<KAIGYO>}<KAIGYO><KAIGYO>class DeadCodeElimination: public ExprVisitor {<KAIGYO>    int _lastUncollectible;<KAIGYO>    DefUsesCalculator &_defUses;<KAIGYO>    QVector<int> _worklist;<KAIGYO><KAIGYO>public:<KAIGYO>    DeadCodeElimination(DefUsesCalculator &defUses, Function *function)<KAIGYO>        : _defUses(defUses)<KAIGYO>    {<KAIGYO>        _worklist = QVector<int>::fromList(_defUses.defs());<KAIGYO><KAIGYO>        if (function->variablesCanEscape())<KAIGYO>            _lastUncollectible = function->locals.size() - 1;<KAIGYO>        else<KAIGYO>            _lastUncollectible = -1;<KAIGYO>    }<KAIGYO><KAIGYO>    void run() {<KAIGYO>        while (!_worklist.isEmpty()) {<KAIGYO>            const int v = _worklist.first();<KAIGYO>            _worklist.removeFirst();<KAIGYO><KAIGYO>            if (_defUses.useCount(v) == 0) {<KAIGYO>//                qDebug()<<"""";<KAIGYO>                Stmt *s = _defUses.defStmt(v);<KAIGYO>                if (!s) {<KAIGYO>                    _defUses.removeDef(v);<KAIGYO>                } else if (!hasSideEffect(s)) {<KAIGYO>//                    qDebug()<<"""";<KAIGYO>                    QVector<Stmt *> &stmts = _defUses.defStmtBlock(v)->statements;<KAIGYO>                    int idx = stmts.indexOf(s);<KAIGYO>                    if (idx != -1)<KAIGYO>                        stmts.remove(idx);<KAIGYO>                    foreach (int usedVar, _defUses.usedVars(s)) {<KAIGYO>                        _defUses.removeUse(s, usedVar);<KAIGYO>                        _worklist.append(usedVar);<KAIGYO>                    }<KAIGYO>                    _defUses.removeDef(v);<KAIGYO>                }<KAIGYO>            }<KAIGYO>        }<KAIGYO><KAIGYO>#ifdef SHOW_SSA<KAIGYO>        qout<<"""";<KAIGYO>        _defUses.dump();<KAIGYO>#endif<KAIGYO>    }<KAIGYO><KAIGYO>private:<KAIGYO>    bool _sideEffect;<KAIGYO><KAIGYO>    bool hasSideEffect(Stmt *s) {<KAIGYO>        // TODO: check if this can be moved to IR building.<KAIGYO>        _sideEffect = false;<KAIGYO>        if (Move *move = s->asMove()) {<KAIGYO>            if (Temp *t = move->target->asTemp())<KAIGYO>                if (t->index <= _lastUncollectible || t->scope)<KAIGYO>                    return true;<KAIGYO>            move->source->accept(this);<KAIGYO>        }<KAIGYO>        return _sideEffect;<KAIGYO>    }<KAIGYO><KAIGYO>protected:<KAIGYO>    virtual void visitConst(Const *) {}<KAIGYO>    virtual void visitString(String *) {}<KAIGYO>    virtual void visitRegExp(RegExp *) {}<KAIGYO>    virtual void visitName(Name *e) {<KAIGYO>        // TODO: maybe we can distinguish between built-ins of which we know that they do not have<KAIGYO>        // a side-effect.<KAIGYO>        if (e->builtin == Name::builtin_invalid || (e->id && *e->id != QStringLiteral("""")))<KAIGYO>            _sideEffect = true;<KAIGYO>    }<KAIGYO>    virtual void visitTemp(Temp *e) {<KAIGYO>    }<KAIGYO>    virtual void visitClosure(Closure *) {}<KAIGYO>    virtual void visitUnop(Unop *e) {<KAIGYO>        switch (e->op) {<KAIGYO>        case V4IR::OpIncrement:<KAIGYO>        case V4IR::OpDecrement:<KAIGYO>            _sideEffect = true;<KAIGYO>            break;<KAIGYO><KAIGYO>        default:<KAIGYO>            break;<KAIGYO>        }<KAIGYO><KAIGYO>        if (!_sideEffect) e->expr->accept(this);<KAIGYO>    }<KAIGYO>    virtual void visitBinop(Binop *e) { if (!_sideEffect) e->left->accept(this); if (!_sideEffect) e->right->accept(this); }<KAIGYO>    virtual void visitSubscript(Subscript *e) {<KAIGYO>        // TODO: see if we can have subscript accesses without side effect<KAIGYO>        _sideEffect = true;<KAIGYO>    }<KAIGYO>    virtual void visitMember(Member *e) {<KAIGYO>        // TODO: see if we can have member accesses without side effect<KAIGYO>        _sideEffect = true;<KAIGYO>    }<KAIGYO>    virtual void visitCall(Call *e) {<KAIGYO>        _sideEffect = true; // TODO: there are built-in functions that have no side effect.<KAIGYO>    }<KAIGYO>    virtual void visitNew(New *e) {<KAIGYO>        if (!_sideEffect) e->base->accept(this);<KAIGYO>        for (ExprList *it = e->args; it && !_sideEffect; it = it->next)<KAIGYO>            it->expr->accept(this);<KAIGYO>    }<KAIGYO>};<KAIGYO><KAIGYO>Const *isConstPhi(Phi *phi)<KAIGYO>{<KAIGYO>    if (Const *c = phi->incoming[0]->asConst()) {<KAIGYO>        for (int i = 1, ei = phi->incoming.size(); i != ei; ++i) {<KAIGYO>            if (Const *cc = phi->incoming[i]->asConst()) {<KAIGYO>                if (c->value != cc->value)<KAIGYO>                    return 0;<KAIGYO>                if (!(c->type == cc->type || (c->type & NumberType && cc->type & NumberType)))<KAIGYO>                    return 0;<KAIGYO>            } else {<KAIGYO>                return 0;<KAIGYO>            }<KAIGYO>        }<KAIGYO>        return c;<KAIGYO>    }<KAIGYO>    return 0;<KAIGYO>}<KAIGYO><KAIGYO>Temp *isSameTempPhi(Phi *phi)<KAIGYO>{<KAIGYO>    if (Temp *t = phi->incoming[0]->asTemp()) {<KAIGYO>        for (int i = 1, ei = phi->incoming.size(); i != ei; ++i) {<KAIGYO>            if (Temp *tt = phi->incoming[i]->asTemp())<KAIGYO>                if (t->index == tt->index)<KAIGYO>                    continue;<KAIGYO>            return 0;<KAIGYO>        }<KAIGYO>        return t;<KAIGYO>    }<KAIGYO>    return 0;<KAIGYO>}<KAIGYO><KAIGYO>class ExprReplacer: public StmtVisitor, public ExprVisitor<KAIGYO>{<KAIGYO>    DefUsesCalculator &_defUses;<KAIGYO>    Temp *_toReplace;<KAIGYO>    Expr *_replacement;<KAIGYO><KAIGYO>public:<KAIGYO>    ExprReplacer(DefUsesCalculator &defUses)<KAIGYO>        : _defUses(defUses)<KAIGYO>        , _toReplace(0)<KAIGYO>        , _replacement(0)<KAIGYO>    {}<KAIGYO><KAIGYO>    QVector<Stmt *> operator()(Temp *toReplace, Expr *replacement)<KAIGYO>    {<KAIGYO>        Q_ASSERT(replacement->asTemp() || replacement->asConst() || replacement->asName());<KAIGYO><KAIGYO>        qSwap(_toReplace, toReplace);<KAIGYO>        qSwap(_replacement, replacement);<KAIGYO><KAIGYO>        QList<Stmt *> uses = _defUses.uses(_toReplace->index);<KAIGYO>        QVector<Stmt *> result;<KAIGYO>        result.reserve(uses.size());<KAIGYO>        foreach (Stmt *use, uses) {<KAIGYO>//            qout<<"""";<KAIGYO>            use->accept(this);<KAIGYO>//            qout<<"""";<KAIGYO>            result.append(use);<KAIGYO>        }<KAIGYO><KAIGYO>        qSwap(_replacement, replacement);<KAIGYO>        qSwap(_toReplace, toReplace);<KAIGYO>        return result;<KAIGYO>    }<KAIGYO><KAIGYO>protected:<KAIGYO>    virtual void visitConst(Const *) {}<KAIGYO>    virtual void visitString(String *) {}<KAIGYO>    virtual void visitRegExp(RegExp *) {}<KAIGYO>    virtual void visitName(Name *) {}<KAIGYO>    virtual void visitTemp(Temp *) {}<KAIGYO>    virtual void visitClosure(Closure *) {}<KAIGYO>    virtual void visitUnop(Unop *e) { check(e->expr); }<KAIGYO>    virtual void visitBinop(Binop *e) { check(e->left); check(e->right); }<KAIGYO>    virtual void visitCall(Call *e) {<KAIGYO>        check(e->base);<KAIGYO>        for (ExprList *it = e->args; it; it = it->next)<KAIGYO>            check(it->expr);<KAIGYO>    }<KAIGYO>    virtual void visitNew(New *e) {<KAIGYO>        check(e->base);<KAIGYO>        for (ExprList *it = e->args; it; it = it->next)<KAIGYO>            check(it->expr);<KAIGYO>    }<KAIGYO>    virtual void visitSubscript(Subscript *e) { check(e->base); check(e->index); }<KAIGYO>    virtual void visitMember(Member *e) { check(e->base); }<KAIGYO>    virtual void visitExp(Exp *s) { check(s->expr); }<KAIGYO>    virtual void visitEnter(Enter *s) { check(s->expr); }<KAIGYO>    virtual void visitLeave(Leave *) {}<KAIGYO>    virtual void visitMove(Move *s) { check(s->target); check(s->source); }<KAIGYO>    virtual void visitJump(Jump *) {}<KAIGYO>    virtual void visitCJump(CJump *s) { check(s->cond); }<KAIGYO>    virtual void visitRet(Ret *s) { check(s->expr); }<KAIGYO>    virtual void visitTry(Try *) {}<KAIGYO>    virtual void visitPhi(Phi *s) {<KAIGYO>        for (int i = 0, ei = s->incoming.size(); i != ei; ++i)<KAIGYO>            check(s->incoming[i]);<KAIGYO>    }<KAIGYO><KAIGYO>private:<KAIGYO>    void check(Expr *&e) {<KAIGYO>        if (equals(e, _toReplace))<KAIGYO>            // TODO: clone the replacement!<KAIGYO>            e = _replacement;<KAIGYO>        else<KAIGYO>            e->accept(this);<KAIGYO>    }<KAIGYO><KAIGYO>    // This only calculates equality for everything needed by constant propagation<KAIGYO>    bool equals(Expr *e1, Expr *e2) const {<KAIGYO>        if (e1 == e2)<KAIGYO>            return true;<KAIGYO><KAIGYO>        if (Const *c1 = e1->asConst()) {<KAIGYO>            if (Const *c2 = e2->asConst())<KAIGYO>                return c1->value == c2->value && (c1->type == c2->type || (c1->type & NumberType && c2->type & NumberType));<KAIGYO>        } else if (Temp *t1 = e1->asTemp()) {<KAIGYO>            if (Temp *t2 = e2->asTemp())<KAIGYO>                return t1->index == t2->index;<KAIGYO>        } else if (Name *n1 = e1->asName()) {<KAIGYO>            if (Name *n2 = e2->asName()) {<KAIGYO>                if (n1->id) {<KAIGYO>                    if (n2->id)<KAIGYO>                        return *n1->id == *n2->id;<KAIGYO>                } else {<KAIGYO>                    return n1->builtin == n2->builtin;<KAIGYO>                }<KAIGYO>            }<KAIGYO>        }<KAIGYO><KAIGYO>        return false;<KAIGYO>    }<KAIGYO>};<KAIGYO><KAIGYO>void optimizeSSA(Function *function, DefUsesCalculator &defUses)<KAIGYO>{<KAIGYO>    // FIXME: if an assignment to a local occurs that can escape through closures, it cannot be optimised out.<KAIGYO><KAIGYO>    QHash<Stmt*,Stmt**> ref;<KAIGYO>    QVector<Stmt *> W;<KAIGYO>    foreach (BasicBlock *bb, function->basicBlocks) {<KAIGYO>        for (int i = 0, ei = bb->statements.size(); i != ei; ++i) {<KAIGYO>            Stmt **s = &bb->statements[i];<KAIGYO>            W.append(*s);<KAIGYO>            ref.insert(*s, s);<KAIGYO>        }<KAIGYO>    }<KAIGYO><KAIGYO>    ExprReplacer replaceUses(defUses);<KAIGYO><KAIGYO>    while (!W.isEmpty()) {<KAIGYO>        Stmt *s = W.last();<KAIGYO>        W.removeLast();<KAIGYO><KAIGYO>        if (Phi *phi = s->asPhi()) {<KAIGYO>            // constant propagation:<KAIGYO>            if (Const *c = isConstPhi(phi)) {<KAIGYO>                W += replaceUses(phi->targetTemp, c);<KAIGYO>                defUses.removeDef(phi->targetTemp->index);<KAIGYO>                *ref[s] = 0;<KAIGYO>                continue;<KAIGYO>            }<KAIGYO><KAIGYO>            // copy propagation:<KAIGYO>            if (phi->incoming.size() == 1) {<KAIGYO>                Temp *t = phi->targetTemp;<KAIGYO>                Expr *e = phi->incoming.first();<KAIGYO><KAIGYO>                QVector<Stmt *> newT2Uses = replaceUses(t, e);<KAIGYO>                W += newT2Uses;<KAIGYO>                if (Temp *t2 = e->asTemp()) {<KAIGYO>                    defUses.removeUse(s, t2->index);<KAIGYO>                    defUses.addUses(t2->index, QList<Stmt*>::fromVector(newT2Uses));<KAIGYO>                }<KAIGYO>                defUses.removeDef(t->index);<KAIGYO>                *ref[s] = 0;<KAIGYO>                continue;<KAIGYO>            }<KAIGYO><KAIGYO>        }<KAIGYO><KAIGYO>        if (Move *m = s->asMove()) {<KAIGYO>            if (Temp *t = m->target->asTemp()) {<KAIGYO>                if (t->index >= 0) {<KAIGYO>                    // constant propagation:<KAIGYO>                    if (Const *c = m->source->asConst()) {<KAIGYO>//                        qout<<""""<<endl;<KAIGYO>                        W += replaceUses(t, c);<KAIGYO>                        defUses.removeDef(t->index);<KAIGYO>                        *ref[s] = 0;<KAIGYO>                        continue;<KAIGYO>                    }<KAIGYO>#if PROPAGATE_THIS<KAIGYO>                    if (Name *n = m->source->asName()) {<KAIGYO>                        qout<<""""<<endl;<KAIGYO>                        W += replaceUses(t, n);<KAIGYO>                        defUses.removeDef(t->index);<KAIGYO>                        *ref[s] = 0;<KAIGYO>                        continue;<KAIGYO>                    }<KAIGYO>#endif<KAIGYO>                    // copy propagation:<KAIGYO>                    if (Temp *t2 = m->source->asTemp()) {<KAIGYO>                        QVector<Stmt *> newT2Uses = replaceUses(t, t2);<KAIGYO>                        W += newT2Uses;<KAIGYO>                        defUses.removeUse(s, t2->index);<KAIGYO>                        defUses.addUses(t2->index, QList<Stmt*>::fromVector(newT2Uses));<KAIGYO>                        defUses.removeDef(t->index);<KAIGYO>                        *ref[s] = 0;<KAIGYO>                        continue;<KAIGYO>                    }<KAIGYO>                }<KAIGYO>            }<KAIGYO>        }<KAIGYO>    }<KAIGYO><KAIGYO>    foreach (BasicBlock *bb, function->basicBlocks) {<KAIGYO>        for (int i = 0; i < bb->statements.size();) {<KAIGYO>            if (bb->statements[i])<KAIGYO>                ++i;<KAIGYO>            else<KAIGYO>                bb->statements.remove(i);<KAIGYO>        }<KAIGYO>    }<KAIGYO>}<KAIGYO><KAIGYO>class TypeInference: public StmtVisitor, public ExprVisitor {<KAIGYO>    const DefUsesCalculator &_defUses;<KAIGYO>    QHash<int, int> _tempTypes;<KAIGYO>    QSet<Stmt *> _worklist;<KAIGYO>    struct TypingResult {<KAIGYO>        int type;<KAIGYO>        bool fullyTyped;<KAIGYO><KAIGYO>        TypingResult(int type, bool fullyTyped): type(type), fullyTyped(fullyTyped) {}<KAIGYO>        explicit TypingResult(int type = UnknownType): type(type), fullyTyped(type != UnknownType) {}<KAIGYO>    };<KAIGYO>    TypingResult _ty;<KAIGYO>    int _localCount;<KAIGYO><KAIGYO>public:<KAIGYO>    TypeInference(const DefUsesCalculator &defUses): _defUses(defUses), _ty(UnknownType) {}<KAIGYO><KAIGYO>    void run(Function *function) {<KAIGYO>        _localCount = function->variablesCanEscape() ? function->locals.size() : 0;<KAIGYO><KAIGYO>        // TODO: the worklist handling looks a bit inefficient... check if there is something better<KAIGYO>        _worklist.clear();<KAIGYO>        for (int i = 0, ei = function->basicBlocks.size(); i != ei; ++i) {<KAIGYO>            BasicBlock *bb = function->basicBlocks[i];<KAIGYO>            if (i == 0 || !bb->in.isEmpty())<KAIGYO>                foreach (Stmt *s, bb->statements)<KAIGYO>                    _worklist.insert(s);<KAIGYO>        }<KAIGYO><KAIGYO>        while (!_worklist.isEmpty()) {<KAIGYO>            QList<Stmt *> worklist = _worklist.values();<KAIGYO>            _worklist.clear();<KAIGYO>            while (!worklist.isEmpty()) {<KAIGYO>                Stmt *s = worklist.first();<KAIGYO>                worklist.removeFirst();<KAIGYO>#if defined(SHOW_SSA)<KAIGYO>                qout<<"""";s->dump(qout);qout<<endl;<KAIGYO>#endif<KAIGYO><KAIGYO>                if (!run(s)) {<KAIGYO>                    _worklist.insert(s);<KAIGYO>#if defined(SHOW_SSA)<KAIGYO>                    qout<<"""";<KAIGYO>                    s->dump(qout);qout<<endl;<KAIGYO>                } else {<KAIGYO>                    qout<<"""";<KAIGYO>                    s->dump(qout);qout<<endl;<KAIGYO>#endif<KAIGYO>                }<KAIGYO>            }<KAIGYO>        }<KAIGYO>    }<KAIGYO><KAIGYO>private:<KAIGYO>    bool run(Stmt *s) {<KAIGYO>        TypingResult ty;<KAIGYO>        std::swap(_ty, ty);<KAIGYO>        s->accept(this);<KAIGYO>        std::swap(_ty, ty);<KAIGYO>        return ty.fullyTyped;<KAIGYO>    }<KAIGYO><KAIGYO>    TypingResult run(Expr *e) {<KAIGYO>        TypingResult ty;<KAIGYO>        std::swap(_ty, ty);<KAIGYO>        e->accept(this);<KAIGYO>        std::swap(_ty, ty);<KAIGYO><KAIGYO>        if (ty.type != UnknownType)<KAIGYO>            setType(e, ty.type);<KAIGYO>        return ty;<KAIGYO>    }<KAIGYO><KAIGYO>    void setType(Expr *e, int ty) {<KAIGYO>        if (Temp *t = e->asTemp()) {<KAIGYO>#if defined(SHOW_SSA)<KAIGYO>            qout<<"""" << endl;<KAIGYO>#endif<KAIGYO>            if (t->scope || t->index < _localCount) {<KAIGYO>                e->type = ObjectType;<KAIGYO>            } else {<KAIGYO>                e->type = (Type) ty;<KAIGYO><KAIGYO>                if (_tempTypes[t->index] != ty) {<KAIGYO>                    _tempTypes[t->index] = ty;<KAIGYO><KAIGYO>#if defined(SHOW_SSA)<KAIGYO>                    foreach (Stmt *s, _defUses.uses(t->index)) {<KAIGYO>                        qout << """";<KAIGYO>                        s->dump(qout);<KAIGYO>                        qout << endl;<KAIGYO>                    }<KAIGYO>#endif<KAIGYO><KAIGYO>                    _worklist += QSet<Stmt *>::fromList(_defUses.uses(t->index));<KAIGYO>                }<KAIGYO>            }<KAIGYO>        } else {<KAIGYO>            e->type = (Type) ty;<KAIGYO>        }<KAIGYO>    }<KAIGYO><KAIGYO>protected:<KAIGYO>    virtual void visitConst(Const *e) { _ty = TypingResult(e->type); }<KAIGYO>    virtual void visitString(String *) { _ty = TypingResult(StringType); }<KAIGYO>    virtual void visitRegExp(RegExp *) { _ty = TypingResult(ObjectType); }<KAIGYO>    virtual void visitName(Name *) { _ty = TypingResult(ObjectType); }<KAIGYO>    virtual void visitTemp(Temp *e) {<KAIGYO>        if (e->scope)<KAIGYO>            _ty = TypingResult(ObjectType);<KAIGYO>        else if (e->index < _localCount)<KAIGYO>            _ty = TypingResult(ObjectType);<KAIGYO>        else<KAIGYO>            _ty = TypingResult(_tempTypes.value(e->index, UnknownType));<KAIGYO>        setType(e, _ty.type);<KAIGYO>    }<KAIGYO>    virtual void visitClosure(Closure *) { _ty = TypingResult(ObjectType); } // TODO: VERIFY THIS!<KAIGYO>    virtual void visitUnop(Unop *e) {<KAIGYO>        _ty = run(e->expr);<KAIGYO>        switch (e->op) {<KAIGYO>        case OpUPlus: _ty.type = DoubleType; return;<KAIGYO>        case OpUMinus: _ty.type = DoubleType; return;<KAIGYO>        case OpCompl: _ty.type = SInt32Type; return;<KAIGYO>        case OpNot: _ty.type = BoolType; return;<KAIGYO><KAIGYO>        case OpIncrement:<KAIGYO>        case OpDecrement:<KAIGYO>            Q_ASSERT(!"""");<KAIGYO>        default:<KAIGYO>            Q_UNIMPLEMENTED();<KAIGYO>            Q_UNREACHABLE();<KAIGYO>        }<KAIGYO>    }<KAIGYO><KAIGYO>    virtual void visitBinop(Binop *e) {<KAIGYO>        TypingResult leftTy = run(e->left);<KAIGYO>        TypingResult rightTy = run(e->right);<KAIGYO>        _ty.fullyTyped = leftTy.fullyTyped && rightTy.fullyTyped;<KAIGYO><KAIGYO>        switch (e->op) {<KAIGYO>        case OpAdd:<KAIGYO>            if (leftTy.type & StringType || rightTy.type & StringType)<KAIGYO>                _ty.type = StringType;<KAIGYO>            else if (leftTy.type != UnknownType && rightTy.type != UnknownType)<KAIGYO>                _ty.type = DoubleType;<KAIGYO>            else<KAIGYO>                _ty.type = UnknownType;<KAIGYO>            break;<KAIGYO>        case OpSub:<KAIGYO>            _ty.type = DoubleType;<KAIGYO>            break;<KAIGYO><KAIGYO>        case OpMul:<KAIGYO>        case OpDiv:<KAIGYO>        case OpMod:<KAIGYO>            _ty.type = DoubleType;<KAIGYO>            break;<KAIGYO><KAIGYO>        case OpBitAnd:<KAIGYO>        case OpBitOr:<KAIGYO>        case OpBitXor:<KAIGYO>        case OpLShift:<KAIGYO>        case OpRShift:<KAIGYO>            _ty.type = SInt32Type;<KAIGYO>            break;<KAIGYO>        case OpURShift:<KAIGYO>            _ty.type = UInt32Type;<KAIGYO>            break;<KAIGYO><KAIGYO>        case OpGt:<KAIGYO>        case OpLt:<KAIGYO>        case OpGe:<KAIGYO>        case OpLe:<KAIGYO>        case OpEqual:<KAIGYO>        case OpNotEqual:<KAIGYO>        case OpStrictEqual:<KAIGYO>        case OpStrictNotEqual:<KAIGYO>        case OpAnd:<KAIGYO>        case OpOr:<KAIGYO>        case OpInstanceof:<KAIGYO>        case OpIn:<KAIGYO>            _ty.type = BoolType;<KAIGYO>            break;<KAIGYO><KAIGYO>        default:<KAIGYO>            Q_UNIMPLEMENTED();<KAIGYO>            Q_UNREACHABLE();<KAIGYO>        }<KAIGYO>    }<KAIGYO><KAIGYO>    virtual void visitCall(Call *e) {<KAIGYO>        _ty = run(e->base);<KAIGYO>        for (ExprList *it = e->args; it; it = it->next)<KAIGYO>            _ty.fullyTyped &= run(it->expr).fullyTyped;<KAIGYO>        _ty.type = ObjectType;<KAIGYO>    }<KAIGYO>    virtual void visitNew(New *e) {<KAIGYO>        _ty = run(e->base);<KAIGYO>        for (ExprList *it = e->args; it; it = it->next)<KAIGYO>            _ty.fullyTyped &= run(it->expr).fullyTyped;<KAIGYO>        _ty.type = ObjectType;<KAIGYO>    }<KAIGYO>    virtual void visitSubscript(Subscript *e) {<KAIGYO>        _ty.fullyTyped = run(e->base).fullyTyped && run(e->index).fullyTyped;<KAIGYO>        _ty.type = ObjectType;<KAIGYO>    }<KAIGYO><KAIGYO>    virtual void visitMember(Member *e) {<KAIGYO>        // TODO: for QML, try to do a static lookup<KAIGYO>        _ty = run(e->base);<KAIGYO>        _ty.type = ObjectType;<KAIGYO>    }<KAIGYO><KAIGYO>    virtual void visitExp(Exp *s) { _ty = run(s->expr); }<KAIGYO>    virtual void visitEnter(Enter *s) { _ty = run(s->expr); }<KAIGYO>    virtual void visitLeave(Leave *) { _ty = TypingResult(MissingType); }<KAIGYO>    virtual void visitMove(Move *s) {<KAIGYO>        TypingResult sourceTy = run(s->source);<KAIGYO>        Q_ASSERT(s->op == OpInvalid);<KAIGYO>        if (Temp *t = s->target->asTemp()) {<KAIGYO>            setType(t, sourceTy.type);<KAIGYO>            _ty = sourceTy;<KAIGYO>            return;<KAIGYO>        }<KAIGYO><KAIGYO>        _ty = run(s->target);<KAIGYO>        _ty.fullyTyped &= sourceTy.fullyTyped;<KAIGYO>    }<KAIGYO><KAIGYO>    virtual void visitJump(Jump *) { _ty = TypingResult(MissingType); }<KAIGYO>    virtual void visitCJump(CJump *s) { _ty = run(s->cond); }<KAIGYO>    virtual void visitRet(Ret *s) { _ty = run(s->expr); }<KAIGYO>    virtual void visitTry(Try *s) { setType(s->exceptionVar, ObjectType); _ty = TypingResult(MissingType); }<KAIGYO>    virtual void visitPhi(Phi *s) {<KAIGYO>        _ty = run(s->incoming[0]);<KAIGYO>        for (int i = 1, ei = s->incoming.size(); i != ei; ++i) {<KAIGYO>            TypingResult ty = run(s->incoming[i]);<KAIGYO>            _ty.type |= ty.type;<KAIGYO>            _ty.fullyTyped &= ty.fullyTyped;<KAIGYO>        }<KAIGYO><KAIGYO>        // TODO: check & double check the next condition!<KAIGYO>        if (_ty.type & ObjectType || _ty.type & UndefinedType || _ty.type & NullType)<KAIGYO>            _ty.type = ObjectType;<KAIGYO>        else if (_ty.type & NumberType)<KAIGYO>            _ty.type = DoubleType;<KAIGYO><KAIGYO>        setType(s->targetTemp, _ty.type);<KAIGYO>    }<KAIGYO>};<KAIGYO><KAIGYO>class TypePropagation: public StmtVisitor, public ExprVisitor {<KAIGYO>    Type _ty;<KAIGYO><KAIGYO>    void run(Expr *e, Type requestedType = UnknownType) {<KAIGYO>        qSwap(_ty, requestedType);<KAIGYO>        e->accept(this);<KAIGYO>        qSwap(_ty, requestedType);<KAIGYO>    }<KAIGYO><KAIGYO>public:<KAIGYO>    TypePropagation() : _ty(UnknownType) {}<KAIGYO><KAIGYO>    void run(Function *f) {<KAIGYO>        foreach (BasicBlock *bb, f->basicBlocks)<KAIGYO>            foreach (Stmt *s, bb->statements)<KAIGYO>                s->accept(this);<KAIGYO>    }<KAIGYO><KAIGYO>protected:<KAIGYO>    virtual void visitConst(Const *c) {<KAIGYO>        if (_ty & NumberType && c->type & NumberType) {<KAIGYO>            c->type = _ty;<KAIGYO>        }<KAIGYO>    }<KAIGYO><KAIGYO>    virtual void visitString(String *) {}<KAIGYO>    virtual void visitRegExp(RegExp *) {}<KAIGYO>    virtual void visitName(Name *) {}<KAIGYO>    virtual void visitTemp(Temp *) {}<KAIGYO>    virtual void visitClosure(Closure *) {}<KAIGYO>    virtual void visitUnop(Unop *e) { run(e->expr, e->type); }<KAIGYO>    virtual void visitBinop(Binop *e) { run(e->left, e->type); run(e->right, e->type); }<KAIGYO>    virtual void visitCall(Call *e) {<KAIGYO>        run(e->base);<KAIGYO>        for (ExprList *it = e->args; it; it = it->next)<KAIGYO>            run(it->expr);<KAIGYO>    }<KAIGYO>    virtual void visitNew(New *e) {<KAIGYO>        run(e->base);<KAIGYO>        for (ExprList *it = e->args; it; it = it->next)<KAIGYO>            run(it->expr);<KAIGYO>    }<KAIGYO>    virtual void visitSubscript(Subscript *e) { run(e->base); run(e->index); }<KAIGYO>    virtual void visitMember(Member *e) { run(e->base); }<KAIGYO>    virtual void visitExp(Exp *s) { run(s->expr); }<KAIGYO>    virtual void visitEnter(Enter *s) { run(s->expr); }<KAIGYO>    virtual void visitLeave(Leave *) {}<KAIGYO>    virtual void visitMove(Move *s) {<KAIGYO>        run(s->target);<KAIGYO>        run(s->source, s->target->type);<KAIGYO>    }<KAIGYO>    virtual void visitJump(Jump *) {}<KAIGYO>    virtual void visitCJump(CJump *s) {<KAIGYO>        run(s->cond, BoolType);<KAIGYO>    }<KAIGYO>    virtual void visitRet(Ret *s) { run(s->expr); }<KAIGYO>    virtual void visitTry(Try *) {}<KAIGYO>    virtual void visitPhi(Phi *s) {<KAIGYO>        Type ty = s->targetTemp->type;<KAIGYO>        foreach (Expr *e, s->incoming)<KAIGYO>            run(e, ty);<KAIGYO>    }<KAIGYO>};<KAIGYO><KAIGYO>void insertMove(Function *function, BasicBlock *basicBlock, Temp *target, Expr *source) {<KAIGYO>    Move *s = function->New<Move>();<KAIGYO>    s->init(target, source, OpInvalid);<KAIGYO>    basicBlock->statements.insert(basicBlock->statements.size() - 1, s);<KAIGYO>}<KAIGYO><KAIGYO>bool doEdgeSplitting(Function *f)<KAIGYO>{<KAIGYO>    const QVector<BasicBlock *> oldBBs = f->basicBlocks;<KAIGYO><KAIGYO>    foreach (BasicBlock *bb, oldBBs) {<KAIGYO>        if (bb->in.size() > 1) {<KAIGYO>            for (int inIdx = 0, eInIdx = bb->in.size(); inIdx != eInIdx; ++inIdx) {<KAIGYO>                BasicBlock *inBB = bb->in[inIdx];<KAIGYO>                if (inBB->out.size() > 1) { // this should have been split!<KAIGYO>#if defined(SHOW_SSA)<KAIGYO>                    qDebug() << """" << bb->index;<KAIGYO>#endif<KAIGYO><KAIGYO>                    // create the basic block:<KAIGYO>                    BasicBlock *newBB = new BasicBlock(f);<KAIGYO>                    newBB->index = f->basicBlocks.last()->index + 1;<KAIGYO>                    f->basicBlocks.append(newBB);<KAIGYO>                    Jump *s = f->New<Jump>();<KAIGYO>                    s->init(bb);<KAIGYO>                    newBB->statements.append(s);<KAIGYO><KAIGYO>                    // rewire the old outgoing edge<KAIGYO>                    int outIdx = inBB->out.indexOf(bb);<KAIGYO>                    inBB->out[outIdx] = newBB;<KAIGYO>                    newBB->in.append(inBB);<KAIGYO><KAIGYO>                    // rewire the old incoming edge<KAIGYO>                    bb->in[inIdx] = newBB;<KAIGYO>                    newBB->out.append(bb);<KAIGYO><KAIGYO>                    // patch the terminator<KAIGYO>                    Stmt *terminator = inBB->terminator();<KAIGYO>                    if (Jump *j = terminator->asJump()) {<KAIGYO>                        Q_ASSERT(outIdx == 0);<KAIGYO>                        j->target = newBB;<KAIGYO>                    } else if (CJump *j = terminator->asCJump()) {<KAIGYO>                        if (outIdx == 0)<KAIGYO>                            j->iftrue = newBB;<KAIGYO>                        else if (outIdx == 1)<KAIGYO>                            j->iffalse = newBB;<KAIGYO>                        else<KAIGYO>                            Q_ASSERT(!"""");<KAIGYO>                    } else {<KAIGYO>                        Q_ASSERT(!"""");<KAIGYO>                    }<KAIGYO>                }<KAIGYO>            }<KAIGYO>        }<KAIGYO>    }<KAIGYO>}<KAIGYO><KAIGYO>void scheduleBlocks(QVector<BasicBlock *> &basicBlocks)<KAIGYO>{<KAIGYO>    // FIXME: this should not do DFS scheduling.<KAIGYO>    struct I {<KAIGYO>        QSet<BasicBlock *> visited;<KAIGYO>        QVector<BasicBlock *> &sequence;<KAIGYO><KAIGYO>        I(QVector<BasicBlock *> &sequence): sequence(sequence) {}<KAIGYO><KAIGYO>        void DFS(BasicBlock *bb) {<KAIGYO>            if (visited.contains(bb))<KAIGYO>                return;<KAIGYO>            visited.insert(bb);<KAIGYO>            sequence.append(bb);<KAIGYO>            if (Stmt *terminator = bb->terminator()) {<KAIGYO>                if (Jump *j = terminator->asJump()) {<KAIGYO>                    Q_ASSERT(bb->out.size() == 1);<KAIGYO>                    DFS(j->target);<KAIGYO>                } else if (CJump *cj = terminator->asCJump()) {<KAIGYO>                    Q_ASSERT(bb->out.size() == 2);<KAIGYO>                    DFS(cj->iftrue);<KAIGYO>                    DFS(cj->iffalse);<KAIGYO>                } else if (terminator->asRet()) {<KAIGYO>                    Q_ASSERT(bb->out.size() == 0);<KAIGYO>                    // nothing to do.<KAIGYO>                } else {<KAIGYO>                    Q_UNREACHABLE();<KAIGYO>                }<KAIGYO>            } else {<KAIGYO>                Q_UNREACHABLE();<KAIGYO>            }<KAIGYO>        }<KAIGYO>    };<KAIGYO><KAIGYO>    QVector<BasicBlock *> sequence;<KAIGYO>    sequence.reserve(basicBlocks.size());<KAIGYO>    I(sequence).DFS(basicBlocks.first());<KAIGYO>    qSwap(basicBlocks, sequence);<KAIGYO>}<KAIGYO><KAIGYO>/*<KAIGYO> * Quick function to convert out of SSA, so we can put the stuff through the ISel phases. This<KAIGYO> * has to be replaced by a phase in the specific ISel back-ends and do register allocation at the<KAIGYO> * same time. That way the huge number of redundant moves generated by this function are eliminated.<KAIGYO> */': 10, '    virtual void visitTry(Try *s) { /* this should never happen */ }<KAIGYO><KAIGYO>    virtual void visitConst(Const *) {}<KAIGYO>    virtual void visitString(String *) {}<KAIGYO>    virtual void visitRegExp(RegExp *) {}<KAIGYO>    virtual void visitName(Name *) {}<KAIGYO>    virtual void visitClosure(Closure *) {}<KAIGYO>    virtual void visitUnop(Unop *e) { e->expr->accept(this); }<KAIGYO>    virtual void visitBinop(Binop *e) { e->left->accept(this); e->right->accept(this); }<KAIGYO>    virtual void visitCall(Call *e) {<KAIGYO>        e->base->accept(this);<KAIGYO>        for (ExprList *it = e->args; it; it = it->next)<KAIGYO>            it->expr->accept(this);<KAIGYO>    }<KAIGYO><KAIGYO>    virtual void visitNew(New *e) {<KAIGYO>        e->base->accept(this);<KAIGYO>        for (ExprList *it = e->args; it; it = it->next)<KAIGYO>            it->expr->accept(this);<KAIGYO>    }<KAIGYO><KAIGYO>    virtual void visitSubscript(Subscript *e) {<KAIGYO>        e->base->accept(this);<KAIGYO>        e->index->accept(this);<KAIGYO>    }<KAIGYO><KAIGYO>    virtual void visitMember(Member *e) {<KAIGYO>        e->base->accept(this);<KAIGYO>    }<KAIGYO>};<KAIGYO><KAIGYO>QHash<int, int> convertToSSA(Function *function)<KAIGYO>{<KAIGYO>#ifdef SHOW_SSA<KAIGYO>    qout << """";<KAIGYO>    if (function->name)<KAIGYO>        qout << *function->name;<KAIGYO>    else<KAIGYO>        qout << """";<KAIGYO>    qout << """" << endl;<KAIGYO>#endif // SHOW_SSA<KAIGYO><KAIGYO>    QVector<BasicBlock *> &nodes = function->basicBlocks;<KAIGYO><KAIGYO>    // Calculate the dominator tree:<KAIGYO>    DominatorTree df(nodes);<KAIGYO><KAIGYO>    // Collect all applicable variables:<KAIGYO>    VariableCollector variables(function);<KAIGYO><KAIGYO>    // Place phi functions:<KAIGYO>    QHash<BasicBlock *, QSet<int> > A_phi;<KAIGYO>    foreach (int a, variables.vars()) {<KAIGYO>        if (!variables.isNonLocal(a))<KAIGYO>            continue; // for semi-pruned SSA<KAIGYO><KAIGYO>        QList<BasicBlock *> W = QList<BasicBlock *>::fromSet(variables.defsite(a));<KAIGYO>        while (!W.isEmpty()) {<KAIGYO>            BasicBlock *n = W.first();<KAIGYO>            W.removeFirst();<KAIGYO>            foreach (BasicBlock *y, df[n]) {<KAIGYO>                if (!A_phi[y].contains(a)) {<KAIGYO>                    insertPhiNode(a, y, function);<KAIGYO>                    A_phi[y].insert(a);<KAIGYO>                    if (!variables.inBlock(y).contains(a))<KAIGYO>                        W.append(y);<KAIGYO>                }<KAIGYO>            }<KAIGYO>        }<KAIGYO>    }<KAIGYO><KAIGYO>    // Rename variables:<KAIGYO>    return VariableRenamer(function).run();<KAIGYO>}<KAIGYO><KAIGYO>class DefUsesCalculator: public StmtVisitor, public ExprVisitor {<KAIGYO>public:<KAIGYO>    struct DefUse {<KAIGYO>        Stmt *defStmt;<KAIGYO>        BasicBlock *blockOfStatement;<KAIGYO>        QList<Stmt *> uses;<KAIGYO>    };<KAIGYO><KAIGYO>private:<KAIGYO>    QHash<int, DefUse> _defUses;<KAIGYO>    QHash<Stmt *, QList<int> > _usesPerStatement;<KAIGYO><KAIGYO>    BasicBlock *_block;<KAIGYO>    Stmt *_stmt;<KAIGYO><KAIGYO>    void addUse(Temp *t) {<KAIGYO>        Q_ASSERT(t);<KAIGYO><KAIGYO>        _defUses[t->index].uses.append(_stmt);<KAIGYO>        _usesPerStatement[_stmt].append(t->index);<KAIGYO>    }<KAIGYO><KAIGYO>    void addDef(Temp *t) {<KAIGYO>        DefUse &defUse = _defUses[t->index];<KAIGYO>        defUse.defStmt = _stmt;<KAIGYO>        defUse.blockOfStatement = _block;<KAIGYO>    }<KAIGYO><KAIGYO>public:<KAIGYO>    DefUsesCalculator(const QVector<BasicBlock *> &bbs) {<KAIGYO>        foreach (BasicBlock *bb, bbs) {<KAIGYO>            _block = bb;<KAIGYO>            foreach (Stmt *stmt, bb->statements) {<KAIGYO>                _stmt = stmt;<KAIGYO>                stmt->accept(this);<KAIGYO>            }<KAIGYO>        }<KAIGYO><KAIGYO>        QMutableHashIterator<int, DefUse> it(_defUses);<KAIGYO>        while (it.hasNext()) {<KAIGYO>            it.next();<KAIGYO>            if (!it.value().defStmt)<KAIGYO>                it.remove();<KAIGYO>        }<KAIGYO>    }<KAIGYO><KAIGYO>    QList<int> defs() const {<KAIGYO>        return _defUses.keys();<KAIGYO>    }<KAIGYO><KAIGYO>    void removeDef(int var) {<KAIGYO>        _defUses.remove(var);<KAIGYO>    }<KAIGYO><KAIGYO>    void addUses(int variable, QList<Stmt *>newUses)<KAIGYO>    { _defUses[variable].uses.append(newUses); }<KAIGYO><KAIGYO>    int useCount(int variable) const<KAIGYO>    { return _defUses[variable].uses.size(); }<KAIGYO><KAIGYO>    Stmt *defStmt(int variable) const<KAIGYO>    { return _defUses[variable].defStmt; }<KAIGYO><KAIGYO>    BasicBlock *defStmtBlock(int variable) const<KAIGYO>    { return _defUses[variable].blockOfStatement; }<KAIGYO><KAIGYO>    void removeUse(Stmt *usingStmt, int var)<KAIGYO>    { _defUses[var].uses.removeAll(usingStmt); }<KAIGYO><KAIGYO>    QList<int> usedVars(Stmt *s) const<KAIGYO>    { return _usesPerStatement[s]; }<KAIGYO><KAIGYO>    QList<Stmt *> uses(int var) const<KAIGYO>    { return _defUses[var].uses; }<KAIGYO><KAIGYO>    void dump() const<KAIGYO>    {<KAIGYO>        foreach (int var, _defUses.keys()) {<KAIGYO>            const DefUse &du = _defUses[var];<KAIGYO>            qout<<var<<"""";<KAIGYO>            du.defStmt->dump(qout);<KAIGYO>            qout<<endl<<""""<<endl;<KAIGYO>            foreach (Stmt *s, du.uses) {<KAIGYO>                qout<<"""";s->dump(qout);qout<<endl;<KAIGYO>            }<KAIGYO>        }<KAIGYO>    }<KAIGYO><KAIGYO>protected:<KAIGYO>    virtual void visitExp(Exp *s) { s->expr->accept(this); }<KAIGYO>    virtual void visitEnter(Enter *) {}<KAIGYO>    virtual void visitLeave(Leave *) {}<KAIGYO>    virtual void visitJump(Jump *) {}<KAIGYO>    virtual void visitCJump(CJump *s) { s->cond->accept(this); }<KAIGYO>    virtual void visitRet(Ret *s) { s->expr->accept(this); }<KAIGYO>    virtual void visitTry(Try *) {}<KAIGYO><KAIGYO>    virtual void visitPhi(Phi *s) {<KAIGYO>        addDef(s->targetTemp);<KAIGYO>        foreach (Expr *e, s->incoming)<KAIGYO>            addUse(e->asTemp());<KAIGYO>    }<KAIGYO><KAIGYO>    virtual void visitMove(Move *s) {<KAIGYO>        if (Temp *t = s->target->asTemp())<KAIGYO>            addDef(t);<KAIGYO>        else<KAIGYO>            s->target->accept(this);<KAIGYO><KAIGYO>        s->source->accept(this);<KAIGYO>    }<KAIGYO><KAIGYO>    virtual void visitTemp(Temp *e) { addUse(e); }<KAIGYO><KAIGYO>    virtual void visitConst(Const *) {}<KAIGYO>    virtual void visitString(String *) {}<KAIGYO>    virtual void visitRegExp(RegExp *) {}<KAIGYO>    virtual void visitName(Name *) {}<KAIGYO>    virtual void visitClosure(Closure *) {}<KAIGYO>    virtual void visitUnop(Unop *e) { e->expr->accept(this); }<KAIGYO>    virtual void visitBinop(Binop *e) { e->left->accept(this); e->right->accept(this); }<KAIGYO>    virtual void visitSubscript(Subscript *e) { e->base->accept(this); e->index->accept(this); }<KAIGYO>    virtual void visitMember(Member *e) { e->base->accept(this); }<KAIGYO>    virtual void visitCall(Call *e) {<KAIGYO>        e->base->accept(this);<KAIGYO>        for (ExprList *it = e->args; it; it = it->next)<KAIGYO>            it->expr->accept(this);<KAIGYO>    }<KAIGYO><KAIGYO>    virtual void visitNew(New *e) {<KAIGYO>        e->base->accept(this);<KAIGYO>        for (ExprList *it = e->args; it; it = it->next)<KAIGYO>            it->expr->accept(this);<KAIGYO>    }<KAIGYO>};<KAIGYO><KAIGYO>bool hasPhiOnlyUses(Phi *phi, const DefUsesCalculator &defUses, QSet<Phi *> &collectedPhis)<KAIGYO>{<KAIGYO>    collectedPhis.insert(phi);<KAIGYO>    foreach (Stmt *use, defUses.uses(phi->targetTemp->index)) {<KAIGYO>        if (Phi *dependentPhi = use->asPhi()) {<KAIGYO>            if (!collectedPhis.contains(dependentPhi)) {<KAIGYO>                if (!hasPhiOnlyUses(dependentPhi, defUses, collectedPhis))<KAIGYO>                    return false;<KAIGYO>            }<KAIGYO>        } else {<KAIGYO>            return false;<KAIGYO>        }<KAIGYO>    }<KAIGYO>    return true;<KAIGYO>}<KAIGYO><KAIGYO>void cleanupPhis(DefUsesCalculator &defUses)<KAIGYO>{<KAIGYO>    QLinkedList<Phi *> phis;<KAIGYO>    foreach (int def, defUses.defs())<KAIGYO>        if (Phi *phi = defUses.defStmt(def)->asPhi())<KAIGYO>            phis.append(phi);<KAIGYO><KAIGYO>    QSet<Phi *> toRemove;<KAIGYO>    while (!phis.isEmpty()) {<KAIGYO>        Phi *phi = phis.first();<KAIGYO>        phis.removeFirst();<KAIGYO>        if (toRemove.contains(phi))<KAIGYO>            continue;<KAIGYO>        QSet<Phi *> collectedPhis;<KAIGYO>        if (hasPhiOnlyUses(phi, defUses, collectedPhis))<KAIGYO>            toRemove.unite(collectedPhis);<KAIGYO>    }<KAIGYO><KAIGYO>    foreach (Phi *phi, toRemove) {<KAIGYO>        int targetVar = phi->targetTemp->index;<KAIGYO><KAIGYO>        BasicBlock *bb = defUses.defStmtBlock(targetVar);<KAIGYO>        int idx = bb->statements.indexOf(phi);<KAIGYO>        bb->statements.remove(idx);<KAIGYO><KAIGYO>        foreach (int usedVar, defUses.usedVars(phi))<KAIGYO>            defUses.removeUse(phi, usedVar);<KAIGYO>        defUses.removeDef(targetVar);<KAIGYO>    }<KAIGYO>}<KAIGYO><KAIGYO>class DeadCodeElimination: public ExprVisitor {<KAIGYO>    int _lastUncollectible;<KAIGYO>    DefUsesCalculator &_defUses;<KAIGYO>    QVector<int> _worklist;<KAIGYO><KAIGYO>public:<KAIGYO>    DeadCodeElimination(DefUsesCalculator &defUses, Function *function)<KAIGYO>        : _defUses(defUses)<KAIGYO>    {<KAIGYO>        _worklist = QVector<int>::fromList(_defUses.defs());<KAIGYO><KAIGYO>        if (function->variablesCanEscape())<KAIGYO>            _lastUncollectible = function->locals.size() - 1;<KAIGYO>        else<KAIGYO>            _lastUncollectible = -1;<KAIGYO>    }<KAIGYO><KAIGYO>    void run() {<KAIGYO>        while (!_worklist.isEmpty()) {<KAIGYO>            const int v = _worklist.first();<KAIGYO>            _worklist.removeFirst();<KAIGYO><KAIGYO>            if (_defUses.useCount(v) == 0) {<KAIGYO>//                qDebug()<<"""";<KAIGYO>                Stmt *s = _defUses.defStmt(v);<KAIGYO>                if (!s) {<KAIGYO>                    _defUses.removeDef(v);<KAIGYO>                } else if (!hasSideEffect(s)) {<KAIGYO>//                    qDebug()<<"""";<KAIGYO>                    QVector<Stmt *> &stmts = _defUses.defStmtBlock(v)->statements;<KAIGYO>                    int idx = stmts.indexOf(s);<KAIGYO>                    if (idx != -1)<KAIGYO>                        stmts.remove(idx);<KAIGYO>                    foreach (int usedVar, _defUses.usedVars(s)) {<KAIGYO>                        _defUses.removeUse(s, usedVar);<KAIGYO>                        _worklist.append(usedVar);<KAIGYO>                    }<KAIGYO>                    _defUses.removeDef(v);<KAIGYO>                }<KAIGYO>            }<KAIGYO>        }<KAIGYO><KAIGYO>#ifdef SHOW_SSA<KAIGYO>        qout<<"""";<KAIGYO>        _defUses.dump();<KAIGYO>#endif<KAIGYO>    }<KAIGYO><KAIGYO>private:<KAIGYO>    bool _sideEffect;<KAIGYO><KAIGYO>    bool hasSideEffect(Stmt *s) {<KAIGYO>        // TODO: check if this can be moved to IR building.<KAIGYO>        _sideEffect = false;<KAIGYO>        if (Move *move = s->asMove()) {<KAIGYO>            if (Temp *t = move->target->asTemp())<KAIGYO>                if (t->index <= _lastUncollectible || t->scope)<KAIGYO>                    return true;<KAIGYO>            move->source->accept(this);<KAIGYO>        }<KAIGYO>        return _sideEffect;<KAIGYO>    }<KAIGYO><KAIGYO>protected:<KAIGYO>    virtual void visitConst(Const *) {}<KAIGYO>    virtual void visitString(String *) {}<KAIGYO>    virtual void visitRegExp(RegExp *) {}<KAIGYO>    virtual void visitName(Name *e) {<KAIGYO>        // TODO: maybe we can distinguish between built-ins of which we know that they do not have<KAIGYO>        // a side-effect.<KAIGYO>        if (e->builtin == Name::builtin_invalid || (e->id && *e->id != QStringLiteral("""")))<KAIGYO>            _sideEffect = true;<KAIGYO>    }<KAIGYO>    virtual void visitTemp(Temp *e) {<KAIGYO>    }<KAIGYO>    virtual void visitClosure(Closure *) {}<KAIGYO>    virtual void visitUnop(Unop *e) {<KAIGYO>        switch (e->op) {<KAIGYO>        case V4IR::OpIncrement:<KAIGYO>        case V4IR::OpDecrement:<KAIGYO>            _sideEffect = true;<KAIGYO>            break;<KAIGYO><KAIGYO>        default:<KAIGYO>            break;<KAIGYO>        }<KAIGYO><KAIGYO>        if (!_sideEffect) e->expr->accept(this);<KAIGYO>    }<KAIGYO>    virtual void visitBinop(Binop *e) { if (!_sideEffect) e->left->accept(this); if (!_sideEffect) e->right->accept(this); }<KAIGYO>    virtual void visitSubscript(Subscript *e) {<KAIGYO>        // TODO: see if we can have subscript accesses without side effect<KAIGYO>        _sideEffect = true;<KAIGYO>    }<KAIGYO>    virtual void visitMember(Member *e) {<KAIGYO>        // TODO: see if we can have member accesses without side effect<KAIGYO>        _sideEffect = true;<KAIGYO>    }<KAIGYO>    virtual void visitCall(Call *e) {<KAIGYO>        _sideEffect = true; // TODO: there are built-in functions that have no side effect.<KAIGYO>    }<KAIGYO>    virtual void visitNew(New *e) {<KAIGYO>        if (!_sideEffect) e->base->accept(this);<KAIGYO>        for (ExprList *it = e->args; it && !_sideEffect; it = it->next)<KAIGYO>            it->expr->accept(this);<KAIGYO>    }<KAIGYO>};<KAIGYO><KAIGYO>class TypeInference: public StmtVisitor, public ExprVisitor {<KAIGYO>    const DefUsesCalculator &_defUses;<KAIGYO>    QHash<int, int> _tempTypes;<KAIGYO>    QSet<Stmt *> _worklist;<KAIGYO>    struct TypingResult {<KAIGYO>        int type;<KAIGYO>        bool fullyTyped;<KAIGYO><KAIGYO>        TypingResult(int type, bool fullyTyped): type(type), fullyTyped(fullyTyped) {}<KAIGYO>        explicit TypingResult(int type = UnknownType): type(type), fullyTyped(type != UnknownType) {}<KAIGYO>    };<KAIGYO>    TypingResult _ty;<KAIGYO>    int _localCount;<KAIGYO><KAIGYO>public:<KAIGYO>    TypeInference(const DefUsesCalculator &defUses): _defUses(defUses), _ty(UnknownType) {}<KAIGYO><KAIGYO>    void run(Function *function) {<KAIGYO>        _localCount = function->variablesCanEscape() ? function->locals.size() : 0;<KAIGYO><KAIGYO>        // TODO: the worklist handling looks a bit inefficient... check if there is something better<KAIGYO>        _worklist.clear();<KAIGYO>        for (int i = 0, ei = function->basicBlocks.size(); i != ei; ++i) {<KAIGYO>            BasicBlock *bb = function->basicBlocks[i];<KAIGYO>            if (i == 0 || !bb->in.isEmpty())<KAIGYO>                foreach (Stmt *s, bb->statements)<KAIGYO>                    _worklist.insert(s);<KAIGYO>        }<KAIGYO><KAIGYO>        while (!_worklist.isEmpty()) {<KAIGYO>            QList<Stmt *> worklist = _worklist.values();<KAIGYO>            _worklist.clear();<KAIGYO>            while (!worklist.isEmpty()) {<KAIGYO>                Stmt *s = worklist.first();<KAIGYO>                worklist.removeFirst();<KAIGYO>#if defined(SHOW_SSA)<KAIGYO>                qout<<"""";s->dump(qout);qout<<endl;<KAIGYO>#endif<KAIGYO><KAIGYO>                if (!run(s)) {<KAIGYO>                    _worklist.insert(s);<KAIGYO>#if defined(SHOW_SSA)<KAIGYO>                    qout<<"""";<KAIGYO>                    s->dump(qout);qout<<endl;<KAIGYO>                } else {<KAIGYO>                    qout<<"""";<KAIGYO>                    s->dump(qout);qout<<endl;<KAIGYO>#endif<KAIGYO>                }<KAIGYO>            }<KAIGYO>        }<KAIGYO>    }<KAIGYO><KAIGYO>private:<KAIGYO>    bool run(Stmt *s) {<KAIGYO>        TypingResult ty;<KAIGYO>        std::swap(_ty, ty);<KAIGYO>        s->accept(this);<KAIGYO>        std::swap(_ty, ty);<KAIGYO>        return ty.fullyTyped;<KAIGYO>    }<KAIGYO><KAIGYO>    TypingResult run(Expr *e) {<KAIGYO>        TypingResult ty;<KAIGYO>        std::swap(_ty, ty);<KAIGYO>        e->accept(this);<KAIGYO>        std::swap(_ty, ty);<KAIGYO><KAIGYO>        if (ty.type != UnknownType)<KAIGYO>            setType(e, ty.type);<KAIGYO>        return ty;<KAIGYO>    }<KAIGYO><KAIGYO>    void setType(Expr *e, int ty) {<KAIGYO>        if (Temp *t = e->asTemp()) {<KAIGYO>#if defined(SHOW_SSA)<KAIGYO>            qout<<"""" << endl;<KAIGYO>#endif<KAIGYO>            if (t->scope || t->index < _localCount) {<KAIGYO>                e->type = ObjectType;<KAIGYO>            } else {<KAIGYO>                e->type = (Type) ty;<KAIGYO><KAIGYO>                if (_tempTypes[t->index] != ty) {<KAIGYO>                    _tempTypes[t->index] = ty;<KAIGYO><KAIGYO>#if defined(SHOW_SSA)<KAIGYO>                    foreach (Stmt *s, _defUses.uses(t->index)) {<KAIGYO>                        qout << """";<KAIGYO>                        s->dump(qout);<KAIGYO>                        qout << endl;<KAIGYO>                    }<KAIGYO>#endif<KAIGYO><KAIGYO>                    _worklist += QSet<Stmt *>::fromList(_defUses.uses(t->index));<KAIGYO>                }<KAIGYO>            }<KAIGYO>        } else {<KAIGYO>            e->type = (Type) ty;<KAIGYO>        }<KAIGYO>    }<KAIGYO><KAIGYO>protected:<KAIGYO>    virtual void visitConst(Const *e) { _ty = TypingResult(e->type); }<KAIGYO>    virtual void visitString(String *) { _ty = TypingResult(StringType); }<KAIGYO>    virtual void visitRegExp(RegExp *) { _ty = TypingResult(ObjectType); }<KAIGYO>    virtual void visitName(Name *) { _ty = TypingResult(ObjectType); }<KAIGYO>    virtual void visitTemp(Temp *e) {<KAIGYO>        if (e->scope)<KAIGYO>            _ty = TypingResult(ObjectType);<KAIGYO>        else if (e->index < _localCount)<KAIGYO>            _ty = TypingResult(ObjectType);<KAIGYO>        else<KAIGYO>            _ty = TypingResult(_tempTypes.value(e->index, UnknownType));<KAIGYO>        setType(e, _ty.type);<KAIGYO>    }<KAIGYO>    virtual void visitClosure(Closure *) { _ty = TypingResult(ObjectType); } // TODO: VERIFY THIS!<KAIGYO>    virtual void visitUnop(Unop *e) {<KAIGYO>        _ty = run(e->expr);<KAIGYO>        switch (e->op) {<KAIGYO>        case OpUPlus: _ty.type = DoubleType; return;<KAIGYO>        case OpUMinus: _ty.type = DoubleType; return;<KAIGYO>        case OpCompl: _ty.type = SInt32Type; return;<KAIGYO>        case OpNot: _ty.type = BoolType; return;<KAIGYO><KAIGYO>        case OpIncrement:<KAIGYO>        case OpDecrement:<KAIGYO>            Q_ASSERT(!"""");<KAIGYO>        default:<KAIGYO>            Q_UNIMPLEMENTED();<KAIGYO>            Q_UNREACHABLE();<KAIGYO>        }<KAIGYO>    }<KAIGYO><KAIGYO>    virtual void visitBinop(Binop *e) {<KAIGYO>        TypingResult leftTy = run(e->left);<KAIGYO>        TypingResult rightTy = run(e->right);<KAIGYO>        _ty.fullyTyped = leftTy.fullyTyped && rightTy.fullyTyped;<KAIGYO><KAIGYO>        switch (e->op) {<KAIGYO>        case OpAdd:<KAIGYO>            if (leftTy.type & StringType || rightTy.type & StringType)<KAIGYO>                _ty.type = StringType;<KAIGYO>            else if (leftTy.type != UnknownType && rightTy.type != UnknownType)<KAIGYO>                _ty.type = DoubleType;<KAIGYO>            else<KAIGYO>                _ty.type = UnknownType;<KAIGYO>            break;<KAIGYO>        case OpSub:<KAIGYO>            _ty.type = DoubleType;<KAIGYO>            break;<KAIGYO><KAIGYO>        case OpMul:<KAIGYO>        case OpDiv:<KAIGYO>        case OpMod:<KAIGYO>            _ty.type = DoubleType;<KAIGYO>            break;<KAIGYO><KAIGYO>        case OpBitAnd:<KAIGYO>        case OpBitOr:<KAIGYO>        case OpBitXor:<KAIGYO>        case OpLShift:<KAIGYO>        case OpRShift:<KAIGYO>            _ty.type = SInt32Type;<KAIGYO>            break;<KAIGYO>        case OpURShift:<KAIGYO>            _ty.type = UInt32Type;<KAIGYO>            break;<KAIGYO><KAIGYO>        case OpGt:<KAIGYO>        case OpLt:<KAIGYO>        case OpGe:<KAIGYO>        case OpLe:<KAIGYO>        case OpEqual:<KAIGYO>        case OpNotEqual:<KAIGYO>        case OpStrictEqual:<KAIGYO>        case OpStrictNotEqual:<KAIGYO>        case OpAnd:<KAIGYO>        case OpOr:<KAIGYO>        case OpInstanceof:<KAIGYO>        case OpIn:<KAIGYO>            _ty.type = BoolType;<KAIGYO>            break;<KAIGYO><KAIGYO>        default:<KAIGYO>            Q_UNIMPLEMENTED();<KAIGYO>            Q_UNREACHABLE();<KAIGYO>        }<KAIGYO>    }<KAIGYO><KAIGYO>    virtual void visitCall(Call *e) {<KAIGYO>        _ty = run(e->base);<KAIGYO>        for (ExprList *it = e->args; it; it = it->next)<KAIGYO>            _ty.fullyTyped &= run(it->expr).fullyTyped;<KAIGYO>        _ty.type = ObjectType;<KAIGYO>    }<KAIGYO>    virtual void visitNew(New *e) {<KAIGYO>        _ty = run(e->base);<KAIGYO>        for (ExprList *it = e->args; it; it = it->next)<KAIGYO>            _ty.fullyTyped &= run(it->expr).fullyTyped;<KAIGYO>        _ty.type = ObjectType;<KAIGYO>    }<KAIGYO>    virtual void visitSubscript(Subscript *e) {<KAIGYO>        _ty.fullyTyped = run(e->base).fullyTyped && run(e->index).fullyTyped;<KAIGYO>        _ty.type = ObjectType;<KAIGYO>    }<KAIGYO><KAIGYO>    virtual void visitMember(Member *e) {<KAIGYO>        // TODO: for QML, try to do a static lookup<KAIGYO>        _ty = run(e->base);<KAIGYO>        _ty.type = ObjectType;<KAIGYO>    }<KAIGYO><KAIGYO>    virtual void visitExp(Exp *s) { _ty = run(s->expr); }<KAIGYO>    virtual void visitEnter(Enter *s) { _ty = run(s->expr); }<KAIGYO>    virtual void visitLeave(Leave *) { _ty = TypingResult(MissingType); }<KAIGYO>    virtual void visitMove(Move *s) {<KAIGYO>        TypingResult sourceTy = run(s->source);<KAIGYO>        Q_ASSERT(s->op == OpInvalid);<KAIGYO>        if (Temp *t = s->target->asTemp()) {<KAIGYO>            setType(t, sourceTy.type);<KAIGYO>            _ty = sourceTy;<KAIGYO>            return;<KAIGYO>        }<KAIGYO><KAIGYO>        _ty = run(s->target);<KAIGYO>        _ty.fullyTyped &= sourceTy.fullyTyped;<KAIGYO>    }<KAIGYO><KAIGYO>    virtual void visitJump(Jump *) { _ty = TypingResult(MissingType); }<KAIGYO>    virtual void visitCJump(CJump *s) { _ty = run(s->cond); }<KAIGYO>    virtual void visitRet(Ret *s) { _ty = run(s->expr); }<KAIGYO>    virtual void visitTry(Try *s) { setType(s->exceptionVar, ObjectType); _ty = TypingResult(MissingType); }<KAIGYO>    virtual void visitPhi(Phi *s) {<KAIGYO>        _ty = run(s->incoming[0]);<KAIGYO>        for (int i = 1, ei = s->incoming.size(); i != ei; ++i) {<KAIGYO>            TypingResult ty = run(s->incoming[i]);<KAIGYO>            _ty.type |= ty.type;<KAIGYO>            _ty.fullyTyped &= ty.fullyTyped;<KAIGYO>        }<KAIGYO><KAIGYO>        // TODO: check & double check the next condition!<KAIGYO>        if (_ty.type & ObjectType || _ty.type & UndefinedType || _ty.type & NullType)<KAIGYO>            _ty.type = ObjectType;<KAIGYO>        else if (_ty.type & NumberType)<KAIGYO>            _ty.type = DoubleType;<KAIGYO><KAIGYO>        setType(s->targetTemp, _ty.type);<KAIGYO>    }<KAIGYO>};<KAIGYO><KAIGYO>class TypePropagation: public StmtVisitor, public ExprVisitor {<KAIGYO>    Type _ty;<KAIGYO><KAIGYO>    void run(Expr *e, Type requestedType = UnknownType) {<KAIGYO>        qSwap(_ty, requestedType);<KAIGYO>        e->accept(this);<KAIGYO>        qSwap(_ty, requestedType);<KAIGYO>    }<KAIGYO><KAIGYO>public:<KAIGYO>    TypePropagation() : _ty(UnknownType) {}<KAIGYO><KAIGYO>    void run(Function *f) {<KAIGYO>        foreach (BasicBlock *bb, f->basicBlocks)<KAIGYO>            foreach (Stmt *s, bb->statements)<KAIGYO>                s->accept(this);<KAIGYO>    }<KAIGYO><KAIGYO>protected:<KAIGYO>    virtual void visitConst(Const *c) {<KAIGYO>        if (_ty & NumberType && c->type & NumberType) {<KAIGYO>            c->type = _ty;<KAIGYO>        }<KAIGYO>    }<KAIGYO><KAIGYO>    virtual void visitString(String *) {}<KAIGYO>    virtual void visitRegExp(RegExp *) {}<KAIGYO>    virtual void visitName(Name *) {}<KAIGYO>    virtual void visitTemp(Temp *) {}<KAIGYO>    virtual void visitClosure(Closure *) {}<KAIGYO>    virtual void visitUnop(Unop *e) { run(e->expr, e->type); }<KAIGYO>    virtual void visitBinop(Binop *e) { run(e->left, e->type); run(e->right, e->type); }<KAIGYO>    virtual void visitCall(Call *e) {<KAIGYO>        run(e->base);<KAIGYO>        for (ExprList *it = e->args; it; it = it->next)<KAIGYO>            run(it->expr);<KAIGYO>    }<KAIGYO>    virtual void visitNew(New *e) {<KAIGYO>        run(e->base);<KAIGYO>        for (ExprList *it = e->args; it; it = it->next)<KAIGYO>            run(it->expr);<KAIGYO>    }<KAIGYO>    virtual void visitSubscript(Subscript *e) { run(e->base); run(e->index); }<KAIGYO>    virtual void visitMember(Member *e) { run(e->base); }<KAIGYO>    virtual void visitExp(Exp *s) { run(s->expr); }<KAIGYO>    virtual void visitEnter(Enter *s) { run(s->expr); }<KAIGYO>    virtual void visitLeave(Leave *) {}<KAIGYO>    virtual void visitMove(Move *s) {<KAIGYO>        run(s->target);<KAIGYO>        run(s->source, s->target->type);<KAIGYO>    }<KAIGYO>    virtual void visitJump(Jump *) {}<KAIGYO>    virtual void visitCJump(CJump *s) {<KAIGYO>        run(s->cond, BoolType);<KAIGYO>    }<KAIGYO>    virtual void visitRet(Ret *s) { run(s->expr); }<KAIGYO>    virtual void visitTry(Try *) {}<KAIGYO>    virtual void visitPhi(Phi *s) {<KAIGYO>        Type ty = s->targetTemp->type;<KAIGYO>        foreach (Expr *e, s->incoming)<KAIGYO>            run(e, ty);<KAIGYO>    }<KAIGYO>};<KAIGYO><KAIGYO>void insertMove(Function *function, BasicBlock *basicBlock, Temp *target, Expr *source) {<KAIGYO>    Move *s = function->New<Move>();<KAIGYO>    s->init(target, source, OpInvalid);<KAIGYO>    basicBlock->statements.insert(basicBlock->statements.size() - 1, s);<KAIGYO>}<KAIGYO><KAIGYO>bool doEdgeSplitting(Function *f)<KAIGYO>{<KAIGYO>    const QVector<BasicBlock *> oldBBs = f->basicBlocks;<KAIGYO><KAIGYO>    foreach (BasicBlock *bb, oldBBs) {<KAIGYO>        if (bb->in.size() > 1) {<KAIGYO>            for (int inIdx = 0, eInIdx = bb->in.size(); inIdx != eInIdx; ++inIdx) {<KAIGYO>                BasicBlock *inBB = bb->in[inIdx];<KAIGYO>                if (inBB->out.size() > 1) { // this should have been split!<KAIGYO>#if defined(SHOW_SSA)<KAIGYO>                    qDebug() << """" << bb->index;<KAIGYO>#endif<KAIGYO><KAIGYO>                    // create the basic block:<KAIGYO>                    BasicBlock *newBB = new BasicBlock(f);<KAIGYO>                    newBB->index = f->basicBlocks.last()->index + 1;<KAIGYO>                    f->basicBlocks.append(newBB);<KAIGYO>                    Jump *s = f->New<Jump>();<KAIGYO>                    s->init(bb);<KAIGYO>                    newBB->statements.append(s);<KAIGYO><KAIGYO>                    // rewire the old outgoing edge<KAIGYO>                    int outIdx = inBB->out.indexOf(bb);<KAIGYO>                    inBB->out[outIdx] = newBB;<KAIGYO>                    newBB->in.append(inBB);<KAIGYO><KAIGYO>                    // rewire the old incoming edge<KAIGYO>                    bb->in[inIdx] = newBB;<KAIGYO>                    newBB->out.append(bb);<KAIGYO><KAIGYO>                    // patch the terminator<KAIGYO>                    Stmt *terminator = inBB->terminator();<KAIGYO>                    if (Jump *j = terminator->asJump()) {<KAIGYO>                        Q_ASSERT(outIdx == 0);<KAIGYO>                        j->target = newBB;<KAIGYO>                    } else if (CJump *j = terminator->asCJump()) {<KAIGYO>                        if (outIdx == 0)<KAIGYO>                            j->iftrue = newBB;<KAIGYO>                        else if (outIdx == 1)<KAIGYO>                            j->iffalse = newBB;<KAIGYO>                        else<KAIGYO>                            Q_ASSERT(!"""");<KAIGYO>                    } else {<KAIGYO>                        Q_ASSERT(!"""");<KAIGYO>                    }<KAIGYO>                }<KAIGYO>            }<KAIGYO>        }<KAIGYO>    }<KAIGYO>}<KAIGYO><KAIGYO>void scheduleBlocks(QVector<BasicBlock *> &basicBlocks)<KAIGYO>{<KAIGYO>    // FIXME: this should not do DFS scheduling.<KAIGYO>    struct I {<KAIGYO>        QSet<BasicBlock *> visited;<KAIGYO>        QVector<BasicBlock *> &sequence;<KAIGYO><KAIGYO>        I(QVector<BasicBlock *> &sequence): sequence(sequence) {}<KAIGYO><KAIGYO>        void DFS(BasicBlock *bb) {<KAIGYO>            if (visited.contains(bb))<KAIGYO>                return;<KAIGYO>            visited.insert(bb);<KAIGYO>            sequence.append(bb);<KAIGYO>            if (Stmt *terminator = bb->terminator()) {<KAIGYO>                if (Jump *j = terminator->asJump()) {<KAIGYO>                    Q_ASSERT(bb->out.size() == 1);<KAIGYO>                    DFS(j->target);<KAIGYO>                } else if (CJump *cj = terminator->asCJump()) {<KAIGYO>                    Q_ASSERT(bb->out.size() == 2);<KAIGYO>                    DFS(cj->iftrue);<KAIGYO>                    DFS(cj->iffalse);<KAIGYO>                } else if (terminator->asRet()) {<KAIGYO>                    Q_ASSERT(bb->out.size() == 0);<KAIGYO>                    // nothing to do.<KAIGYO>                } else {<KAIGYO>                    Q_UNREACHABLE();<KAIGYO>                }<KAIGYO>            } else {<KAIGYO>                Q_UNREACHABLE();<KAIGYO>            }<KAIGYO>        }<KAIGYO>    };<KAIGYO><KAIGYO>    QVector<BasicBlock *> sequence;<KAIGYO>    sequence.reserve(basicBlocks.size());<KAIGYO>    I(sequence).DFS(basicBlocks.first());<KAIGYO>    qSwap(basicBlocks, sequence);<KAIGYO>}<KAIGYO><KAIGYO>/*<KAIGYO> * Quick function to convert out of SSA, so we can put the stuff through the ISel phases. This<KAIGYO> * has to be replaced by a phase in the specific ISel back-ends and do register allocation at the<KAIGYO> * same time. That way the huge number of redundant moves generated by this function are eliminated.<KAIGYO> */': 13, '            if (n && s->asCJump() /*&& s->asCJump()->iffalse != leader.value(n)*/) {<KAIGYO>                qout << """" << endl;<KAIGYO>            }<KAIGYO>        }<KAIGYO><KAIGYO>        qout << """" << endl<KAIGYO>             << endl;<KAIGYO>    }<KAIGYO>}<KAIGYO><KAIGYO>using namespace V4IR;<KAIGYO><KAIGYO>class DominatorTree {<KAIGYO>    int N = 0;<KAIGYO>    QHash<BasicBlock *, int> dfnum;<KAIGYO>    QVector<BasicBlock *> vertex;<KAIGYO>    QHash<BasicBlock *, BasicBlock *> parent;<KAIGYO>    QHash<BasicBlock *, BasicBlock *> ancestor;<KAIGYO>    QHash<BasicBlock *, BasicBlock *> best;<KAIGYO>    QHash<BasicBlock *, BasicBlock *> semi;<KAIGYO>    QHash<BasicBlock *, BasicBlock *> idom;<KAIGYO>    QHash<BasicBlock *, BasicBlock *> samedom;<KAIGYO>    QHash<BasicBlock *, QSet<BasicBlock *> > bucket;<KAIGYO><KAIGYO>    void DFS(BasicBlock *p, BasicBlock *n) {<KAIGYO>        if (dfnum[n] == 0) {<KAIGYO>            dfnum[n] = N;<KAIGYO>            vertex[N] = n;<KAIGYO>            parent[n] = p;<KAIGYO>            ++N;<KAIGYO>            foreach (BasicBlock *w, n->out)<KAIGYO>                DFS(n, w);<KAIGYO>        }<KAIGYO>    }<KAIGYO><KAIGYO>    BasicBlock *ancestorWithLowestSemi(BasicBlock *v) {<KAIGYO>        BasicBlock *a = ancestor[v];<KAIGYO>        if (ancestor[a]) {<KAIGYO>            BasicBlock *b = ancestorWithLowestSemi(a);<KAIGYO>            ancestor[v] = ancestor[a];<KAIGYO>            if (dfnum[semi[b]] < dfnum[semi[best[v]]])<KAIGYO>                best[v] = b;<KAIGYO>        }<KAIGYO>        return best[v];<KAIGYO>    }<KAIGYO><KAIGYO>    void link(BasicBlock *p, BasicBlock *n) {<KAIGYO>        ancestor[n] = p;<KAIGYO>        best[n] = n;<KAIGYO>    }<KAIGYO><KAIGYO>    void calculateIDoms(const QVector<BasicBlock *> &nodes) {<KAIGYO>        vertex.resize(nodes.size());<KAIGYO>        foreach (BasicBlock *n, nodes) {<KAIGYO>            dfnum[n] = 0;<KAIGYO>            semi[n] = 0;<KAIGYO>            ancestor[n] = 0;<KAIGYO>            idom[n] = 0;<KAIGYO>            samedom[n] = 0;<KAIGYO>        }<KAIGYO><KAIGYO>        DFS(0, nodes.first());<KAIGYO><KAIGYO>        for (int i = N - 1; i > 0; --i) {<KAIGYO>            BasicBlock *n = vertex[i];<KAIGYO>            BasicBlock *p = parent[n];<KAIGYO>            BasicBlock *s = p;<KAIGYO><KAIGYO>            foreach (BasicBlock *v, n->in) {<KAIGYO>                BasicBlock *ss;<KAIGYO>                if (dfnum[v] <= dfnum[s])<KAIGYO>                    ss = v;<KAIGYO>                else<KAIGYO>                    ss = semi[ancestorWithLowestSemi(v)];<KAIGYO>                if (dfnum[ss] < dfnum[s])<KAIGYO>                    s = ss;<KAIGYO>            }<KAIGYO>            semi[n] = s;<KAIGYO>            bucket[s].insert(n);<KAIGYO>            link(p, n);<KAIGYO>            foreach (BasicBlock *v, bucket[p]) {<KAIGYO>                BasicBlock *y = ancestorWithLowestSemi(v);<KAIGYO>                if (semi[y] == semi[v])<KAIGYO>                    idom[v] = p;<KAIGYO>                else<KAIGYO>                    samedom[v] = y;<KAIGYO>            }<KAIGYO>            bucket[p].clear();<KAIGYO>        }<KAIGYO>        for (int i = 1; i < N; ++i) {<KAIGYO>            BasicBlock *n = vertex[i];<KAIGYO>            if (BasicBlock *sdn = samedom[n])<KAIGYO>                idom[n] = idom[sdn];<KAIGYO>        }<KAIGYO><KAIGYO>#ifdef SHOW_SSA<KAIGYO>        qout << """" << endl;<KAIGYO>        foreach (BasicBlock *to, nodes) {<KAIGYO>            qout << \'\\t\';<KAIGYO>            if (BasicBlock *from = idom.value(to))<KAIGYO>                qout << from->index;<KAIGYO>            else<KAIGYO>                qout << """";<KAIGYO>            qout << """" << to->index << endl;<KAIGYO>        }<KAIGYO>#endif // SHOW_SSA<KAIGYO>    }<KAIGYO><KAIGYO>    bool dominates(BasicBlock *dominator, BasicBlock *dominated) const {<KAIGYO>        for (BasicBlock *it = dominated; it; it = idom[it]) {<KAIGYO>            if (it == dominator)<KAIGYO>                return true;<KAIGYO>        }<KAIGYO><KAIGYO>        return false;<KAIGYO>    }<KAIGYO><KAIGYO>    void computeDF(BasicBlock *n) {<KAIGYO>        if (DF.contains(n))<KAIGYO>            return; // TODO: verify this!<KAIGYO><KAIGYO>        QSet<BasicBlock *> S;<KAIGYO>        foreach (BasicBlock *y, n->out)<KAIGYO>            if (idom[y] != n)<KAIGYO>                S.insert(y);<KAIGYO><KAIGYO>        /*<KAIGYO>         * foreach child c of n in the dominator tree<KAIGYO>         *   computeDF[c]<KAIGYO>         *   foreach element w of DF[c]<KAIGYO>         *     if n does not dominate w or if n = w<KAIGYO>         *       S.insert(w)<KAIGYO>         * DF[n] = S;<KAIGYO>         */': 14, '            if (n && s->asCJump() /*&& s->asCJump()->iffalse != leader.value(n)*/) {<KAIGYO>                qout << """" << endl;<KAIGYO>            }<KAIGYO>        }<KAIGYO><KAIGYO>        qout << """" << endl<KAIGYO>             << endl;<KAIGYO>    }<KAIGYO>}<KAIGYO><KAIGYO>using namespace V4IR;<KAIGYO><KAIGYO>class DominatorTree {<KAIGYO>    int N = 0;<KAIGYO>    QHash<BasicBlock *, int> dfnum;<KAIGYO>    QVector<BasicBlock *> vertex;<KAIGYO>    QHash<BasicBlock *, BasicBlock *> parent;<KAIGYO>    QHash<BasicBlock *, BasicBlock *> ancestor;<KAIGYO>    QHash<BasicBlock *, BasicBlock *> best;<KAIGYO>    QHash<BasicBlock *, BasicBlock *> semi;<KAIGYO>    QHash<BasicBlock *, BasicBlock *> idom;<KAIGYO>    QHash<BasicBlock *, BasicBlock *> samedom;<KAIGYO>    QHash<BasicBlock *, QSet<BasicBlock *> > bucket;<KAIGYO><KAIGYO>    void DFS(BasicBlock *p, BasicBlock *n) {<KAIGYO>        if (dfnum[n] == 0) {<KAIGYO>            dfnum[n] = N;<KAIGYO>            vertex[N] = n;<KAIGYO>            parent[n] = p;<KAIGYO>            ++N;<KAIGYO>            foreach (BasicBlock *w, n->out)<KAIGYO>                DFS(n, w);<KAIGYO>        }<KAIGYO>    }<KAIGYO><KAIGYO>    BasicBlock *ancestorWithLowestSemi(BasicBlock *v) {<KAIGYO>        BasicBlock *a = ancestor[v];<KAIGYO>        if (ancestor[a]) {<KAIGYO>            BasicBlock *b = ancestorWithLowestSemi(a);<KAIGYO>            ancestor[v] = ancestor[a];<KAIGYO>            if (dfnum[semi[b]] < dfnum[semi[best[v]]])<KAIGYO>                best[v] = b;<KAIGYO>        }<KAIGYO>        return best[v];<KAIGYO>    }<KAIGYO><KAIGYO>    void link(BasicBlock *p, BasicBlock *n) {<KAIGYO>        ancestor[n] = p;<KAIGYO>        best[n] = n;<KAIGYO>    }<KAIGYO><KAIGYO>    void calculateIDoms(const QVector<BasicBlock *> &nodes) {<KAIGYO>        Q_ASSERT(nodes.first()->in.isEmpty());<KAIGYO>        vertex.resize(nodes.size());<KAIGYO>        foreach (BasicBlock *n, nodes) {<KAIGYO>            dfnum[n] = 0;<KAIGYO>            semi[n] = 0;<KAIGYO>            ancestor[n] = 0;<KAIGYO>            idom[n] = 0;<KAIGYO>            samedom[n] = 0;<KAIGYO>        }<KAIGYO><KAIGYO>        DFS(0, nodes.first());<KAIGYO>        Q_ASSERT(N == nodes.size()); // fails with unreachable nodes...<KAIGYO><KAIGYO>        for (int i = N - 1; i > 0; --i) {<KAIGYO>            BasicBlock *n = vertex[i];<KAIGYO>            BasicBlock *p = parent[n];<KAIGYO>            BasicBlock *s = p;<KAIGYO><KAIGYO>            foreach (BasicBlock *v, n->in) {<KAIGYO>                BasicBlock *ss;<KAIGYO>                if (dfnum[v] <= dfnum[n])<KAIGYO>                    ss = v;<KAIGYO>                else<KAIGYO>                    ss = semi[ancestorWithLowestSemi(v)];<KAIGYO>                if (dfnum[ss] < dfnum[s])<KAIGYO>                    s = ss;<KAIGYO>            }<KAIGYO>            semi[n] = s;<KAIGYO>            bucket[s].insert(n);<KAIGYO>            link(p, n);<KAIGYO>            foreach (BasicBlock *v, bucket[p]) {<KAIGYO>                BasicBlock *y = ancestorWithLowestSemi(v);<KAIGYO>                Q_ASSERT(semi[y] == p);<KAIGYO>                if (semi[y] == semi[v])<KAIGYO>                    idom[v] = p;<KAIGYO>                else<KAIGYO>                    samedom[v] = y;<KAIGYO>            }<KAIGYO>            bucket[p].clear();<KAIGYO>        }<KAIGYO>        for (int i = 1; i < N; ++i) {<KAIGYO>            BasicBlock *n = vertex[i];<KAIGYO>            Q_ASSERT(ancestor[n] && ((semi[n] && dfnum[ancestor[n]] <= dfnum[semi[n]]) || semi[n] == n));<KAIGYO>            Q_ASSERT(bucket[n].isEmpty());<KAIGYO>            if (BasicBlock *sdn = samedom[n])<KAIGYO>                idom[n] = idom[sdn];<KAIGYO>        }<KAIGYO><KAIGYO>#ifdef SHOW_SSA<KAIGYO>        qout << """" << endl;<KAIGYO>        foreach (BasicBlock *to, nodes) {<KAIGYO>            qout << \'\\t\';<KAIGYO>            if (BasicBlock *from = idom.value(to))<KAIGYO>                qout << from->index;<KAIGYO>            else<KAIGYO>                qout << """";<KAIGYO>            qout << """" << to->index << endl;<KAIGYO>        }<KAIGYO>#endif // SHOW_SSA<KAIGYO>    }<KAIGYO><KAIGYO>    bool dominates(BasicBlock *dominator, BasicBlock *dominated) const {<KAIGYO>        for (BasicBlock *it = dominated; it; it = idom[it]) {<KAIGYO>            if (it == dominator)<KAIGYO>                return true;<KAIGYO>        }<KAIGYO><KAIGYO>        return false;<KAIGYO>    }<KAIGYO><KAIGYO>    void computeDF(BasicBlock *n) {<KAIGYO>        if (DF.contains(n))<KAIGYO>            return; // TODO: verify this!<KAIGYO><KAIGYO>        QSet<BasicBlock *> S;<KAIGYO>        foreach (BasicBlock *y, n->out)<KAIGYO>            if (idom[y] != n)<KAIGYO>                S.insert(y);<KAIGYO><KAIGYO>        /*<KAIGYO>         * foreach child c of n in the dominator tree<KAIGYO>         *   computeDF[c]<KAIGYO>         *   foreach element w of DF[c]<KAIGYO>         *     if n does not dominate w or if n = w<KAIGYO>         *       S.insert(w)<KAIGYO>         * DF[n] = S;<KAIGYO>         */': 17, '    virtual void visitTry(Try *s) { /* this should never happen */ }<KAIGYO><KAIGYO>    virtual void visitConst(Const *) {}<KAIGYO>    virtual void visitString(String *) {}<KAIGYO>    virtual void visitRegExp(RegExp *) {}<KAIGYO>    virtual void visitName(Name *) {}<KAIGYO>    virtual void visitClosure(Closure *) {}<KAIGYO>    virtual void visitUnop(Unop *e) { e->expr->accept(this); }<KAIGYO>    virtual void visitBinop(Binop *e) { e->left->accept(this); e->right->accept(this); }<KAIGYO>    virtual void visitCall(Call *e) {<KAIGYO>        e->base->accept(this);<KAIGYO>        for (ExprList *it = e->args; it; it = it->next)<KAIGYO>            it->expr->accept(this);<KAIGYO>    }<KAIGYO><KAIGYO>    virtual void visitNew(New *e) {<KAIGYO>        e->base->accept(this);<KAIGYO>        for (ExprList *it = e->args; it; it = it->next)<KAIGYO>            it->expr->accept(this);<KAIGYO>    }<KAIGYO><KAIGYO>    virtual void visitSubscript(Subscript *e) {<KAIGYO>        e->base->accept(this);<KAIGYO>        e->index->accept(this);<KAIGYO>    }<KAIGYO><KAIGYO>    virtual void visitMember(Member *e) {<KAIGYO>        e->base->accept(this);<KAIGYO>    }<KAIGYO>};<KAIGYO><KAIGYO>QHash<int, int> convertToSSA(Function *function)<KAIGYO>{<KAIGYO>#ifdef SHOW_SSA<KAIGYO>    qout << """";<KAIGYO>    if (function->name)<KAIGYO>        qout << *function->name;<KAIGYO>    else<KAIGYO>        qout << """";<KAIGYO>    qout << """" << endl;<KAIGYO>#endif // SHOW_SSA<KAIGYO><KAIGYO>    QVector<BasicBlock *> &nodes = function->basicBlocks;<KAIGYO><KAIGYO>    // Calculate the dominator tree:<KAIGYO>    DominatorTree df(nodes);<KAIGYO><KAIGYO>    // Collect all applicable variables:<KAIGYO>    VariableCollector variables(function);<KAIGYO><KAIGYO>    // Place phi functions:<KAIGYO>    QHash<BasicBlock *, QSet<int> > A_phi;<KAIGYO>    foreach (int a, variables.vars()) {<KAIGYO>        if (!variables.isNonLocal(a))<KAIGYO>            continue; // for semi-pruned SSA<KAIGYO><KAIGYO>        QList<BasicBlock *> W = QList<BasicBlock *>::fromSet(variables.defsite(a));<KAIGYO>        while (!W.isEmpty()) {<KAIGYO>            BasicBlock *n = W.first();<KAIGYO>            W.removeFirst();<KAIGYO>            foreach (BasicBlock *y, df[n]) {<KAIGYO>                if (!A_phi[y].contains(a)) {<KAIGYO>                    insertPhiNode(a, y, function);<KAIGYO>                    A_phi[y].insert(a);<KAIGYO>                    if (!variables.inBlock(y).contains(a))<KAIGYO>                        W.append(y);<KAIGYO>                }<KAIGYO>            }<KAIGYO>        }<KAIGYO>    }<KAIGYO><KAIGYO>    // Rename variables:<KAIGYO>    return VariableRenamer(function).run();<KAIGYO>}<KAIGYO><KAIGYO>class DefUsesCalculator: public StmtVisitor, public ExprVisitor {<KAIGYO>public:<KAIGYO>    struct DefUse {<KAIGYO>        Stmt *defStmt;<KAIGYO>        BasicBlock *blockOfStatement;<KAIGYO>        QList<Stmt *> uses;<KAIGYO>    };<KAIGYO><KAIGYO>private:<KAIGYO>    int _lastUncollectible;<KAIGYO>    QHash<int, DefUse> _defUses;<KAIGYO>    QHash<Stmt *, QList<int> > _usesPerStatement;<KAIGYO><KAIGYO>    BasicBlock *_block;<KAIGYO>    Stmt *_stmt;<KAIGYO><KAIGYO>    void addUse(Temp *t) {<KAIGYO>        Q_ASSERT(t);<KAIGYO>        if (t->scope || t->index <= _lastUncollectible)<KAIGYO>            return;<KAIGYO><KAIGYO>        _defUses[t->index].uses.append(_stmt);<KAIGYO>        _usesPerStatement[_stmt].append(t->index);<KAIGYO>    }<KAIGYO><KAIGYO>    void addDef(Temp *t) {<KAIGYO>        if (t->scope || t->index <= _lastUncollectible)<KAIGYO>            return;<KAIGYO><KAIGYO>        DefUse &defUse = _defUses[t->index];<KAIGYO>        defUse.defStmt = _stmt;<KAIGYO>        defUse.blockOfStatement = _block;<KAIGYO>    }<KAIGYO><KAIGYO>public:<KAIGYO>    DefUsesCalculator(Function *function) {<KAIGYO>        if (function->variablesCanEscape())<KAIGYO>            _lastUncollectible = function->locals.size() - 1;<KAIGYO>        else<KAIGYO>            _lastUncollectible = -1;<KAIGYO><KAIGYO>        foreach (BasicBlock *bb, function->basicBlocks) {<KAIGYO>            _block = bb;<KAIGYO>            foreach (Stmt *stmt, bb->statements) {<KAIGYO>                _stmt = stmt;<KAIGYO>                stmt->accept(this);<KAIGYO>            }<KAIGYO>        }<KAIGYO><KAIGYO>        QMutableHashIterator<int, DefUse> it(_defUses);<KAIGYO>        while (it.hasNext()) {<KAIGYO>            it.next();<KAIGYO>            if (!it.value().defStmt)<KAIGYO>                it.remove();<KAIGYO>        }<KAIGYO>    }<KAIGYO><KAIGYO>    QList<int> defs() const {<KAIGYO>        return _defUses.keys();<KAIGYO>    }<KAIGYO><KAIGYO>    void removeDef(int var) {<KAIGYO>        _defUses.remove(var);<KAIGYO>    }<KAIGYO><KAIGYO>    void addUses(int variable, QList<Stmt *>newUses)<KAIGYO>    { _defUses[variable].uses.append(newUses); }<KAIGYO><KAIGYO>    int useCount(int variable) const<KAIGYO>    { return _defUses[variable].uses.size(); }<KAIGYO><KAIGYO>    Stmt *defStmt(int variable) const<KAIGYO>    { return _defUses[variable].defStmt; }<KAIGYO><KAIGYO>    BasicBlock *defStmtBlock(int variable) const<KAIGYO>    { return _defUses[variable].blockOfStatement; }<KAIGYO><KAIGYO>    void removeUse(Stmt *usingStmt, int var)<KAIGYO>    { _defUses[var].uses.removeAll(usingStmt); }<KAIGYO><KAIGYO>    QList<int> usedVars(Stmt *s) const<KAIGYO>    { return _usesPerStatement[s]; }<KAIGYO><KAIGYO>    QList<Stmt *> uses(int var) const<KAIGYO>    { return _defUses[var].uses; }<KAIGYO><KAIGYO>    void dump() const<KAIGYO>    {<KAIGYO>        foreach (int var, _defUses.keys()) {<KAIGYO>            const DefUse &du = _defUses[var];<KAIGYO>            qout<<var<<"""";<KAIGYO>            du.defStmt->dump(qout);<KAIGYO>            qout<<endl<<""""<<endl;<KAIGYO>            foreach (Stmt *s, du.uses) {<KAIGYO>                qout<<"""";s->dump(qout);qout<<endl;<KAIGYO>            }<KAIGYO>        }<KAIGYO>    }<KAIGYO><KAIGYO>protected:<KAIGYO>    virtual void visitExp(Exp *s) { s->expr->accept(this); }<KAIGYO>    virtual void visitEnter(Enter *) {}<KAIGYO>    virtual void visitLeave(Leave *) {}<KAIGYO>    virtual void visitJump(Jump *) {}<KAIGYO>    virtual void visitCJump(CJump *s) { s->cond->accept(this); }<KAIGYO>    virtual void visitRet(Ret *s) { s->expr->accept(this); }<KAIGYO>    virtual void visitTry(Try *) {}<KAIGYO><KAIGYO>    virtual void visitPhi(Phi *s) {<KAIGYO>        addDef(s->targetTemp);<KAIGYO>        foreach (Expr *e, s->incoming)<KAIGYO>            addUse(e->asTemp());<KAIGYO>    }<KAIGYO><KAIGYO>    virtual void visitMove(Move *s) {<KAIGYO>        if (Temp *t = s->target->asTemp())<KAIGYO>            addDef(t);<KAIGYO>        else<KAIGYO>            s->target->accept(this);<KAIGYO><KAIGYO>        s->source->accept(this);<KAIGYO>    }<KAIGYO><KAIGYO>    virtual void visitTemp(Temp *e) { addUse(e); }<KAIGYO><KAIGYO>    virtual void visitConst(Const *) {}<KAIGYO>    virtual void visitString(String *) {}<KAIGYO>    virtual void visitRegExp(RegExp *) {}<KAIGYO>    virtual void visitName(Name *) {}<KAIGYO>    virtual void visitClosure(Closure *) {}<KAIGYO>    virtual void visitUnop(Unop *e) { e->expr->accept(this); }<KAIGYO>    virtual void visitBinop(Binop *e) { e->left->accept(this); e->right->accept(this); }<KAIGYO>    virtual void visitSubscript(Subscript *e) { e->base->accept(this); e->index->accept(this); }<KAIGYO>    virtual void visitMember(Member *e) { e->base->accept(this); }<KAIGYO>    virtual void visitCall(Call *e) {<KAIGYO>        e->base->accept(this);<KAIGYO>        for (ExprList *it = e->args; it; it = it->next)<KAIGYO>            it->expr->accept(this);<KAIGYO>    }<KAIGYO><KAIGYO>    virtual void visitNew(New *e) {<KAIGYO>        e->base->accept(this);<KAIGYO>        for (ExprList *it = e->args; it; it = it->next)<KAIGYO>            it->expr->accept(this);<KAIGYO>    }<KAIGYO>};<KAIGYO><KAIGYO>bool hasPhiOnlyUses(Phi *phi, const DefUsesCalculator &defUses, QSet<Phi *> &collectedPhis)<KAIGYO>{<KAIGYO>    collectedPhis.insert(phi);<KAIGYO>    foreach (Stmt *use, defUses.uses(phi->targetTemp->index)) {<KAIGYO>        if (Phi *dependentPhi = use->asPhi()) {<KAIGYO>            if (!collectedPhis.contains(dependentPhi)) {<KAIGYO>                if (!hasPhiOnlyUses(dependentPhi, defUses, collectedPhis))<KAIGYO>                    return false;<KAIGYO>            }<KAIGYO>        } else {<KAIGYO>            return false;<KAIGYO>        }<KAIGYO>    }<KAIGYO>    return true;<KAIGYO>}<KAIGYO><KAIGYO>void cleanupPhis(DefUsesCalculator &defUses)<KAIGYO>{<KAIGYO>    QLinkedList<Phi *> phis;<KAIGYO>    foreach (int def, defUses.defs())<KAIGYO>        if (Phi *phi = defUses.defStmt(def)->asPhi())<KAIGYO>            phis.append(phi);<KAIGYO><KAIGYO>    QSet<Phi *> toRemove;<KAIGYO>    while (!phis.isEmpty()) {<KAIGYO>        Phi *phi = phis.first();<KAIGYO>        phis.removeFirst();<KAIGYO>        if (toRemove.contains(phi))<KAIGYO>            continue;<KAIGYO>        QSet<Phi *> collectedPhis;<KAIGYO>        if (hasPhiOnlyUses(phi, defUses, collectedPhis))<KAIGYO>            toRemove.unite(collectedPhis);<KAIGYO>    }<KAIGYO><KAIGYO>    foreach (Phi *phi, toRemove) {<KAIGYO>        int targetVar = phi->targetTemp->index;<KAIGYO><KAIGYO>        BasicBlock *bb = defUses.defStmtBlock(targetVar);<KAIGYO>        int idx = bb->statements.indexOf(phi);<KAIGYO>        bb->statements.remove(idx);<KAIGYO><KAIGYO>        foreach (int usedVar, defUses.usedVars(phi))<KAIGYO>            defUses.removeUse(phi, usedVar);<KAIGYO>        defUses.removeDef(targetVar);<KAIGYO>    }<KAIGYO>}<KAIGYO><KAIGYO>class DeadCodeElimination: public ExprVisitor {<KAIGYO>    int _lastUncollectible;<KAIGYO>    DefUsesCalculator &_defUses;<KAIGYO>    QVector<int> _worklist;<KAIGYO><KAIGYO>public:<KAIGYO>    DeadCodeElimination(DefUsesCalculator &defUses, Function *function)<KAIGYO>        : _defUses(defUses)<KAIGYO>    {<KAIGYO>        _worklist = QVector<int>::fromList(_defUses.defs());<KAIGYO><KAIGYO>        if (function->variablesCanEscape())<KAIGYO>            _lastUncollectible = function->locals.size() - 1;<KAIGYO>        else<KAIGYO>            _lastUncollectible = -1;<KAIGYO>    }<KAIGYO><KAIGYO>    void run() {<KAIGYO>        while (!_worklist.isEmpty()) {<KAIGYO>            const int v = _worklist.first();<KAIGYO>            _worklist.removeFirst();<KAIGYO><KAIGYO>            if (_defUses.useCount(v) == 0) {<KAIGYO>//                qDebug()<<"""";<KAIGYO>                Stmt *s = _defUses.defStmt(v);<KAIGYO>                if (!s) {<KAIGYO>                    _defUses.removeDef(v);<KAIGYO>                } else if (!hasSideEffect(s)) {<KAIGYO>//                    qDebug()<<"""";<KAIGYO>                    QVector<Stmt *> &stmts = _defUses.defStmtBlock(v)->statements;<KAIGYO>                    int idx = stmts.indexOf(s);<KAIGYO>                    if (idx != -1)<KAIGYO>                        stmts.remove(idx);<KAIGYO>                    foreach (int usedVar, _defUses.usedVars(s)) {<KAIGYO>                        _defUses.removeUse(s, usedVar);<KAIGYO>                        _worklist.append(usedVar);<KAIGYO>                    }<KAIGYO>                    _defUses.removeDef(v);<KAIGYO>                }<KAIGYO>            }<KAIGYO>        }<KAIGYO><KAIGYO>#ifdef SHOW_SSA<KAIGYO>        qout<<"""";<KAIGYO>        _defUses.dump();<KAIGYO>#endif<KAIGYO>    }<KAIGYO><KAIGYO>private:<KAIGYO>    bool _sideEffect;<KAIGYO><KAIGYO>    bool hasSideEffect(Stmt *s) {<KAIGYO>        // TODO: check if this can be moved to IR building.<KAIGYO>        _sideEffect = false;<KAIGYO>        if (Move *move = s->asMove()) {<KAIGYO>            if (Temp *t = move->target->asTemp())<KAIGYO>                if (t->index <= _lastUncollectible || t->scope)<KAIGYO>                    return true;<KAIGYO>            move->source->accept(this);<KAIGYO>        }<KAIGYO>        return _sideEffect;<KAIGYO>    }<KAIGYO><KAIGYO>protected:<KAIGYO>    virtual void visitConst(Const *) {}<KAIGYO>    virtual void visitString(String *) {}<KAIGYO>    virtual void visitRegExp(RegExp *) {}<KAIGYO>    virtual void visitName(Name *e) {<KAIGYO>        // TODO: maybe we can distinguish between built-ins of which we know that they do not have<KAIGYO>        // a side-effect.<KAIGYO>        if (e->builtin == Name::builtin_invalid || (e->id && *e->id != QStringLiteral("""")))<KAIGYO>            _sideEffect = true;<KAIGYO>    }<KAIGYO>    virtual void visitTemp(Temp *e) {<KAIGYO>    }<KAIGYO>    virtual void visitClosure(Closure *) {}<KAIGYO>    virtual void visitUnop(Unop *e) {<KAIGYO>        switch (e->op) {<KAIGYO>        case V4IR::OpIncrement:<KAIGYO>        case V4IR::OpDecrement:<KAIGYO>            _sideEffect = true;<KAIGYO>            break;<KAIGYO><KAIGYO>        default:<KAIGYO>            break;<KAIGYO>        }<KAIGYO><KAIGYO>        if (!_sideEffect) e->expr->accept(this);<KAIGYO>    }<KAIGYO>    virtual void visitBinop(Binop *e) { if (!_sideEffect) e->left->accept(this); if (!_sideEffect) e->right->accept(this); }<KAIGYO>    virtual void visitSubscript(Subscript *e) {<KAIGYO>        // TODO: see if we can have subscript accesses without side effect<KAIGYO>        _sideEffect = true;<KAIGYO>    }<KAIGYO>    virtual void visitMember(Member *e) {<KAIGYO>        // TODO: see if we can have member accesses without side effect<KAIGYO>        _sideEffect = true;<KAIGYO>    }<KAIGYO>    virtual void visitCall(Call *e) {<KAIGYO>        _sideEffect = true; // TODO: there are built-in functions that have no side effect.<KAIGYO>    }<KAIGYO>    virtual void visitNew(New *e) {<KAIGYO>        _sideEffect = true; // TODO: there are built-in types that have no side effect.<KAIGYO>    }<KAIGYO>};<KAIGYO><KAIGYO>class TypeInference: public StmtVisitor, public ExprVisitor {<KAIGYO>    const DefUsesCalculator &_defUses;<KAIGYO>    QHash<int, int> _tempTypes;<KAIGYO>    QSet<Stmt *> _worklist;<KAIGYO>    struct TypingResult {<KAIGYO>        int type;<KAIGYO>        bool fullyTyped;<KAIGYO><KAIGYO>        TypingResult(int type, bool fullyTyped): type(type), fullyTyped(fullyTyped) {}<KAIGYO>        explicit TypingResult(int type = UnknownType): type(type), fullyTyped(type != UnknownType) {}<KAIGYO>    };<KAIGYO>    TypingResult _ty;<KAIGYO>    int _localCount;<KAIGYO><KAIGYO>public:<KAIGYO>    TypeInference(const DefUsesCalculator &defUses): _defUses(defUses), _ty(UnknownType) {}<KAIGYO><KAIGYO>    void run(Function *function) {<KAIGYO>        _localCount = function->variablesCanEscape() ? function->locals.size() : 0;<KAIGYO><KAIGYO>        // TODO: the worklist handling looks a bit inefficient... check if there is something better<KAIGYO>        _worklist.clear();<KAIGYO>        for (int i = 0, ei = function->basicBlocks.size(); i != ei; ++i) {<KAIGYO>            BasicBlock *bb = function->basicBlocks[i];<KAIGYO>            if (i == 0 || !bb->in.isEmpty())<KAIGYO>                foreach (Stmt *s, bb->statements)<KAIGYO>                    _worklist.insert(s);<KAIGYO>        }<KAIGYO><KAIGYO>        while (!_worklist.isEmpty()) {<KAIGYO>            QList<Stmt *> worklist = _worklist.values();<KAIGYO>            _worklist.clear();<KAIGYO>            while (!worklist.isEmpty()) {<KAIGYO>                Stmt *s = worklist.first();<KAIGYO>                worklist.removeFirst();<KAIGYO>#if defined(SHOW_SSA)<KAIGYO>                qout<<"""";s->dump(qout);qout<<endl;<KAIGYO>#endif<KAIGYO><KAIGYO>                if (!run(s)) {<KAIGYO>                    _worklist.insert(s);<KAIGYO>#if defined(SHOW_SSA)<KAIGYO>                    qout<<"""";<KAIGYO>                    s->dump(qout);qout<<endl;<KAIGYO>                } else {<KAIGYO>                    qout<<"""";<KAIGYO>                    s->dump(qout);qout<<endl;<KAIGYO>#endif<KAIGYO>                }<KAIGYO>            }<KAIGYO>        }<KAIGYO>    }<KAIGYO><KAIGYO>private:<KAIGYO>    bool run(Stmt *s) {<KAIGYO>        TypingResult ty;<KAIGYO>        std::swap(_ty, ty);<KAIGYO>        s->accept(this);<KAIGYO>        std::swap(_ty, ty);<KAIGYO>        return ty.fullyTyped;<KAIGYO>    }<KAIGYO><KAIGYO>    TypingResult run(Expr *e) {<KAIGYO>        TypingResult ty;<KAIGYO>        std::swap(_ty, ty);<KAIGYO>        e->accept(this);<KAIGYO>        std::swap(_ty, ty);<KAIGYO><KAIGYO>        if (ty.type != UnknownType)<KAIGYO>            setType(e, ty.type);<KAIGYO>        return ty;<KAIGYO>    }<KAIGYO><KAIGYO>    void setType(Expr *e, int ty) {<KAIGYO>        if (Temp *t = e->asTemp()) {<KAIGYO>#if defined(SHOW_SSA)<KAIGYO>            qout<<"""" << endl;<KAIGYO>#endif<KAIGYO>            if (t->scope || t->index < _localCount) {<KAIGYO>                e->type = ObjectType;<KAIGYO>            } else {<KAIGYO>                e->type = (Type) ty;<KAIGYO><KAIGYO>                if (_tempTypes[t->index] != ty) {<KAIGYO>                    _tempTypes[t->index] = ty;<KAIGYO><KAIGYO>#if defined(SHOW_SSA)<KAIGYO>                    foreach (Stmt *s, _defUses.uses(t->index)) {<KAIGYO>                        qout << """";<KAIGYO>                        s->dump(qout);<KAIGYO>                        qout << endl;<KAIGYO>                    }<KAIGYO>#endif<KAIGYO><KAIGYO>                    _worklist += QSet<Stmt *>::fromList(_defUses.uses(t->index));<KAIGYO>                }<KAIGYO>            }<KAIGYO>        } else {<KAIGYO>            e->type = (Type) ty;<KAIGYO>        }<KAIGYO>    }<KAIGYO><KAIGYO>protected:<KAIGYO>    virtual void visitConst(Const *e) { _ty = TypingResult(e->type); }<KAIGYO>    virtual void visitString(String *) { _ty = TypingResult(StringType); }<KAIGYO>    virtual void visitRegExp(RegExp *) { _ty = TypingResult(ObjectType); }<KAIGYO>    virtual void visitName(Name *) { _ty = TypingResult(ObjectType); }<KAIGYO>    virtual void visitTemp(Temp *e) {<KAIGYO>        if (e->scope)<KAIGYO>            _ty = TypingResult(ObjectType);<KAIGYO>        else if (e->index < _localCount)<KAIGYO>            _ty = TypingResult(ObjectType);<KAIGYO>        else<KAIGYO>            _ty = TypingResult(_tempTypes.value(e->index, UnknownType));<KAIGYO>        setType(e, _ty.type);<KAIGYO>    }<KAIGYO>    virtual void visitClosure(Closure *) { _ty = TypingResult(ObjectType); } // TODO: VERIFY THIS!<KAIGYO>    virtual void visitUnop(Unop *e) {<KAIGYO>        _ty = run(e->expr);<KAIGYO>        switch (e->op) {<KAIGYO>        case OpUPlus: _ty.type = DoubleType; return;<KAIGYO>        case OpUMinus: _ty.type = DoubleType; return;<KAIGYO>        case OpCompl: _ty.type = SInt32Type; return;<KAIGYO>        case OpNot: _ty.type = BoolType; return;<KAIGYO><KAIGYO>        case OpIncrement:<KAIGYO>        case OpDecrement:<KAIGYO>            Q_ASSERT(!"""");<KAIGYO>        default:<KAIGYO>            Q_UNIMPLEMENTED();<KAIGYO>            Q_UNREACHABLE();<KAIGYO>        }<KAIGYO>    }<KAIGYO><KAIGYO>    virtual void visitBinop(Binop *e) {<KAIGYO>        TypingResult leftTy = run(e->left);<KAIGYO>        TypingResult rightTy = run(e->right);<KAIGYO>        _ty.fullyTyped = leftTy.fullyTyped && rightTy.fullyTyped;<KAIGYO><KAIGYO>        switch (e->op) {<KAIGYO>        case OpAdd:<KAIGYO>            if (leftTy.type & StringType || rightTy.type & StringType)<KAIGYO>                _ty.type = StringType;<KAIGYO>            else if (leftTy.type != UnknownType && rightTy.type != UnknownType)<KAIGYO>                _ty.type = DoubleType;<KAIGYO>            else<KAIGYO>                _ty.type = UnknownType;<KAIGYO>            break;<KAIGYO>        case OpSub:<KAIGYO>            _ty.type = DoubleType;<KAIGYO>            break;<KAIGYO><KAIGYO>        case OpMul:<KAIGYO>        case OpDiv:<KAIGYO>        case OpMod:<KAIGYO>            _ty.type = DoubleType;<KAIGYO>            break;<KAIGYO><KAIGYO>        case OpBitAnd:<KAIGYO>        case OpBitOr:<KAIGYO>        case OpBitXor:<KAIGYO>        case OpLShift:<KAIGYO>        case OpRShift:<KAIGYO>            _ty.type = SInt32Type;<KAIGYO>            break;<KAIGYO>        case OpURShift:<KAIGYO>            _ty.type = UInt32Type;<KAIGYO>            break;<KAIGYO><KAIGYO>        case OpGt:<KAIGYO>        case OpLt:<KAIGYO>        case OpGe:<KAIGYO>        case OpLe:<KAIGYO>        case OpEqual:<KAIGYO>        case OpNotEqual:<KAIGYO>        case OpStrictEqual:<KAIGYO>        case OpStrictNotEqual:<KAIGYO>        case OpAnd:<KAIGYO>        case OpOr:<KAIGYO>        case OpInstanceof:<KAIGYO>        case OpIn:<KAIGYO>            _ty.type = BoolType;<KAIGYO>            break;<KAIGYO><KAIGYO>        default:<KAIGYO>            Q_UNIMPLEMENTED();<KAIGYO>            Q_UNREACHABLE();<KAIGYO>        }<KAIGYO>    }<KAIGYO><KAIGYO>    virtual void visitCall(Call *e) {<KAIGYO>        _ty = run(e->base);<KAIGYO>        for (ExprList *it = e->args; it; it = it->next)<KAIGYO>            _ty.fullyTyped &= run(it->expr).fullyTyped;<KAIGYO>        _ty.type = ObjectType;<KAIGYO>    }<KAIGYO>    virtual void visitNew(New *e) {<KAIGYO>        _ty = run(e->base);<KAIGYO>        for (ExprList *it = e->args; it; it = it->next)<KAIGYO>            _ty.fullyTyped &= run(it->expr).fullyTyped;<KAIGYO>        _ty.type = ObjectType;<KAIGYO>    }<KAIGYO>    virtual void visitSubscript(Subscript *e) {<KAIGYO>        _ty.fullyTyped = run(e->base).fullyTyped && run(e->index).fullyTyped;<KAIGYO>        _ty.type = ObjectType;<KAIGYO>    }<KAIGYO><KAIGYO>    virtual void visitMember(Member *e) {<KAIGYO>        // TODO: for QML, try to do a static lookup<KAIGYO>        _ty = run(e->base);<KAIGYO>        _ty.type = ObjectType;<KAIGYO>    }<KAIGYO><KAIGYO>    virtual void visitExp(Exp *s) { _ty = run(s->expr); }<KAIGYO>    virtual void visitEnter(Enter *s) { _ty = run(s->expr); }<KAIGYO>    virtual void visitLeave(Leave *) { _ty = TypingResult(MissingType); }<KAIGYO>    virtual void visitMove(Move *s) {<KAIGYO>        TypingResult sourceTy = run(s->source);<KAIGYO>        Q_ASSERT(s->op == OpInvalid);<KAIGYO>        if (Temp *t = s->target->asTemp()) {<KAIGYO>            setType(t, sourceTy.type);<KAIGYO>            _ty = sourceTy;<KAIGYO>            return;<KAIGYO>        }<KAIGYO><KAIGYO>        _ty = run(s->target);<KAIGYO>        _ty.fullyTyped &= sourceTy.fullyTyped;<KAIGYO>    }<KAIGYO><KAIGYO>    virtual void visitJump(Jump *) { _ty = TypingResult(MissingType); }<KAIGYO>    virtual void visitCJump(CJump *s) { _ty = run(s->cond); }<KAIGYO>    virtual void visitRet(Ret *s) { _ty = run(s->expr); }<KAIGYO>    virtual void visitTry(Try *s) { setType(s->exceptionVar, ObjectType); _ty = TypingResult(MissingType); }<KAIGYO>    virtual void visitPhi(Phi *s) {<KAIGYO>        _ty = run(s->incoming[0]);<KAIGYO>        for (int i = 1, ei = s->incoming.size(); i != ei; ++i) {<KAIGYO>            TypingResult ty = run(s->incoming[i]);<KAIGYO>            _ty.type |= ty.type;<KAIGYO>            _ty.fullyTyped &= ty.fullyTyped;<KAIGYO>        }<KAIGYO><KAIGYO>        // TODO: check & double check the next condition!<KAIGYO>        if (_ty.type & ObjectType || _ty.type & UndefinedType || _ty.type & NullType)<KAIGYO>            _ty.type = ObjectType;<KAIGYO>        else if (_ty.type & NumberType)<KAIGYO>            _ty.type = DoubleType;<KAIGYO><KAIGYO>        setType(s->targetTemp, _ty.type);<KAIGYO>    }<KAIGYO>};<KAIGYO><KAIGYO>class TypePropagation: public StmtVisitor, public ExprVisitor {<KAIGYO>    Type _ty;<KAIGYO><KAIGYO>    void run(Expr *e, Type requestedType = UnknownType) {<KAIGYO>        qSwap(_ty, requestedType);<KAIGYO>        e->accept(this);<KAIGYO>        qSwap(_ty, requestedType);<KAIGYO>    }<KAIGYO><KAIGYO>public:<KAIGYO>    TypePropagation() : _ty(UnknownType) {}<KAIGYO><KAIGYO>    void run(Function *f) {<KAIGYO>        foreach (BasicBlock *bb, f->basicBlocks)<KAIGYO>            foreach (Stmt *s, bb->statements)<KAIGYO>                s->accept(this);<KAIGYO>    }<KAIGYO><KAIGYO>protected:<KAIGYO>    virtual void visitConst(Const *c) {<KAIGYO>        if (_ty & NumberType && c->type & NumberType) {<KAIGYO>            c->type = _ty;<KAIGYO>        }<KAIGYO>    }<KAIGYO><KAIGYO>    virtual void visitString(String *) {}<KAIGYO>    virtual void visitRegExp(RegExp *) {}<KAIGYO>    virtual void visitName(Name *) {}<KAIGYO>    virtual void visitTemp(Temp *) {}<KAIGYO>    virtual void visitClosure(Closure *) {}<KAIGYO>    virtual void visitUnop(Unop *e) { run(e->expr, e->type); }<KAIGYO>    virtual void visitBinop(Binop *e) { run(e->left, e->type); run(e->right, e->type); }<KAIGYO>    virtual void visitCall(Call *e) {<KAIGYO>        run(e->base);<KAIGYO>        for (ExprList *it = e->args; it; it = it->next)<KAIGYO>            run(it->expr);<KAIGYO>    }<KAIGYO>    virtual void visitNew(New *e) {<KAIGYO>        run(e->base);<KAIGYO>        for (ExprList *it = e->args; it; it = it->next)<KAIGYO>            run(it->expr);<KAIGYO>    }<KAIGYO>    virtual void visitSubscript(Subscript *e) { run(e->base); run(e->index); }<KAIGYO>    virtual void visitMember(Member *e) { run(e->base); }<KAIGYO>    virtual void visitExp(Exp *s) { run(s->expr); }<KAIGYO>    virtual void visitEnter(Enter *s) { run(s->expr); }<KAIGYO>    virtual void visitLeave(Leave *) {}<KAIGYO>    virtual void visitMove(Move *s) {<KAIGYO>        run(s->target);<KAIGYO>        run(s->source, s->target->type);<KAIGYO>    }<KAIGYO>    virtual void visitJump(Jump *) {}<KAIGYO>    virtual void visitCJump(CJump *s) {<KAIGYO>        run(s->cond, BoolType);<KAIGYO>    }<KAIGYO>    virtual void visitRet(Ret *s) { run(s->expr); }<KAIGYO>    virtual void visitTry(Try *) {}<KAIGYO>    virtual void visitPhi(Phi *s) {<KAIGYO>        Type ty = s->targetTemp->type;<KAIGYO>        foreach (Expr *e, s->incoming)<KAIGYO>            run(e, ty);<KAIGYO>    }<KAIGYO>};<KAIGYO><KAIGYO>void insertMove(Function *function, BasicBlock *basicBlock, Temp *target, Expr *source) {<KAIGYO>    Move *s = function->New<Move>();<KAIGYO>    s->init(target, source, OpInvalid);<KAIGYO>    basicBlock->statements.insert(basicBlock->statements.size() - 1, s);<KAIGYO>}<KAIGYO><KAIGYO>bool doEdgeSplitting(Function *f)<KAIGYO>{<KAIGYO>    const QVector<BasicBlock *> oldBBs = f->basicBlocks;<KAIGYO><KAIGYO>    foreach (BasicBlock *bb, oldBBs) {<KAIGYO>        if (bb->in.size() > 1) {<KAIGYO>            for (int inIdx = 0, eInIdx = bb->in.size(); inIdx != eInIdx; ++inIdx) {<KAIGYO>                BasicBlock *inBB = bb->in[inIdx];<KAIGYO>                if (inBB->out.size() > 1) { // this should have been split!<KAIGYO>#if defined(SHOW_SSA)<KAIGYO>                    qDebug() << """" << bb->index;<KAIGYO>#endif<KAIGYO><KAIGYO>                    // create the basic block:<KAIGYO>                    BasicBlock *newBB = new BasicBlock(f);<KAIGYO>                    newBB->index = f->basicBlocks.last()->index + 1;<KAIGYO>                    f->basicBlocks.append(newBB);<KAIGYO>                    Jump *s = f->New<Jump>();<KAIGYO>                    s->init(bb);<KAIGYO>                    newBB->statements.append(s);<KAIGYO><KAIGYO>                    // rewire the old outgoing edge<KAIGYO>                    int outIdx = inBB->out.indexOf(bb);<KAIGYO>                    inBB->out[outIdx] = newBB;<KAIGYO>                    newBB->in.append(inBB);<KAIGYO><KAIGYO>                    // rewire the old incoming edge<KAIGYO>                    bb->in[inIdx] = newBB;<KAIGYO>                    newBB->out.append(bb);<KAIGYO><KAIGYO>                    // patch the terminator<KAIGYO>                    Stmt *terminator = inBB->terminator();<KAIGYO>                    if (Jump *j = terminator->asJump()) {<KAIGYO>                        Q_ASSERT(outIdx == 0);<KAIGYO>                        j->target = newBB;<KAIGYO>                    } else if (CJump *j = terminator->asCJump()) {<KAIGYO>                        if (outIdx == 0)<KAIGYO>                            j->iftrue = newBB;<KAIGYO>                        else if (outIdx == 1)<KAIGYO>                            j->iffalse = newBB;<KAIGYO>                        else<KAIGYO>                            Q_ASSERT(!"""");<KAIGYO>                    } else {<KAIGYO>                        Q_ASSERT(!"""");<KAIGYO>                    }<KAIGYO>                }<KAIGYO>            }<KAIGYO>        }<KAIGYO>    }<KAIGYO>}<KAIGYO><KAIGYO>void scheduleBlocks(QVector<BasicBlock *> &basicBlocks)<KAIGYO>{<KAIGYO>    // FIXME: this should not do DFS scheduling.<KAIGYO>    struct I {<KAIGYO>        QSet<BasicBlock *> visited;<KAIGYO>        QVector<BasicBlock *> &sequence;<KAIGYO><KAIGYO>        I(QVector<BasicBlock *> &sequence): sequence(sequence) {}<KAIGYO><KAIGYO>        void DFS(BasicBlock *bb) {<KAIGYO>            if (visited.contains(bb))<KAIGYO>                return;<KAIGYO>            visited.insert(bb);<KAIGYO>            sequence.append(bb);<KAIGYO>            if (Stmt *terminator = bb->terminator()) {<KAIGYO>                if (Jump *j = terminator->asJump()) {<KAIGYO>                    Q_ASSERT(bb->out.size() == 1);<KAIGYO>                    DFS(j->target);<KAIGYO>                } else if (CJump *cj = terminator->asCJump()) {<KAIGYO>                    Q_ASSERT(bb->out.size() == 2);<KAIGYO>                    DFS(cj->iftrue);<KAIGYO>                    DFS(cj->iffalse);<KAIGYO>                } else if (terminator->asRet()) {<KAIGYO>                    Q_ASSERT(bb->out.size() == 0);<KAIGYO>                    // nothing to do.<KAIGYO>                } else {<KAIGYO>                    Q_UNREACHABLE();<KAIGYO>                }<KAIGYO>            } else {<KAIGYO>                Q_UNREACHABLE();<KAIGYO>            }<KAIGYO>        }<KAIGYO>    };<KAIGYO><KAIGYO>    QVector<BasicBlock *> sequence;<KAIGYO>    sequence.reserve(basicBlocks.size());<KAIGYO>    I(sequence).DFS(basicBlocks.first());<KAIGYO>    qSwap(basicBlocks, sequence);<KAIGYO>}<KAIGYO><KAIGYO>/*<KAIGYO> * Quick function to convert out of SSA, so we can put the stuff through the ISel phases. This<KAIGYO> * has to be replaced by a phase in the specific ISel back-ends and do register allocation at the<KAIGYO> * same time. That way the huge number of redundant moves generated by this function are eliminated.<KAIGYO> */': 17, '    virtual void visitTry(Try *s) { /* this should never happen */ }<KAIGYO><KAIGYO>    virtual void visitConst(Const *) {}<KAIGYO>    virtual void visitString(String *) {}<KAIGYO>    virtual void visitRegExp(RegExp *) {}<KAIGYO>    virtual void visitName(Name *) {}<KAIGYO>    virtual void visitClosure(Closure *) {}<KAIGYO>    virtual void visitUnop(Unop *e) { e->expr->accept(this); }<KAIGYO>    virtual void visitBinop(Binop *e) { e->left->accept(this); e->right->accept(this); }<KAIGYO>    virtual void visitCall(Call *e) {<KAIGYO>        e->base->accept(this);<KAIGYO>        for (ExprList *it = e->args; it; it = it->next)<KAIGYO>            it->expr->accept(this);<KAIGYO>    }<KAIGYO><KAIGYO>    virtual void visitNew(New *e) {<KAIGYO>        e->base->accept(this);<KAIGYO>        for (ExprList *it = e->args; it; it = it->next)<KAIGYO>            it->expr->accept(this);<KAIGYO>    }<KAIGYO><KAIGYO>    virtual void visitSubscript(Subscript *e) {<KAIGYO>        e->base->accept(this);<KAIGYO>        e->index->accept(this);<KAIGYO>    }<KAIGYO><KAIGYO>    virtual void visitMember(Member *e) {<KAIGYO>        e->base->accept(this);<KAIGYO>    }<KAIGYO>};<KAIGYO><KAIGYO>QHash<int, int> convertToSSA(Function *function)<KAIGYO>{<KAIGYO>#ifdef SHOW_SSA<KAIGYO>    qout << """";<KAIGYO>    if (function->name)<KAIGYO>        qout << *function->name;<KAIGYO>    else<KAIGYO>        qout << """";<KAIGYO>    qout << """" << endl;<KAIGYO>#endif // SHOW_SSA<KAIGYO><KAIGYO>    QVector<BasicBlock *> &nodes = function->basicBlocks;<KAIGYO><KAIGYO>    // Calculate the dominator tree:<KAIGYO>    DominatorTree df(nodes);<KAIGYO><KAIGYO>    // Collect all applicable variables:<KAIGYO>    VariableCollector variables(function);<KAIGYO><KAIGYO>    // Place phi functions:<KAIGYO>    QHash<BasicBlock *, QSet<int> > A_phi;<KAIGYO>    foreach (int a, variables.vars()) {<KAIGYO>        if (!variables.isNonLocal(a))<KAIGYO>            continue; // for semi-pruned SSA<KAIGYO><KAIGYO>        QList<BasicBlock *> W = QList<BasicBlock *>::fromSet(variables.defsite(a));<KAIGYO>        while (!W.isEmpty()) {<KAIGYO>            BasicBlock *n = W.first();<KAIGYO>            W.removeFirst();<KAIGYO>            foreach (BasicBlock *y, df[n]) {<KAIGYO>                if (!A_phi[y].contains(a)) {<KAIGYO>                    insertPhiNode(a, y, function);<KAIGYO>                    A_phi[y].insert(a);<KAIGYO>                    if (!variables.inBlock(y).contains(a))<KAIGYO>                        W.append(y);<KAIGYO>                }<KAIGYO>            }<KAIGYO>        }<KAIGYO>    }<KAIGYO><KAIGYO>    // Rename variables:<KAIGYO>    return VariableRenamer(function).run();<KAIGYO>}<KAIGYO><KAIGYO>class DefUsesCalculator: public StmtVisitor, public ExprVisitor {<KAIGYO>public:<KAIGYO>    struct DefUse {<KAIGYO>        Stmt *defStmt;<KAIGYO>        BasicBlock *blockOfStatement;<KAIGYO>        QList<Stmt *> uses;<KAIGYO>    };<KAIGYO><KAIGYO>private:<KAIGYO>    int _lastUncollectible;<KAIGYO>    QHash<int, DefUse> _defUses;<KAIGYO>    QHash<Stmt *, QList<int> > _usesPerStatement;<KAIGYO><KAIGYO>    BasicBlock *_block;<KAIGYO>    Stmt *_stmt;<KAIGYO><KAIGYO>    void addUse(Temp *t) {<KAIGYO>        Q_ASSERT(t);<KAIGYO>        if (t->scope || t->index <= _lastUncollectible)<KAIGYO>            return;<KAIGYO><KAIGYO>        _defUses[t->index].uses.append(_stmt);<KAIGYO>        _usesPerStatement[_stmt].append(t->index);<KAIGYO>    }<KAIGYO><KAIGYO>    void addDef(Temp *t) {<KAIGYO>        if (t->scope || t->index <= _lastUncollectible)<KAIGYO>            return;<KAIGYO><KAIGYO>        Q_ASSERT(!_defUses.contains(t->index) || _defUses.value(t->index).defStmt == 0 || _defUses.value(t->index).defStmt == _stmt);<KAIGYO><KAIGYO>        DefUse &defUse = _defUses[t->index];<KAIGYO>        defUse.defStmt = _stmt;<KAIGYO>        defUse.blockOfStatement = _block;<KAIGYO>    }<KAIGYO><KAIGYO>public:<KAIGYO>    DefUsesCalculator(Function *function) {<KAIGYO>        if (function->variablesCanEscape())<KAIGYO>            _lastUncollectible = function->locals.size() - 1;<KAIGYO>        else<KAIGYO>            _lastUncollectible = -1;<KAIGYO><KAIGYO>        foreach (BasicBlock *bb, function->basicBlocks) {<KAIGYO>            _block = bb;<KAIGYO>            foreach (Stmt *stmt, bb->statements) {<KAIGYO>                _stmt = stmt;<KAIGYO>                stmt->accept(this);<KAIGYO>            }<KAIGYO>        }<KAIGYO><KAIGYO>        QMutableHashIterator<int, DefUse> it(_defUses);<KAIGYO>        while (it.hasNext()) {<KAIGYO>            it.next();<KAIGYO>            if (!it.value().defStmt)<KAIGYO>                it.remove();<KAIGYO>        }<KAIGYO>    }<KAIGYO><KAIGYO>    QList<int> defs() const {<KAIGYO>        return _defUses.keys();<KAIGYO>    }<KAIGYO><KAIGYO>    void removeDef(int var) {<KAIGYO>        _defUses.remove(var);<KAIGYO>    }<KAIGYO><KAIGYO>    void addUses(int variable, QList<Stmt *>newUses)<KAIGYO>    { _defUses[variable].uses.append(newUses); }<KAIGYO><KAIGYO>    int useCount(int variable) const<KAIGYO>    { return _defUses[variable].uses.size(); }<KAIGYO><KAIGYO>    Stmt *defStmt(int variable) const<KAIGYO>    { return _defUses[variable].defStmt; }<KAIGYO><KAIGYO>    BasicBlock *defStmtBlock(int variable) const<KAIGYO>    { return _defUses[variable].blockOfStatement; }<KAIGYO><KAIGYO>    void removeUse(Stmt *usingStmt, int var)<KAIGYO>    { _defUses[var].uses.removeAll(usingStmt); }<KAIGYO><KAIGYO>    QList<int> usedVars(Stmt *s) const<KAIGYO>    { return _usesPerStatement[s]; }<KAIGYO><KAIGYO>    QList<Stmt *> uses(int var) const<KAIGYO>    { return _defUses[var].uses; }<KAIGYO><KAIGYO>    void dump() const<KAIGYO>    {<KAIGYO>        foreach (int var, _defUses.keys()) {<KAIGYO>            const DefUse &du = _defUses[var];<KAIGYO>            qout<<var<<"""";<KAIGYO>            du.defStmt->dump(qout);<KAIGYO>            qout<<endl<<""""<<endl;<KAIGYO>            foreach (Stmt *s, du.uses) {<KAIGYO>                qout<<"""";s->dump(qout);qout<<endl;<KAIGYO>            }<KAIGYO>        }<KAIGYO>    }<KAIGYO><KAIGYO>protected:<KAIGYO>    virtual void visitExp(Exp *s) { s->expr->accept(this); }<KAIGYO>    virtual void visitEnter(Enter *) {}<KAIGYO>    virtual void visitLeave(Leave *) {}<KAIGYO>    virtual void visitJump(Jump *) {}<KAIGYO>    virtual void visitCJump(CJump *s) { s->cond->accept(this); }<KAIGYO>    virtual void visitRet(Ret *s) { s->expr->accept(this); }<KAIGYO>    virtual void visitTry(Try *) {}<KAIGYO><KAIGYO>    virtual void visitPhi(Phi *s) {<KAIGYO>        addDef(s->targetTemp);<KAIGYO>        foreach (Expr *e, s->incoming)<KAIGYO>            addUse(e->asTemp());<KAIGYO>    }<KAIGYO><KAIGYO>    virtual void visitMove(Move *s) {<KAIGYO>        if (Temp *t = s->target->asTemp())<KAIGYO>            addDef(t);<KAIGYO>        else<KAIGYO>            s->target->accept(this);<KAIGYO><KAIGYO>        s->source->accept(this);<KAIGYO>    }<KAIGYO><KAIGYO>    virtual void visitTemp(Temp *e) { addUse(e); }<KAIGYO><KAIGYO>    virtual void visitConst(Const *) {}<KAIGYO>    virtual void visitString(String *) {}<KAIGYO>    virtual void visitRegExp(RegExp *) {}<KAIGYO>    virtual void visitName(Name *) {}<KAIGYO>    virtual void visitClosure(Closure *) {}<KAIGYO>    virtual void visitUnop(Unop *e) { e->expr->accept(this); }<KAIGYO>    virtual void visitBinop(Binop *e) { e->left->accept(this); e->right->accept(this); }<KAIGYO>    virtual void visitSubscript(Subscript *e) { e->base->accept(this); e->index->accept(this); }<KAIGYO>    virtual void visitMember(Member *e) { e->base->accept(this); }<KAIGYO>    virtual void visitCall(Call *e) {<KAIGYO>        e->base->accept(this);<KAIGYO>        for (ExprList *it = e->args; it; it = it->next)<KAIGYO>            it->expr->accept(this);<KAIGYO>    }<KAIGYO><KAIGYO>    virtual void visitNew(New *e) {<KAIGYO>        e->base->accept(this);<KAIGYO>        for (ExprList *it = e->args; it; it = it->next)<KAIGYO>            it->expr->accept(this);<KAIGYO>    }<KAIGYO>};<KAIGYO><KAIGYO>bool hasPhiOnlyUses(Phi *phi, const DefUsesCalculator &defUses, QSet<Phi *> &collectedPhis)<KAIGYO>{<KAIGYO>    collectedPhis.insert(phi);<KAIGYO>    foreach (Stmt *use, defUses.uses(phi->targetTemp->index)) {<KAIGYO>        if (Phi *dependentPhi = use->asPhi()) {<KAIGYO>            if (!collectedPhis.contains(dependentPhi)) {<KAIGYO>                if (!hasPhiOnlyUses(dependentPhi, defUses, collectedPhis))<KAIGYO>                    return false;<KAIGYO>            }<KAIGYO>        } else {<KAIGYO>            return false;<KAIGYO>        }<KAIGYO>    }<KAIGYO>    return true;<KAIGYO>}<KAIGYO><KAIGYO>void cleanupPhis(DefUsesCalculator &defUses)<KAIGYO>{<KAIGYO>    QLinkedList<Phi *> phis;<KAIGYO>    foreach (int def, defUses.defs())<KAIGYO>        if (Phi *phi = defUses.defStmt(def)->asPhi())<KAIGYO>            phis.append(phi);<KAIGYO><KAIGYO>    QSet<Phi *> toRemove;<KAIGYO>    while (!phis.isEmpty()) {<KAIGYO>        Phi *phi = phis.first();<KAIGYO>        phis.removeFirst();<KAIGYO>        if (toRemove.contains(phi))<KAIGYO>            continue;<KAIGYO>        QSet<Phi *> collectedPhis;<KAIGYO>        if (hasPhiOnlyUses(phi, defUses, collectedPhis))<KAIGYO>            toRemove.unite(collectedPhis);<KAIGYO>    }<KAIGYO><KAIGYO>    foreach (Phi *phi, toRemove) {<KAIGYO>        int targetVar = phi->targetTemp->index;<KAIGYO><KAIGYO>        BasicBlock *bb = defUses.defStmtBlock(targetVar);<KAIGYO>        int idx = bb->statements.indexOf(phi);<KAIGYO>        bb->statements.remove(idx);<KAIGYO><KAIGYO>        foreach (int usedVar, defUses.usedVars(phi))<KAIGYO>            defUses.removeUse(phi, usedVar);<KAIGYO>        defUses.removeDef(targetVar);<KAIGYO>    }<KAIGYO>}<KAIGYO><KAIGYO>class DeadCodeElimination: public ExprVisitor {<KAIGYO>    int _lastUncollectible;<KAIGYO>    DefUsesCalculator &_defUses;<KAIGYO>    QVector<int> _worklist;<KAIGYO><KAIGYO>public:<KAIGYO>    DeadCodeElimination(DefUsesCalculator &defUses, Function *function)<KAIGYO>        : _defUses(defUses)<KAIGYO>    {<KAIGYO>        _worklist = QVector<int>::fromList(_defUses.defs());<KAIGYO><KAIGYO>        if (function->variablesCanEscape())<KAIGYO>            _lastUncollectible = function->locals.size() - 1;<KAIGYO>        else<KAIGYO>            _lastUncollectible = -1;<KAIGYO>    }<KAIGYO><KAIGYO>    void run() {<KAIGYO>        while (!_worklist.isEmpty()) {<KAIGYO>            const int v = _worklist.first();<KAIGYO>            _worklist.removeFirst();<KAIGYO><KAIGYO>            if (_defUses.useCount(v) == 0) {<KAIGYO>//                qDebug()<<"""";<KAIGYO>                Stmt *s = _defUses.defStmt(v);<KAIGYO>                if (!s) {<KAIGYO>                    _defUses.removeDef(v);<KAIGYO>                } else if (!hasSideEffect(s)) {<KAIGYO>//                    qDebug()<<"""";<KAIGYO>                    QVector<Stmt *> &stmts = _defUses.defStmtBlock(v)->statements;<KAIGYO>                    int idx = stmts.indexOf(s);<KAIGYO>                    if (idx != -1)<KAIGYO>                        stmts.remove(idx);<KAIGYO>                    foreach (int usedVar, _defUses.usedVars(s)) {<KAIGYO>                        _defUses.removeUse(s, usedVar);<KAIGYO>                        _worklist.append(usedVar);<KAIGYO>                    }<KAIGYO>                    _defUses.removeDef(v);<KAIGYO>                }<KAIGYO>            }<KAIGYO>        }<KAIGYO><KAIGYO>#ifdef SHOW_SSA<KAIGYO>        qout<<"""";<KAIGYO>        _defUses.dump();<KAIGYO>#endif<KAIGYO>    }<KAIGYO><KAIGYO>private:<KAIGYO>    bool _sideEffect;<KAIGYO><KAIGYO>    bool hasSideEffect(Stmt *s) {<KAIGYO>        // TODO: check if this can be moved to IR building.<KAIGYO>        _sideEffect = false;<KAIGYO>        if (Move *move = s->asMove()) {<KAIGYO>            if (Temp *t = move->target->asTemp())<KAIGYO>                if (t->index <= _lastUncollectible || t->scope)<KAIGYO>                    return true;<KAIGYO>            move->source->accept(this);<KAIGYO>        }<KAIGYO>        return _sideEffect;<KAIGYO>    }<KAIGYO><KAIGYO>protected:<KAIGYO>    virtual void visitConst(Const *) {}<KAIGYO>    virtual void visitString(String *) {}<KAIGYO>    virtual void visitRegExp(RegExp *) {}<KAIGYO>    virtual void visitName(Name *e) {<KAIGYO>        // TODO: maybe we can distinguish between built-ins of which we know that they do not have<KAIGYO>        // a side-effect.<KAIGYO>        if (e->builtin == Name::builtin_invalid || (e->id && *e->id != QStringLiteral("""")))<KAIGYO>            _sideEffect = true;<KAIGYO>    }<KAIGYO>    virtual void visitTemp(Temp *e) {<KAIGYO>    }<KAIGYO>    virtual void visitClosure(Closure *) {}<KAIGYO>    virtual void visitUnop(Unop *e) {<KAIGYO>        switch (e->op) {<KAIGYO>        case V4IR::OpIncrement:<KAIGYO>        case V4IR::OpDecrement:<KAIGYO>            _sideEffect = true;<KAIGYO>            break;<KAIGYO><KAIGYO>        default:<KAIGYO>            break;<KAIGYO>        }<KAIGYO><KAIGYO>        if (!_sideEffect) e->expr->accept(this);<KAIGYO>    }<KAIGYO>    virtual void visitBinop(Binop *e) { if (!_sideEffect) e->left->accept(this); if (!_sideEffect) e->right->accept(this); }<KAIGYO>    virtual void visitSubscript(Subscript *e) {<KAIGYO>        // TODO: see if we can have subscript accesses without side effect<KAIGYO>        _sideEffect = true;<KAIGYO>    }<KAIGYO>    virtual void visitMember(Member *e) {<KAIGYO>        // TODO: see if we can have member accesses without side effect<KAIGYO>        _sideEffect = true;<KAIGYO>    }<KAIGYO>    virtual void visitCall(Call *e) {<KAIGYO>        _sideEffect = true; // TODO: there are built-in functions that have no side effect.<KAIGYO>    }<KAIGYO>    virtual void visitNew(New *e) {<KAIGYO>        _sideEffect = true; // TODO: there are built-in types that have no side effect.<KAIGYO>    }<KAIGYO>};<KAIGYO><KAIGYO>class TypeInference: public StmtVisitor, public ExprVisitor {<KAIGYO>    const DefUsesCalculator &_defUses;<KAIGYO>    QHash<int, int> _tempTypes;<KAIGYO>    QSet<Stmt *> _worklist;<KAIGYO>    struct TypingResult {<KAIGYO>        int type;<KAIGYO>        bool fullyTyped;<KAIGYO><KAIGYO>        TypingResult(int type, bool fullyTyped): type(type), fullyTyped(fullyTyped) {}<KAIGYO>        explicit TypingResult(int type = UnknownType): type(type), fullyTyped(type != UnknownType) {}<KAIGYO>    };<KAIGYO>    TypingResult _ty;<KAIGYO>    int _localCount;<KAIGYO><KAIGYO>public:<KAIGYO>    TypeInference(const DefUsesCalculator &defUses): _defUses(defUses), _ty(UnknownType) {}<KAIGYO><KAIGYO>    void run(Function *function) {<KAIGYO>        _localCount = function->variablesCanEscape() ? function->locals.size() : 0;<KAIGYO><KAIGYO>        // TODO: the worklist handling looks a bit inefficient... check if there is something better<KAIGYO>        _worklist.clear();<KAIGYO>        for (int i = 0, ei = function->basicBlocks.size(); i != ei; ++i) {<KAIGYO>            BasicBlock *bb = function->basicBlocks[i];<KAIGYO>            if (i == 0 || !bb->in.isEmpty())<KAIGYO>                foreach (Stmt *s, bb->statements)<KAIGYO>                    _worklist.insert(s);<KAIGYO>        }<KAIGYO><KAIGYO>        while (!_worklist.isEmpty()) {<KAIGYO>            QList<Stmt *> worklist = _worklist.values();<KAIGYO>            _worklist.clear();<KAIGYO>            while (!worklist.isEmpty()) {<KAIGYO>                Stmt *s = worklist.first();<KAIGYO>                worklist.removeFirst();<KAIGYO>#if defined(SHOW_SSA)<KAIGYO>                qout<<"""";s->dump(qout);qout<<endl;<KAIGYO>#endif<KAIGYO><KAIGYO>                if (!run(s)) {<KAIGYO>                    _worklist.insert(s);<KAIGYO>#if defined(SHOW_SSA)<KAIGYO>                    qout<<"""";<KAIGYO>                    s->dump(qout);qout<<endl;<KAIGYO>                } else {<KAIGYO>                    qout<<"""";<KAIGYO>                    s->dump(qout);qout<<endl;<KAIGYO>#endif<KAIGYO>                }<KAIGYO>            }<KAIGYO>        }<KAIGYO>    }<KAIGYO><KAIGYO>private:<KAIGYO>    bool run(Stmt *s) {<KAIGYO>        TypingResult ty;<KAIGYO>        std::swap(_ty, ty);<KAIGYO>        s->accept(this);<KAIGYO>        std::swap(_ty, ty);<KAIGYO>        return ty.fullyTyped;<KAIGYO>    }<KAIGYO><KAIGYO>    TypingResult run(Expr *e) {<KAIGYO>        TypingResult ty;<KAIGYO>        std::swap(_ty, ty);<KAIGYO>        e->accept(this);<KAIGYO>        std::swap(_ty, ty);<KAIGYO><KAIGYO>        if (ty.type != UnknownType)<KAIGYO>            setType(e, ty.type);<KAIGYO>        return ty;<KAIGYO>    }<KAIGYO><KAIGYO>    void setType(Expr *e, int ty) {<KAIGYO>        if (Temp *t = e->asTemp()) {<KAIGYO>#if defined(SHOW_SSA)<KAIGYO>            qout<<"""" << endl;<KAIGYO>#endif<KAIGYO>            if (t->scope || t->index < _localCount) {<KAIGYO>                e->type = ObjectType;<KAIGYO>            } else {<KAIGYO>                e->type = (Type) ty;<KAIGYO><KAIGYO>                if (_tempTypes[t->index] != ty) {<KAIGYO>                    _tempTypes[t->index] = ty;<KAIGYO><KAIGYO>#if defined(SHOW_SSA)<KAIGYO>                    foreach (Stmt *s, _defUses.uses(t->index)) {<KAIGYO>                        qout << """";<KAIGYO>                        s->dump(qout);<KAIGYO>                        qout << endl;<KAIGYO>                    }<KAIGYO>#endif<KAIGYO><KAIGYO>                    _worklist += QSet<Stmt *>::fromList(_defUses.uses(t->index));<KAIGYO>                }<KAIGYO>            }<KAIGYO>        } else {<KAIGYO>            e->type = (Type) ty;<KAIGYO>        }<KAIGYO>    }<KAIGYO><KAIGYO>protected:<KAIGYO>    virtual void visitConst(Const *e) { _ty = TypingResult(e->type); }<KAIGYO>    virtual void visitString(String *) { _ty = TypingResult(StringType); }<KAIGYO>    virtual void visitRegExp(RegExp *) { _ty = TypingResult(ObjectType); }<KAIGYO>    virtual void visitName(Name *) { _ty = TypingResult(ObjectType); }<KAIGYO>    virtual void visitTemp(Temp *e) {<KAIGYO>        if (e->scope)<KAIGYO>            _ty = TypingResult(ObjectType);<KAIGYO>        else if (e->index < _localCount)<KAIGYO>            _ty = TypingResult(ObjectType);<KAIGYO>        else<KAIGYO>            _ty = TypingResult(_tempTypes.value(e->index, UnknownType));<KAIGYO>        setType(e, _ty.type);<KAIGYO>    }<KAIGYO>    virtual void visitClosure(Closure *) { _ty = TypingResult(ObjectType); } // TODO: VERIFY THIS!<KAIGYO>    virtual void visitUnop(Unop *e) {<KAIGYO>        _ty = run(e->expr);<KAIGYO>        switch (e->op) {<KAIGYO>        case OpUPlus: _ty.type = DoubleType; return;<KAIGYO>        case OpUMinus: _ty.type = DoubleType; return;<KAIGYO>        case OpCompl: _ty.type = SInt32Type; return;<KAIGYO>        case OpNot: _ty.type = BoolType; return;<KAIGYO><KAIGYO>        case OpIncrement:<KAIGYO>        case OpDecrement:<KAIGYO>            Q_ASSERT(!"""");<KAIGYO>        default:<KAIGYO>            Q_UNIMPLEMENTED();<KAIGYO>            Q_UNREACHABLE();<KAIGYO>        }<KAIGYO>    }<KAIGYO><KAIGYO>    virtual void visitBinop(Binop *e) {<KAIGYO>        TypingResult leftTy = run(e->left);<KAIGYO>        TypingResult rightTy = run(e->right);<KAIGYO>        _ty.fullyTyped = leftTy.fullyTyped && rightTy.fullyTyped;<KAIGYO><KAIGYO>        switch (e->op) {<KAIGYO>        case OpAdd:<KAIGYO>            if (leftTy.type & StringType || rightTy.type & StringType)<KAIGYO>                _ty.type = StringType;<KAIGYO>            else if (leftTy.type != UnknownType && rightTy.type != UnknownType)<KAIGYO>                _ty.type = DoubleType;<KAIGYO>            else<KAIGYO>                _ty.type = UnknownType;<KAIGYO>            break;<KAIGYO>        case OpSub:<KAIGYO>            _ty.type = DoubleType;<KAIGYO>            break;<KAIGYO><KAIGYO>        case OpMul:<KAIGYO>        case OpDiv:<KAIGYO>        case OpMod:<KAIGYO>            _ty.type = DoubleType;<KAIGYO>            break;<KAIGYO><KAIGYO>        case OpBitAnd:<KAIGYO>        case OpBitOr:<KAIGYO>        case OpBitXor:<KAIGYO>        case OpLShift:<KAIGYO>        case OpRShift:<KAIGYO>            _ty.type = SInt32Type;<KAIGYO>            break;<KAIGYO>        case OpURShift:<KAIGYO>            _ty.type = UInt32Type;<KAIGYO>            break;<KAIGYO><KAIGYO>        case OpGt:<KAIGYO>        case OpLt:<KAIGYO>        case OpGe:<KAIGYO>        case OpLe:<KAIGYO>        case OpEqual:<KAIGYO>        case OpNotEqual:<KAIGYO>        case OpStrictEqual:<KAIGYO>        case OpStrictNotEqual:<KAIGYO>        case OpAnd:<KAIGYO>        case OpOr:<KAIGYO>        case OpInstanceof:<KAIGYO>        case OpIn:<KAIGYO>            _ty.type = BoolType;<KAIGYO>            break;<KAIGYO><KAIGYO>        default:<KAIGYO>            Q_UNIMPLEMENTED();<KAIGYO>            Q_UNREACHABLE();<KAIGYO>        }<KAIGYO>    }<KAIGYO><KAIGYO>    virtual void visitCall(Call *e) {<KAIGYO>        _ty = run(e->base);<KAIGYO>        for (ExprList *it = e->args; it; it = it->next)<KAIGYO>            _ty.fullyTyped &= run(it->expr).fullyTyped;<KAIGYO>        _ty.type = ObjectType;<KAIGYO>    }<KAIGYO>    virtual void visitNew(New *e) {<KAIGYO>        _ty = run(e->base);<KAIGYO>        for (ExprList *it = e->args; it; it = it->next)<KAIGYO>            _ty.fullyTyped &= run(it->expr).fullyTyped;<KAIGYO>        _ty.type = ObjectType;<KAIGYO>    }<KAIGYO>    virtual void visitSubscript(Subscript *e) {<KAIGYO>        _ty.fullyTyped = run(e->base).fullyTyped && run(e->index).fullyTyped;<KAIGYO>        _ty.type = ObjectType;<KAIGYO>    }<KAIGYO><KAIGYO>    virtual void visitMember(Member *e) {<KAIGYO>        // TODO: for QML, try to do a static lookup<KAIGYO>        _ty = run(e->base);<KAIGYO>        _ty.type = ObjectType;<KAIGYO>    }<KAIGYO><KAIGYO>    virtual void visitExp(Exp *s) { _ty = run(s->expr); }<KAIGYO>    virtual void visitEnter(Enter *s) { _ty = run(s->expr); }<KAIGYO>    virtual void visitLeave(Leave *) { _ty = TypingResult(MissingType); }<KAIGYO>    virtual void visitMove(Move *s) {<KAIGYO>        TypingResult sourceTy = run(s->source);<KAIGYO>        Q_ASSERT(s->op == OpInvalid);<KAIGYO>        if (Temp *t = s->target->asTemp()) {<KAIGYO>            setType(t, sourceTy.type);<KAIGYO>            _ty = sourceTy;<KAIGYO>            return;<KAIGYO>        }<KAIGYO><KAIGYO>        _ty = run(s->target);<KAIGYO>        _ty.fullyTyped &= sourceTy.fullyTyped;<KAIGYO>    }<KAIGYO><KAIGYO>    virtual void visitJump(Jump *) { _ty = TypingResult(MissingType); }<KAIGYO>    virtual void visitCJump(CJump *s) { _ty = run(s->cond); }<KAIGYO>    virtual void visitRet(Ret *s) { _ty = run(s->expr); }<KAIGYO>    virtual void visitTry(Try *s) { setType(s->exceptionVar, ObjectType); _ty = TypingResult(MissingType); }<KAIGYO>    virtual void visitPhi(Phi *s) {<KAIGYO>        _ty = run(s->incoming[0]);<KAIGYO>        for (int i = 1, ei = s->incoming.size(); i != ei; ++i) {<KAIGYO>            TypingResult ty = run(s->incoming[i]);<KAIGYO>            _ty.type |= ty.type;<KAIGYO>            _ty.fullyTyped &= ty.fullyTyped;<KAIGYO>        }<KAIGYO><KAIGYO>        // TODO: check & double check the next condition!<KAIGYO>        if (_ty.type & ObjectType || _ty.type & UndefinedType || _ty.type & NullType)<KAIGYO>            _ty.type = ObjectType;<KAIGYO>        else if (_ty.type & NumberType)<KAIGYO>            _ty.type = DoubleType;<KAIGYO><KAIGYO>        setType(s->targetTemp, _ty.type);<KAIGYO>    }<KAIGYO>};<KAIGYO><KAIGYO>class TypePropagation: public StmtVisitor, public ExprVisitor {<KAIGYO>    Type _ty;<KAIGYO><KAIGYO>    void run(Expr *e, Type requestedType = UnknownType) {<KAIGYO>        qSwap(_ty, requestedType);<KAIGYO>        e->accept(this);<KAIGYO>        qSwap(_ty, requestedType);<KAIGYO>    }<KAIGYO><KAIGYO>public:<KAIGYO>    TypePropagation() : _ty(UnknownType) {}<KAIGYO><KAIGYO>    void run(Function *f) {<KAIGYO>        foreach (BasicBlock *bb, f->basicBlocks)<KAIGYO>            foreach (Stmt *s, bb->statements)<KAIGYO>                s->accept(this);<KAIGYO>    }<KAIGYO><KAIGYO>protected:<KAIGYO>    virtual void visitConst(Const *c) {<KAIGYO>        if (_ty & NumberType && c->type & NumberType) {<KAIGYO>            c->type = _ty;<KAIGYO>        }<KAIGYO>    }<KAIGYO><KAIGYO>    virtual void visitString(String *) {}<KAIGYO>    virtual void visitRegExp(RegExp *) {}<KAIGYO>    virtual void visitName(Name *) {}<KAIGYO>    virtual void visitTemp(Temp *) {}<KAIGYO>    virtual void visitClosure(Closure *) {}<KAIGYO>    virtual void visitUnop(Unop *e) { run(e->expr, e->type); }<KAIGYO>    virtual void visitBinop(Binop *e) { run(e->left, e->type); run(e->right, e->type); }<KAIGYO>    virtual void visitCall(Call *e) {<KAIGYO>        run(e->base);<KAIGYO>        for (ExprList *it = e->args; it; it = it->next)<KAIGYO>            run(it->expr);<KAIGYO>    }<KAIGYO>    virtual void visitNew(New *e) {<KAIGYO>        run(e->base);<KAIGYO>        for (ExprList *it = e->args; it; it = it->next)<KAIGYO>            run(it->expr);<KAIGYO>    }<KAIGYO>    virtual void visitSubscript(Subscript *e) { run(e->base); run(e->index); }<KAIGYO>    virtual void visitMember(Member *e) { run(e->base); }<KAIGYO>    virtual void visitExp(Exp *s) { run(s->expr); }<KAIGYO>    virtual void visitEnter(Enter *s) { run(s->expr); }<KAIGYO>    virtual void visitLeave(Leave *) {}<KAIGYO>    virtual void visitMove(Move *s) {<KAIGYO>        run(s->target);<KAIGYO>        run(s->source, s->target->type);<KAIGYO>    }<KAIGYO>    virtual void visitJump(Jump *) {}<KAIGYO>    virtual void visitCJump(CJump *s) {<KAIGYO>        run(s->cond, BoolType);<KAIGYO>    }<KAIGYO>    virtual void visitRet(Ret *s) { run(s->expr); }<KAIGYO>    virtual void visitTry(Try *) {}<KAIGYO>    virtual void visitPhi(Phi *s) {<KAIGYO>        Type ty = s->targetTemp->type;<KAIGYO>        foreach (Expr *e, s->incoming)<KAIGYO>            run(e, ty);<KAIGYO>    }<KAIGYO>};<KAIGYO><KAIGYO>void insertMove(Function *function, BasicBlock *basicBlock, Temp *target, Expr *source) {<KAIGYO>    Move *s = function->New<Move>();<KAIGYO>    s->init(target, source, OpInvalid);<KAIGYO>    basicBlock->statements.insert(basicBlock->statements.size() - 1, s);<KAIGYO>}<KAIGYO><KAIGYO>bool doEdgeSplitting(Function *f)<KAIGYO>{<KAIGYO>    const QVector<BasicBlock *> oldBBs = f->basicBlocks;<KAIGYO><KAIGYO>    foreach (BasicBlock *bb, oldBBs) {<KAIGYO>        if (bb->in.size() > 1) {<KAIGYO>            for (int inIdx = 0, eInIdx = bb->in.size(); inIdx != eInIdx; ++inIdx) {<KAIGYO>                BasicBlock *inBB = bb->in[inIdx];<KAIGYO>                if (inBB->out.size() > 1) { // this should have been split!<KAIGYO>#if defined(SHOW_SSA)<KAIGYO>                    qDebug() << """" << bb->index;<KAIGYO>#endif<KAIGYO><KAIGYO>                    // create the basic block:<KAIGYO>                    BasicBlock *newBB = new BasicBlock(f);<KAIGYO>                    newBB->index = f->basicBlocks.last()->index + 1;<KAIGYO>                    f->basicBlocks.append(newBB);<KAIGYO>                    Jump *s = f->New<Jump>();<KAIGYO>                    s->init(bb);<KAIGYO>                    newBB->statements.append(s);<KAIGYO><KAIGYO>                    // rewire the old outgoing edge<KAIGYO>                    int outIdx = inBB->out.indexOf(bb);<KAIGYO>                    inBB->out[outIdx] = newBB;<KAIGYO>                    newBB->in.append(inBB);<KAIGYO><KAIGYO>                    // rewire the old incoming edge<KAIGYO>                    bb->in[inIdx] = newBB;<KAIGYO>                    newBB->out.append(bb);<KAIGYO><KAIGYO>                    // patch the terminator<KAIGYO>                    Stmt *terminator = inBB->terminator();<KAIGYO>                    if (Jump *j = terminator->asJump()) {<KAIGYO>                        Q_ASSERT(outIdx == 0);<KAIGYO>                        j->target = newBB;<KAIGYO>                    } else if (CJump *j = terminator->asCJump()) {<KAIGYO>                        if (outIdx == 0)<KAIGYO>                            j->iftrue = newBB;<KAIGYO>                        else if (outIdx == 1)<KAIGYO>                            j->iffalse = newBB;<KAIGYO>                        else<KAIGYO>                            Q_ASSERT(!"""");<KAIGYO>                    } else {<KAIGYO>                        Q_ASSERT(!"""");<KAIGYO>                    }<KAIGYO>                }<KAIGYO>            }<KAIGYO>        }<KAIGYO>    }<KAIGYO>}<KAIGYO><KAIGYO>void scheduleBlocks(QVector<BasicBlock *> &basicBlocks)<KAIGYO>{<KAIGYO>    // FIXME: this should not do DFS scheduling.<KAIGYO>    struct I {<KAIGYO>        QSet<BasicBlock *> visited;<KAIGYO>        QVector<BasicBlock *> &sequence;<KAIGYO><KAIGYO>        I(QVector<BasicBlock *> &sequence): sequence(sequence) {}<KAIGYO><KAIGYO>        void DFS(BasicBlock *bb) {<KAIGYO>            if (visited.contains(bb))<KAIGYO>                return;<KAIGYO>            visited.insert(bb);<KAIGYO>            sequence.append(bb);<KAIGYO>            if (Stmt *terminator = bb->terminator()) {<KAIGYO>                if (Jump *j = terminator->asJump()) {<KAIGYO>                    Q_ASSERT(bb->out.size() == 1);<KAIGYO>                    DFS(j->target);<KAIGYO>                } else if (CJump *cj = terminator->asCJump()) {<KAIGYO>                    Q_ASSERT(bb->out.size() == 2);<KAIGYO>                    DFS(cj->iftrue);<KAIGYO>                    DFS(cj->iffalse);<KAIGYO>                } else if (terminator->asRet()) {<KAIGYO>                    Q_ASSERT(bb->out.size() == 0);<KAIGYO>                    // nothing to do.<KAIGYO>                } else {<KAIGYO>                    Q_UNREACHABLE();<KAIGYO>                }<KAIGYO>            } else {<KAIGYO>                Q_UNREACHABLE();<KAIGYO>            }<KAIGYO>        }<KAIGYO>    };<KAIGYO><KAIGYO>    QVector<BasicBlock *> sequence;<KAIGYO>    sequence.reserve(basicBlocks.size());<KAIGYO>    I(sequence).DFS(basicBlocks.first());<KAIGYO>    qSwap(basicBlocks, sequence);<KAIGYO>}<KAIGYO><KAIGYO>/*<KAIGYO> * Quick function to convert out of SSA, so we can put the stuff through the ISel phases. This<KAIGYO> * has to be replaced by a phase in the specific ISel back-ends and do register allocation at the<KAIGYO> * same time. That way the huge number of redundant moves generated by this function are eliminated.<KAIGYO> */': 18}",1.0,"{'// source was not a temp, but maybe a sub-expression has a temp<KAIGYO>// (e.g. base expressions for subscripts/member-access),<KAIGYO>// so visit it.': 5, '// TODO: change this to use a worklist.<KAIGYO>// FIXME: actually, use SSA and then re-implement it.': 5}",1.0,{}
239,55882.0,2.0,2.0,0.0,ABANDONED,False,https://codereview.qt-project.org/#/c/55882,WIP: SSA calculation fixes and optimisation passes.,1.0,"{'// TODO: clone the replacement!': 1, '// TODO: VERIFY THIS!': 1, '// TODO: for QML, try to do a static lookup': 1, '// TODO: verify the rest of the function for when op == OpInvalid': 1}",1.0,"{'// FIXME: add a flag that indicates whether the whole statement has been successfully typed, and do not abuse the Unknown/Missing _ty for that!': 1, '// TODO: VERIFY THIS!': 1, '// TODO: try to do a static lookup': 1, '// TODO: check if we want to decide what kind of move we need to generate in ISel... meaning: do we need to annotate the move?<KAIGYO>// For now:': 1}",1.0,{}
12,56028.0,2.0,4.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/56028,Fix connect/disconnect in QObject bindings,1.0,{'// Hack to allow us to identify these functions': 1},1.0,{'// Hack to allow us to identify these functions': 1},1.0,{}
93,56237.0,2.0,3.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/56237,convert QV8VariantWrapper to v4,1.0,"{'//    // XXX NewInstance() should be optimized<KAIGYO>//    v8::Handle<v8::Object> rv;<KAIGYO>//    QV8VariantResource *r = new QV8VariantResource(m_engine, value);': 1}",1.0,{'// XXX NewInstance() should be optimized': 1},1.0,{}
57,56309.0,1.0,8.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/56309,Update feature paths on assignment to QMAKE_PLATFORM,1.0,{},0.0,"{'// The spec extends the feature search path, so rebuild the cache.': 1}",1.0,{}
92,56447.0,1.0,1.0,0.0,ABANDONED,False,https://codereview.qt-project.org/#/c/56447,WIP: more varying stuff.,1.0,"{'// FIXME: this should not do DFS scheduling.<KAIGYO>//        showMeTheCode(function);<KAIGYO>//        showMeTheCode(function);': 1, '// TODO: check if a*b==b*a': 1, '// TODO: check if a+b==b+a': 1}",1.0,"{'// TODO: this is inefficient on ARM, because the JSC assembler uses d0 as a<KAIGYO>// scratch register, while it is also the return register, which means that an<KAIGYO>// extra move is inserted. It would be more useful if d7 or d8 were used as<KAIGYO>// scratch register.<KAIGYO>// Maybe we should hand-tune this for ARM, by not using any instructions that<KAIGYO>// use that scratch register, leave the return value in d0, load the lhs in d1,<KAIGYO>// and compare those.': 1}",1.0,{}
96,56463.0,1.0,3.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/56463,convert qv8workerscript to v4,1.0,{'// XXX TODO: Generalize passing objects between the main thread and worker scripts so': 1},1.0,{'// XXX TODO: Generalize passing objects between the main thread and worker scripts so ': 1},1.0,{}
195,56700.0,5.0,6.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/56700,Replace QV8QObjectResource with QV4::QObjectWrapper,1.0,"{'// ### FIXME: registerWeakQObjectReference(wrapper);': 1, '// ### FIXME registerWeakQObjectReference(wrapper);': 1}",1.0,"{""// XXX TODO: Enables fast property accessors.  These more than double the property access <KAIGYO>// performance, but the  cost of setting up this structure hasn't been measured so <KAIGYO>// its not guaranteed that this is a win overall.  We need to try and measure the cost."": 4, '// XXX NewInstance() should be optimized': 4}",1.0,{}
231,56872.0,2.0,10.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/56872,Make QQuickSettings::style a property with a notifier signal,1.0,{},0.0,{'//Following variable is for internal use only. It is very possible<KAIGYO>//that it will disappear in future releases.': 1},1.0,{}
206,56905.0,1.0,2.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/56905,Remove the remaining dependencies onto the binding rewriter,1.0,{},0.0,"{'//        ss.bindingId = rewriteBinding(script, prop->name());<KAIGYO>// XXX': 1}",1.0,{}
203,56922.0,2.0,3.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/56922,Implement QObject ownership policy for QObject JavaScript wrappers,1.0,{'// ### FIXME: remove when qv8qobjectwrapper port is done.': 1},1.0,"{""// circular references shouldn't keep them alive."": 1}",1.0,{}
221,56942.0,8.0,10.0,1.0,MERGED,True,https://codereview.qt-project.org/#/c/56942,"Improved block scheduling with ""tuned"" DFS.",1.0,{},0.0,{'// FIXME: this should not do DFS scheduling.': 4},1.0,{}
232,56961.0,9.0,9.0,0.0,ABANDONED,False,https://codereview.qt-project.org/#/c/56961,WIP: adding an SSA optimization pass.,1.0,"{'// TODO: clone the replacement!': 1, '// FIXME: if an assignment to a local occurs that can escape through closures, it cannot be optimised out.': 1, '// FIXME!': 9, '// TODO: do not generate a call (meaning: block all registers), but annotate the conversion with registers that need to be saved and have masm take care of that.': 9, '// FIXME: propagate this': 9, '//            if (!it.covers(successorStart))<KAIGYO>// FIXME: I think we can remove this line...': 9}",1.0,"{'// TODO: merge 2 basic blocks A and B if A has one outgoing edge (to B), B has one incoming<KAIGYO>// edge (from A), but not when A has more than 1 incoming edge and B has more than one<KAIGYO>// outgoing edge.': 4, '// TODO!': 9, '// FIXME!': 9, '// todo: dst := src op dst -> dst inplace-op src<KAIGYO>// todo: dst := dst op addr -> dat inplace-op addr': 9, '// TODO: I think we can remove this line...': 9}",1.0,{}
212,56972.0,2.0,3.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/56972,Port method closures over to V4,1.0,{},0.0,"{'// Hack to allow us to identify these functions': 1, '// Special hack to return info about this closure.': 1}",1.0,{}
228,56973.0,2.0,4.0,1.0,MERGED,True,https://codereview.qt-project.org/#/c/56973,Implement JS ownership policy for var and variant properties,1.0,"{'// Need JS wrapper to ensure variant and var properties are marked.<KAIGYO>// ### FIXME: I hope that this can be removed once we have the proper scope chain<KAIGYO>// set up and the JS wrappers always exist.': 1, '// XXX TODO: optimize?': 1}",1.0,"{'// ### FIXME': 1, '// XXX TODO: optimize?': 1, '// ### FIXME<KAIGYO>// ep->v8engine()->addRelationshipForGC(vmemo->object, vmemo->varProperties);': 1}",1.0,{}
214,56975.0,1.0,3.0,0.0,ABANDONED,False,https://codereview.qt-project.org/#/c/56975,Font’s fast code path doesn’t handle partial runs correctly when kerning or ligatures are enabled,1.0,{},0.0,"{'// FIXME: Use the fast code path once it handles partial runs with kerning and ligatures. See httpwebkit.org/b/100050': 1, '// FIXME: Using separate glyph buffers for the prefix and the suffix is incorrect when kerning or<KAIGYO>// ligatures are enabled.': 1}",1.0,{}
33,57015.0,4.0,5.0,1.0,MERGED,True,https://codereview.qt-project.org/#/c/57015,Convert builtin methods from v8 to v4,1.0,{'// FIXME: With v8 we cloned the binding argument': 3},1.0,{'// FIXME: With v8 we cloned the binding argument': 3},1.0,{}
61,57168.0,3.0,7.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/57168,Package dialogs examples into a single executable,1.0,"{""// TODO: QTBUG-29814 This isn't portable, but we don't expose QDir::tempPath to QML yet."": 2}",1.0,"{""// TODO: QTBUG-29814 This isn't portable, but we don't expose QDir::tempPath to QML yet."": 2}",1.0,{}
76,57265.0,4.0,5.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/57265,Clean-up the linearize function.,1.0,"{'// TODO: merge 2 basic blocks A and B if A has one outgoing edge (to B), B has one incoming<KAIGYO>// edge (from A), but not when A has more than 1 incoming edge and B has more than one<KAIGYO>// outgoing edge.': 1, '// Number all basic blocks, so we have nice numbers in the dumps:': 1}",1.0,"{'// TODO: merge 2 basic blocks A and B if A has one outgoing edge (to B), B has one incoming<KAIGYO>// edge (from A), but not when A has more than 1 incoming edge and B has more than one<KAIGYO>// outgoing edge.': 1, '// TODO: remove blocks that only have a JUMP statement, and re-wire their predecessor/successor.': 1}",1.0,{}
272,57266.0,20.0,30.0,12.0,MERGED,True,https://codereview.qt-project.org/#/c/57266,Add lifetime interval calculation.,1.0,"{'// TODO: extend to optimize out temp-to-temp moves, where the lifetime of one temp ends at that statement.<KAIGYO>//       To handle that, add a hint when such a move will occur, and add a stmt for the hint.<KAIGYO>//       Then when asked for a register, check if the active statement is the terminating statement, and if so, apply the hint.<KAIGYO>//       This generalises the hint usage for Phi removal too, when the phi is passed in there as the current statement.': 6, '// not allocated by a hint, so search for a free slot': 6, '// FIXME: support Const exprs in Phi nodes.': 6, '// TODO: patch stack size (the push instruction)': 6, '// ### TODO': 6, '/*<KAIGYO> * Quick function to convert out of SSA, so we can put the stuff through the ISel phases. This<KAIGYO> * has to be replaced by a phase in the specific ISel back-ends and do register allocation at the<KAIGYO> * same time. That way the huge number of redundant moves generated by this function are eliminated.<KAIGYO> */': 6}",1.0,"{'// ### TODO': 6, '/*<KAIGYO> * Quick function to convert out of SSA, so we can put the stuff through the ISel phases. This<KAIGYO> * has to be replaced by a phase in the specific ISel back-ends and do register allocation at the<KAIGYO> * same time. That way the huge number of redundant moves generated by this function are eliminated.<KAIGYO> */': 6}",1.0,{}
118,57426.0,1.0,5.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/57426,Font’s fast code path doesn’t handle partial runs correctly when kerning or ligatures are enabled,1.0,{},0.0,"{'// FIXME: Use the fast code path once it handles partial runs with kerning and ligatures. See httpwebkit.org/b/100050': 1, '// FIXME: Using separate glyph buffers for the prefix and the suffix is incorrect when kerning or<KAIGYO>// ligatures are enabled.': 1}",1.0,{}
169,57443.0,7.0,9.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/57443,Remove the index magic from the temp.,1.0,{'// TODO': 1},1.0,{'// TODO: maybe we should move this somewhere else?': 1},1.0,{}
115,57444.0,1.0,2.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/57444,Remove now unused subcontext functionality,1.0,{},0.0,"{'// This is a pretty horrible hack, and an abuse of external strings.  When we create a <KAIGYO>// sub-context (a context created by a Qt.include() in an external javascript file),<KAIGYO>// we pass a specially crafted SubContext external string as the v8::Script::Data() to<KAIGYO>// the script, which contains a pointer to the context.  We can then access the <KAIGYO>// v8::Script::Data() later on to resolve names and URLs against the sub-context instead<KAIGYO>// of the main outer context.': 1}",1.0,{}
121,57468.0,1.0,2.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/57468,Cleanup: Remove dead code in QObject ownership handling,1.0,{},0.0,"{'// ### FIXME<KAIGYO>// handle.MakeWeak(0, WeakQObjectReferenceCallback); // revive.': 1, '// ### FIXME<KAIGYO>//ddata->v8object.MakeWeak(this, WeakQObjectReferenceCallback);': 1, '// ### FIXME: registerWeakQObjectReference(wrapper);<KAIGYO>// ### FIXME<KAIGYO>//ddata->v8object.MakeWeak(this, WeakQObjectReferenceCallback);': 1, ""// ### FIXME registerWeakQObjectReference(wrapper);<KAIGYO>// ### FIXME<KAIGYO>//            (*iter)->v8object.MakeWeak((*iter), WeakQObjectInstanceCallback);<KAIGYO>// returns true if the object's qqmldata v8object handle should<KAIGYO>// be disposed by the caller, false if it should not be (due to<KAIGYO>// creation status, etc)."": 1}",1.0,{}
134,57481.0,4.0,6.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/57481,Move v8contextwrapper implementation over to v4.,1.0,{},0.0,{'// XXX NewInstance() should be optimized': 1},1.0,{}
139,57509.0,2.0,9.0,9.0,ABANDONED,False,https://codereview.qt-project.org/#/c/57509,Port QQuickParticleData JS wrapper to V4,1.0,"{'/*!<KAIGYO>    \\qmltype Particle<KAIGYO>    \\inqmlmodule QtQuick.Particles 2<KAIGYO>    \\brief Represents particles manipulated by emitters and affectors<KAIGYO>    \\ingroup qtquick-particles<KAIGYO><KAIGYO>    Particle elements are always managed internally by the ParticleSystem and cannot be created in QML.<KAIGYO>    However, sometimes they are exposed via signals so as to allow arbitrary changes to the particle state<KAIGYO>*/': 1, ""//### Particle data handles are not locked to within certain scopes like QQuickContext2D, but there's no way to reload either...<KAIGYO>//TODO: Guard needed?"": 1}",1.0,"{'/*!<KAIGYO>    \\qmltype Particle<KAIGYO>    \\inqmlmodule QtQuick.Particles 2<KAIGYO>    \\brief Represents particles manipulated by emitters and affectors<KAIGYO>    \\ingroup qtquick-particles<KAIGYO><KAIGYO>    Particle elements are always managed internally by the ParticleSystem and cannot be created in QML.<KAIGYO>    However, sometimes they are exposed via signals so as to allow arbitrary changes to the particle state<KAIGYO>*/': 1, '//TODO: Guard needed?': 1}",1.0,{}
140,57540.0,1.0,2.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/57540,Port the type wrapper over to v4,1.0,{},0.0,{'// XXX NewInstance() should be optimized': 1},1.0,{}
146,57564.0,2.0,3.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/57564,Port the value type wrapper over to use V4,1.0,{},0.0,{'// XXX NewInstance() should be optimized': 1},1.0,{}
154,57589.0,4.0,5.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/57589,QObject bindings: Cleanups,1.0,{'// why -1 instead of callType?': 4},1.0,{'// why -1 instead of callType?': 4},1.0,{}
171,57590.0,2.0,4.0,2.0,MERGED,True,https://codereview.qt-project.org/#/c/57590,Port the list wrapper over to v4,1.0,{},0.0,{'// XXX NewInstance() should be optimized': 1},1.0,{}
192,57689.0,2.0,3.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/57689,Remove some unused code,1.0,{},0.0,"{'// see also: QV8GCCallback::garbageCollectorPrologueCallback()<KAIGYO>// ### FIXME<KAIGYO>//    varProperties.MakeWeak(static_cast<void*>(this), VarPropertiesWeakReferenceCallback);': 1, '// ### FIXME<KAIGYO>//        v8::V8::AddImplicitReferences(m_strongReferencer, &handle, 1);': 1, '// ### FIXME': 1}",1.0,{}
230,57792.0,3.0,3.0,0.0,ABANDONED,False,https://codereview.qt-project.org/#/c/57792,Created a class out of the SSA functions.,1.0,"{'// TODO: merge/change the hash above': 1, '/*<KAIGYO> * Quick function to convert out of SSA, so we can put the stuff through the ISel phases. This<KAIGYO> * has to be replaced by a phase in the specific ISel back-ends and do register allocation at the<KAIGYO> * same time. That way the huge number of redundant moves generated by this function are eliminated.<KAIGYO> */': 1}",1.0,"{'/*<KAIGYO> * Quick function to convert out of SSA, so we can put the stuff through the ISel phases. This<KAIGYO> * has to be replaced by a phase in the specific ISel back-ends and do register allocation at the<KAIGYO> * same time. That way the huge number of redundant moves generated by this function are eliminated.<KAIGYO> */': 1}",1.0,{}
221,57820.0,1.0,2.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/57820,Get rid of inner MethodClosure object in QV8QObjectWrapper,1.0,{},0.0,"{'// XXX More recent versions of V8 introduced """" objects.  It is possible that these<KAIGYO>// will be a faster way of creating QObject method objects.': 1}",1.0,{}
54,58026.0,4.0,5.0,0.0,ABANDONED,False,https://codereview.qt-project.org/#/c/58026,Added a stack-slot allocator for the interpreter.,1.0,"{'// TODO: extend to optimise out temp-to-temp moves, where the lifetime of one temp ends at that statement.<KAIGYO>//       To handle that, add a hint when such a move will occur, and add a stmt for the hint.<KAIGYO>//       Then when asked for a register, check if the active statement is the terminating statement, and if so, apply the hint.<KAIGYO>//       This generalises the hint usage for Phi removal too, when the phi is passed in there as the current statement.': 1, '// not allocated by a hint, so search for a free slot': 1, '// FIXME: support Const exprs in Phi nodes.': 1, '// TODO: patch stack size (the push instruction)': 1, '// ### TODO': 1, '// TODO: extend to optimize out temp-to-temp moves, where the lifetime of one temp ends at that statement.<KAIGYO>//       To handle that, add a hint when such a move will occur, and add a stmt for the hint.<KAIGYO>//       Then when asked for a register, check if the active statement is the terminating statement, and if so, apply the hint.<KAIGYO>//       This generalises the hint usage for Phi removal too, when the phi is passed in there as the current statement.': 4}",1.0,"{'// ### TODO': 1, '// TODO: merge/change the hash above': 1}",1.0,{}
44,58236.0,1.0,2.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/58236,Move QV4::QObjectWrapper into the v4/ subdirectory,1.0,{},0.0,{'// ### FIXME: remove when qv8qobjectwrapper port is done.': 1},1.0,{}
70,58318.0,1.0,2.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/58318,Fix qqmlecmascript::sequenceConversionIndexes,1.0,{},0.0,{'// ### FIXME: we may need to record the return address upon entering from<KAIGYO>// JIT code and then look up in a map from instruction pointer to line number.': 1},1.0,{}
169,58671.0,2.0,3.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/58671,Remove last traces of v8 API and v8 compatibility layer,1.0,{},0.0,"{'// ### FIXME.': 1, '// ### FIXME': 1}",1.0,{}
161,58712.0,3.0,16.0,4.0,ABANDONED,False,https://codereview.qt-project.org/#/c/58712,build-time invoke qlalr,1.0,{},0.0,"{'     sym(2).VariableDeclarationList->finish (/*readOnly=*/sym(1).ival == T_CONST));<KAIGYO>  node->declarationKindToken = loc(1);<KAIGYO>  node->semicolonToken = loc(3);<KAIGYO>  sym(1).Node = node;<KAIGYO>} break;<KAIGYO><KAIGYO>case 274: {<KAIGYO>  sym(1).ival = T_CONST;<KAIGYO>} break;<KAIGYO><KAIGYO>case 275: {<KAIGYO>  sym(1).ival = T_VAR;<KAIGYO>} break;<KAIGYO><KAIGYO>case 276: {<KAIGYO>  sym(1).Node = new (pool) AST::VariableDeclarationList(sym(1).VariableDeclaration);<KAIGYO>} break;<KAIGYO><KAIGYO>case 277: {<KAIGYO>  AST::VariableDeclarationList *node = new (pool) AST::VariableDeclarationList(<KAIGYO>    sym(1).VariableDeclarationList, sym(3).VariableDeclaration);<KAIGYO>  node->commaToken = loc(2);<KAIGYO>  sym(1).Node = node;<KAIGYO>} break;<KAIGYO><KAIGYO>case 278: {<KAIGYO>  sym(1).Node = new (pool) AST::VariableDeclarationList(sym(1).VariableDeclaration);<KAIGYO>} break;<KAIGYO><KAIGYO>case 279: {<KAIGYO>  sym(1).Node = new (pool) AST::VariableDeclarationList(sym(1).VariableDeclarationList, sym(3).VariableDeclaration);<KAIGYO>} break;<KAIGYO><KAIGYO>case 280: {<KAIGYO>  AST::VariableDeclaration *node = new (pool) AST::VariableDeclaration(stringRef(1), sym(2).Expression);<KAIGYO>  node->identifierToken = loc(1);<KAIGYO>  sym(1).Node = node;<KAIGYO>} break;<KAIGYO><KAIGYO>case 281: {<KAIGYO>  AST::VariableDeclaration *node = new (pool) AST::VariableDeclaration(stringRef(1), sym(2).Expression);<KAIGYO>  node->identifierToken = loc(1);<KAIGYO>  sym(1).Node = node;<KAIGYO>} break;<KAIGYO><KAIGYO>case 282: {<KAIGYO>  // ### TODO: AST for initializer<KAIGYO>  sym(1) = sym(2);<KAIGYO>} break;<KAIGYO><KAIGYO>case 283: {<KAIGYO>  sym(1).Node = 0;<KAIGYO>} break;<KAIGYO><KAIGYO>case 285: {<KAIGYO>  // ### TODO: AST for initializer<KAIGYO>  sym(1) = sym(2);<KAIGYO>} break;<KAIGYO><KAIGYO>case 286: {<KAIGYO>  sym(1).Node = 0;<KAIGYO>} break;<KAIGYO><KAIGYO>case 288: {<KAIGYO>  AST::EmptyStatement *node = new (pool) AST::EmptyStatement();<KAIGYO>  node->semicolonToken = loc(1);<KAIGYO>  sym(1).Node = node;<KAIGYO>} break;<KAIGYO><KAIGYO>case 290: {<KAIGYO>  AST::ExpressionStatement *node = new (pool) AST::ExpressionStatement(sym(1).Expression);<KAIGYO>  node->semicolonToken = loc(2);<KAIGYO>  sym(1).Node = node;<KAIGYO>} break;<KAIGYO><KAIGYO>case 291: {<KAIGYO>  AST::IfStatement *node = new (pool) AST::IfStatement(sym(3).Expression, sym(5).Statement, sym(7).Statement);<KAIGYO>  node->ifToken = loc(1);<KAIGYO>  node->lparenToken = loc(2);<KAIGYO>  node->rparenToken = loc(4);<KAIGYO>  node->elseToken = loc(6);<KAIGYO>  sym(1).Node = node;<KAIGYO>} break;<KAIGYO><KAIGYO>case 292: {<KAIGYO>  AST::IfStatement *node = new (pool) AST::IfStatement(sym(3).Expression, sym(5).Statement);<KAIGYO>  node->ifToken = loc(1);<KAIGYO>  node->lparenToken = loc(2);<KAIGYO>  node->rparenToken = loc(4);<KAIGYO>  sym(1).Node = node;<KAIGYO>} break;<KAIGYO><KAIGYO>case 295: {<KAIGYO>  AST::DoWhileStatement *node = new (pool) AST::DoWhileStatement(sym(2).Statement, sym(5).Expression);<KAIGYO>  node->doToken = loc(1);<KAIGYO>  node->whileToken = loc(3);<KAIGYO>  node->lparenToken = loc(4);<KAIGYO>  node->rparenToken = loc(6);<KAIGYO>  node->semicolonToken = loc(7);<KAIGYO>  sym(1).Node = node;<KAIGYO>} break;<KAIGYO><KAIGYO>case 296: {<KAIGYO>  AST::WhileStatement *node = new (pool) AST::WhileStatement(sym(3).Expression, sym(5).Statement);<KAIGYO>  node->whileToken = loc(1);<KAIGYO>  node->lparenToken = loc(2);<KAIGYO>  node->rparenToken = loc(4);<KAIGYO>  sym(1).Node = node;<KAIGYO>} break;<KAIGYO><KAIGYO>case 297: {<KAIGYO>  AST::ForStatement *node = new (pool) AST::ForStatement(sym(3).Expression,<KAIGYO>    sym(5).Expression, sym(7).Expression, sym(9).Statement);<KAIGYO>  node->forToken = loc(1);<KAIGYO>  node->lparenToken = loc(2);<KAIGYO>  node->firstSemicolonToken = loc(4);<KAIGYO>  node->secondSemicolonToken = loc(6);<KAIGYO>  node->rparenToken = loc(8);<KAIGYO>  sym(1).Node = node;<KAIGYO>} break;<KAIGYO><KAIGYO>case 298: {<KAIGYO>  AST::LocalForStatement *node = new (pool) AST::LocalForStatement(<KAIGYO>     sym(4).VariableDeclarationList->finish (/*readOnly=*/': 1, '     sym(2).VariableDeclarationList->finish (/*readOnly=*/sym(1).ival == T_CONST));<KAIGYO>  node->declarationKindToken = loc(1);<KAIGYO>  node->semicolonToken = loc(3);<KAIGYO>  sym(1).Node = node;<KAIGYO>} break;<KAIGYO><KAIGYO>case 280: {<KAIGYO>  sym(1).ival = T_CONST;<KAIGYO>} break;<KAIGYO><KAIGYO>case 281: {<KAIGYO>  sym(1).ival = T_VAR;<KAIGYO>} break;<KAIGYO><KAIGYO>case 282: {<KAIGYO>  sym(1).Node = new (pool) AST::VariableDeclarationList(sym(1).VariableDeclaration);<KAIGYO>} break;<KAIGYO><KAIGYO>case 283: {<KAIGYO>  AST::VariableDeclarationList *node = new (pool) AST::VariableDeclarationList(<KAIGYO>    sym(1).VariableDeclarationList, sym(3).VariableDeclaration);<KAIGYO>  node->commaToken = loc(2);<KAIGYO>  sym(1).Node = node;<KAIGYO>} break;<KAIGYO><KAIGYO>case 284: {<KAIGYO>  sym(1).Node = new (pool) AST::VariableDeclarationList(sym(1).VariableDeclaration);<KAIGYO>} break;<KAIGYO><KAIGYO>case 285: {<KAIGYO>  sym(1).Node = new (pool) AST::VariableDeclarationList(sym(1).VariableDeclarationList, sym(3).VariableDeclaration);<KAIGYO>} break;<KAIGYO><KAIGYO>case 286: {<KAIGYO>  AST::VariableDeclaration *node = new (pool) AST::VariableDeclaration(stringRef(1), sym(2).Expression);<KAIGYO>  node->identifierToken = loc(1);<KAIGYO>  sym(1).Node = node;<KAIGYO>} break;<KAIGYO><KAIGYO>case 287: {<KAIGYO>  AST::VariableDeclaration *node = new (pool) AST::VariableDeclaration(stringRef(1), sym(2).Expression);<KAIGYO>  node->identifierToken = loc(1);<KAIGYO>  sym(1).Node = node;<KAIGYO>} break;<KAIGYO><KAIGYO>case 288: {<KAIGYO>  // ### TODO: AST for initializer<KAIGYO>  sym(1) = sym(2);<KAIGYO>} break;<KAIGYO><KAIGYO>case 289: {<KAIGYO>  sym(1).Node = 0;<KAIGYO>} break;<KAIGYO><KAIGYO>case 291: {<KAIGYO>  // ### TODO: AST for initializer<KAIGYO>  sym(1) = sym(2);<KAIGYO>} break;<KAIGYO><KAIGYO>case 292: {<KAIGYO>  sym(1).Node = 0;<KAIGYO>} break;<KAIGYO><KAIGYO>case 294: {<KAIGYO>  AST::EmptyStatement *node = new (pool) AST::EmptyStatement();<KAIGYO>  node->semicolonToken = loc(1);<KAIGYO>  sym(1).Node = node;<KAIGYO>} break;<KAIGYO><KAIGYO>case 296: {<KAIGYO>  AST::ExpressionStatement *node = new (pool) AST::ExpressionStatement(sym(1).Expression);<KAIGYO>  node->semicolonToken = loc(2);<KAIGYO>  sym(1).Node = node;<KAIGYO>} break;<KAIGYO><KAIGYO>case 297: {<KAIGYO>  AST::IfStatement *node = new (pool) AST::IfStatement(sym(3).Expression, sym(5).Statement, sym(7).Statement);<KAIGYO>  node->ifToken = loc(1);<KAIGYO>  node->lparenToken = loc(2);<KAIGYO>  node->rparenToken = loc(4);<KAIGYO>  node->elseToken = loc(6);<KAIGYO>  sym(1).Node = node;<KAIGYO>} break;<KAIGYO><KAIGYO>case 298: {<KAIGYO>  AST::IfStatement *node = new (pool) AST::IfStatement(sym(3).Expression, sym(5).Statement);<KAIGYO>  node->ifToken = loc(1);<KAIGYO>  node->lparenToken = loc(2);<KAIGYO>  node->rparenToken = loc(4);<KAIGYO>  sym(1).Node = node;<KAIGYO>} break;<KAIGYO><KAIGYO>case 301: {<KAIGYO>  AST::DoWhileStatement *node = new (pool) AST::DoWhileStatement(sym(2).Statement, sym(5).Expression);<KAIGYO>  node->doToken = loc(1);<KAIGYO>  node->whileToken = loc(3);<KAIGYO>  node->lparenToken = loc(4);<KAIGYO>  node->rparenToken = loc(6);<KAIGYO>  node->semicolonToken = loc(7);<KAIGYO>  sym(1).Node = node;<KAIGYO>} break;<KAIGYO><KAIGYO>case 302: {<KAIGYO>  AST::WhileStatement *node = new (pool) AST::WhileStatement(sym(3).Expression, sym(5).Statement);<KAIGYO>  node->whileToken = loc(1);<KAIGYO>  node->lparenToken = loc(2);<KAIGYO>  node->rparenToken = loc(4);<KAIGYO>  sym(1).Node = node;<KAIGYO>} break;<KAIGYO><KAIGYO>case 303: {<KAIGYO>  AST::ForStatement *node = new (pool) AST::ForStatement(sym(3).Expression,<KAIGYO>    sym(5).Expression, sym(7).Expression, sym(9).Statement);<KAIGYO>  node->forToken = loc(1);<KAIGYO>  node->lparenToken = loc(2);<KAIGYO>  node->firstSemicolonToken = loc(4);<KAIGYO>  node->secondSemicolonToken = loc(6);<KAIGYO>  node->rparenToken = loc(8);<KAIGYO>  sym(1).Node = node;<KAIGYO>} break;<KAIGYO><KAIGYO>case 304: {<KAIGYO>  AST::LocalForStatement *node = new (pool) AST::LocalForStatement(<KAIGYO>     sym(4).VariableDeclarationList->finish (/*readOnly=*/': 2}",1.0,{}
208,58817.0,10.0,26.0,6.0,MERGED,True,https://codereview.qt-project.org/#/c/58817,Correctly parse Context2D font as per CSS shorthand font property,1.0,"{'// TODO': 1, '            Q_TRY_SET_TOKEN(FontWeight, """", /*TODO*/ qt_noop())<KAIGYO>        } else if (token.compare(QLatin1String("""")) == 0) {<KAIGYO>            Q_TRY_SET_TOKEN(FontWeight, """", /*TODO*/': 2, ""// TODO: Validate font family.<KAIGYO>// When a modern browser encounters a ctx.font assignment which specifies a font family<KAIGYO>// that the host machine doesn't have, it will search for a similar font.<KAIGYO>// Currently QFontDatabase::hasFamily is not that smart; it can't find a replacement for<KAIGYO>// Arial on Ubuntu 12.04, nor sans-serif on Mac OSX 10.8. Since we can't do this, we<KAIGYO>// can't be sure that the family passed in is invalid, so we just set it regardless."": 7}",1.0,{'// ### this is simplified and incomplete<KAIGYO>// ### TODO:get code from Qt webkit': 1},1.0,{}
188,58861.0,1.0,2.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/58861,Remove test case that violates the ecma spec,1.0,{},0.0,"{'// ECMA-262 does not allow function declarations to be used as statements,<KAIGYO>// but several popular implementations (including JSC) do. See the NOTE<KAIGYO>// at the beginning of chapter 12 in ECMA-262 5th edition, where it\'s<KAIGYO>// recommended that implementations either disallow this usage or issue<KAIGYO>// a warning.<KAIGYO>// Since we had a bug report long ago about QtScript not supporting this<KAIGYO>// """" (and thus deviating from other implementations), we still<KAIGYO>// check this behavior.': 1}",1.0,{}
50,59144.0,5.0,5.0,0.0,ABANDONED,False,https://codereview.qt-project.org/#/c/59144,WIP: Collect all info needed by register allocator.,1.0,"{'// TODO: verify this method': 1, '// FIXME: distinguish between inline binops and calling binops': 1, '// TODO: remove this!': 1}",1.0,{'// TODO: add a register allocator here.': 1},1.0,{}
239,59145.0,29.0,33.0,15.0,ABANDONED,False,https://codereview.qt-project.org/#/c/59145,Add linear scan register allocation.,1.0,"{'// TODO: if multiple registers are available for the whole life-time of an interval, use the one that is blocked first by a fixed interval.': 2, '// TODO: split _inactive?': 3, '// TODO: split inactive': 3, '// TODO: fixed intervals for reg': 3, '// FIXME: support Const exprs in Phi nodes.': 4, '// TODO: use the hints!<KAIGYO>// TODO: if multiple registers are available for the whole life-time of an interval, use the one that is blocked first by a fixed interval.': 5, '// TODO: check if we need to have a range which is inactive have an end that is explicit instead of the end of the last range.': 11, '// TODO: verify this method': 14, '// FIXME: distinguish between inline binops and calling binops': 14, '// TODO: remove this!': 14, '// TODO: I think we can remove this line...': 19, '// TODO: check if we can always skip the optional register uses': 19, '// TODO: do not generate a call (meaning: block all registers), but annotate the conversion with registers that need to be saved and have masm take care of that.': 25, '// FIXME: propagate this': 25, '// FIXME: I think we can remove this line...': 25, '// FIXME: not sure about this, check isStructurallyValidLanguageTag': 25, '// TODO: masm cannot handle registers yet.': 26, '// TODO: check isStructurallyValidLanguageTag': 29}",1.0,{'// TODO: add a register allocator here.': 14},1.0,{}
30,59215.0,1.0,2.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/59215,Fix two more errors in the worker script auto test,1.0,{},0.0,"{'// ###        QQmlExpressionPrivate::exceptionToError(e, error);<KAIGYO>// XXX ???<KAIGYO>// workerEngine->baseUrl = url;': 1}",1.0,{}
34,59245.0,1.0,2.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/59245,Fix tst_qqmlecmascript::functionAssignment_afterBinding,1.0,{},0.0,{'// FIXME: With v8 we cloned the binding argument': 1},1.0,{}
182,59656.0,1.0,3.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/59656,Merge branch 'dev' of ssh://codereview.qt-project.org/qt/qtdeclarative into wip/v4,1.0,{'// ### FIXME: v4': 1},1.0,"{'//    ### FIXME: v4<KAIGYO>//    v8::Debug::SetMessageHandler2(DebugMessageHandler);<KAIGYO>//    v8::Debug::SetDebugMessageDispatchHandler(DebugMessageDispatchHandler);': 1, '//  ### FIXME: v4  v8::Debug::SendCommand(message.utf16(), message.size());': 1, '// TODO: avoid construction of name and name-based lookup': 1, ""// Delegate the conversion. This is pretty fast and it doesn't require a QScriptEngine.<KAIGYO>// Ideally we should just call the methods in the QScript namespace directly."": 1, '// RootStorage is more efficient than ScopeStorage, so prefer that if they are the same': 1, '// ### TODO: cx format': 1, '// The binding was not compiled.  There are some exceptional cases which the<KAIGYO>// expression rewriter does not rewrite properly (e.g., \\r-terminated lines<KAIGYO>// are not rewritten correctly but this bug is demed out-of-scope to fix for<KAIGYO>// performance reasons; see QTBUG-24064).': 1, '// This is a pretty horrible hack, and an abuse of external strings.  When we create a <KAIGYO>// sub-context (a context created by a Qt.include() in an external javascript file),<KAIGYO>// we pass a specially crafted SubContext external string as the v8::Script::Data() to<KAIGYO>// the script, which contains a pointer to the context.  We can then access the <KAIGYO>// v8::Script::Data() later on to resolve names and URLs against the sub-context instead<KAIGYO>// of the main outer context.': 1, '// XXX NewInstance() should be optimized': 1, '// XXX TODO: Need to review all calls to QQmlEngine *engine() to confirm QObjects work<KAIGYO>// correctly in a worker thread': 1, '// Hack to allow us to identify these functions': 1, '// XXX More recent versions of V8 introduced """" objects.  It is possible that these<KAIGYO>// will be a faster way of creating QObject method objects.': 1, ""// XXX TODO: Enables fast property accessors.  These more than double the property access <KAIGYO>// performance, but the  cost of setting up this structure hasn't been measured so <KAIGYO>// its not guaranteed that this is a win overall.  We need to try and measure the cost."": 1, '// We already have a better option': 1, '// Special hack to return info about this closure.': 1, '// why -1 instead of callType?': 1, '// XXX Can this be made more by using Array as a prototype and implementing<KAIGYO>// directly against QList<QObject*>?': 1, '// ECMA-262 does not allow function declarations to be used as statements,<KAIGYO>// but several popular implementations (including JSC) do. See the NOTE<KAIGYO>// at the beginning of chapter 12 in ECMA-262 5th edition, where it\'s<KAIGYO>// recommended that implementations either disallow this usage or issue<KAIGYO>// a warning.<KAIGYO>// Since we had a bug report long ago about Qt Script not supporting this<KAIGYO>// """" (and thus deviating from other implementations), we still<KAIGYO>// check this behavior.': 1}",1.0,{}
226,59754.0,15.0,15.0,0.0,ABANDONED,False,https://codereview.qt-project.org/#/c/59754,WIP: change the JIT to use the register allocator.,1.0,"{'// FIXME!': 1, '// TODO!': 1, '// todo: dst := src op dst -> dst inplace-op src<KAIGYO>// todo: dst := dst op addr -> dat inplace-op addr': 10}",1.0,{'// FIXME: do something more useful with this info': 1},1.0,{}
41,60050.0,5.0,13.0,4.0,MERGED,True,https://codereview.qt-project.org/#/c/60050,Fix broken QBluetoothLocalDevice::isValid() behavior,1.0,{},0.0,{'    /*<KAIGYO>    //TODO the above should really be the following once QBluetoothLocalDevice has been fixed<KAIGYO>    if (!QBluetoothLocalDevice::allDevices().count())<KAIGYO>        QVERIFY(!localDevice.isValid());<KAIGYO>    else<KAIGYO>    */': 1},1.0,{}
47,60093.0,5.0,21.0,5.0,MERGED,True,https://codereview.qt-project.org/#/c/60093,QtQuick.Dialogs: use URLs for interface with QPlatformFileDialogHelper,1.0,{},0.0,"{'    /* TODO after dialog helper switches to URLs<KAIGYO>        return QUrl::fromLocalFile(m_dlgHelper->directory());<KAIGYO>    return QUrl::fromLocalFile(m_options->initialDirectory());<KAIGYO>    */': 2, '    /* TODO after dialog helper switches to URLs<KAIGYO>    if (m_dlgHelper)<KAIGYO>        foreach (QString path, m_dlgHelper->selectedFiles())<KAIGYO>            ret << QUrl::fromLocalFile(path);<KAIGYO>    */': 2, '    /* TODO after dialog helper switches to URLs<KAIGYO>    virtual QString directory() const { return m_dialog.directory().absolutePath(); }<KAIGYO>    virtual QStringList selectedFiles() const { return m_dialog.selectedFiles(); }<KAIGYO>    */': 2, '    /* TODO after dialog helper switches to URLs<KAIGYO>    */': 5}",1.0,{}
115,60414.0,3.0,5.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/60414,Fix regression in tst_qqmlecmascript::signalAssignment,1.0,{'//TODO: look at using the property cache here (as in the compiler)<KAIGYO>//      for further optimization': 2},1.0,{'//TODO: look at using the property cache here (as in the compiler)<KAIGYO>//      for further optimization': 2},1.0,{}
151,60839.0,5.0,5.0,0.0,ABANDONED,False,https://codereview.qt-project.org/#/c/60839,WIP: JIT changes to support SSA optimizations.,1.0,{},0.0,{'// TODO!': 2},1.0,{}
55,61323.0,3.0,11.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/61323,Merge branch 'dev' of ssh://codereview.qt-project.org/qt/qtdeclarative into wip/v4,1.0,{},0.0,{'// ### this is simplified and incomplete<KAIGYO>// ### TODO:get code from Qt webkit': 1},1.0,{}
51,61324.0,1.0,8.0,0.0,ABANDONED,False,https://codereview.qt-project.org/#/c/61324,Re-enable the dialogs module,1.0,{},0.0,{'    /* TODO after dialog helper switches to URLs<KAIGYO>    */': 1},1.0,{}
56,61368.0,1.0,5.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/61368,[Qt] Avoid creating a QWindow for offscreen GraphicsContext3D,1.0,{},0.0,{'// FIXME: Find a way to create a QOpenGLContext without creating a QWindow at all.<KAIGYO>// We need to create a surface in order to create a QOpenGLContext and make it current.': 1},1.0,{}
64,61379.0,1.0,7.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/61379,FolderListModel provides file URLs and the QML FileDialog uses them,1.0,{},0.0,{'// TODO after QTBUG-32039: should not need to convert pathToUrl here': 1},1.0,{}
142,61570.0,4.0,4.0,0.0,ABANDONED,False,https://codereview.qt-project.org/#/c/61570,WIP: asdf,1.0,"{'// FIXME!': 1, '// TODO: do not generate a call (meaning: block all registers), but annotate the conversion with registers that need to be saved and have masm take care of that.': 1, '// FIXME: propagate this': 1}",1.0,"{'// FIXME!': 1, '// todo: dst := src op dst -> dst inplace-op src<KAIGYO>// todo: dst := dst op addr -> dat inplace-op addr': 1}",1.0,{}
165,61695.0,3.0,3.0,0.0,ABANDONED,False,https://codereview.qt-project.org/#/c/61695,WIP: now passing ch06,1.0,{'//            if (!it.covers(successorStart))<KAIGYO>// FIXME: I think we can remove this line...': 1},1.0,{'// TODO: I think we can remove this line...': 1},1.0,{}
200,61914.0,10.0,19.0,8.0,ABANDONED,False,https://codereview.qt-project.org/#/c/61914,Various fixes to the optimizer.,1.0,"{'// TODO: when propagating other constants, e.g. undefined, the other<KAIGYO>// optimization passes have to be changed to cope with them.<KAIGYO>//                        qout<<""""<<endl;': 1, '// TODO: implement unop propagation for other constant types': 1, '// TODO: Constant binary expression evaluation': 1}",1.0,"{'// TODO: merge 2 basic blocks A and B if A has one outgoing edge (to B), B has one incoming<KAIGYO>// edge (from A), but not when A has more than 1 incoming edge and B has more than one<KAIGYO>// outgoing edge.': 1}",1.0,{}
203,61979.0,14.0,14.0,0.0,ABANDONED,False,https://codereview.qt-project.org/#/c/61979,"WIP: The fast and the furious, register drift.",1.0,"{'// TODO: change masm to generate code': 1, '// FIXME: TODO!': 2, ""// switch<KAIGYO>// TODO: in SSA optimisation, do constant expression evaluation.<KAIGYO>// The case here is, for example:<KAIGYO>//   if (true === true) .....<KAIGYO>// Of course, after folding the CJUMP to a JUMP, dead-code (dead-basic-block)<KAIGYO>// elimination (which isn't there either) would remove the whole else block."": 2, '// TODO: SSA optimisation for constant condition evaluation should remove this.<KAIGYO>// See also visitCJump() in RegAllocInfo.': 5, '// TODO: SSA optimisation for constant condition evaluation should remove this.<KAIGYO>// See also visitCJump() in masm.': 5, '    _as->leaveStandardStackFrame(/*locals*/false);<KAIGYO>    Q_ASSERT(arg);<KAIGYO>    Q_ASSERT(result);<KAIGYO><KAIGYO>    Q_ASSERT(arg);<KAIGYO>    Q_ASSERT(result);<KAIGYO><KAIGYO>    Q_ASSERT(arg);<KAIGYO><KAIGYO>    Q_ASSERT(object);<KAIGYO>    Q_ASSERT(getter);<KAIGYO>    Q_ASSERT(setter);<KAIGYO>void InstructionSelection::callBuiltinDefineProperty(V4IR::Temp *object, const QString &name,<KAIGYO>                                                     V4IR::Expr *value)<KAIGYO>    Q_ASSERT(object);<KAIGYO>    Q_ASSERT(value->asTemp() || value->asConst());<KAIGYO><KAIGYO>    generateFunctionCall(Assembler::Void, __qmljs_builtin_define_property,<KAIGYO>                         Assembler::ContextRegister, Assembler::Reference(object), identifier(name),<KAIGYO>                         Assembler::PointerToValue(value));<KAIGYO>    Q_ASSERT(result);<KAIGYO><KAIGYO>                         Assembler::PointerToValue(result), baseAddressForCallArguments(),<KAIGYO>                         Assembler::TrustedImm32(length));<KAIGYO>    Q_ASSERT(result);<KAIGYO><KAIGYO>        _as->copyValue(_as->_stackLayout.argumentAddressForCall(argc++), it->expr);<KAIGYO>            _as->copyValue(_as->_stackLayout.argumentAddressForCall(argc++), it->expr);<KAIGYO>    Q_ASSERT(value);<KAIGYO><KAIGYO>    _as->load64(Pointer(Assembler::ContextRegister, offsetof(ExecutionContext, thisObject)),<KAIGYO>                Assembler::ReturnValueRegister);<KAIGYO>    if (targetTemp->kind == V4IR::Temp::PhysicalRegister) {<KAIGYO>        if (targetTemp->type == V4IR::DoubleType) {<KAIGYO>            Q_ASSERT(sourceConst->type == V4IR::DoubleType);<KAIGYO>            _as->loadDouble(_as->constTableAddr(sourceConst).m_ptr,<KAIGYO>                            (Assembler::FPRegisterID) targetTemp->index);<KAIGYO>        } else if (targetTemp->type == V4IR::SInt32Type) {<KAIGYO>            Q_ASSERT(sourceConst->type == V4IR::SInt32Type);<KAIGYO>            _as->move(Assembler::TrustedImm32(convertToValue(sourceConst).int_32),<KAIGYO>                      (Assembler::RegisterID) targetTemp->index);<KAIGYO>        } else if (targetTemp->type == V4IR::UInt32Type) {<KAIGYO>            Q_ASSERT(sourceConst->type == V4IR::UInt32Type);<KAIGYO>            _as->move(Assembler::TrustedImm32(convertToValue(sourceConst).uint_32),<KAIGYO>                      (Assembler::RegisterID) targetTemp->index);<KAIGYO>        } else if (targetTemp->type == V4IR::BoolType) {<KAIGYO>            Q_ASSERT(sourceConst->type == V4IR::BoolType);<KAIGYO>            _as->move(Assembler::TrustedImm32(convertToValue(sourceConst).int_32),<KAIGYO>                      (Assembler::RegisterID) targetTemp->index);<KAIGYO>        } else {<KAIGYO>            Q_UNIMPLEMENTED();<KAIGYO>        }<KAIGYO>    } else {<KAIGYO>        _as->storeValue(convertToValue(sourceConst), targetTemp);<KAIGYO>    }<KAIGYO>void InstructionSelection::setActivationProperty(V4IR::Expr *source, const QString &targetName)<KAIGYO>                         Assembler::ContextRegister, propertyName, Assembler::PointerToValue(source));<KAIGYO>void InstructionSelection::getProperty(V4IR::Expr *base, const QString &name, V4IR::Temp *target)<KAIGYO>                           Assembler::PointerToValue(base));<KAIGYO>        generateFunctionCall(Assembler::Void, __qmljs_get_property, Assembler::ContextRegister,<KAIGYO>                             Assembler::PointerToValue(target), Assembler::PointerToValue(base),<KAIGYO>                             identifier(name));<KAIGYO>void InstructionSelection::setProperty(V4IR::Expr *source, V4IR::Expr *targetBase,<KAIGYO>                                       const QString &targetName)<KAIGYO>        generateLookupCall(index, offsetof(QV4::Lookup, setter),<KAIGYO>                           Assembler::PointerToValue(targetBase),<KAIGYO>                           Assembler::PointerToValue(source));<KAIGYO>                             Assembler::PointerToValue(targetBase), identifier(targetName),<KAIGYO>                             Assembler::PointerToValue(source));<KAIGYO>void InstructionSelection::getElement(V4IR::Expr *base, V4IR::Expr *index, V4IR::Temp *target)<KAIGYO>                         Assembler::PointerToValue(target), Assembler::PointerToValue(base),<KAIGYO>                         Assembler::PointerToValue(index));<KAIGYO>void InstructionSelection::setElement(V4IR::Expr *source, V4IR::Expr *targetBase, V4IR::Expr *targetIndex)<KAIGYO>                         Assembler::PointerToValue(targetBase), Assembler::PointerToValue(targetIndex),<KAIGYO>                         Assembler::PointerToValue(source));<KAIGYO>    if (*sourceTemp == *targetTemp)<KAIGYO>        return;<KAIGYO><KAIGYO>    if (sourceTemp->kind == V4IR::Temp::PhysicalRegister) {<KAIGYO>        if (targetTemp->kind == V4IR::Temp::PhysicalRegister) {<KAIGYO>            if (sourceTemp->type == V4IR::DoubleType)<KAIGYO>                _as->moveDouble((Assembler::FPRegisterID) sourceTemp->index,<KAIGYO>                                (Assembler::FPRegisterID) targetTemp->index);<KAIGYO>            else<KAIGYO>                _as->move((Assembler::RegisterID) sourceTemp->index,<KAIGYO>                          (Assembler::RegisterID) targetTemp->index);<KAIGYO>            return;<KAIGYO>        } else {<KAIGYO>            Assembler::Pointer addr = _as->loadTempAddress(Assembler::ScratchRegister, targetTemp);<KAIGYO>            switch (sourceTemp->type) {<KAIGYO>            case V4IR::DoubleType:<KAIGYO>                _as->storeDouble((Assembler::FPRegisterID) sourceTemp->index, addr);<KAIGYO>                break;<KAIGYO>            case V4IR::SInt32Type:<KAIGYO>                _as->store32((Assembler::RegisterID) sourceTemp->index, addr);<KAIGYO>                addr.offset += 4;<KAIGYO>                _as->store32(Assembler::TrustedImm32(Value::fromInt32(0).tag), addr);<KAIGYO>                break;<KAIGYO>            case V4IR::UInt32Type:<KAIGYO>                _as->store32((Assembler::RegisterID) sourceTemp->index, addr);<KAIGYO>                addr.offset += 4;<KAIGYO>                _as->store32(Assembler::TrustedImm32(Value::fromUInt32(0).tag), addr);<KAIGYO>                break;<KAIGYO>            case V4IR::BoolType:<KAIGYO>                _as->storeBool((Assembler::RegisterID) sourceTemp->index, addr);<KAIGYO>                break;<KAIGYO>            default:<KAIGYO>                _as->store64((Assembler::RegisterID) sourceTemp->index, addr);<KAIGYO>                break;<KAIGYO>            }<KAIGYO>            return;<KAIGYO>        }<KAIGYO>    } else if (targetTemp->kind == V4IR::Temp::PhysicalRegister) {<KAIGYO>        switch (targetTemp->type) {<KAIGYO>        case V4IR::DoubleType:<KAIGYO>            toDoubleRegister(sourceTemp, (Assembler::FPRegisterID) targetTemp->index);<KAIGYO>            return;<KAIGYO>        case V4IR::BoolType:<KAIGYO>        case V4IR::SInt32Type:<KAIGYO>        case V4IR::UInt32Type:<KAIGYO>            toInt32Register(sourceTemp, (Assembler::RegisterID) targetTemp->index);<KAIGYO>            return;<KAIGYO>        case V4IR::StringType:<KAIGYO>            _as->load64(_as->stackSlotPointer(sourceTemp),<KAIGYO>                        (Assembler::RegisterID) targetTemp->index);<KAIGYO>            return;<KAIGYO>        default:<KAIGYO>            break;<KAIGYO>        }<KAIGYO>    }<KAIGYO><KAIGYO>void InstructionSelection::swapValues(V4IR::Temp *sourceTemp, V4IR::Temp *targetTemp)<KAIGYO>{<KAIGYO>    Q_ASSERT(sourceTemp->type == targetTemp->type);<KAIGYO><KAIGYO>    if (sourceTemp->kind == V4IR::Temp::PhysicalRegister) {<KAIGYO>        if (targetTemp->kind == V4IR::Temp::PhysicalRegister) {<KAIGYO>            if (sourceTemp->type == V4IR::DoubleType) {<KAIGYO>                _as->moveDouble((Assembler::FPRegisterID) targetTemp->index, Assembler::FPGpr0);<KAIGYO>                _as->moveDouble((Assembler::FPRegisterID) sourceTemp->index,<KAIGYO>                                (Assembler::FPRegisterID) targetTemp->index);<KAIGYO>                _as->moveDouble(Assembler::FPGpr0, (Assembler::FPRegisterID) sourceTemp->index);<KAIGYO>            } else {<KAIGYO>                _as->swap((Assembler::RegisterID) sourceTemp->index,<KAIGYO>                          (Assembler::RegisterID) targetTemp->index);<KAIGYO>            }<KAIGYO>            return;<KAIGYO>        }<KAIGYO>    } else if (sourceTemp->kind == V4IR::Temp::StackSlot) {<KAIGYO>        if (targetTemp->kind == V4IR::Temp::StackSlot) {<KAIGYO>            Assembler::FPRegisterID tReg = toDoubleRegister(targetTemp);<KAIGYO>#if CPU(X86_64)<KAIGYO>            _as->load64(_as->stackSlotPointer(sourceTemp), Assembler::ScratchRegister);<KAIGYO>            _as->store64(Assembler::ScratchRegister, _as->stackSlotPointer(targetTemp));<KAIGYO>#else<KAIGYO>            Assembler::Pointer sAddr = _as->stackSlotPointer(sourceTemp);<KAIGYO>            Assembler::Pointer tAddr = _as->stackSlotPointer(targetTemp);<KAIGYO>            _as->load32(sAddr, Assembler::ScratchRegister);<KAIGYO>            _as->store32(Assembler::ScratchRegister, tAddr);<KAIGYO>            sAddr.offset += 4;<KAIGYO>            tAddr.offset += 4;<KAIGYO>            _as->load32(sAddr, Assembler::ScratchRegister);<KAIGYO>            _as->store32(Assembler::ScratchRegister, tAddr);<KAIGYO>#endif<KAIGYO>            _as->storeDouble(tReg, _as->stackSlotPointer(sourceTemp));<KAIGYO>            return;<KAIGYO>        }<KAIGYO>    }<KAIGYO><KAIGYO>    // FIXME: TODO!<KAIGYO>    Q_UNIMPLEMENTED();<KAIGYO>}<KAIGYO><KAIGYO>                                     Assembler::PointerToValue(sourceTemp));<KAIGYO>    const Assembler::BinaryOperationInfo& info = Assembler::binaryOperation(oper);<KAIGYO>    if (!info.fallbackImplementation) {<KAIGYO>        assert(!"""");<KAIGYO>        return;<KAIGYO>    }<KAIGYO><KAIGYO>    _as->generateFunctionCallImp(Assembler::Void, info.name, info.fallbackImplementation,<KAIGYO>                                 Assembler::ContextRegister, Assembler::PointerToValue(target),<KAIGYO>                                 Assembler::PointerToValue(leftSource),<KAIGYO>                                 Assembler::PointerToValue(rightSource));<KAIGYO>void InstructionSelection::callProperty(V4IR::Expr *base, const QString &name, V4IR::ExprList *args,<KAIGYO>                                        V4IR::Temp *result)<KAIGYO>                             Assembler::PointerToValue(base), Assembler::TrustedImm32(index),<KAIGYO>        generateFunctionCall(Assembler::Void, __qmljs_call_property, Assembler::ContextRegister,<KAIGYO>                             Assembler::PointerToValue(result), Assembler::PointerToValue(base), s,<KAIGYO>                             baseAddressForCallArguments(), Assembler::TrustedImm32(argc));<KAIGYO>void InstructionSelection::callSubscript(V4IR::Expr *base, V4IR::Expr *index, V4IR::ExprList *args,<KAIGYO>                                         V4IR::Temp *result)<KAIGYO>    generateFunctionCall(Assembler::Void, __qmljs_call_element, Assembler::ContextRegister,<KAIGYO>                         Assembler::PointerToValue(result), Assembler::PointerToValue(base),<KAIGYO>                         Assembler::PointerToValue(index), baseAddressForCallArguments(),<KAIGYO>        generateFunctionCall(Assembler::ReturnValueRegister, __qmljs_to_boolean,<KAIGYO>                             Assembler::Reference(t));<KAIGYO>    } else if (V4IR::Const *c = s->cond->asConst()) {<KAIGYO>        // TODO: SSA optimisation for constant condition evaluation should remove this.<KAIGYO>        // See also visitCJump() in RegAllocInfo.<KAIGYO>        generateFunctionCall(Assembler::ReturnValueRegister, __qmljs_to_boolean,<KAIGYO>                             Assembler::PointerToValue(c));<KAIGYO>        Assembler::Jump target = _as->branch32(Assembler::NotEqual, Assembler::ReturnValueRegister,<KAIGYO>                                               Assembler::TrustedImm32(0));<KAIGYO>        _as->addPatch(s->iftrue, target);<KAIGYO>        _as->jumpToBlock(_block, s->iffalse);<KAIGYO>        return;<KAIGYO>        CmpOp op = 0;<KAIGYO>        const char *opName = 0;<KAIGYO>        switch (b->op) {<KAIGYO>        default: Q_UNREACHABLE(); assert(!""""); break;<KAIGYO>        case V4IR::OpGt: setOp(op, opName, __qmljs_cmp_gt); break;<KAIGYO>        case V4IR::OpLt: setOp(op, opName, __qmljs_cmp_lt); break;<KAIGYO>        case V4IR::OpGe: setOp(op, opName, __qmljs_cmp_ge); break;<KAIGYO>        case V4IR::OpLe: setOp(op, opName, __qmljs_cmp_le); break;<KAIGYO>        case V4IR::OpEqual: setOp(op, opName, __qmljs_cmp_eq); break;<KAIGYO>        case V4IR::OpNotEqual: setOp(op, opName, __qmljs_cmp_ne); break;<KAIGYO>        case V4IR::OpStrictEqual: setOp(op, opName, __qmljs_cmp_se); break;<KAIGYO>        case V4IR::OpStrictNotEqual: setOp(op, opName, __qmljs_cmp_sne); break;<KAIGYO>        case V4IR::OpInstanceof: setOp(op, opName, __qmljs_cmp_instanceof); break;<KAIGYO>        case V4IR::OpIn: setOp(op, opName, __qmljs_cmp_in); break;<KAIGYO>        } // switch<KAIGYO>        // TODO: in SSA optimisation, do constant expression evaluation.<KAIGYO>        // The case here is, for example:<KAIGYO>        //   if (true === true) .....<KAIGYO>        // Of course, after folding the CJUMP to a JUMP, dead-code (dead-basic-block)<KAIGYO>        // elimination (which isn\'t there either) would remove the whole else block.<KAIGYO>        _as->generateFunctionCallImp(Assembler::ReturnValueRegister, opName, op,<KAIGYO>                                     Assembler::ContextRegister,<KAIGYO>                                     Assembler::PointerToValue(b->left),<KAIGYO>                                     Assembler::PointerToValue(b->right));<KAIGYO>        Assembler::Jump target = _as->branch32(Assembler::NotEqual, Assembler::ReturnValueRegister,<KAIGYO>                                               Assembler::TrustedImm32(0));<KAIGYO>        _as->addPatch(s->iftrue, target);<KAIGYO>        _as->jumpToBlock(_block, s->iffalse);<KAIGYO>        return;<KAIGYO>        if (t->kind == V4IR::Temp::PhysicalRegister) {<KAIGYO>            if (t->type == V4IR::DoubleType) {<KAIGYO>                _as->moveDoubleTo64((Assembler::FPRegisterID) t->index,<KAIGYO>                                    Assembler::ReturnValueRegister);<KAIGYO>            } else {<KAIGYO>                _as->zeroExtend32ToPtr((Assembler::RegisterID) t->index,<KAIGYO>                                       Assembler::ReturnValueRegister);<KAIGYO>                QV4::Value upper;<KAIGYO>                switch (t->type) {<KAIGYO>                case V4IR::SInt32Type:<KAIGYO>                case V4IR::UInt32Type:<KAIGYO>                    upper = QV4::Value::fromInt32(0);<KAIGYO>                    break;<KAIGYO>                case V4IR::BoolType:<KAIGYO>                    upper = QV4::Value::fromBoolean(false);<KAIGYO>                    break;<KAIGYO>                default:<KAIGYO>                    upper = QV4::Value::undefinedValue();<KAIGYO>                    Q_UNIMPLEMENTED();<KAIGYO>                }<KAIGYO>                _as->or64(Assembler::TrustedImm64(((int64_t) upper.tag) << 32),<KAIGYO>                          Assembler::ReturnValueRegister);<KAIGYO>            }<KAIGYO>        } else {<KAIGYO>            _as->copyValue(Assembler::ReturnValueRegister, t);<KAIGYO>        }<KAIGYO>    _as->leaveStandardStackFrame(/*withLocals*/': 12, '    _as->leaveStandardStackFrame(/*locals*/false);<KAIGYO>    Q_ASSERT(arg);<KAIGYO>    Q_ASSERT(result);<KAIGYO><KAIGYO>    Q_ASSERT(arg);<KAIGYO>    Q_ASSERT(result);<KAIGYO><KAIGYO>    Q_ASSERT(arg);<KAIGYO><KAIGYO>    Q_ASSERT(object);<KAIGYO>    Q_ASSERT(getter);<KAIGYO>    Q_ASSERT(setter);<KAIGYO>void InstructionSelection::callBuiltinDefineProperty(V4IR::Temp *object, const QString &name,<KAIGYO>                                                     V4IR::Expr *value)<KAIGYO>    Q_ASSERT(object);<KAIGYO>    Q_ASSERT(value->asTemp() || value->asConst());<KAIGYO><KAIGYO>    generateFunctionCall(Assembler::Void, __qmljs_builtin_define_property,<KAIGYO>                         Assembler::ContextRegister, Assembler::Reference(object), identifier(name),<KAIGYO>                         Assembler::PointerToValue(value));<KAIGYO>    Q_ASSERT(result);<KAIGYO><KAIGYO>                         Assembler::PointerToValue(result), baseAddressForCallArguments(),<KAIGYO>                         Assembler::TrustedImm32(length));<KAIGYO>    Q_ASSERT(result);<KAIGYO><KAIGYO>        _as->copyValue(_as->_stackLayout.argumentAddressForCall(argc++), it->expr);<KAIGYO>            _as->copyValue(_as->_stackLayout.argumentAddressForCall(argc++), it->expr);<KAIGYO>    Q_ASSERT(value);<KAIGYO><KAIGYO>    _as->load64(Pointer(Assembler::ContextRegister, offsetof(ExecutionContext, thisObject)),<KAIGYO>                Assembler::ReturnValueRegister);<KAIGYO>    if (targetTemp->kind == V4IR::Temp::PhysicalRegister) {<KAIGYO>        if (targetTemp->type == V4IR::DoubleType) {<KAIGYO>            Q_ASSERT(sourceConst->type == V4IR::DoubleType);<KAIGYO>            _as->loadDouble(_as->constTableAddr(sourceConst).m_ptr,<KAIGYO>                            (Assembler::FPRegisterID) targetTemp->index);<KAIGYO>        } else if (targetTemp->type == V4IR::SInt32Type) {<KAIGYO>            Q_ASSERT(sourceConst->type == V4IR::SInt32Type);<KAIGYO>            _as->move(Assembler::TrustedImm32(convertToValue(sourceConst).int_32),<KAIGYO>                      (Assembler::RegisterID) targetTemp->index);<KAIGYO>        } else if (targetTemp->type == V4IR::UInt32Type) {<KAIGYO>            Q_ASSERT(sourceConst->type == V4IR::UInt32Type);<KAIGYO>            _as->move(Assembler::TrustedImm32(convertToValue(sourceConst).uint_32),<KAIGYO>                      (Assembler::RegisterID) targetTemp->index);<KAIGYO>        } else if (targetTemp->type == V4IR::BoolType) {<KAIGYO>            Q_ASSERT(sourceConst->type == V4IR::BoolType);<KAIGYO>            _as->move(Assembler::TrustedImm32(convertToValue(sourceConst).int_32),<KAIGYO>                      (Assembler::RegisterID) targetTemp->index);<KAIGYO>        } else {<KAIGYO>            Q_UNIMPLEMENTED();<KAIGYO>        }<KAIGYO>    } else {<KAIGYO>        _as->storeValue(convertToValue(sourceConst), targetTemp);<KAIGYO>    }<KAIGYO>void InstructionSelection::setActivationProperty(V4IR::Expr *source, const QString &targetName)<KAIGYO>                         Assembler::ContextRegister, propertyName, Assembler::PointerToValue(source));<KAIGYO>void InstructionSelection::getProperty(V4IR::Expr *base, const QString &name, V4IR::Temp *target)<KAIGYO>                           Assembler::PointerToValue(base));<KAIGYO>        generateFunctionCall(Assembler::Void, __qmljs_get_property, Assembler::ContextRegister,<KAIGYO>                             Assembler::PointerToValue(target), Assembler::PointerToValue(base),<KAIGYO>                             identifier(name));<KAIGYO>void InstructionSelection::setProperty(V4IR::Expr *source, V4IR::Expr *targetBase,<KAIGYO>                                       const QString &targetName)<KAIGYO>        generateLookupCall(index, offsetof(QV4::Lookup, setter),<KAIGYO>                           Assembler::PointerToValue(targetBase),<KAIGYO>                           Assembler::PointerToValue(source));<KAIGYO>                             Assembler::PointerToValue(targetBase), identifier(targetName),<KAIGYO>                             Assembler::PointerToValue(source));<KAIGYO>void InstructionSelection::getElement(V4IR::Expr *base, V4IR::Expr *index, V4IR::Temp *target)<KAIGYO>                         Assembler::PointerToValue(target), Assembler::PointerToValue(base),<KAIGYO>                         Assembler::PointerToValue(index));<KAIGYO>void InstructionSelection::setElement(V4IR::Expr *source, V4IR::Expr *targetBase, V4IR::Expr *targetIndex)<KAIGYO>                         Assembler::PointerToValue(targetBase), Assembler::PointerToValue(targetIndex),<KAIGYO>                         Assembler::PointerToValue(source));<KAIGYO>    if (*sourceTemp == *targetTemp)<KAIGYO>        return;<KAIGYO><KAIGYO>    if (sourceTemp->kind == V4IR::Temp::PhysicalRegister) {<KAIGYO>        if (targetTemp->kind == V4IR::Temp::PhysicalRegister) {<KAIGYO>            if (sourceTemp->type == V4IR::DoubleType)<KAIGYO>                _as->moveDouble((Assembler::FPRegisterID) sourceTemp->index,<KAIGYO>                                (Assembler::FPRegisterID) targetTemp->index);<KAIGYO>            else<KAIGYO>                _as->move((Assembler::RegisterID) sourceTemp->index,<KAIGYO>                          (Assembler::RegisterID) targetTemp->index);<KAIGYO>            return;<KAIGYO>        } else {<KAIGYO>            Assembler::Pointer addr = _as->loadTempAddress(Assembler::ScratchRegister, targetTemp);<KAIGYO>            switch (sourceTemp->type) {<KAIGYO>            case V4IR::DoubleType:<KAIGYO>                _as->storeDouble((Assembler::FPRegisterID) sourceTemp->index, addr);<KAIGYO>                break;<KAIGYO>            case V4IR::SInt32Type:<KAIGYO>                _as->store32((Assembler::RegisterID) sourceTemp->index, addr);<KAIGYO>                addr.offset += 4;<KAIGYO>                _as->store32(Assembler::TrustedImm32(Value::fromInt32(0).tag), addr);<KAIGYO>                break;<KAIGYO>            case V4IR::UInt32Type:<KAIGYO>                _as->store32((Assembler::RegisterID) sourceTemp->index, addr);<KAIGYO>                addr.offset += 4;<KAIGYO>                _as->store32(Assembler::TrustedImm32(Value::fromUInt32(0).tag), addr);<KAIGYO>                break;<KAIGYO>            case V4IR::BoolType:<KAIGYO>                _as->storeBool((Assembler::RegisterID) sourceTemp->index, addr);<KAIGYO>                break;<KAIGYO>            default:<KAIGYO>                _as->store64((Assembler::RegisterID) sourceTemp->index, addr);<KAIGYO>                break;<KAIGYO>            }<KAIGYO>            return;<KAIGYO>        }<KAIGYO>    } else if (targetTemp->kind == V4IR::Temp::PhysicalRegister) {<KAIGYO>        switch (targetTemp->type) {<KAIGYO>        case V4IR::DoubleType:<KAIGYO>            _as->toDoubleRegister(sourceTemp, (Assembler::FPRegisterID) targetTemp->index);<KAIGYO>            return;<KAIGYO>        case V4IR::BoolType:<KAIGYO>        case V4IR::SInt32Type:<KAIGYO>        case V4IR::UInt32Type:<KAIGYO>            _as->toInt32Register(sourceTemp, (Assembler::RegisterID) targetTemp->index);<KAIGYO>            return;<KAIGYO>        case V4IR::StringType:<KAIGYO>            _as->load64(_as->stackSlotPointer(sourceTemp),<KAIGYO>                        (Assembler::RegisterID) targetTemp->index);<KAIGYO>            return;<KAIGYO>        default:<KAIGYO>            break;<KAIGYO>        }<KAIGYO>    }<KAIGYO><KAIGYO>void InstructionSelection::swapValues(V4IR::Temp *sourceTemp, V4IR::Temp *targetTemp)<KAIGYO>{<KAIGYO>    Q_ASSERT(sourceTemp->type == targetTemp->type);<KAIGYO><KAIGYO>    if (sourceTemp->kind == V4IR::Temp::PhysicalRegister) {<KAIGYO>        if (targetTemp->kind == V4IR::Temp::PhysicalRegister) {<KAIGYO>            if (sourceTemp->type == V4IR::DoubleType) {<KAIGYO>                _as->moveDouble((Assembler::FPRegisterID) targetTemp->index, Assembler::FPGpr0);<KAIGYO>                _as->moveDouble((Assembler::FPRegisterID) sourceTemp->index,<KAIGYO>                                (Assembler::FPRegisterID) targetTemp->index);<KAIGYO>                _as->moveDouble(Assembler::FPGpr0, (Assembler::FPRegisterID) sourceTemp->index);<KAIGYO>            } else {<KAIGYO>                _as->swap((Assembler::RegisterID) sourceTemp->index,<KAIGYO>                          (Assembler::RegisterID) targetTemp->index);<KAIGYO>            }<KAIGYO>            return;<KAIGYO>        }<KAIGYO>    } else if (sourceTemp->kind == V4IR::Temp::StackSlot) {<KAIGYO>        if (targetTemp->kind == V4IR::Temp::StackSlot) {<KAIGYO>            Assembler::FPRegisterID tReg = _as->toDoubleRegister(targetTemp);<KAIGYO>#if CPU(X86_64)<KAIGYO>            _as->load64(_as->stackSlotPointer(sourceTemp), Assembler::ScratchRegister);<KAIGYO>            _as->store64(Assembler::ScratchRegister, _as->stackSlotPointer(targetTemp));<KAIGYO>#else<KAIGYO>            Assembler::Pointer sAddr = _as->stackSlotPointer(sourceTemp);<KAIGYO>            Assembler::Pointer tAddr = _as->stackSlotPointer(targetTemp);<KAIGYO>            _as->load32(sAddr, Assembler::ScratchRegister);<KAIGYO>            _as->store32(Assembler::ScratchRegister, tAddr);<KAIGYO>            sAddr.offset += 4;<KAIGYO>            tAddr.offset += 4;<KAIGYO>            _as->load32(sAddr, Assembler::ScratchRegister);<KAIGYO>            _as->store32(Assembler::ScratchRegister, tAddr);<KAIGYO>#endif<KAIGYO>            _as->storeDouble(tReg, _as->stackSlotPointer(sourceTemp));<KAIGYO>            return;<KAIGYO>        }<KAIGYO>    }<KAIGYO><KAIGYO>    // FIXME: TODO!<KAIGYO>    Q_UNIMPLEMENTED();<KAIGYO>}<KAIGYO><KAIGYO>                                     Assembler::PointerToValue(sourceTemp));<KAIGYO>    const Assembler::BinaryOperationInfo& info = Assembler::binaryOperation(oper);<KAIGYO>    if (!info.fallbackImplementation) {<KAIGYO>        assert(!"""");<KAIGYO>        return;<KAIGYO>    }<KAIGYO><KAIGYO>    _as->generateFunctionCallImp(Assembler::Void, info.name, info.fallbackImplementation,<KAIGYO>                                 Assembler::ContextRegister, Assembler::PointerToValue(target),<KAIGYO>                                 Assembler::PointerToValue(leftSource),<KAIGYO>                                 Assembler::PointerToValue(rightSource));<KAIGYO>void InstructionSelection::callProperty(V4IR::Expr *base, const QString &name, V4IR::ExprList *args,<KAIGYO>                                        V4IR::Temp *result)<KAIGYO>                             Assembler::PointerToValue(base), Assembler::TrustedImm32(index),<KAIGYO>        generateFunctionCall(Assembler::Void, __qmljs_call_property, Assembler::ContextRegister,<KAIGYO>                             Assembler::PointerToValue(result), Assembler::PointerToValue(base), s,<KAIGYO>                             baseAddressForCallArguments(), Assembler::TrustedImm32(argc));<KAIGYO>void InstructionSelection::callSubscript(V4IR::Expr *base, V4IR::Expr *index, V4IR::ExprList *args,<KAIGYO>                                         V4IR::Temp *result)<KAIGYO>    generateFunctionCall(Assembler::Void, __qmljs_call_element, Assembler::ContextRegister,<KAIGYO>                         Assembler::PointerToValue(result), Assembler::PointerToValue(base),<KAIGYO>                         Assembler::PointerToValue(index), baseAddressForCallArguments(),<KAIGYO>        Assembler::RegisterID reg;<KAIGYO>        if (t->kind == V4IR::Temp::PhysicalRegister) {<KAIGYO>            Q_ASSERT(t->type == V4IR::BoolType);<KAIGYO>            reg = (Assembler::RegisterID) t->index;<KAIGYO>        } else {<KAIGYO>            Address temp = _as->loadTempAddress(Assembler::ScratchRegister, t);<KAIGYO>            Address tag = temp;<KAIGYO>            tag.offset += offsetof(QV4::Value, tag);<KAIGYO>            Assembler::Jump booleanConversion = _as->branch32(Assembler::NotEqual, tag, Assembler::TrustedImm32(QV4::Value::Boolean_Type));<KAIGYO>            Address data = temp;<KAIGYO>            data.offset += offsetof(QV4::Value, int_32);<KAIGYO>            _as->load32(data, Assembler::ReturnValueRegister);<KAIGYO>            Assembler::Jump testBoolean = _as->jump();<KAIGYO>            booleanConversion.link(_as);<KAIGYO>            reg = Assembler::ReturnValueRegister;<KAIGYO>            generateFunctionCall(reg, __qmljs_to_boolean, Assembler::Reference(t));<KAIGYO>            testBoolean.link(_as);<KAIGYO>        }<KAIGYO>        Assembler::Jump target = _as->branch32(Assembler::NotEqual, reg, Assembler::TrustedImm32(0));<KAIGYO>        _as->addPatch(s->iftrue, target);<KAIGYO>        _as->jumpToBlock(_block, s->iffalse);<KAIGYO>        return;<KAIGYO>    } else if (V4IR::Const *c = s->cond->asConst()) {<KAIGYO>        // TODO: SSA optimisation for constant condition evaluation should remove this.<KAIGYO>        // See also visitCJump() in RegAllocInfo.<KAIGYO>        generateFunctionCall(Assembler::ReturnValueRegister, __qmljs_to_boolean,<KAIGYO>                             Assembler::PointerToValue(c));<KAIGYO>        Assembler::Jump target = _as->branch32(Assembler::NotEqual, Assembler::ReturnValueRegister,<KAIGYO>                                               Assembler::TrustedImm32(0));<KAIGYO>        _as->addPatch(s->iftrue, target);<KAIGYO>        CmpOp op = 0;<KAIGYO>        const char *opName = 0;<KAIGYO>        switch (b->op) {<KAIGYO>        default: Q_UNREACHABLE(); assert(!""""); break;<KAIGYO>        case V4IR::OpGt: setOp(op, opName, __qmljs_cmp_gt); break;<KAIGYO>        case V4IR::OpLt: setOp(op, opName, __qmljs_cmp_lt); break;<KAIGYO>        case V4IR::OpGe: setOp(op, opName, __qmljs_cmp_ge); break;<KAIGYO>        case V4IR::OpLe: setOp(op, opName, __qmljs_cmp_le); break;<KAIGYO>        case V4IR::OpEqual: setOp(op, opName, __qmljs_cmp_eq); break;<KAIGYO>        case V4IR::OpNotEqual: setOp(op, opName, __qmljs_cmp_ne); break;<KAIGYO>        case V4IR::OpStrictEqual: setOp(op, opName, __qmljs_cmp_se); break;<KAIGYO>        case V4IR::OpStrictNotEqual: setOp(op, opName, __qmljs_cmp_sne); break;<KAIGYO>        case V4IR::OpInstanceof: setOp(op, opName, __qmljs_cmp_instanceof); break;<KAIGYO>        case V4IR::OpIn: setOp(op, opName, __qmljs_cmp_in); break;<KAIGYO>        } // switch<KAIGYO>        // TODO: in SSA optimisation, do constant expression evaluation.<KAIGYO>        // The case here is, for example:<KAIGYO>        //   if (true === true) .....<KAIGYO>        // Of course, after folding the CJUMP to a JUMP, dead-code (dead-basic-block)<KAIGYO>        // elimination (which isn\'t there either) would remove the whole else block.<KAIGYO>        _as->generateFunctionCallImp(Assembler::ReturnValueRegister, opName, op,<KAIGYO>                                     Assembler::ContextRegister,<KAIGYO>                                     Assembler::PointerToValue(b->left),<KAIGYO>                                     Assembler::PointerToValue(b->right));<KAIGYO>        Assembler::Jump target = _as->branch32(Assembler::NotEqual, Assembler::ReturnValueRegister,<KAIGYO>                                               Assembler::TrustedImm32(0));<KAIGYO>        _as->addPatch(s->iftrue, target);<KAIGYO>        _as->jumpToBlock(_block, s->iffalse);<KAIGYO>        return;<KAIGYO>        if (t->kind == V4IR::Temp::PhysicalRegister) {<KAIGYO>            if (t->type == V4IR::DoubleType) {<KAIGYO>                _as->moveDoubleTo64((Assembler::FPRegisterID) t->index,<KAIGYO>                                    Assembler::ReturnValueRegister);<KAIGYO>            } else {<KAIGYO>                _as->zeroExtend32ToPtr((Assembler::RegisterID) t->index,<KAIGYO>                                       Assembler::ReturnValueRegister);<KAIGYO>                QV4::Value upper;<KAIGYO>                switch (t->type) {<KAIGYO>                case V4IR::SInt32Type:<KAIGYO>                case V4IR::UInt32Type:<KAIGYO>                    upper = QV4::Value::fromInt32(0);<KAIGYO>                    break;<KAIGYO>                case V4IR::BoolType:<KAIGYO>                    upper = QV4::Value::fromBoolean(false);<KAIGYO>                    break;<KAIGYO>                default:<KAIGYO>                    upper = QV4::Value::undefinedValue();<KAIGYO>                    Q_UNIMPLEMENTED();<KAIGYO>                }<KAIGYO>                _as->or64(Assembler::TrustedImm64(((int64_t) upper.tag) << 32),<KAIGYO>                          Assembler::ReturnValueRegister);<KAIGYO>            }<KAIGYO>        } else {<KAIGYO>            _as->copyValue(Assembler::ReturnValueRegister, t);<KAIGYO>        }<KAIGYO>    _as->leaveStandardStackFrame(/*withLocals*/': 14}",1.0,{'// TODO: masm cannot handle registers yet.': 1},1.0,{}
197,61987.0,1.0,3.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/61987,QNX: Fix compiler warnings,1.0,{'//TODO another instance of the nearfieldmanager might still<KAIGYO>//want to detect targets so we have to do ref counting': 1},1.0,{'//TODO another instance of the nearfieldmanager might still want to detect targets': 1},1.0,{}
96,62366.0,2.0,2.0,0.0,ABANDONED,False,https://codereview.qt-project.org/#/c/62366,Cleanup: Separate JS environment scanner class declaration from definition,1.0,{'// TODO: give a warning.': 1},1.0,{'// TODO: give a warning.': 1},1.0,{}
165,62570.0,2.0,9.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/62570,Remove QV4::DiagnosticMessage,1.0,{},0.0,{'// ### FIXME: support msg->next': 1},1.0,{}
151,62619.0,1.0,3.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/62619,[Qt] REGRESSION(r) Two pixel result fail after r153522,1.0,"{'// The quality of down scaling at 0.5x and below in QPainter is not very good<KAIGYO>// due to using bilinear sampling, so for high quality scaling we need to<KAIGYO>// perform scaling ourselves.': 1}",1.0,"{'// The quality of down scaling at 0.5x and below in QPainter is not very good<KAIGYO>// due only using bilinear sampling, so for high quality scaling we need to<KAIGYO>// perform scaling ourselves.': 1}",1.0,{}
175,62641.0,1.0,1.0,0.0,ABANDONED,False,https://codereview.qt-project.org/#/c/62641,Remove QV4::DiagnosticMessage,1.0,{},0.0,{'// ### FIXME: support msg->next': 1},1.0,{}
188,62712.0,1.0,2.0,1.0,ABANDONED,False,https://codereview.qt-project.org/#/c/62712,Unset the cursor when an Item is unparented,1.0,"{'// cursorItem, but given the situation will correct itself after the next mouse move it<KAIGYO>// simply unsets the window cursor for now.': 1}",1.0,"{""// cursorItem, but given the situation will correct itself after the next mouse move it's<KAIGYO>// probably better left as is to avoid unnecessary work during tear down."": 1}",1.0,{}
211,62838.0,2.0,18.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/62838,Unset the cursor when an Item is unparented,1.0,"{'// cursorItem, but given the situation will correct itself after the next mouse move it<KAIGYO>// simply unsets the window cursor for now.': 1}",1.0,"{""// cursorItem, but given the situation will correct itself after the next mouse move it's<KAIGYO>// probably better left as is to avoid unnecessary work during tear down."": 1}",1.0,{}
206,62891.0,1.0,1.0,0.0,ABANDONED,False,https://codereview.qt-project.org/#/c/62891,[Qt][WK2] Composited and transformed links asserts in tap highlight,1.0,{},0.0,"{'// ensure rounded highlight rects. This clipping has the problem with nested<KAIGYO>// divs with transforms, which could be resolved by proper Path::intersecting.': 1}",1.0,{}
213,62892.0,1.0,5.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/62892,[Qt][WK2] Composited and transformed links asserts in tap highlight,1.0,{},0.0,"{'// ensure rounded highlight rects. This clipping has the problem with nested<KAIGYO>// divs with transforms, which could be resolved by proper Path::intersecting.': 1}",1.0,{}
239,62900.0,10.0,35.0,2.0,MERGED,True,https://codereview.qt-project.org/#/c/62900,Add linear scan register allocation.,1.0,"{'// TODO: masm cannot handle registers yet.': 1, '// TODO: do not generate a call (meaning: block all registers), but annotate the conversion with registers that need to be saved and have masm take care of that.': 1, '// TODO: verify this method': 1, '// FIXME: propagate this': 1, '// TODO: remove this!': 1, '// TODO: check isStructurallyValidLanguageTag': 1, '// TODO: check if we can always skip the optional register uses': 1}",1.0,{'// TODO: add a register allocator here.': 1},1.0,{}
236,62902.0,8.0,25.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/62902,Various fixes to the optimizer.,1.0,"{'// TODO: when propagating other constants, e.g. undefined, the other<KAIGYO>// optimization passes have to be changed to cope with them.<KAIGYO>//                        qout<<""""<<endl;': 1, '// TODO: implement unop propagation for other constant types': 1, '// TODO: Constant binary expression evaluation': 1}",1.0,"{'// TODO: merge 2 basic blocks A and B if A has one outgoing edge (to B), B has one incoming<KAIGYO>// edge (from A), but not when A has more than 1 incoming edge and B has more than one<KAIGYO>// outgoing edge.': 1}",1.0,{}
240,62906.0,27.0,61.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/62906,"The fast and the furious, register drift.",1.0,"{'    _as->leaveStandardStackFrame(/*locals*/false);<KAIGYO>    Q_ASSERT(arg);<KAIGYO>    Q_ASSERT(result);<KAIGYO><KAIGYO>    Q_ASSERT(arg);<KAIGYO>    Q_ASSERT(result);<KAIGYO><KAIGYO>    Q_ASSERT(arg);<KAIGYO><KAIGYO>    Q_ASSERT(object);<KAIGYO>    Q_ASSERT(getter);<KAIGYO>    Q_ASSERT(setter);<KAIGYO>void InstructionSelection::callBuiltinDefineProperty(V4IR::Temp *object, const QString &name,<KAIGYO>                                                     V4IR::Expr *value)<KAIGYO>    Q_ASSERT(object);<KAIGYO>    Q_ASSERT(value->asTemp() || value->asConst());<KAIGYO><KAIGYO>    generateFunctionCall(Assembler::Void, __qmljs_builtin_define_property,<KAIGYO>                         Assembler::ContextRegister, Assembler::Reference(object), identifier(name),<KAIGYO>                         Assembler::PointerToValue(value));<KAIGYO>    Q_ASSERT(result);<KAIGYO><KAIGYO>                         Assembler::PointerToValue(result), baseAddressForCallArguments(),<KAIGYO>                         Assembler::TrustedImm32(length));<KAIGYO>    Q_ASSERT(result);<KAIGYO><KAIGYO>        _as->copyValue(_as->_stackLayout.argumentAddressForCall(argc++), it->expr);<KAIGYO>            _as->copyValue(_as->_stackLayout.argumentAddressForCall(argc++), it->expr);<KAIGYO>    Q_ASSERT(value);<KAIGYO><KAIGYO>    _as->load64(Pointer(Assembler::ContextRegister, offsetof(ExecutionContext, thisObject)),<KAIGYO>                Assembler::ReturnValueRegister);<KAIGYO>    if (targetTemp->kind == V4IR::Temp::PhysicalRegister) {<KAIGYO>        if (targetTemp->type == V4IR::DoubleType) {<KAIGYO>            Q_ASSERT(sourceConst->type == V4IR::DoubleType);<KAIGYO>            _as->loadDouble(_as->constTableAddr(sourceConst).m_ptr,<KAIGYO>                            (Assembler::FPRegisterID) targetTemp->index);<KAIGYO>        } else if (targetTemp->type == V4IR::SInt32Type) {<KAIGYO>            Q_ASSERT(sourceConst->type == V4IR::SInt32Type);<KAIGYO>            _as->move(Assembler::TrustedImm32(convertToValue(sourceConst).int_32),<KAIGYO>                      (Assembler::RegisterID) targetTemp->index);<KAIGYO>        } else if (targetTemp->type == V4IR::UInt32Type) {<KAIGYO>            Q_ASSERT(sourceConst->type == V4IR::UInt32Type);<KAIGYO>            _as->move(Assembler::TrustedImm32(convertToValue(sourceConst).uint_32),<KAIGYO>                      (Assembler::RegisterID) targetTemp->index);<KAIGYO>        } else if (targetTemp->type == V4IR::BoolType) {<KAIGYO>            Q_ASSERT(sourceConst->type == V4IR::BoolType);<KAIGYO>            _as->move(Assembler::TrustedImm32(convertToValue(sourceConst).int_32),<KAIGYO>                      (Assembler::RegisterID) targetTemp->index);<KAIGYO>        } else {<KAIGYO>            Q_UNIMPLEMENTED();<KAIGYO>        }<KAIGYO>    } else {<KAIGYO>        _as->storeValue(convertToValue(sourceConst), targetTemp);<KAIGYO>    }<KAIGYO>void InstructionSelection::setActivationProperty(V4IR::Expr *source, const QString &targetName)<KAIGYO>                         Assembler::ContextRegister, propertyName, Assembler::PointerToValue(source));<KAIGYO>void InstructionSelection::getProperty(V4IR::Expr *base, const QString &name, V4IR::Temp *target)<KAIGYO>                           Assembler::PointerToValue(base));<KAIGYO>        generateFunctionCall(Assembler::Void, __qmljs_get_property, Assembler::ContextRegister,<KAIGYO>                             Assembler::PointerToValue(target), Assembler::PointerToValue(base),<KAIGYO>                             identifier(name));<KAIGYO>void InstructionSelection::setProperty(V4IR::Expr *source, V4IR::Expr *targetBase,<KAIGYO>                                       const QString &targetName)<KAIGYO>        generateLookupCall(index, offsetof(QV4::Lookup, setter),<KAIGYO>                           Assembler::PointerToValue(targetBase),<KAIGYO>                           Assembler::PointerToValue(source));<KAIGYO>                             Assembler::PointerToValue(targetBase), identifier(targetName),<KAIGYO>                             Assembler::PointerToValue(source));<KAIGYO>void InstructionSelection::getElement(V4IR::Expr *base, V4IR::Expr *index, V4IR::Temp *target)<KAIGYO>                         Assembler::PointerToValue(target), Assembler::PointerToValue(base),<KAIGYO>                         Assembler::PointerToValue(index));<KAIGYO>void InstructionSelection::setElement(V4IR::Expr *source, V4IR::Expr *targetBase, V4IR::Expr *targetIndex)<KAIGYO>                         Assembler::PointerToValue(targetBase), Assembler::PointerToValue(targetIndex),<KAIGYO>                         Assembler::PointerToValue(source));<KAIGYO>    if (*sourceTemp == *targetTemp)<KAIGYO>        return;<KAIGYO><KAIGYO>    if (sourceTemp->kind == V4IR::Temp::PhysicalRegister) {<KAIGYO>        if (targetTemp->kind == V4IR::Temp::PhysicalRegister) {<KAIGYO>            if (sourceTemp->type == V4IR::DoubleType)<KAIGYO>                _as->moveDouble((Assembler::FPRegisterID) sourceTemp->index,<KAIGYO>                                (Assembler::FPRegisterID) targetTemp->index);<KAIGYO>            else<KAIGYO>                _as->move((Assembler::RegisterID) sourceTemp->index,<KAIGYO>                          (Assembler::RegisterID) targetTemp->index);<KAIGYO>            return;<KAIGYO>        } else {<KAIGYO>            Assembler::Pointer addr = _as->loadTempAddress(Assembler::ScratchRegister, targetTemp);<KAIGYO>            switch (sourceTemp->type) {<KAIGYO>            case V4IR::DoubleType:<KAIGYO>                _as->storeDouble((Assembler::FPRegisterID) sourceTemp->index, addr);<KAIGYO>                break;<KAIGYO>            case V4IR::SInt32Type:<KAIGYO>                _as->store32((Assembler::RegisterID) sourceTemp->index, addr);<KAIGYO>                addr.offset += 4;<KAIGYO>                _as->store32(Assembler::TrustedImm32(Value::fromInt32(0).tag), addr);<KAIGYO>                break;<KAIGYO>            case V4IR::UInt32Type:<KAIGYO>                _as->store32((Assembler::RegisterID) sourceTemp->index, addr);<KAIGYO>                addr.offset += 4;<KAIGYO>                _as->store32(Assembler::TrustedImm32(Value::fromUInt32(0).tag), addr);<KAIGYO>                break;<KAIGYO>            case V4IR::BoolType:<KAIGYO>                _as->storeBool((Assembler::RegisterID) sourceTemp->index, addr);<KAIGYO>                break;<KAIGYO>            default:<KAIGYO>                _as->store64((Assembler::RegisterID) sourceTemp->index, addr);<KAIGYO>                break;<KAIGYO>            }<KAIGYO>            return;<KAIGYO>        }<KAIGYO>    } else if (targetTemp->kind == V4IR::Temp::PhysicalRegister) {<KAIGYO>        switch (targetTemp->type) {<KAIGYO>        case V4IR::DoubleType:<KAIGYO>            _as->toDoubleRegister(sourceTemp, (Assembler::FPRegisterID) targetTemp->index);<KAIGYO>            return;<KAIGYO>        case V4IR::BoolType:<KAIGYO>        case V4IR::SInt32Type:<KAIGYO>        case V4IR::UInt32Type:<KAIGYO>            _as->toInt32Register(sourceTemp, (Assembler::RegisterID) targetTemp->index);<KAIGYO>            return;<KAIGYO>        case V4IR::StringType:<KAIGYO>            _as->load64(_as->stackSlotPointer(sourceTemp),<KAIGYO>                        (Assembler::RegisterID) targetTemp->index);<KAIGYO>            return;<KAIGYO>        default:<KAIGYO>            break;<KAIGYO>        }<KAIGYO>    }<KAIGYO><KAIGYO>void InstructionSelection::swapValues(V4IR::Temp *sourceTemp, V4IR::Temp *targetTemp)<KAIGYO>{<KAIGYO>    Q_ASSERT(sourceTemp->type == targetTemp->type);<KAIGYO><KAIGYO>    if (sourceTemp->kind == V4IR::Temp::PhysicalRegister) {<KAIGYO>        if (targetTemp->kind == V4IR::Temp::PhysicalRegister) {<KAIGYO>            if (sourceTemp->type == V4IR::DoubleType) {<KAIGYO>                _as->moveDouble((Assembler::FPRegisterID) targetTemp->index, Assembler::FPGpr0);<KAIGYO>                _as->moveDouble((Assembler::FPRegisterID) sourceTemp->index,<KAIGYO>                                (Assembler::FPRegisterID) targetTemp->index);<KAIGYO>                _as->moveDouble(Assembler::FPGpr0, (Assembler::FPRegisterID) sourceTemp->index);<KAIGYO>            } else {<KAIGYO>                _as->swap((Assembler::RegisterID) sourceTemp->index,<KAIGYO>                          (Assembler::RegisterID) targetTemp->index);<KAIGYO>            }<KAIGYO>            return;<KAIGYO>        }<KAIGYO>    } else if (sourceTemp->kind == V4IR::Temp::StackSlot) {<KAIGYO>        if (targetTemp->kind == V4IR::Temp::StackSlot) {<KAIGYO>            Assembler::FPRegisterID tReg = _as->toDoubleRegister(targetTemp);<KAIGYO>#if CPU(X86_64)<KAIGYO>            _as->load64(_as->stackSlotPointer(sourceTemp), Assembler::ScratchRegister);<KAIGYO>            _as->store64(Assembler::ScratchRegister, _as->stackSlotPointer(targetTemp));<KAIGYO>#else<KAIGYO>            Assembler::Pointer sAddr = _as->stackSlotPointer(sourceTemp);<KAIGYO>            Assembler::Pointer tAddr = _as->stackSlotPointer(targetTemp);<KAIGYO>            _as->load32(sAddr, Assembler::ScratchRegister);<KAIGYO>            _as->store32(Assembler::ScratchRegister, tAddr);<KAIGYO>            sAddr.offset += 4;<KAIGYO>            tAddr.offset += 4;<KAIGYO>            _as->load32(sAddr, Assembler::ScratchRegister);<KAIGYO>            _as->store32(Assembler::ScratchRegister, tAddr);<KAIGYO>#endif<KAIGYO>            _as->storeDouble(tReg, _as->stackSlotPointer(sourceTemp));<KAIGYO>            return;<KAIGYO>        }<KAIGYO>    }<KAIGYO><KAIGYO>    // FIXME: TODO!<KAIGYO>    Q_UNIMPLEMENTED();<KAIGYO>}<KAIGYO><KAIGYO>                                     Assembler::PointerToValue(sourceTemp));<KAIGYO>    const Assembler::BinaryOperationInfo& info = Assembler::binaryOperation(oper);<KAIGYO>    if (!info.fallbackImplementation) {<KAIGYO>        assert(!"""");<KAIGYO>        return;<KAIGYO>    }<KAIGYO><KAIGYO>    _as->generateFunctionCallImp(Assembler::Void, info.name, info.fallbackImplementation,<KAIGYO>                                 Assembler::ContextRegister, Assembler::PointerToValue(target),<KAIGYO>                                 Assembler::PointerToValue(leftSource),<KAIGYO>                                 Assembler::PointerToValue(rightSource));<KAIGYO>void InstructionSelection::callProperty(V4IR::Expr *base, const QString &name, V4IR::ExprList *args,<KAIGYO>                                        V4IR::Temp *result)<KAIGYO>                             Assembler::PointerToValue(base), Assembler::TrustedImm32(index),<KAIGYO>        generateFunctionCall(Assembler::Void, __qmljs_call_property, Assembler::ContextRegister,<KAIGYO>                             Assembler::PointerToValue(result), Assembler::PointerToValue(base), s,<KAIGYO>                             baseAddressForCallArguments(), Assembler::TrustedImm32(argc));<KAIGYO>void InstructionSelection::callSubscript(V4IR::Expr *base, V4IR::Expr *index, V4IR::ExprList *args,<KAIGYO>                                         V4IR::Temp *result)<KAIGYO>    generateFunctionCall(Assembler::Void, __qmljs_call_element, Assembler::ContextRegister,<KAIGYO>                         Assembler::PointerToValue(result), Assembler::PointerToValue(base),<KAIGYO>                         Assembler::PointerToValue(index), baseAddressForCallArguments(),<KAIGYO>        Assembler::RegisterID reg;<KAIGYO>        if (t->kind == V4IR::Temp::PhysicalRegister) {<KAIGYO>            Q_ASSERT(t->type == V4IR::BoolType);<KAIGYO>            reg = (Assembler::RegisterID) t->index;<KAIGYO>        } else {<KAIGYO>            Address temp = _as->loadTempAddress(Assembler::ScratchRegister, t);<KAIGYO>            Address tag = temp;<KAIGYO>            tag.offset += offsetof(QV4::Value, tag);<KAIGYO>            Assembler::Jump booleanConversion = _as->branch32(Assembler::NotEqual, tag, Assembler::TrustedImm32(QV4::Value::Boolean_Type));<KAIGYO>            Address data = temp;<KAIGYO>            data.offset += offsetof(QV4::Value, int_32);<KAIGYO>            _as->load32(data, Assembler::ReturnValueRegister);<KAIGYO>            Assembler::Jump testBoolean = _as->jump();<KAIGYO>            booleanConversion.link(_as);<KAIGYO>            reg = Assembler::ReturnValueRegister;<KAIGYO>            generateFunctionCall(reg, __qmljs_to_boolean, Assembler::Reference(t));<KAIGYO>            testBoolean.link(_as);<KAIGYO>        }<KAIGYO>        Assembler::Jump target = _as->branch32(Assembler::NotEqual, reg, Assembler::TrustedImm32(0));<KAIGYO>        _as->addPatch(s->iftrue, target);<KAIGYO>        _as->jumpToBlock(_block, s->iffalse);<KAIGYO>        return;<KAIGYO>    } else if (V4IR::Const *c = s->cond->asConst()) {<KAIGYO>        // TODO: SSA optimisation for constant condition evaluation should remove this.<KAIGYO>        // See also visitCJump() in RegAllocInfo.<KAIGYO>        generateFunctionCall(Assembler::ReturnValueRegister, __qmljs_to_boolean,<KAIGYO>                             Assembler::PointerToValue(c));<KAIGYO>        Assembler::Jump target = _as->branch32(Assembler::NotEqual, Assembler::ReturnValueRegister,<KAIGYO>                                               Assembler::TrustedImm32(0));<KAIGYO>        _as->addPatch(s->iftrue, target);<KAIGYO>        CmpOp op = 0;<KAIGYO>        const char *opName = 0;<KAIGYO>        switch (b->op) {<KAIGYO>        default: Q_UNREACHABLE(); assert(!""""); break;<KAIGYO>        case V4IR::OpGt: setOp(op, opName, __qmljs_cmp_gt); break;<KAIGYO>        case V4IR::OpLt: setOp(op, opName, __qmljs_cmp_lt); break;<KAIGYO>        case V4IR::OpGe: setOp(op, opName, __qmljs_cmp_ge); break;<KAIGYO>        case V4IR::OpLe: setOp(op, opName, __qmljs_cmp_le); break;<KAIGYO>        case V4IR::OpEqual: setOp(op, opName, __qmljs_cmp_eq); break;<KAIGYO>        case V4IR::OpNotEqual: setOp(op, opName, __qmljs_cmp_ne); break;<KAIGYO>        case V4IR::OpStrictEqual: setOp(op, opName, __qmljs_cmp_se); break;<KAIGYO>        case V4IR::OpStrictNotEqual: setOp(op, opName, __qmljs_cmp_sne); break;<KAIGYO>        case V4IR::OpInstanceof: setOp(op, opName, __qmljs_cmp_instanceof); break;<KAIGYO>        case V4IR::OpIn: setOp(op, opName, __qmljs_cmp_in); break;<KAIGYO>        } // switch<KAIGYO>        // TODO: in SSA optimisation, do constant expression evaluation.<KAIGYO>        // The case here is, for example:<KAIGYO>        //   if (true === true) .....<KAIGYO>        // Of course, after folding the CJUMP to a JUMP, dead-code (dead-basic-block)<KAIGYO>        // elimination (which isn\'t there either) would remove the whole else block.<KAIGYO>        _as->generateFunctionCallImp(Assembler::ReturnValueRegister, opName, op,<KAIGYO>                                     Assembler::ContextRegister,<KAIGYO>                                     Assembler::PointerToValue(b->left),<KAIGYO>                                     Assembler::PointerToValue(b->right));<KAIGYO>        Assembler::Jump target = _as->branch32(Assembler::NotEqual, Assembler::ReturnValueRegister,<KAIGYO>                                               Assembler::TrustedImm32(0));<KAIGYO>        _as->addPatch(s->iftrue, target);<KAIGYO>        _as->jumpToBlock(_block, s->iffalse);<KAIGYO>        return;<KAIGYO>        if (t->kind == V4IR::Temp::PhysicalRegister) {<KAIGYO>            if (t->type == V4IR::DoubleType) {<KAIGYO>                _as->moveDoubleTo64((Assembler::FPRegisterID) t->index,<KAIGYO>                                    Assembler::ReturnValueRegister);<KAIGYO>            } else {<KAIGYO>                _as->zeroExtend32ToPtr((Assembler::RegisterID) t->index,<KAIGYO>                                       Assembler::ReturnValueRegister);<KAIGYO>                QV4::Value upper;<KAIGYO>                switch (t->type) {<KAIGYO>                case V4IR::SInt32Type:<KAIGYO>                case V4IR::UInt32Type:<KAIGYO>                    upper = QV4::Value::fromInt32(0);<KAIGYO>                    break;<KAIGYO>                case V4IR::BoolType:<KAIGYO>                    upper = QV4::Value::fromBoolean(false);<KAIGYO>                    break;<KAIGYO>                default:<KAIGYO>                    upper = QV4::Value::undefinedValue();<KAIGYO>                    Q_UNIMPLEMENTED();<KAIGYO>                }<KAIGYO>                _as->or64(Assembler::TrustedImm64(((int64_t) upper.tag) << 32),<KAIGYO>                          Assembler::ReturnValueRegister);<KAIGYO>            }<KAIGYO>        } else {<KAIGYO>            _as->copyValue(Assembler::ReturnValueRegister, t);<KAIGYO>        }<KAIGYO>    _as->leaveStandardStackFrame(/*withLocals*/': 1, '// TODO: change masm to generate code': 1, '// TODO: SSA optimisation for constant condition evaluation should remove this.<KAIGYO>// See also visitCJump() in masm.': 1, '    _as->leaveStandardStackFrame(/*locals*/false);<KAIGYO>    Q_ASSERT(arg);<KAIGYO>    Q_ASSERT(result);<KAIGYO><KAIGYO>    Q_ASSERT(arg);<KAIGYO>    Q_ASSERT(result);<KAIGYO><KAIGYO>    Q_ASSERT(arg);<KAIGYO><KAIGYO>    Q_ASSERT(object);<KAIGYO>    Q_ASSERT(getter);<KAIGYO>    Q_ASSERT(setter);<KAIGYO>void InstructionSelection::callBuiltinDefineProperty(V4IR::Temp *object, const QString &name,<KAIGYO>                                                     V4IR::Expr *value)<KAIGYO>    Q_ASSERT(object);<KAIGYO>    Q_ASSERT(value->asTemp() || value->asConst());<KAIGYO><KAIGYO>    generateFunctionCall(Assembler::Void, __qmljs_builtin_define_property,<KAIGYO>                         Assembler::ContextRegister, Assembler::Reference(object), identifier(name),<KAIGYO>                         Assembler::PointerToValue(value));<KAIGYO>    Q_ASSERT(result);<KAIGYO><KAIGYO>                         Assembler::PointerToValue(result), baseAddressForCallArguments(),<KAIGYO>                         Assembler::TrustedImm32(length));<KAIGYO>    Q_ASSERT(result);<KAIGYO><KAIGYO>        _as->copyValue(_as->_stackLayout.argumentAddressForCall(argc++), it->expr);<KAIGYO>            _as->copyValue(_as->_stackLayout.argumentAddressForCall(argc++), it->expr);<KAIGYO>    Q_ASSERT(value);<KAIGYO><KAIGYO>    _as->load64(Pointer(Assembler::ContextRegister, offsetof(ExecutionContext, thisObject)),<KAIGYO>                Assembler::ReturnValueRegister);<KAIGYO>    if (targetTemp->kind == V4IR::Temp::PhysicalRegister) {<KAIGYO>        if (targetTemp->type == V4IR::DoubleType) {<KAIGYO>            Q_ASSERT(sourceConst->type == V4IR::DoubleType);<KAIGYO>            _as->loadDouble(_as->constTableAddr(sourceConst).m_ptr,<KAIGYO>                            (Assembler::FPRegisterID) targetTemp->index);<KAIGYO>        } else if (targetTemp->type == V4IR::SInt32Type) {<KAIGYO>            Q_ASSERT(sourceConst->type == V4IR::SInt32Type);<KAIGYO>            _as->move(Assembler::TrustedImm32(convertToValue(sourceConst).int_32),<KAIGYO>                      (Assembler::RegisterID) targetTemp->index);<KAIGYO>        } else if (targetTemp->type == V4IR::UInt32Type) {<KAIGYO>            Q_ASSERT(sourceConst->type == V4IR::UInt32Type);<KAIGYO>            _as->move(Assembler::TrustedImm32(convertToValue(sourceConst).uint_32),<KAIGYO>                      (Assembler::RegisterID) targetTemp->index);<KAIGYO>        } else if (targetTemp->type == V4IR::BoolType) {<KAIGYO>            Q_ASSERT(sourceConst->type == V4IR::BoolType);<KAIGYO>            _as->move(Assembler::TrustedImm32(convertToValue(sourceConst).int_32),<KAIGYO>                      (Assembler::RegisterID) targetTemp->index);<KAIGYO>        } else {<KAIGYO>            Q_UNIMPLEMENTED();<KAIGYO>        }<KAIGYO>    } else {<KAIGYO>        _as->storeValue(convertToValue(sourceConst), targetTemp);<KAIGYO>    }<KAIGYO>void InstructionSelection::setActivationProperty(V4IR::Expr *source, const QString &targetName)<KAIGYO>                         Assembler::ContextRegister, propertyName, Assembler::PointerToValue(source));<KAIGYO>void InstructionSelection::getProperty(V4IR::Expr *base, const QString &name, V4IR::Temp *target)<KAIGYO>                           Assembler::PointerToValue(base));<KAIGYO>        generateFunctionCall(Assembler::Void, __qmljs_get_property, Assembler::ContextRegister,<KAIGYO>                             Assembler::PointerToValue(target), Assembler::PointerToValue(base),<KAIGYO>                             identifier(name));<KAIGYO>void InstructionSelection::setProperty(V4IR::Expr *source, V4IR::Expr *targetBase,<KAIGYO>                                       const QString &targetName)<KAIGYO>        generateLookupCall(index, offsetof(QV4::Lookup, setter),<KAIGYO>                           Assembler::PointerToValue(targetBase),<KAIGYO>                           Assembler::PointerToValue(source));<KAIGYO>                             Assembler::PointerToValue(targetBase), identifier(targetName),<KAIGYO>                             Assembler::PointerToValue(source));<KAIGYO>void InstructionSelection::getElement(V4IR::Expr *base, V4IR::Expr *index, V4IR::Temp *target)<KAIGYO>                         Assembler::PointerToValue(target), Assembler::PointerToValue(base),<KAIGYO>                         Assembler::PointerToValue(index));<KAIGYO>void InstructionSelection::setElement(V4IR::Expr *source, V4IR::Expr *targetBase, V4IR::Expr *targetIndex)<KAIGYO>                         Assembler::PointerToValue(targetBase), Assembler::PointerToValue(targetIndex),<KAIGYO>                         Assembler::PointerToValue(source));<KAIGYO>    if (*sourceTemp == *targetTemp)<KAIGYO>        return;<KAIGYO><KAIGYO>    if (sourceTemp->kind == V4IR::Temp::PhysicalRegister) {<KAIGYO>        if (targetTemp->kind == V4IR::Temp::PhysicalRegister) {<KAIGYO>            if (sourceTemp->type == V4IR::DoubleType)<KAIGYO>                _as->moveDouble((Assembler::FPRegisterID) sourceTemp->index,<KAIGYO>                                (Assembler::FPRegisterID) targetTemp->index);<KAIGYO>            else<KAIGYO>                _as->move((Assembler::RegisterID) sourceTemp->index,<KAIGYO>                          (Assembler::RegisterID) targetTemp->index);<KAIGYO>            return;<KAIGYO>        } else {<KAIGYO>            Assembler::Pointer addr = _as->loadTempAddress(Assembler::ScratchRegister, targetTemp);<KAIGYO>            switch (sourceTemp->type) {<KAIGYO>            case V4IR::DoubleType:<KAIGYO>                _as->storeDouble((Assembler::FPRegisterID) sourceTemp->index, addr);<KAIGYO>                break;<KAIGYO>            case V4IR::SInt32Type:<KAIGYO>                _as->store32((Assembler::RegisterID) sourceTemp->index, addr);<KAIGYO>                addr.offset += 4;<KAIGYO>                _as->store32(Assembler::TrustedImm32(Value::fromInt32(0).tag), addr);<KAIGYO>                break;<KAIGYO>            case V4IR::UInt32Type:<KAIGYO>                _as->store32((Assembler::RegisterID) sourceTemp->index, addr);<KAIGYO>                addr.offset += 4;<KAIGYO>                _as->store32(Assembler::TrustedImm32(Value::fromUInt32(0).tag), addr);<KAIGYO>                break;<KAIGYO>            case V4IR::BoolType:<KAIGYO>                _as->storeBool((Assembler::RegisterID) sourceTemp->index, addr);<KAIGYO>                break;<KAIGYO>            default:<KAIGYO>                _as->store64((Assembler::RegisterID) sourceTemp->index, addr);<KAIGYO>                break;<KAIGYO>            }<KAIGYO>            return;<KAIGYO>        }<KAIGYO>    } else if (targetTemp->kind == V4IR::Temp::PhysicalRegister) {<KAIGYO>        switch (targetTemp->type) {<KAIGYO>        case V4IR::DoubleType:<KAIGYO>            _as->toDoubleRegister(sourceTemp, (Assembler::FPRegisterID) targetTemp->index);<KAIGYO>            return;<KAIGYO>        case V4IR::BoolType:<KAIGYO>        case V4IR::SInt32Type:<KAIGYO>        case V4IR::UInt32Type:<KAIGYO>            _as->toInt32Register(sourceTemp, (Assembler::RegisterID) targetTemp->index);<KAIGYO>            return;<KAIGYO>        case V4IR::StringType:<KAIGYO>            _as->load64(_as->stackSlotPointer(sourceTemp),<KAIGYO>                        (Assembler::RegisterID) targetTemp->index);<KAIGYO>            return;<KAIGYO>        default:<KAIGYO>            break;<KAIGYO>        }<KAIGYO>    }<KAIGYO><KAIGYO>void InstructionSelection::swapValues(V4IR::Temp *sourceTemp, V4IR::Temp *targetTemp)<KAIGYO>{<KAIGYO>    Q_ASSERT(sourceTemp->type == targetTemp->type);<KAIGYO><KAIGYO>    if (sourceTemp->kind == V4IR::Temp::PhysicalRegister) {<KAIGYO>        if (targetTemp->kind == V4IR::Temp::PhysicalRegister) {<KAIGYO>            if (sourceTemp->type == V4IR::DoubleType) {<KAIGYO>                _as->moveDouble((Assembler::FPRegisterID) targetTemp->index, Assembler::FPGpr0);<KAIGYO>                _as->moveDouble((Assembler::FPRegisterID) sourceTemp->index,<KAIGYO>                                (Assembler::FPRegisterID) targetTemp->index);<KAIGYO>                _as->moveDouble(Assembler::FPGpr0, (Assembler::FPRegisterID) sourceTemp->index);<KAIGYO>            } else {<KAIGYO>                _as->swap((Assembler::RegisterID) sourceTemp->index,<KAIGYO>                          (Assembler::RegisterID) targetTemp->index);<KAIGYO>            }<KAIGYO>            return;<KAIGYO>        }<KAIGYO>    } else if (sourceTemp->kind == V4IR::Temp::StackSlot) {<KAIGYO>        if (targetTemp->kind == V4IR::Temp::StackSlot) {<KAIGYO>            Assembler::FPRegisterID tReg = _as->toDoubleRegister(targetTemp);<KAIGYO>#if CPU(X86_64)<KAIGYO>            _as->load64(_as->stackSlotPointer(sourceTemp), Assembler::ScratchRegister);<KAIGYO>            _as->store64(Assembler::ScratchRegister, _as->stackSlotPointer(targetTemp));<KAIGYO>#else<KAIGYO>            Assembler::Pointer sAddr = _as->stackSlotPointer(sourceTemp);<KAIGYO>            Assembler::Pointer tAddr = _as->stackSlotPointer(targetTemp);<KAIGYO>            _as->load32(sAddr, Assembler::ScratchRegister);<KAIGYO>            _as->store32(Assembler::ScratchRegister, tAddr);<KAIGYO>            sAddr.offset += 4;<KAIGYO>            tAddr.offset += 4;<KAIGYO>            _as->load32(sAddr, Assembler::ScratchRegister);<KAIGYO>            _as->store32(Assembler::ScratchRegister, tAddr);<KAIGYO>#endif<KAIGYO>            _as->storeDouble(tReg, _as->stackSlotPointer(sourceTemp));<KAIGYO>            return;<KAIGYO>        }<KAIGYO>    }<KAIGYO><KAIGYO>    // FIXME: TODO!<KAIGYO>    Q_UNIMPLEMENTED();<KAIGYO>}<KAIGYO><KAIGYO>    if (op) {<KAIGYO>        _as->generateFunctionCallImp(Assembler::Void, opName, op,<KAIGYO>                                     Assembler::PointerToValue(targetTemp),<KAIGYO>                                     Assembler::PointerToValue(sourceTemp));<KAIGYO>        storeTarget(0, targetTemp);<KAIGYO>    }<KAIGYO>    const Assembler::BinaryOperationInfo& info = Assembler::binaryOperation(oper);<KAIGYO>    if (info.fallbackImplementation) {<KAIGYO>        _as->generateFunctionCallImp(Assembler::Void, info.name, info.fallbackImplementation,<KAIGYO>                                     Assembler::PointerToValue(target),<KAIGYO>                                     Assembler::PointerToValue(leftSource),<KAIGYO>                                     Assembler::PointerToValue(rightSource));<KAIGYO>        storeTarget(0, target);<KAIGYO>    } else if (info.contextImplementation) {<KAIGYO>        _as->generateFunctionCallImp(Assembler::Void, info.name, info.contextImplementation,<KAIGYO>                                     Assembler::ContextRegister,<KAIGYO>                                     Assembler::PointerToValue(target),<KAIGYO>                                     Assembler::PointerToValue(leftSource),<KAIGYO>                                     Assembler::PointerToValue(rightSource));<KAIGYO>        storeTarget(1, target);<KAIGYO>    } else {<KAIGYO>        assert(!"""");<KAIGYO>    }<KAIGYO>void InstructionSelection::callProperty(V4IR::Expr *base, const QString &name, V4IR::ExprList *args,<KAIGYO>                                        V4IR::Temp *result)<KAIGYO>                             Assembler::PointerToValue(base), Assembler::TrustedImm32(index),<KAIGYO>        generateFunctionCall(Assembler::Void, __qmljs_call_property, Assembler::ContextRegister,<KAIGYO>                             Assembler::PointerToValue(result), Assembler::PointerToValue(base), s,<KAIGYO>                             baseAddressForCallArguments(), Assembler::TrustedImm32(argc));<KAIGYO>void InstructionSelection::callSubscript(V4IR::Expr *base, V4IR::Expr *index, V4IR::ExprList *args,<KAIGYO>                                         V4IR::Temp *result)<KAIGYO>    generateFunctionCall(Assembler::Void, __qmljs_call_element, Assembler::ContextRegister,<KAIGYO>                         Assembler::PointerToValue(result), Assembler::PointerToValue(base),<KAIGYO>                         Assembler::PointerToValue(index), baseAddressForCallArguments(),<KAIGYO>    if (target->type & V4IR::NumberType)<KAIGYO>    else if (target->type == target->type == V4IR::BoolType) {<KAIGYO>        generateFunctionCall(Assembler::ReturnValueRegister, __qmljs_to_boolean,<KAIGYO>                             Assembler::PointerToValue(source));<KAIGYO>        _as->storeBool(Assembler::ReturnValueRegister, target);<KAIGYO>    } else<KAIGYO>        Assembler::RegisterID reg;<KAIGYO>        if (t->kind == V4IR::Temp::PhysicalRegister) {<KAIGYO>            Q_ASSERT(t->type == V4IR::BoolType);<KAIGYO>            reg = (Assembler::RegisterID) t->index;<KAIGYO>        } else if (t->kind == V4IR::Temp::StackSlot && t->type == V4IR::BoolType) {<KAIGYO>            reg = Assembler::ReturnValueRegister;<KAIGYO>            _as->toInt32Register(t, reg);<KAIGYO>        } else {<KAIGYO>            Address temp = _as->loadTempAddress(Assembler::ScratchRegister, t);<KAIGYO>            Address tag = temp;<KAIGYO>            tag.offset += offsetof(QV4::Value, tag);<KAIGYO>            Assembler::Jump booleanConversion = _as->branch32(Assembler::NotEqual, tag, Assembler::TrustedImm32(QV4::Value::Boolean_Type));<KAIGYO>            Address data = temp;<KAIGYO>            data.offset += offsetof(QV4::Value, int_32);<KAIGYO>            _as->load32(data, Assembler::ReturnValueRegister);<KAIGYO>            Assembler::Jump testBoolean = _as->jump();<KAIGYO>            booleanConversion.link(_as);<KAIGYO>            reg = Assembler::ReturnValueRegister;<KAIGYO>            generateFunctionCall(reg, __qmljs_to_boolean, Assembler::Reference(t));<KAIGYO>            testBoolean.link(_as);<KAIGYO>        }<KAIGYO>        Assembler::Jump target = _as->branch32(Assembler::NotEqual, reg, Assembler::TrustedImm32(0));<KAIGYO>        _as->addPatch(s->iftrue, target);<KAIGYO>        _as->jumpToBlock(_block, s->iffalse);<KAIGYO>        return;<KAIGYO>    } else if (V4IR::Const *c = s->cond->asConst()) {<KAIGYO>        // TODO: SSA optimisation for constant condition evaluation should remove this.<KAIGYO>        // See also visitCJump() in RegAllocInfo.<KAIGYO>        generateFunctionCall(Assembler::ReturnValueRegister, __qmljs_to_boolean,<KAIGYO>                             Assembler::PointerToValue(c));<KAIGYO>        Assembler::Jump target = _as->branch32(Assembler::NotEqual, Assembler::ReturnValueRegister,<KAIGYO>                                               Assembler::TrustedImm32(0));<KAIGYO>        _as->addPatch(s->iftrue, target);<KAIGYO>        CmpOp op = 0;<KAIGYO>        CmpOpContext opContext = 0;<KAIGYO>        const char *opName = 0;<KAIGYO>        switch (b->op) {<KAIGYO>        default: Q_UNREACHABLE(); assert(!""""); break;<KAIGYO>        case V4IR::OpGt: setOp(op, opName, __qmljs_cmp_gt); break;<KAIGYO>        case V4IR::OpLt: setOp(op, opName, __qmljs_cmp_lt); break;<KAIGYO>        case V4IR::OpGe: setOp(op, opName, __qmljs_cmp_ge); break;<KAIGYO>        case V4IR::OpLe: setOp(op, opName, __qmljs_cmp_le); break;<KAIGYO>        case V4IR::OpEqual: setOp(op, opName, __qmljs_cmp_eq); break;<KAIGYO>        case V4IR::OpNotEqual: setOp(op, opName, __qmljs_cmp_ne); break;<KAIGYO>        case V4IR::OpStrictEqual: setOp(op, opName, __qmljs_cmp_se); break;<KAIGYO>        case V4IR::OpStrictNotEqual: setOp(op, opName, __qmljs_cmp_sne); break;<KAIGYO>        case V4IR::OpInstanceof: setOpContext(op, opName, __qmljs_cmp_instanceof); break;<KAIGYO>        case V4IR::OpIn: setOpContext(op, opName, __qmljs_cmp_in); break;<KAIGYO>        } // switch<KAIGYO>        // TODO: in SSA optimisation, do constant expression evaluation.<KAIGYO>        // The case here is, for example:<KAIGYO>        //   if (true === true) .....<KAIGYO>        // Of course, after folding the CJUMP to a JUMP, dead-code (dead-basic-block)<KAIGYO>        // elimination (which isn\'t there either) would remove the whole else block.<KAIGYO>        if (opContext)<KAIGYO>            _as->generateFunctionCallImp(Assembler::ReturnValueRegister, opName, opContext,<KAIGYO>                                         Assembler::ContextRegister,<KAIGYO>                                         Assembler::PointerToValue(b->left),<KAIGYO>                                         Assembler::PointerToValue(b->right));<KAIGYO>        else<KAIGYO>            _as->generateFunctionCallImp(Assembler::ReturnValueRegister, opName, op,<KAIGYO>                                         Assembler::PointerToValue(b->left),<KAIGYO>                                         Assembler::PointerToValue(b->right));<KAIGYO>        Assembler::Jump target = _as->branch32(Assembler::NotEqual, Assembler::ReturnValueRegister,<KAIGYO>                                               Assembler::TrustedImm32(0));<KAIGYO>        _as->addPatch(s->iftrue, target);<KAIGYO>        _as->jumpToBlock(_block, s->iffalse);<KAIGYO>        return;<KAIGYO>        if (t->kind == V4IR::Temp::PhysicalRegister) {<KAIGYO>            if (t->type == V4IR::DoubleType) {<KAIGYO>                _as->moveDoubleTo64((Assembler::FPRegisterID) t->index,<KAIGYO>                                    Assembler::ReturnValueRegister);<KAIGYO>            } else {<KAIGYO>                _as->zeroExtend32ToPtr((Assembler::RegisterID) t->index,<KAIGYO>                                       Assembler::ReturnValueRegister);<KAIGYO>                QV4::Value upper;<KAIGYO>                switch (t->type) {<KAIGYO>                case V4IR::SInt32Type:<KAIGYO>                case V4IR::UInt32Type:<KAIGYO>                    upper = QV4::Value::fromInt32(0);<KAIGYO>                    break;<KAIGYO>                case V4IR::BoolType:<KAIGYO>                    upper = QV4::Value::fromBoolean(false);<KAIGYO>                    break;<KAIGYO>                default:<KAIGYO>                    upper = QV4::Value::undefinedValue();<KAIGYO>                    Q_UNIMPLEMENTED();<KAIGYO>                }<KAIGYO>                _as->or64(Assembler::TrustedImm64(((int64_t) upper.tag) << 32),<KAIGYO>                          Assembler::ReturnValueRegister);<KAIGYO>            }<KAIGYO>        } else {<KAIGYO>            _as->copyValue(Assembler::ReturnValueRegister, t);<KAIGYO>        }<KAIGYO>    _as->leaveStandardStackFrame(/*withLocals*/': 5, '    _as->leaveStandardStackFrame(/*locals*/false);<KAIGYO>    Q_ASSERT(arg);<KAIGYO>    Q_ASSERT(result);<KAIGYO><KAIGYO>    Q_ASSERT(arg);<KAIGYO>    Q_ASSERT(result);<KAIGYO><KAIGYO>    Q_ASSERT(arg);<KAIGYO><KAIGYO>    Q_ASSERT(object);<KAIGYO>    Q_ASSERT(getter);<KAIGYO>    Q_ASSERT(setter);<KAIGYO>void InstructionSelection::callBuiltinDefineProperty(V4IR::Temp *object, const QString &name,<KAIGYO>                                                     V4IR::Expr *value)<KAIGYO>    Q_ASSERT(object);<KAIGYO>    Q_ASSERT(value->asTemp() || value->asConst());<KAIGYO><KAIGYO>    generateFunctionCall(Assembler::Void, __qmljs_builtin_define_property,<KAIGYO>                         Assembler::ContextRegister, Assembler::Reference(object), identifier(name),<KAIGYO>                         Assembler::PointerToValue(value));<KAIGYO>    Q_ASSERT(result);<KAIGYO><KAIGYO>                         Assembler::PointerToValue(result), baseAddressForCallArguments(),<KAIGYO>                         Assembler::TrustedImm32(length));<KAIGYO>    Q_ASSERT(result);<KAIGYO><KAIGYO>        _as->copyValue(_as->stackLayout().argumentAddressForCall(argc++), it->expr);<KAIGYO>            _as->copyValue(_as->stackLayout().argumentAddressForCall(argc++), it->expr);<KAIGYO>    Q_ASSERT(value);<KAIGYO><KAIGYO>    _as->load64(Pointer(Assembler::ContextRegister, offsetof(ExecutionContext, thisObject)),<KAIGYO>                Assembler::ReturnValueRegister);<KAIGYO>    if (targetTemp->kind == V4IR::Temp::PhysicalRegister) {<KAIGYO>        if (targetTemp->type == V4IR::DoubleType) {<KAIGYO>            Q_ASSERT(sourceConst->type == V4IR::DoubleType);<KAIGYO>            _as->toDoubleRegister(sourceConst, (Assembler::FPRegisterID) targetTemp->index);<KAIGYO>        } else if (targetTemp->type == V4IR::SInt32Type) {<KAIGYO>            Q_ASSERT(sourceConst->type == V4IR::SInt32Type);<KAIGYO>            _as->toInt32Register(sourceConst, (Assembler::RegisterID) targetTemp->index);<KAIGYO>        } else if (targetTemp->type == V4IR::UInt32Type) {<KAIGYO>            Q_ASSERT(sourceConst->type == V4IR::UInt32Type);<KAIGYO>            _as->toUInt32Register(sourceConst, (Assembler::RegisterID) targetTemp->index);<KAIGYO>        } else if (targetTemp->type == V4IR::BoolType) {<KAIGYO>            Q_ASSERT(sourceConst->type == V4IR::BoolType);<KAIGYO>            _as->move(Assembler::TrustedImm32(convertToValue(sourceConst).int_32),<KAIGYO>                      (Assembler::RegisterID) targetTemp->index);<KAIGYO>        } else {<KAIGYO>            Q_UNIMPLEMENTED();<KAIGYO>        }<KAIGYO>    } else {<KAIGYO>        _as->storeValue(convertToValue(sourceConst), targetTemp);<KAIGYO>    }<KAIGYO>    _as->constantTable().add(v);<KAIGYO>void InstructionSelection::setActivationProperty(V4IR::Expr *source, const QString &targetName)<KAIGYO>                         Assembler::ContextRegister, propertyName, Assembler::PointerToValue(source));<KAIGYO>void InstructionSelection::getProperty(V4IR::Expr *base, const QString &name, V4IR::Temp *target)<KAIGYO>                           Assembler::PointerToValue(base));<KAIGYO>        generateFunctionCall(Assembler::Void, __qmljs_get_property, Assembler::ContextRegister,<KAIGYO>                             Assembler::PointerToValue(target), Assembler::PointerToValue(base),<KAIGYO>                             identifier(name));<KAIGYO>void InstructionSelection::setProperty(V4IR::Expr *source, V4IR::Expr *targetBase,<KAIGYO>                                       const QString &targetName)<KAIGYO>        generateLookupCall(index, offsetof(QV4::Lookup, setter),<KAIGYO>                           Assembler::PointerToValue(targetBase),<KAIGYO>                           Assembler::PointerToValue(source));<KAIGYO>                             Assembler::PointerToValue(targetBase), identifier(targetName),<KAIGYO>                             Assembler::PointerToValue(source));<KAIGYO>void InstructionSelection::getElement(V4IR::Expr *base, V4IR::Expr *index, V4IR::Temp *target)<KAIGYO>                         Assembler::PointerToValue(target), Assembler::PointerToValue(base),<KAIGYO>                         Assembler::PointerToValue(index));<KAIGYO>void InstructionSelection::setElement(V4IR::Expr *source, V4IR::Expr *targetBase, V4IR::Expr *targetIndex)<KAIGYO>                         Assembler::PointerToValue(targetBase), Assembler::PointerToValue(targetIndex),<KAIGYO>                         Assembler::PointerToValue(source));<KAIGYO>    if (*sourceTemp == *targetTemp)<KAIGYO>        return;<KAIGYO><KAIGYO>    if (sourceTemp->kind == V4IR::Temp::PhysicalRegister) {<KAIGYO>        if (targetTemp->kind == V4IR::Temp::PhysicalRegister) {<KAIGYO>            if (sourceTemp->type == V4IR::DoubleType)<KAIGYO>                _as->moveDouble((Assembler::FPRegisterID) sourceTemp->index,<KAIGYO>                                (Assembler::FPRegisterID) targetTemp->index);<KAIGYO>            else<KAIGYO>                _as->move((Assembler::RegisterID) sourceTemp->index,<KAIGYO>                          (Assembler::RegisterID) targetTemp->index);<KAIGYO>            return;<KAIGYO>        } else {<KAIGYO>            Assembler::Pointer addr = _as->loadTempAddress(Assembler::ScratchRegister, targetTemp);<KAIGYO>            switch (sourceTemp->type) {<KAIGYO>            case V4IR::DoubleType:<KAIGYO>                _as->storeDouble((Assembler::FPRegisterID) sourceTemp->index, addr);<KAIGYO>                break;<KAIGYO>            case V4IR::SInt32Type:<KAIGYO>                _as->storeInt32((Assembler::RegisterID) sourceTemp->index, addr);<KAIGYO>                break;<KAIGYO>            case V4IR::UInt32Type:<KAIGYO>                _as->storeUInt32((Assembler::RegisterID) sourceTemp->index, addr);<KAIGYO>                break;<KAIGYO>            case V4IR::BoolType:<KAIGYO>                _as->storeBool((Assembler::RegisterID) sourceTemp->index, addr);<KAIGYO>                break;<KAIGYO>            default:<KAIGYO>                _as->store64((Assembler::RegisterID) sourceTemp->index, addr);<KAIGYO>                break;<KAIGYO>            }<KAIGYO>            return;<KAIGYO>        }<KAIGYO>    } else if (targetTemp->kind == V4IR::Temp::PhysicalRegister) {<KAIGYO>        switch (targetTemp->type) {<KAIGYO>        case V4IR::DoubleType:<KAIGYO>            _as->toDoubleRegister(sourceTemp, (Assembler::FPRegisterID) targetTemp->index);<KAIGYO>            return;<KAIGYO>        case V4IR::BoolType:<KAIGYO>        case V4IR::SInt32Type:<KAIGYO>            _as->toInt32Register(sourceTemp, (Assembler::RegisterID) targetTemp->index);<KAIGYO>            return;<KAIGYO>        case V4IR::UInt32Type:<KAIGYO>            _as->toUInt32Register(sourceTemp, (Assembler::RegisterID) targetTemp->index);<KAIGYO>            return;<KAIGYO>        case V4IR::StringType:<KAIGYO>            _as->load64(_as->stackSlotPointer(sourceTemp),<KAIGYO>                        (Assembler::RegisterID) targetTemp->index);<KAIGYO>            return;<KAIGYO>        default:<KAIGYO>            break;<KAIGYO>        }<KAIGYO>    }<KAIGYO><KAIGYO>void InstructionSelection::swapValues(V4IR::Temp *sourceTemp, V4IR::Temp *targetTemp)<KAIGYO>{<KAIGYO>    Q_ASSERT(sourceTemp->type == targetTemp->type);<KAIGYO><KAIGYO>    if (sourceTemp->kind == V4IR::Temp::PhysicalRegister) {<KAIGYO>        if (targetTemp->kind == V4IR::Temp::PhysicalRegister) {<KAIGYO>            if (sourceTemp->type == V4IR::DoubleType) {<KAIGYO>                _as->moveDouble((Assembler::FPRegisterID) targetTemp->index, Assembler::FPGpr0);<KAIGYO>                _as->moveDouble((Assembler::FPRegisterID) sourceTemp->index,<KAIGYO>                                (Assembler::FPRegisterID) targetTemp->index);<KAIGYO>                _as->moveDouble(Assembler::FPGpr0, (Assembler::FPRegisterID) sourceTemp->index);<KAIGYO>            } else {<KAIGYO>                _as->swap((Assembler::RegisterID) sourceTemp->index,<KAIGYO>                          (Assembler::RegisterID) targetTemp->index);<KAIGYO>            }<KAIGYO>            return;<KAIGYO>        }<KAIGYO>    } else if (sourceTemp->kind == V4IR::Temp::StackSlot) {<KAIGYO>        if (targetTemp->kind == V4IR::Temp::StackSlot) {<KAIGYO>            Assembler::FPRegisterID tReg = _as->toDoubleRegister(targetTemp);<KAIGYO>#if CPU(X86_64)<KAIGYO>            _as->load64(_as->stackSlotPointer(sourceTemp), Assembler::ScratchRegister);<KAIGYO>            _as->store64(Assembler::ScratchRegister, _as->stackSlotPointer(targetTemp));<KAIGYO>#else<KAIGYO>            Assembler::Pointer sAddr = _as->stackSlotPointer(sourceTemp);<KAIGYO>            Assembler::Pointer tAddr = _as->stackSlotPointer(targetTemp);<KAIGYO>            _as->load32(sAddr, Assembler::ScratchRegister);<KAIGYO>            _as->store32(Assembler::ScratchRegister, tAddr);<KAIGYO>            sAddr.offset += 4;<KAIGYO>            tAddr.offset += 4;<KAIGYO>            _as->load32(sAddr, Assembler::ScratchRegister);<KAIGYO>            _as->store32(Assembler::ScratchRegister, tAddr);<KAIGYO>#endif<KAIGYO>            _as->storeDouble(tReg, _as->stackSlotPointer(sourceTemp));<KAIGYO>            return;<KAIGYO>        }<KAIGYO>    }<KAIGYO><KAIGYO>    // FIXME: TODO!<KAIGYO>    Q_UNIMPLEMENTED();<KAIGYO>}<KAIGYO><KAIGYO>    if (op) {<KAIGYO>        _as->generateFunctionCallImp(Assembler::Void, opName, op,<KAIGYO>                                     Assembler::PointerToValue(targetTemp),<KAIGYO>                                     Assembler::PointerToValue(sourceTemp));<KAIGYO>        storeTarget(0, targetTemp);<KAIGYO>    }<KAIGYO>    const Assembler::BinaryOperationInfo& info = Assembler::binaryOperation(oper);<KAIGYO>    if (info.fallbackImplementation) {<KAIGYO>        _as->generateFunctionCallImp(Assembler::Void, info.name, info.fallbackImplementation,<KAIGYO>                                     Assembler::PointerToValue(target),<KAIGYO>                                     Assembler::PointerToValue(leftSource),<KAIGYO>                                     Assembler::PointerToValue(rightSource));<KAIGYO>        storeTarget(0, target);<KAIGYO>    } else if (info.contextImplementation) {<KAIGYO>        _as->generateFunctionCallImp(Assembler::Void, info.name, info.contextImplementation,<KAIGYO>                                     Assembler::ContextRegister,<KAIGYO>                                     Assembler::PointerToValue(target),<KAIGYO>                                     Assembler::PointerToValue(leftSource),<KAIGYO>                                     Assembler::PointerToValue(rightSource));<KAIGYO>        storeTarget(1, target);<KAIGYO>    } else {<KAIGYO>        assert(!"""");<KAIGYO>    }<KAIGYO>void InstructionSelection::callProperty(V4IR::Expr *base, const QString &name, V4IR::ExprList *args,<KAIGYO>                                        V4IR::Temp *result)<KAIGYO>                             Assembler::PointerToValue(base), Assembler::TrustedImm32(index),<KAIGYO>        generateFunctionCall(Assembler::Void, __qmljs_call_property, Assembler::ContextRegister,<KAIGYO>                             Assembler::PointerToValue(result), Assembler::PointerToValue(base), s,<KAIGYO>                             baseAddressForCallArguments(), Assembler::TrustedImm32(argc));<KAIGYO>void InstructionSelection::callSubscript(V4IR::Expr *base, V4IR::Expr *index, V4IR::ExprList *args,<KAIGYO>                                         V4IR::Temp *result)<KAIGYO>    generateFunctionCall(Assembler::Void, __qmljs_call_element, Assembler::ContextRegister,<KAIGYO>                         Assembler::PointerToValue(result), Assembler::PointerToValue(base),<KAIGYO>                         Assembler::PointerToValue(index), baseAddressForCallArguments(),<KAIGYO>    if (target->type & V4IR::NumberType)<KAIGYO>    else if (target->type == V4IR::BoolType) {<KAIGYO>        generateFunctionCall(Assembler::ReturnValueRegister, __qmljs_to_boolean,<KAIGYO>                             Assembler::PointerToValue(source));<KAIGYO>        _as->storeBool(Assembler::ReturnValueRegister, target);<KAIGYO>    } else<KAIGYO>        Assembler::RegisterID reg;<KAIGYO>        if (t->kind == V4IR::Temp::PhysicalRegister) {<KAIGYO>            Q_ASSERT(t->type == V4IR::BoolType);<KAIGYO>            reg = (Assembler::RegisterID) t->index;<KAIGYO>        } else if (t->kind == V4IR::Temp::StackSlot && t->type == V4IR::BoolType) {<KAIGYO>            reg = Assembler::ReturnValueRegister;<KAIGYO>            _as->toInt32Register(t, reg);<KAIGYO>        } else {<KAIGYO>            Address temp = _as->loadTempAddress(Assembler::ScratchRegister, t);<KAIGYO>            Address tag = temp;<KAIGYO>            tag.offset += offsetof(QV4::Value, tag);<KAIGYO>            Assembler::Jump booleanConversion = _as->branch32(Assembler::NotEqual, tag, Assembler::TrustedImm32(QV4::Value::Boolean_Type));<KAIGYO>            Address data = temp;<KAIGYO>            data.offset += offsetof(QV4::Value, int_32);<KAIGYO>            _as->load32(data, Assembler::ReturnValueRegister);<KAIGYO>            Assembler::Jump testBoolean = _as->jump();<KAIGYO>            booleanConversion.link(_as);<KAIGYO>            reg = Assembler::ReturnValueRegister;<KAIGYO>            generateFunctionCall(reg, __qmljs_to_boolean, Assembler::Reference(t));<KAIGYO>            testBoolean.link(_as);<KAIGYO>        }<KAIGYO>        Assembler::Jump target = _as->branch32(Assembler::NotEqual, reg, Assembler::TrustedImm32(0));<KAIGYO>        _as->addPatch(s->iftrue, target);<KAIGYO>        _as->jumpToBlock(_block, s->iffalse);<KAIGYO>        return;<KAIGYO>    } else if (V4IR::Const *c = s->cond->asConst()) {<KAIGYO>        // TODO: SSA optimisation for constant condition evaluation should remove this.<KAIGYO>        // See also visitCJump() in RegAllocInfo.<KAIGYO>        generateFunctionCall(Assembler::ReturnValueRegister, __qmljs_to_boolean,<KAIGYO>                             Assembler::PointerToValue(c));<KAIGYO>        Assembler::Jump target = _as->branch32(Assembler::NotEqual, Assembler::ReturnValueRegister,<KAIGYO>                                               Assembler::TrustedImm32(0));<KAIGYO>        _as->addPatch(s->iftrue, target);<KAIGYO>        CmpOp op = 0;<KAIGYO>        CmpOpContext opContext = 0;<KAIGYO>        const char *opName = 0;<KAIGYO>        switch (b->op) {<KAIGYO>        default: Q_UNREACHABLE(); assert(!""""); break;<KAIGYO>        case V4IR::OpGt: setOp(op, opName, __qmljs_cmp_gt); break;<KAIGYO>        case V4IR::OpLt: setOp(op, opName, __qmljs_cmp_lt); break;<KAIGYO>        case V4IR::OpGe: setOp(op, opName, __qmljs_cmp_ge); break;<KAIGYO>        case V4IR::OpLe: setOp(op, opName, __qmljs_cmp_le); break;<KAIGYO>        case V4IR::OpEqual: setOp(op, opName, __qmljs_cmp_eq); break;<KAIGYO>        case V4IR::OpNotEqual: setOp(op, opName, __qmljs_cmp_ne); break;<KAIGYO>        case V4IR::OpStrictEqual: setOp(op, opName, __qmljs_cmp_se); break;<KAIGYO>        case V4IR::OpStrictNotEqual: setOp(op, opName, __qmljs_cmp_sne); break;<KAIGYO>        case V4IR::OpInstanceof: setOpContext(op, opName, __qmljs_cmp_instanceof); break;<KAIGYO>        case V4IR::OpIn: setOpContext(op, opName, __qmljs_cmp_in); break;<KAIGYO>        } // switch<KAIGYO>        // TODO: in SSA optimisation, do constant expression evaluation.<KAIGYO>        // The case here is, for example:<KAIGYO>        //   if (true === true) .....<KAIGYO>        // Of course, after folding the CJUMP to a JUMP, dead-code (dead-basic-block)<KAIGYO>        // elimination (which isn\'t there either) would remove the whole else block.<KAIGYO>        if (opContext)<KAIGYO>            _as->generateFunctionCallImp(Assembler::ReturnValueRegister, opName, opContext,<KAIGYO>                                         Assembler::ContextRegister,<KAIGYO>                                         Assembler::PointerToValue(b->left),<KAIGYO>                                         Assembler::PointerToValue(b->right));<KAIGYO>        else<KAIGYO>            _as->generateFunctionCallImp(Assembler::ReturnValueRegister, opName, op,<KAIGYO>                                         Assembler::PointerToValue(b->left),<KAIGYO>                                         Assembler::PointerToValue(b->right));<KAIGYO>        Assembler::Jump target = _as->branch32(Assembler::NotEqual, Assembler::ReturnValueRegister,<KAIGYO>                                               Assembler::TrustedImm32(0));<KAIGYO>        _as->addPatch(s->iftrue, target);<KAIGYO>        _as->jumpToBlock(_block, s->iffalse);<KAIGYO>        return;<KAIGYO>        if (t->kind == V4IR::Temp::PhysicalRegister) {<KAIGYO>            if (t->type == V4IR::DoubleType) {<KAIGYO>                _as->moveDoubleTo64((Assembler::FPRegisterID) t->index,<KAIGYO>                                    Assembler::ReturnValueRegister);<KAIGYO>            } else {<KAIGYO>                _as->zeroExtend32ToPtr((Assembler::RegisterID) t->index,<KAIGYO>                                       Assembler::ReturnValueRegister);<KAIGYO>                QV4::Value upper;<KAIGYO>                switch (t->type) {<KAIGYO>                case V4IR::SInt32Type:<KAIGYO>                case V4IR::UInt32Type:<KAIGYO>                    upper = QV4::Value::fromInt32(0);<KAIGYO>                    break;<KAIGYO>                case V4IR::BoolType:<KAIGYO>                    upper = QV4::Value::fromBoolean(false);<KAIGYO>                    break;<KAIGYO>                default:<KAIGYO>                    upper = QV4::Value::undefinedValue();<KAIGYO>                    Q_UNIMPLEMENTED();<KAIGYO>                }<KAIGYO>                _as->or64(Assembler::TrustedImm64(((int64_t) upper.tag) << 32),<KAIGYO>                          Assembler::ReturnValueRegister);<KAIGYO>            }<KAIGYO>        } else {<KAIGYO>            _as->copyValue(Assembler::ReturnValueRegister, t);<KAIGYO>        }<KAIGYO>    _as->leaveStandardStackFrame(/*withLocals*/': 6, '    _as->leaveStandardStackFrame(/*locals*/false);<KAIGYO>    Q_ASSERT(arg);<KAIGYO>    Q_ASSERT(result);<KAIGYO><KAIGYO>    Q_ASSERT(arg);<KAIGYO>    Q_ASSERT(result);<KAIGYO><KAIGYO>    Q_ASSERT(arg);<KAIGYO><KAIGYO>    Q_ASSERT(object);<KAIGYO>    Q_ASSERT(getter);<KAIGYO>    Q_ASSERT(setter);<KAIGYO>void InstructionSelection::callBuiltinDefineProperty(V4IR::Temp *object, const QString &name,<KAIGYO>                                                     V4IR::Expr *value)<KAIGYO>    Q_ASSERT(object);<KAIGYO>    Q_ASSERT(value->asTemp() || value->asConst());<KAIGYO><KAIGYO>    generateFunctionCall(Assembler::Void, __qmljs_builtin_define_property,<KAIGYO>                         Assembler::ContextRegister, Assembler::Reference(object), identifier(name),<KAIGYO>                         Assembler::PointerToValue(value));<KAIGYO>    Q_ASSERT(result);<KAIGYO><KAIGYO>                         Assembler::PointerToValue(result), baseAddressForCallArguments(),<KAIGYO>                         Assembler::TrustedImm32(length));<KAIGYO>    Q_ASSERT(result);<KAIGYO><KAIGYO>        _as->copyValue(_as->stackLayout().argumentAddressForCall(argc++), it->expr);<KAIGYO>            _as->copyValue(_as->stackLayout().argumentAddressForCall(argc++), it->expr);<KAIGYO>    Q_ASSERT(value);<KAIGYO><KAIGYO>    _as->load64(Pointer(Assembler::ContextRegister, offsetof(ExecutionContext, thisObject)),<KAIGYO>                Assembler::ReturnValueRegister);<KAIGYO>    if (targetTemp->kind == V4IR::Temp::PhysicalRegister) {<KAIGYO>        if (targetTemp->type == V4IR::DoubleType) {<KAIGYO>            Q_ASSERT(sourceConst->type == V4IR::DoubleType);<KAIGYO>            _as->toDoubleRegister(sourceConst, (Assembler::FPRegisterID) targetTemp->index);<KAIGYO>        } else if (targetTemp->type == V4IR::SInt32Type) {<KAIGYO>            Q_ASSERT(sourceConst->type == V4IR::SInt32Type);<KAIGYO>            _as->toInt32Register(sourceConst, (Assembler::RegisterID) targetTemp->index);<KAIGYO>        } else if (targetTemp->type == V4IR::UInt32Type) {<KAIGYO>            Q_ASSERT(sourceConst->type == V4IR::UInt32Type);<KAIGYO>            _as->toUInt32Register(sourceConst, (Assembler::RegisterID) targetTemp->index);<KAIGYO>        } else if (targetTemp->type == V4IR::BoolType) {<KAIGYO>            Q_ASSERT(sourceConst->type == V4IR::BoolType);<KAIGYO>            _as->move(Assembler::TrustedImm32(convertToValue(sourceConst).int_32),<KAIGYO>                      (Assembler::RegisterID) targetTemp->index);<KAIGYO>        } else {<KAIGYO>            Q_UNIMPLEMENTED();<KAIGYO>        }<KAIGYO>    } else {<KAIGYO>        _as->storeValue(convertToValue(sourceConst), targetTemp);<KAIGYO>    }<KAIGYO>    _as->constantTable().add(v);<KAIGYO>void InstructionSelection::setActivationProperty(V4IR::Expr *source, const QString &targetName)<KAIGYO>                         Assembler::ContextRegister, propertyName, Assembler::PointerToValue(source));<KAIGYO>void InstructionSelection::getProperty(V4IR::Expr *base, const QString &name, V4IR::Temp *target)<KAIGYO>                           Assembler::PointerToValue(base));<KAIGYO>        generateFunctionCall(Assembler::Void, __qmljs_get_property, Assembler::ContextRegister,<KAIGYO>                             Assembler::PointerToValue(target), Assembler::PointerToValue(base),<KAIGYO>                             identifier(name));<KAIGYO>void InstructionSelection::setProperty(V4IR::Expr *source, V4IR::Expr *targetBase,<KAIGYO>                                       const QString &targetName)<KAIGYO>        generateLookupCall(index, offsetof(QV4::Lookup, setter),<KAIGYO>                           Assembler::PointerToValue(targetBase),<KAIGYO>                           Assembler::PointerToValue(source));<KAIGYO>                             Assembler::PointerToValue(targetBase), identifier(targetName),<KAIGYO>                             Assembler::PointerToValue(source));<KAIGYO>void InstructionSelection::getElement(V4IR::Expr *base, V4IR::Expr *index, V4IR::Temp *target)<KAIGYO>                         Assembler::PointerToValue(target), Assembler::PointerToValue(base),<KAIGYO>                         Assembler::PointerToValue(index));<KAIGYO>void InstructionSelection::setElement(V4IR::Expr *source, V4IR::Expr *targetBase, V4IR::Expr *targetIndex)<KAIGYO>                         Assembler::PointerToValue(targetBase), Assembler::PointerToValue(targetIndex),<KAIGYO>                         Assembler::PointerToValue(source));<KAIGYO>    if (*sourceTemp == *targetTemp)<KAIGYO>        return;<KAIGYO><KAIGYO>    if (sourceTemp->kind == V4IR::Temp::PhysicalRegister) {<KAIGYO>        if (targetTemp->kind == V4IR::Temp::PhysicalRegister) {<KAIGYO>            if (sourceTemp->type == V4IR::DoubleType)<KAIGYO>                _as->moveDouble((Assembler::FPRegisterID) sourceTemp->index,<KAIGYO>                                (Assembler::FPRegisterID) targetTemp->index);<KAIGYO>            else<KAIGYO>                _as->move((Assembler::RegisterID) sourceTemp->index,<KAIGYO>                          (Assembler::RegisterID) targetTemp->index);<KAIGYO>            return;<KAIGYO>        } else {<KAIGYO>            Assembler::Pointer addr = _as->loadTempAddress(Assembler::ScratchRegister, targetTemp);<KAIGYO>            switch (sourceTemp->type) {<KAIGYO>            case V4IR::DoubleType:<KAIGYO>                _as->storeDouble((Assembler::FPRegisterID) sourceTemp->index, addr);<KAIGYO>                break;<KAIGYO>            case V4IR::SInt32Type:<KAIGYO>                _as->storeInt32((Assembler::RegisterID) sourceTemp->index, addr);<KAIGYO>                break;<KAIGYO>            case V4IR::UInt32Type:<KAIGYO>                _as->storeUInt32((Assembler::RegisterID) sourceTemp->index, addr);<KAIGYO>                break;<KAIGYO>            case V4IR::BoolType:<KAIGYO>                _as->storeBool((Assembler::RegisterID) sourceTemp->index, addr);<KAIGYO>                break;<KAIGYO>            default:<KAIGYO>                _as->store64((Assembler::RegisterID) sourceTemp->index, addr);<KAIGYO>                break;<KAIGYO>            }<KAIGYO>            return;<KAIGYO>        }<KAIGYO>    } else if (targetTemp->kind == V4IR::Temp::PhysicalRegister) {<KAIGYO>        switch (targetTemp->type) {<KAIGYO>        case V4IR::DoubleType:<KAIGYO>            _as->toDoubleRegister(sourceTemp, (Assembler::FPRegisterID) targetTemp->index);<KAIGYO>            return;<KAIGYO>        case V4IR::BoolType:<KAIGYO>        case V4IR::SInt32Type:<KAIGYO>            _as->toInt32Register(sourceTemp, (Assembler::RegisterID) targetTemp->index);<KAIGYO>            return;<KAIGYO>        case V4IR::UInt32Type:<KAIGYO>            _as->toUInt32Register(sourceTemp, (Assembler::RegisterID) targetTemp->index);<KAIGYO>            return;<KAIGYO>        case V4IR::StringType:<KAIGYO>            _as->load64(_as->stackSlotPointer(sourceTemp),<KAIGYO>                        (Assembler::RegisterID) targetTemp->index);<KAIGYO>            return;<KAIGYO>        default:<KAIGYO>            break;<KAIGYO>        }<KAIGYO>    }<KAIGYO><KAIGYO>void InstructionSelection::swapValues(V4IR::Temp *sourceTemp, V4IR::Temp *targetTemp)<KAIGYO>{<KAIGYO>    Q_ASSERT(sourceTemp->type == targetTemp->type);<KAIGYO><KAIGYO>    if (sourceTemp->kind == V4IR::Temp::PhysicalRegister) {<KAIGYO>        if (targetTemp->kind == V4IR::Temp::PhysicalRegister) {<KAIGYO>            if (sourceTemp->type == V4IR::DoubleType) {<KAIGYO>                _as->moveDouble((Assembler::FPRegisterID) targetTemp->index, Assembler::FPGpr0);<KAIGYO>                _as->moveDouble((Assembler::FPRegisterID) sourceTemp->index,<KAIGYO>                                (Assembler::FPRegisterID) targetTemp->index);<KAIGYO>                _as->moveDouble(Assembler::FPGpr0, (Assembler::FPRegisterID) sourceTemp->index);<KAIGYO>            } else {<KAIGYO>                _as->swap((Assembler::RegisterID) sourceTemp->index,<KAIGYO>                          (Assembler::RegisterID) targetTemp->index);<KAIGYO>            }<KAIGYO>            return;<KAIGYO>        }<KAIGYO>    } else if (sourceTemp->kind == V4IR::Temp::StackSlot) {<KAIGYO>        if (targetTemp->kind == V4IR::Temp::StackSlot) {<KAIGYO>            Assembler::FPRegisterID tReg = _as->toDoubleRegister(targetTemp);<KAIGYO>#if CPU(X86_64)<KAIGYO>            _as->load64(_as->stackSlotPointer(sourceTemp), Assembler::ScratchRegister);<KAIGYO>            _as->store64(Assembler::ScratchRegister, _as->stackSlotPointer(targetTemp));<KAIGYO>#else<KAIGYO>            Assembler::Pointer sAddr = _as->stackSlotPointer(sourceTemp);<KAIGYO>            Assembler::Pointer tAddr = _as->stackSlotPointer(targetTemp);<KAIGYO>            _as->load32(sAddr, Assembler::ScratchRegister);<KAIGYO>            _as->store32(Assembler::ScratchRegister, tAddr);<KAIGYO>            sAddr.offset += 4;<KAIGYO>            tAddr.offset += 4;<KAIGYO>            _as->load32(sAddr, Assembler::ScratchRegister);<KAIGYO>            _as->store32(Assembler::ScratchRegister, tAddr);<KAIGYO>#endif<KAIGYO>            _as->storeDouble(tReg, _as->stackSlotPointer(sourceTemp));<KAIGYO>            return;<KAIGYO>        }<KAIGYO>    }<KAIGYO><KAIGYO>    // FIXME: TODO!<KAIGYO>    Q_UNIMPLEMENTED();<KAIGYO>}<KAIGYO><KAIGYO>    if (op) {<KAIGYO>        _as->generateFunctionCallImp(Assembler::Void, opName, op,<KAIGYO>                                     Assembler::PointerToValue(targetTemp),<KAIGYO>                                     Assembler::PointerToValue(sourceTemp));<KAIGYO>        storeTarget(0, targetTemp);<KAIGYO>    }<KAIGYO>    const Assembler::BinaryOperationInfo& info = Assembler::binaryOperation(oper);<KAIGYO>    if (info.fallbackImplementation) {<KAIGYO>        _as->generateFunctionCallImp(Assembler::Void, info.name, info.fallbackImplementation,<KAIGYO>                                     Assembler::PointerToValue(target),<KAIGYO>                                     Assembler::PointerToValue(leftSource),<KAIGYO>                                     Assembler::PointerToValue(rightSource));<KAIGYO>        storeTarget(0, target);<KAIGYO>    } else if (info.contextImplementation) {<KAIGYO>        _as->generateFunctionCallImp(Assembler::Void, info.name, info.contextImplementation,<KAIGYO>                                     Assembler::ContextRegister,<KAIGYO>                                     Assembler::PointerToValue(target),<KAIGYO>                                     Assembler::PointerToValue(leftSource),<KAIGYO>                                     Assembler::PointerToValue(rightSource));<KAIGYO>        storeTarget(1, target);<KAIGYO>    } else {<KAIGYO>        assert(!"""");<KAIGYO>    }<KAIGYO>void InstructionSelection::callProperty(V4IR::Expr *base, const QString &name, V4IR::ExprList *args,<KAIGYO>                                        V4IR::Temp *result)<KAIGYO>                             Assembler::PointerToValue(base), Assembler::TrustedImm32(index),<KAIGYO>        generateFunctionCall(Assembler::Void, __qmljs_call_property, Assembler::ContextRegister,<KAIGYO>                             Assembler::PointerToValue(result), Assembler::PointerToValue(base), s,<KAIGYO>                             baseAddressForCallArguments(), Assembler::TrustedImm32(argc));<KAIGYO>void InstructionSelection::callSubscript(V4IR::Expr *base, V4IR::Expr *index, V4IR::ExprList *args,<KAIGYO>                                         V4IR::Temp *result)<KAIGYO>    generateFunctionCall(Assembler::Void, __qmljs_call_element, Assembler::ContextRegister,<KAIGYO>                         Assembler::PointerToValue(result), Assembler::PointerToValue(base),<KAIGYO>                         Assembler::PointerToValue(index), baseAddressForCallArguments(),<KAIGYO>    if (target->type & V4IR::NumberType)<KAIGYO>    else if (target->type == V4IR::BoolType) {<KAIGYO>        generateFunctionCall(Assembler::ReturnValueRegister, __qmljs_to_boolean,<KAIGYO>                             Assembler::PointerToValue(source));<KAIGYO>        _as->storeBool(Assembler::ReturnValueRegister, target);<KAIGYO>    } else<KAIGYO>        Assembler::RegisterID reg;<KAIGYO>        if (t->kind == V4IR::Temp::PhysicalRegister) {<KAIGYO>            Q_ASSERT(t->type == V4IR::BoolType);<KAIGYO>            reg = (Assembler::RegisterID) t->index;<KAIGYO>        } else if (t->kind == V4IR::Temp::StackSlot && t->type == V4IR::BoolType) {<KAIGYO>            reg = Assembler::ReturnValueRegister;<KAIGYO>            _as->toInt32Register(t, reg);<KAIGYO>        } else {<KAIGYO>            Address temp = _as->loadTempAddress(Assembler::ScratchRegister, t);<KAIGYO>            Address tag = temp;<KAIGYO>            tag.offset += offsetof(QV4::Value, tag);<KAIGYO>            Assembler::Jump booleanConversion = _as->branch32(Assembler::NotEqual, tag, Assembler::TrustedImm32(QV4::Value::Boolean_Type));<KAIGYO>            Address data = temp;<KAIGYO>            data.offset += offsetof(QV4::Value, int_32);<KAIGYO>            _as->load32(data, Assembler::ReturnValueRegister);<KAIGYO>            Assembler::Jump testBoolean = _as->jump();<KAIGYO>            booleanConversion.link(_as);<KAIGYO>            reg = Assembler::ReturnValueRegister;<KAIGYO>            generateFunctionCall(reg, __qmljs_to_boolean, Assembler::Reference(t));<KAIGYO>            testBoolean.link(_as);<KAIGYO>        }<KAIGYO>        Assembler::Jump target = _as->branch32(Assembler::NotEqual, reg, Assembler::TrustedImm32(0));<KAIGYO>        _as->addPatch(s->iftrue, target);<KAIGYO>        _as->jumpToBlock(_block, s->iffalse);<KAIGYO>        return;<KAIGYO>    } else if (V4IR::Const *c = s->cond->asConst()) {<KAIGYO>        // TODO: SSA optimization for constant condition evaluation should remove this.<KAIGYO>        // See also visitCJump() in RegAllocInfo.<KAIGYO>        generateFunctionCall(Assembler::ReturnValueRegister, __qmljs_to_boolean,<KAIGYO>                             Assembler::PointerToValue(c));<KAIGYO>        Assembler::Jump target = _as->branch32(Assembler::NotEqual, Assembler::ReturnValueRegister,<KAIGYO>                                               Assembler::TrustedImm32(0));<KAIGYO>        _as->addPatch(s->iftrue, target);<KAIGYO>        CmpOp op = 0;<KAIGYO>        CmpOpContext opContext = 0;<KAIGYO>        const char *opName = 0;<KAIGYO>        switch (b->op) {<KAIGYO>        default: Q_UNREACHABLE(); assert(!""""); break;<KAIGYO>        case V4IR::OpGt: setOp(op, opName, __qmljs_cmp_gt); break;<KAIGYO>        case V4IR::OpLt: setOp(op, opName, __qmljs_cmp_lt); break;<KAIGYO>        case V4IR::OpGe: setOp(op, opName, __qmljs_cmp_ge); break;<KAIGYO>        case V4IR::OpLe: setOp(op, opName, __qmljs_cmp_le); break;<KAIGYO>        case V4IR::OpEqual: setOp(op, opName, __qmljs_cmp_eq); break;<KAIGYO>        case V4IR::OpNotEqual: setOp(op, opName, __qmljs_cmp_ne); break;<KAIGYO>        case V4IR::OpStrictEqual: setOp(op, opName, __qmljs_cmp_se); break;<KAIGYO>        case V4IR::OpStrictNotEqual: setOp(op, opName, __qmljs_cmp_sne); break;<KAIGYO>        case V4IR::OpInstanceof: setOpContext(op, opName, __qmljs_cmp_instanceof); break;<KAIGYO>        case V4IR::OpIn: setOpContext(op, opName, __qmljs_cmp_in); break;<KAIGYO>        } // switch<KAIGYO>        // TODO: in SSA optimization, do constant expression evaluation.<KAIGYO>        // The case here is, for example:<KAIGYO>        //   if (true === true) .....<KAIGYO>        // Of course, after folding the CJUMP to a JUMP, dead-code (dead-basic-block)<KAIGYO>        // elimination (which isn\'t there either) would remove the whole else block.<KAIGYO>        if (opContext)<KAIGYO>            _as->generateFunctionCallImp(Assembler::ReturnValueRegister, opName, opContext,<KAIGYO>                                         Assembler::ContextRegister,<KAIGYO>                                         Assembler::PointerToValue(b->left),<KAIGYO>                                         Assembler::PointerToValue(b->right));<KAIGYO>        else<KAIGYO>            _as->generateFunctionCallImp(Assembler::ReturnValueRegister, opName, op,<KAIGYO>                                         Assembler::PointerToValue(b->left),<KAIGYO>                                         Assembler::PointerToValue(b->right));<KAIGYO>        Assembler::Jump target = _as->branch32(Assembler::NotEqual, Assembler::ReturnValueRegister,<KAIGYO>                                               Assembler::TrustedImm32(0));<KAIGYO>        _as->addPatch(s->iftrue, target);<KAIGYO>        _as->jumpToBlock(_block, s->iffalse);<KAIGYO>        return;<KAIGYO>        if (t->kind == V4IR::Temp::PhysicalRegister) {<KAIGYO>            if (t->type == V4IR::DoubleType) {<KAIGYO>                _as->moveDoubleTo64((Assembler::FPRegisterID) t->index,<KAIGYO>                                    Assembler::ReturnValueRegister);<KAIGYO>            } else {<KAIGYO>                _as->zeroExtend32ToPtr((Assembler::RegisterID) t->index,<KAIGYO>                                       Assembler::ReturnValueRegister);<KAIGYO>                QV4::Value upper;<KAIGYO>                switch (t->type) {<KAIGYO>                case V4IR::SInt32Type:<KAIGYO>                case V4IR::UInt32Type:<KAIGYO>                    upper = QV4::Value::fromInt32(0);<KAIGYO>                    break;<KAIGYO>                case V4IR::BoolType:<KAIGYO>                    upper = QV4::Value::fromBoolean(false);<KAIGYO>                    break;<KAIGYO>                default:<KAIGYO>                    upper = QV4::Value::undefinedValue();<KAIGYO>                    Q_UNIMPLEMENTED();<KAIGYO>                }<KAIGYO>                _as->or64(Assembler::TrustedImm64(((int64_t) upper.tag) << 32),<KAIGYO>                          Assembler::ReturnValueRegister);<KAIGYO>            }<KAIGYO>        } else {<KAIGYO>            _as->copyValue(Assembler::ReturnValueRegister, t);<KAIGYO>        }<KAIGYO>    _as->leaveStandardStackFrame(/*withLocals*/': 8, '// TODO: SSA optimization for constant condition evaluation should remove this.<KAIGYO>// See also visitCJump() in masm.': 8, '    _as->leaveStandardStackFrame(/*locals*/false);<KAIGYO>    Q_ASSERT(arg);<KAIGYO>    Q_ASSERT(result);<KAIGYO><KAIGYO>    Q_ASSERT(arg);<KAIGYO>    Q_ASSERT(result);<KAIGYO><KAIGYO>    Q_ASSERT(arg);<KAIGYO><KAIGYO>    Q_ASSERT(object);<KAIGYO>    Q_ASSERT(getter);<KAIGYO>    Q_ASSERT(setter);<KAIGYO>void InstructionSelection::callBuiltinDefineProperty(V4IR::Temp *object, const QString &name,<KAIGYO>                                                     V4IR::Expr *value)<KAIGYO>    Q_ASSERT(object);<KAIGYO>    Q_ASSERT(value->asTemp() || value->asConst());<KAIGYO><KAIGYO>    generateFunctionCall(Assembler::Void, __qmljs_builtin_define_property,<KAIGYO>                         Assembler::ContextRegister, Assembler::Reference(object), Assembler::PointerToString(name),<KAIGYO>                         Assembler::PointerToValue(value));<KAIGYO>    Q_ASSERT(result);<KAIGYO><KAIGYO>                         Assembler::PointerToValue(result), baseAddressForCallArguments(),<KAIGYO>                         Assembler::TrustedImm32(length));<KAIGYO>    Q_ASSERT(result);<KAIGYO><KAIGYO>        _as->copyValue(_as->stackLayout().argumentAddressForCall(argc++), it->expr);<KAIGYO>            _as->copyValue(_as->stackLayout().argumentAddressForCall(argc++), it->expr);<KAIGYO>    Q_ASSERT(value);<KAIGYO><KAIGYO>    _as->load64(Pointer(Assembler::ContextRegister, offsetof(ExecutionContext, thisObject)),<KAIGYO>                Assembler::ReturnValueRegister);<KAIGYO>    if (targetTemp->kind == V4IR::Temp::PhysicalRegister) {<KAIGYO>        if (targetTemp->type == V4IR::DoubleType) {<KAIGYO>            Q_ASSERT(sourceConst->type == V4IR::DoubleType);<KAIGYO>            _as->toDoubleRegister(sourceConst, (Assembler::FPRegisterID) targetTemp->index);<KAIGYO>        } else if (targetTemp->type == V4IR::SInt32Type) {<KAIGYO>            Q_ASSERT(sourceConst->type == V4IR::SInt32Type);<KAIGYO>            _as->toInt32Register(sourceConst, (Assembler::RegisterID) targetTemp->index);<KAIGYO>        } else if (targetTemp->type == V4IR::UInt32Type) {<KAIGYO>            Q_ASSERT(sourceConst->type == V4IR::UInt32Type);<KAIGYO>            _as->toUInt32Register(sourceConst, (Assembler::RegisterID) targetTemp->index);<KAIGYO>        } else if (targetTemp->type == V4IR::BoolType) {<KAIGYO>            Q_ASSERT(sourceConst->type == V4IR::BoolType);<KAIGYO>            _as->move(Assembler::TrustedImm32(convertToValue(sourceConst).int_32),<KAIGYO>                      (Assembler::RegisterID) targetTemp->index);<KAIGYO>        } else {<KAIGYO>            Q_UNIMPLEMENTED();<KAIGYO>        }<KAIGYO>    } else {<KAIGYO>        _as->storeValue(convertToValue(sourceConst), targetTemp);<KAIGYO>    }<KAIGYO>void InstructionSelection::setActivationProperty(V4IR::Expr *source, const QString &targetName)<KAIGYO>                         Assembler::ContextRegister, Assembler::PointerToString(targetName), Assembler::PointerToValue(source));<KAIGYO>void InstructionSelection::getProperty(V4IR::Expr *base, const QString &name, V4IR::Temp *target)<KAIGYO>                           Assembler::PointerToValue(base));<KAIGYO>        generateFunctionCall(Assembler::Void, __qmljs_get_property, Assembler::ContextRegister,<KAIGYO>                             Assembler::PointerToValue(target), Assembler::PointerToValue(base),<KAIGYO>                             Assembler::PointerToString(name));<KAIGYO>void InstructionSelection::setProperty(V4IR::Expr *source, V4IR::Expr *targetBase,<KAIGYO>                                       const QString &targetName)<KAIGYO>        generateLookupCall(index, offsetof(QV4::Lookup, setter),<KAIGYO>                           Assembler::PointerToValue(targetBase),<KAIGYO>                           Assembler::PointerToValue(source));<KAIGYO>                             Assembler::PointerToValue(targetBase), Assembler::PointerToString(targetName),<KAIGYO>                             Assembler::PointerToValue(source));<KAIGYO>void InstructionSelection::getElement(V4IR::Expr *base, V4IR::Expr *index, V4IR::Temp *target)<KAIGYO>                         Assembler::PointerToValue(target), Assembler::PointerToValue(base),<KAIGYO>                         Assembler::PointerToValue(index));<KAIGYO>void InstructionSelection::setElement(V4IR::Expr *source, V4IR::Expr *targetBase, V4IR::Expr *targetIndex)<KAIGYO>                         Assembler::PointerToValue(targetBase), Assembler::PointerToValue(targetIndex),<KAIGYO>                         Assembler::PointerToValue(source));<KAIGYO>    if (*sourceTemp == *targetTemp)<KAIGYO>        return;<KAIGYO><KAIGYO>    if (sourceTemp->kind == V4IR::Temp::PhysicalRegister) {<KAIGYO>        if (targetTemp->kind == V4IR::Temp::PhysicalRegister) {<KAIGYO>            if (sourceTemp->type == V4IR::DoubleType)<KAIGYO>                _as->moveDouble((Assembler::FPRegisterID) sourceTemp->index,<KAIGYO>                                (Assembler::FPRegisterID) targetTemp->index);<KAIGYO>            else<KAIGYO>                _as->move((Assembler::RegisterID) sourceTemp->index,<KAIGYO>                          (Assembler::RegisterID) targetTemp->index);<KAIGYO>            return;<KAIGYO>        } else {<KAIGYO>            Assembler::Pointer addr = _as->loadTempAddress(Assembler::ScratchRegister, targetTemp);<KAIGYO>            switch (sourceTemp->type) {<KAIGYO>            case V4IR::DoubleType:<KAIGYO>                _as->storeDouble((Assembler::FPRegisterID) sourceTemp->index, addr);<KAIGYO>                break;<KAIGYO>            case V4IR::SInt32Type:<KAIGYO>                _as->storeInt32((Assembler::RegisterID) sourceTemp->index, addr);<KAIGYO>                break;<KAIGYO>            case V4IR::UInt32Type:<KAIGYO>                _as->storeUInt32((Assembler::RegisterID) sourceTemp->index, addr);<KAIGYO>                break;<KAIGYO>            case V4IR::BoolType:<KAIGYO>                _as->storeBool((Assembler::RegisterID) sourceTemp->index, addr);<KAIGYO>                break;<KAIGYO>            default:<KAIGYO>                _as->store64((Assembler::RegisterID) sourceTemp->index, addr);<KAIGYO>                break;<KAIGYO>            }<KAIGYO>            return;<KAIGYO>        }<KAIGYO>    } else if (targetTemp->kind == V4IR::Temp::PhysicalRegister) {<KAIGYO>        switch (targetTemp->type) {<KAIGYO>        case V4IR::DoubleType:<KAIGYO>            _as->toDoubleRegister(sourceTemp, (Assembler::FPRegisterID) targetTemp->index);<KAIGYO>            return;<KAIGYO>        case V4IR::BoolType:<KAIGYO>        case V4IR::SInt32Type:<KAIGYO>            _as->toInt32Register(sourceTemp, (Assembler::RegisterID) targetTemp->index);<KAIGYO>            return;<KAIGYO>        case V4IR::UInt32Type:<KAIGYO>            _as->toUInt32Register(sourceTemp, (Assembler::RegisterID) targetTemp->index);<KAIGYO>            return;<KAIGYO>        case V4IR::StringType:<KAIGYO>            _as->load64(_as->stackSlotPointer(sourceTemp),<KAIGYO>                        (Assembler::RegisterID) targetTemp->index);<KAIGYO>            return;<KAIGYO>        default:<KAIGYO>            break;<KAIGYO>        }<KAIGYO>    }<KAIGYO><KAIGYO>void InstructionSelection::swapValues(V4IR::Temp *sourceTemp, V4IR::Temp *targetTemp)<KAIGYO>{<KAIGYO>    Q_ASSERT(sourceTemp->type == targetTemp->type);<KAIGYO><KAIGYO>    if (sourceTemp->kind == V4IR::Temp::PhysicalRegister) {<KAIGYO>        if (targetTemp->kind == V4IR::Temp::PhysicalRegister) {<KAIGYO>            if (sourceTemp->type == V4IR::DoubleType) {<KAIGYO>                _as->moveDouble((Assembler::FPRegisterID) targetTemp->index, Assembler::FPGpr0);<KAIGYO>                _as->moveDouble((Assembler::FPRegisterID) sourceTemp->index,<KAIGYO>                                (Assembler::FPRegisterID) targetTemp->index);<KAIGYO>                _as->moveDouble(Assembler::FPGpr0, (Assembler::FPRegisterID) sourceTemp->index);<KAIGYO>            } else {<KAIGYO>                _as->swap((Assembler::RegisterID) sourceTemp->index,<KAIGYO>                          (Assembler::RegisterID) targetTemp->index);<KAIGYO>            }<KAIGYO>            return;<KAIGYO>        }<KAIGYO>    } else if (sourceTemp->kind == V4IR::Temp::StackSlot) {<KAIGYO>        if (targetTemp->kind == V4IR::Temp::StackSlot) {<KAIGYO>            Assembler::FPRegisterID tReg = _as->toDoubleRegister(targetTemp);<KAIGYO>#if CPU(X86_64)<KAIGYO>            _as->load64(_as->stackSlotPointer(sourceTemp), Assembler::ScratchRegister);<KAIGYO>            _as->store64(Assembler::ScratchRegister, _as->stackSlotPointer(targetTemp));<KAIGYO>#else<KAIGYO>            Assembler::Pointer sAddr = _as->stackSlotPointer(sourceTemp);<KAIGYO>            Assembler::Pointer tAddr = _as->stackSlotPointer(targetTemp);<KAIGYO>            _as->load32(sAddr, Assembler::ScratchRegister);<KAIGYO>            _as->store32(Assembler::ScratchRegister, tAddr);<KAIGYO>            sAddr.offset += 4;<KAIGYO>            tAddr.offset += 4;<KAIGYO>            _as->load32(sAddr, Assembler::ScratchRegister);<KAIGYO>            _as->store32(Assembler::ScratchRegister, tAddr);<KAIGYO>#endif<KAIGYO>            _as->storeDouble(tReg, _as->stackSlotPointer(sourceTemp));<KAIGYO>            return;<KAIGYO>        }<KAIGYO>    }<KAIGYO><KAIGYO>    // FIXME: TODO!<KAIGYO>    Q_UNIMPLEMENTED();<KAIGYO>}<KAIGYO><KAIGYO>    if (op) {<KAIGYO>        _as->generateFunctionCallImp(Assembler::Void, opName, op,<KAIGYO>                                     Assembler::PointerToValue(targetTemp),<KAIGYO>                                     Assembler::PointerToValue(sourceTemp));<KAIGYO>        storeTarget(0, targetTemp);<KAIGYO>    }<KAIGYO>    const Assembler::BinaryOperationInfo& info = Assembler::binaryOperation(oper);<KAIGYO>    if (info.fallbackImplementation) {<KAIGYO>        _as->generateFunctionCallImp(Assembler::Void, info.name, info.fallbackImplementation,<KAIGYO>                                     Assembler::PointerToValue(target),<KAIGYO>                                     Assembler::PointerToValue(leftSource),<KAIGYO>                                     Assembler::PointerToValue(rightSource));<KAIGYO>        storeTarget(0, target);<KAIGYO>    } else if (info.contextImplementation) {<KAIGYO>        _as->generateFunctionCallImp(Assembler::Void, info.name, info.contextImplementation,<KAIGYO>                                     Assembler::ContextRegister,<KAIGYO>                                     Assembler::PointerToValue(target),<KAIGYO>                                     Assembler::PointerToValue(leftSource),<KAIGYO>                                     Assembler::PointerToValue(rightSource));<KAIGYO>        storeTarget(1, target);<KAIGYO>    } else {<KAIGYO>        assert(!"""");<KAIGYO>    }<KAIGYO>void InstructionSelection::callProperty(V4IR::Expr *base, const QString &name, V4IR::ExprList *args,<KAIGYO>                                        V4IR::Temp *result)<KAIGYO>                             Assembler::PointerToValue(base), Assembler::TrustedImm32(index),<KAIGYO>        generateFunctionCall(Assembler::Void, __qmljs_call_property, Assembler::ContextRegister,<KAIGYO>                             Assembler::PointerToValue(result), Assembler::PointerToValue(base), Assembler::PointerToString(name),<KAIGYO>                             baseAddressForCallArguments(), Assembler::TrustedImm32(argc));<KAIGYO>void InstructionSelection::callSubscript(V4IR::Expr *base, V4IR::Expr *index, V4IR::ExprList *args,<KAIGYO>                                         V4IR::Temp *result)<KAIGYO>    generateFunctionCall(Assembler::Void, __qmljs_call_element, Assembler::ContextRegister,<KAIGYO>                         Assembler::PointerToValue(result), Assembler::PointerToValue(base),<KAIGYO>                         Assembler::PointerToValue(index), baseAddressForCallArguments(),<KAIGYO>    if (target->type & V4IR::NumberType)<KAIGYO>    else if (target->type == V4IR::BoolType) {<KAIGYO>        generateFunctionCall(Assembler::ReturnValueRegister, __qmljs_to_boolean,<KAIGYO>                             Assembler::PointerToValue(source));<KAIGYO>        _as->storeBool(Assembler::ReturnValueRegister, target);<KAIGYO>    } else<KAIGYO>        Assembler::RegisterID reg;<KAIGYO>        if (t->kind == V4IR::Temp::PhysicalRegister) {<KAIGYO>            Q_ASSERT(t->type == V4IR::BoolType);<KAIGYO>            reg = (Assembler::RegisterID) t->index;<KAIGYO>        } else if (t->kind == V4IR::Temp::StackSlot && t->type == V4IR::BoolType) {<KAIGYO>            reg = Assembler::ReturnValueRegister;<KAIGYO>            _as->toInt32Register(t, reg);<KAIGYO>        } else {<KAIGYO>            Address temp = _as->loadTempAddress(Assembler::ScratchRegister, t);<KAIGYO>            Address tag = temp;<KAIGYO>            tag.offset += offsetof(QV4::Value, tag);<KAIGYO>            Assembler::Jump booleanConversion = _as->branch32(Assembler::NotEqual, tag, Assembler::TrustedImm32(QV4::Value::Boolean_Type));<KAIGYO>            Address data = temp;<KAIGYO>            data.offset += offsetof(QV4::Value, int_32);<KAIGYO>            _as->load32(data, Assembler::ReturnValueRegister);<KAIGYO>            Assembler::Jump testBoolean = _as->jump();<KAIGYO>            booleanConversion.link(_as);<KAIGYO>            reg = Assembler::ReturnValueRegister;<KAIGYO>            generateFunctionCall(reg, __qmljs_to_boolean, Assembler::Reference(t));<KAIGYO>            testBoolean.link(_as);<KAIGYO>        }<KAIGYO>        Assembler::Jump target = _as->branch32(Assembler::NotEqual, reg, Assembler::TrustedImm32(0));<KAIGYO>        _as->addPatch(s->iftrue, target);<KAIGYO>        _as->jumpToBlock(_block, s->iffalse);<KAIGYO>        return;<KAIGYO>    } else if (V4IR::Const *c = s->cond->asConst()) {<KAIGYO>        // TODO: SSA optimization for constant condition evaluation should remove this.<KAIGYO>        // See also visitCJump() in RegAllocInfo.<KAIGYO>        generateFunctionCall(Assembler::ReturnValueRegister, __qmljs_to_boolean,<KAIGYO>                             Assembler::PointerToValue(c));<KAIGYO>        Assembler::Jump target = _as->branch32(Assembler::NotEqual, Assembler::ReturnValueRegister,<KAIGYO>                                               Assembler::TrustedImm32(0));<KAIGYO>        _as->addPatch(s->iftrue, target);<KAIGYO>        CmpOp op = 0;<KAIGYO>        CmpOpContext opContext = 0;<KAIGYO>        const char *opName = 0;<KAIGYO>        switch (b->op) {<KAIGYO>        default: Q_UNREACHABLE(); assert(!""""); break;<KAIGYO>        case V4IR::OpGt: setOp(op, opName, __qmljs_cmp_gt); break;<KAIGYO>        case V4IR::OpLt: setOp(op, opName, __qmljs_cmp_lt); break;<KAIGYO>        case V4IR::OpGe: setOp(op, opName, __qmljs_cmp_ge); break;<KAIGYO>        case V4IR::OpLe: setOp(op, opName, __qmljs_cmp_le); break;<KAIGYO>        case V4IR::OpEqual: setOp(op, opName, __qmljs_cmp_eq); break;<KAIGYO>        case V4IR::OpNotEqual: setOp(op, opName, __qmljs_cmp_ne); break;<KAIGYO>        case V4IR::OpStrictEqual: setOp(op, opName, __qmljs_cmp_se); break;<KAIGYO>        case V4IR::OpStrictNotEqual: setOp(op, opName, __qmljs_cmp_sne); break;<KAIGYO>        case V4IR::OpInstanceof: setOpContext(op, opName, __qmljs_cmp_instanceof); break;<KAIGYO>        case V4IR::OpIn: setOpContext(op, opName, __qmljs_cmp_in); break;<KAIGYO>        } // switch<KAIGYO>        // TODO: in SSA optimization, do constant expression evaluation.<KAIGYO>        // The case here is, for example:<KAIGYO>        //   if (true === true) .....<KAIGYO>        // Of course, after folding the CJUMP to a JUMP, dead-code (dead-basic-block)<KAIGYO>        // elimination (which isn\'t there either) would remove the whole else block.<KAIGYO>        if (opContext)<KAIGYO>            _as->generateFunctionCallImp(Assembler::ReturnValueRegister, opName, opContext,<KAIGYO>                                         Assembler::ContextRegister,<KAIGYO>                                         Assembler::PointerToValue(b->left),<KAIGYO>                                         Assembler::PointerToValue(b->right));<KAIGYO>        else<KAIGYO>            _as->generateFunctionCallImp(Assembler::ReturnValueRegister, opName, op,<KAIGYO>                                         Assembler::PointerToValue(b->left),<KAIGYO>                                         Assembler::PointerToValue(b->right));<KAIGYO>        Assembler::Jump target = _as->branch32(Assembler::NotEqual, Assembler::ReturnValueRegister,<KAIGYO>                                               Assembler::TrustedImm32(0));<KAIGYO>        _as->addPatch(s->iftrue, target);<KAIGYO>        _as->jumpToBlock(_block, s->iffalse);<KAIGYO>        return;<KAIGYO>        if (t->kind == V4IR::Temp::PhysicalRegister) {<KAIGYO>            if (t->type == V4IR::DoubleType) {<KAIGYO>                _as->moveDoubleTo64((Assembler::FPRegisterID) t->index,<KAIGYO>                                    Assembler::ReturnValueRegister);<KAIGYO>            } else {<KAIGYO>                _as->zeroExtend32ToPtr((Assembler::RegisterID) t->index,<KAIGYO>                                       Assembler::ReturnValueRegister);<KAIGYO>                QV4::Value upper;<KAIGYO>                switch (t->type) {<KAIGYO>                case V4IR::SInt32Type:<KAIGYO>                case V4IR::UInt32Type:<KAIGYO>                    upper = QV4::Value::fromInt32(0);<KAIGYO>                    break;<KAIGYO>                case V4IR::BoolType:<KAIGYO>                    upper = QV4::Value::fromBoolean(false);<KAIGYO>                    break;<KAIGYO>                default:<KAIGYO>                    upper = QV4::Value::undefinedValue();<KAIGYO>                    Q_UNIMPLEMENTED();<KAIGYO>                }<KAIGYO>                _as->or64(Assembler::TrustedImm64(((int64_t) upper.tag) << 32),<KAIGYO>                          Assembler::ReturnValueRegister);<KAIGYO>            }<KAIGYO>        } else {<KAIGYO>            _as->copyValue(Assembler::ReturnValueRegister, t);<KAIGYO>        }<KAIGYO>    _as->leaveStandardStackFrame(/*withLocals*/': 12, '    _as->leaveStandardStackFrame(/*locals*/false);<KAIGYO>    Q_ASSERT(arg);<KAIGYO>    Q_ASSERT(result);<KAIGYO><KAIGYO>    Q_ASSERT(arg);<KAIGYO>    Q_ASSERT(result);<KAIGYO><KAIGYO>    Q_ASSERT(arg);<KAIGYO><KAIGYO>    Q_ASSERT(object);<KAIGYO>    Q_ASSERT(getter);<KAIGYO>    Q_ASSERT(setter);<KAIGYO>void InstructionSelection::callBuiltinDefineProperty(V4IR::Temp *object, const QString &name,<KAIGYO>                                                     V4IR::Expr *value)<KAIGYO>    Q_ASSERT(object);<KAIGYO>    Q_ASSERT(value->asTemp() || value->asConst());<KAIGYO><KAIGYO>    generateFunctionCall(Assembler::Void, __qmljs_builtin_define_property,<KAIGYO>                         Assembler::ContextRegister, Assembler::Reference(object), Assembler::PointerToString(name),<KAIGYO>                         Assembler::PointerToValue(value));<KAIGYO>    Q_ASSERT(result);<KAIGYO><KAIGYO>                         Assembler::PointerToValue(result), baseAddressForCallArguments(),<KAIGYO>                         Assembler::TrustedImm32(length));<KAIGYO>    Q_ASSERT(result);<KAIGYO><KAIGYO>        _as->copyValue(_as->stackLayout().argumentAddressForCall(argc++), it->expr);<KAIGYO>            _as->copyValue(_as->stackLayout().argumentAddressForCall(argc++), it->expr);<KAIGYO>    Q_ASSERT(value);<KAIGYO><KAIGYO>    _as->load64(Pointer(Assembler::ContextRegister, offsetof(ExecutionContext, thisObject)),<KAIGYO>                Assembler::ReturnValueRegister);<KAIGYO>    if (targetTemp->kind == V4IR::Temp::PhysicalRegister) {<KAIGYO>        if (targetTemp->type == V4IR::DoubleType) {<KAIGYO>            Q_ASSERT(sourceConst->type == V4IR::DoubleType);<KAIGYO>            _as->toDoubleRegister(sourceConst, (Assembler::FPRegisterID) targetTemp->index);<KAIGYO>        } else if (targetTemp->type == V4IR::SInt32Type) {<KAIGYO>            Q_ASSERT(sourceConst->type == V4IR::SInt32Type);<KAIGYO>            _as->toInt32Register(sourceConst, (Assembler::RegisterID) targetTemp->index);<KAIGYO>        } else if (targetTemp->type == V4IR::UInt32Type) {<KAIGYO>            Q_ASSERT(sourceConst->type == V4IR::UInt32Type);<KAIGYO>            _as->toUInt32Register(sourceConst, (Assembler::RegisterID) targetTemp->index);<KAIGYO>        } else if (targetTemp->type == V4IR::BoolType) {<KAIGYO>            Q_ASSERT(sourceConst->type == V4IR::BoolType);<KAIGYO>            _as->move(Assembler::TrustedImm32(convertToValue(sourceConst).int_32),<KAIGYO>                      (Assembler::RegisterID) targetTemp->index);<KAIGYO>        } else {<KAIGYO>            Q_UNIMPLEMENTED();<KAIGYO>        }<KAIGYO>    } else {<KAIGYO>        _as->storeValue(convertToValue(sourceConst), targetTemp);<KAIGYO>    }<KAIGYO>void InstructionSelection::setActivationProperty(V4IR::Expr *source, const QString &targetName)<KAIGYO>                         Assembler::ContextRegister, Assembler::PointerToString(targetName), Assembler::PointerToValue(source));<KAIGYO>void InstructionSelection::getProperty(V4IR::Expr *base, const QString &name, V4IR::Temp *target)<KAIGYO>                           Assembler::PointerToValue(base));<KAIGYO>        generateFunctionCall(Assembler::Void, __qmljs_get_property, Assembler::ContextRegister,<KAIGYO>                             Assembler::PointerToValue(target), Assembler::PointerToValue(base),<KAIGYO>                             Assembler::PointerToString(name));<KAIGYO>void InstructionSelection::setProperty(V4IR::Expr *source, V4IR::Expr *targetBase,<KAIGYO>                                       const QString &targetName)<KAIGYO>        generateLookupCall(index, offsetof(QV4::Lookup, setter),<KAIGYO>                           Assembler::PointerToValue(targetBase),<KAIGYO>                           Assembler::PointerToValue(source));<KAIGYO>                             Assembler::PointerToValue(targetBase), Assembler::PointerToString(targetName),<KAIGYO>                             Assembler::PointerToValue(source));<KAIGYO>void InstructionSelection::getElement(V4IR::Expr *base, V4IR::Expr *index, V4IR::Temp *target)<KAIGYO>                         Assembler::PointerToValue(target), Assembler::PointerToValue(base),<KAIGYO>                         Assembler::PointerToValue(index));<KAIGYO>void InstructionSelection::setElement(V4IR::Expr *source, V4IR::Expr *targetBase, V4IR::Expr *targetIndex)<KAIGYO>                         Assembler::PointerToValue(targetBase), Assembler::PointerToValue(targetIndex),<KAIGYO>                         Assembler::PointerToValue(source));<KAIGYO>    if (*sourceTemp == *targetTemp)<KAIGYO>        return;<KAIGYO><KAIGYO>    if (sourceTemp->kind == V4IR::Temp::PhysicalRegister) {<KAIGYO>        if (targetTemp->kind == V4IR::Temp::PhysicalRegister) {<KAIGYO>            if (sourceTemp->type == V4IR::DoubleType)<KAIGYO>                _as->moveDouble((Assembler::FPRegisterID) sourceTemp->index,<KAIGYO>                                (Assembler::FPRegisterID) targetTemp->index);<KAIGYO>            else<KAIGYO>                _as->move((Assembler::RegisterID) sourceTemp->index,<KAIGYO>                          (Assembler::RegisterID) targetTemp->index);<KAIGYO>            return;<KAIGYO>        } else {<KAIGYO>            Assembler::Pointer addr = _as->loadTempAddress(Assembler::ScratchRegister, targetTemp);<KAIGYO>            switch (sourceTemp->type) {<KAIGYO>            case V4IR::DoubleType:<KAIGYO>                _as->storeDouble((Assembler::FPRegisterID) sourceTemp->index, addr);<KAIGYO>                break;<KAIGYO>            case V4IR::SInt32Type:<KAIGYO>                _as->storeInt32((Assembler::RegisterID) sourceTemp->index, addr);<KAIGYO>                break;<KAIGYO>            case V4IR::UInt32Type:<KAIGYO>                _as->storeUInt32((Assembler::RegisterID) sourceTemp->index, addr);<KAIGYO>                break;<KAIGYO>            case V4IR::BoolType:<KAIGYO>                _as->storeBool((Assembler::RegisterID) sourceTemp->index, addr);<KAIGYO>                break;<KAIGYO>            default:<KAIGYO>                _as->store64((Assembler::RegisterID) sourceTemp->index, addr);<KAIGYO>                break;<KAIGYO>            }<KAIGYO>            return;<KAIGYO>        }<KAIGYO>    } else if (targetTemp->kind == V4IR::Temp::PhysicalRegister) {<KAIGYO>        switch (targetTemp->type) {<KAIGYO>        case V4IR::DoubleType:<KAIGYO>            Q_ASSERT(sourceTemp->type == V4IR::DoubleType);<KAIGYO>            _as->toDoubleRegister(sourceTemp, (Assembler::FPRegisterID) targetTemp->index);<KAIGYO>            return;<KAIGYO>        case V4IR::BoolType:<KAIGYO>            Q_ASSERT(sourceTemp->type == V4IR::BoolType);<KAIGYO>            _as->toInt32Register(sourceTemp, (Assembler::RegisterID) targetTemp->index);<KAIGYO>            return;<KAIGYO>        case V4IR::SInt32Type:<KAIGYO>            Q_ASSERT(sourceTemp->type == V4IR::SInt32Type);<KAIGYO>            _as->toInt32Register(sourceTemp, (Assembler::RegisterID) targetTemp->index);<KAIGYO>            return;<KAIGYO>        case V4IR::UInt32Type:<KAIGYO>            Q_ASSERT(sourceTemp->type == V4IR::UInt32Type);<KAIGYO>            _as->toUInt32Register(sourceTemp, (Assembler::RegisterID) targetTemp->index);<KAIGYO>            return;<KAIGYO>        case V4IR::StringType:<KAIGYO>            _as->load64(_as->stackSlotPointer(sourceTemp),<KAIGYO>                        (Assembler::RegisterID) targetTemp->index);<KAIGYO>            return;<KAIGYO>        default:<KAIGYO>            break;<KAIGYO>        }<KAIGYO>    }<KAIGYO><KAIGYO>void InstructionSelection::swapValues(V4IR::Temp *sourceTemp, V4IR::Temp *targetTemp)<KAIGYO>{<KAIGYO>    Q_ASSERT(sourceTemp->type == targetTemp->type);<KAIGYO><KAIGYO>    if (sourceTemp->kind == V4IR::Temp::PhysicalRegister) {<KAIGYO>        if (targetTemp->kind == V4IR::Temp::PhysicalRegister) {<KAIGYO>            if (sourceTemp->type == V4IR::DoubleType) {<KAIGYO>                _as->moveDouble((Assembler::FPRegisterID) targetTemp->index, Assembler::FPGpr0);<KAIGYO>                _as->moveDouble((Assembler::FPRegisterID) sourceTemp->index,<KAIGYO>                                (Assembler::FPRegisterID) targetTemp->index);<KAIGYO>                _as->moveDouble(Assembler::FPGpr0, (Assembler::FPRegisterID) sourceTemp->index);<KAIGYO>            } else {<KAIGYO>                _as->swap((Assembler::RegisterID) sourceTemp->index,<KAIGYO>                          (Assembler::RegisterID) targetTemp->index);<KAIGYO>            }<KAIGYO>            return;<KAIGYO>        }<KAIGYO>    } else if (sourceTemp->kind == V4IR::Temp::StackSlot) {<KAIGYO>        if (targetTemp->kind == V4IR::Temp::StackSlot) {<KAIGYO>            Assembler::FPRegisterID tReg = _as->toDoubleRegister(targetTemp);<KAIGYO>#if CPU(X86_64)<KAIGYO>            _as->load64(_as->stackSlotPointer(sourceTemp), Assembler::ScratchRegister);<KAIGYO>            _as->store64(Assembler::ScratchRegister, _as->stackSlotPointer(targetTemp));<KAIGYO>#else<KAIGYO>            Assembler::Pointer sAddr = _as->stackSlotPointer(sourceTemp);<KAIGYO>            Assembler::Pointer tAddr = _as->stackSlotPointer(targetTemp);<KAIGYO>            _as->load32(sAddr, Assembler::ScratchRegister);<KAIGYO>            _as->store32(Assembler::ScratchRegister, tAddr);<KAIGYO>            sAddr.offset += 4;<KAIGYO>            tAddr.offset += 4;<KAIGYO>            _as->load32(sAddr, Assembler::ScratchRegister);<KAIGYO>            _as->store32(Assembler::ScratchRegister, tAddr);<KAIGYO>#endif<KAIGYO>            _as->storeDouble(tReg, _as->stackSlotPointer(sourceTemp));<KAIGYO>            return;<KAIGYO>        }<KAIGYO>    }<KAIGYO><KAIGYO>    // FIXME: TODO!<KAIGYO>    Q_UNIMPLEMENTED();<KAIGYO>}<KAIGYO><KAIGYO>    if (op) {<KAIGYO>        _as->generateFunctionCallImp(Assembler::Void, opName, op,<KAIGYO>                                     Assembler::PointerToValue(targetTemp),<KAIGYO>                                     Assembler::PointerToValue(sourceTemp));<KAIGYO>        storeTarget(0, targetTemp);<KAIGYO>    }<KAIGYO>    const Assembler::BinaryOperationInfo& info = Assembler::binaryOperation(oper);<KAIGYO>    if (info.fallbackImplementation) {<KAIGYO>        _as->generateFunctionCallImp(Assembler::Void, info.name, info.fallbackImplementation,<KAIGYO>                                     Assembler::PointerToValue(target),<KAIGYO>                                     Assembler::PointerToValue(leftSource),<KAIGYO>                                     Assembler::PointerToValue(rightSource));<KAIGYO>        storeTarget(0, target);<KAIGYO>    } else if (info.contextImplementation) {<KAIGYO>        _as->generateFunctionCallImp(Assembler::Void, info.name, info.contextImplementation,<KAIGYO>                                     Assembler::ContextRegister,<KAIGYO>                                     Assembler::PointerToValue(target),<KAIGYO>                                     Assembler::PointerToValue(leftSource),<KAIGYO>                                     Assembler::PointerToValue(rightSource));<KAIGYO>        storeTarget(1, target);<KAIGYO>    } else {<KAIGYO>        assert(!"""");<KAIGYO>    }<KAIGYO>void InstructionSelection::callProperty(V4IR::Expr *base, const QString &name, V4IR::ExprList *args,<KAIGYO>                                        V4IR::Temp *result)<KAIGYO>                             Assembler::PointerToValue(base), Assembler::TrustedImm32(index),<KAIGYO>        generateFunctionCall(Assembler::Void, __qmljs_call_property, Assembler::ContextRegister,<KAIGYO>                             Assembler::PointerToValue(result), Assembler::PointerToValue(base), Assembler::PointerToString(name),<KAIGYO>                             baseAddressForCallArguments(), Assembler::TrustedImm32(argc));<KAIGYO>void InstructionSelection::callSubscript(V4IR::Expr *base, V4IR::Expr *index, V4IR::ExprList *args,<KAIGYO>                                         V4IR::Temp *result)<KAIGYO>    generateFunctionCall(Assembler::Void, __qmljs_call_element, Assembler::ContextRegister,<KAIGYO>                         Assembler::PointerToValue(result), Assembler::PointerToValue(base),<KAIGYO>                         Assembler::PointerToValue(index), baseAddressForCallArguments(),<KAIGYO>    if (target->type & V4IR::NumberType)<KAIGYO>    else if (target->type == V4IR::BoolType) {<KAIGYO>        generateFunctionCall(Assembler::ReturnValueRegister, __qmljs_to_boolean,<KAIGYO>                             Assembler::PointerToValue(source));<KAIGYO>        _as->storeBool(Assembler::ReturnValueRegister, target);<KAIGYO>    } else<KAIGYO>        Assembler::RegisterID reg;<KAIGYO>        if (t->kind == V4IR::Temp::PhysicalRegister) {<KAIGYO>            Q_ASSERT(t->type == V4IR::BoolType);<KAIGYO>            reg = (Assembler::RegisterID) t->index;<KAIGYO>        } else if (t->kind == V4IR::Temp::StackSlot && t->type == V4IR::BoolType) {<KAIGYO>            reg = Assembler::ReturnValueRegister;<KAIGYO>            _as->toInt32Register(t, reg);<KAIGYO>        } else {<KAIGYO>            Address temp = _as->loadTempAddress(Assembler::ScratchRegister, t);<KAIGYO>            Address tag = temp;<KAIGYO>            tag.offset += offsetof(QV4::Value, tag);<KAIGYO>            Assembler::Jump booleanConversion = _as->branch32(Assembler::NotEqual, tag, Assembler::TrustedImm32(QV4::Value::Boolean_Type));<KAIGYO>            Address data = temp;<KAIGYO>            data.offset += offsetof(QV4::Value, int_32);<KAIGYO>            _as->load32(data, Assembler::ReturnValueRegister);<KAIGYO>            Assembler::Jump testBoolean = _as->jump();<KAIGYO>            booleanConversion.link(_as);<KAIGYO>            reg = Assembler::ReturnValueRegister;<KAIGYO>            generateFunctionCall(reg, __qmljs_to_boolean, Assembler::Reference(t));<KAIGYO>            testBoolean.link(_as);<KAIGYO>        }<KAIGYO>        Assembler::Jump target = _as->branch32(Assembler::NotEqual, reg, Assembler::TrustedImm32(0));<KAIGYO>        _as->addPatch(s->iftrue, target);<KAIGYO>        _as->jumpToBlock(_block, s->iffalse);<KAIGYO>        return;<KAIGYO>    } else if (V4IR::Const *c = s->cond->asConst()) {<KAIGYO>        // TODO: SSA optimization for constant condition evaluation should remove this.<KAIGYO>        // See also visitCJump() in RegAllocInfo.<KAIGYO>        generateFunctionCall(Assembler::ReturnValueRegister, __qmljs_to_boolean,<KAIGYO>                             Assembler::PointerToValue(c));<KAIGYO>        Assembler::Jump target = _as->branch32(Assembler::NotEqual, Assembler::ReturnValueRegister,<KAIGYO>                                               Assembler::TrustedImm32(0));<KAIGYO>        _as->addPatch(s->iftrue, target);<KAIGYO>        CmpOp op = 0;<KAIGYO>        CmpOpContext opContext = 0;<KAIGYO>        const char *opName = 0;<KAIGYO>        switch (b->op) {<KAIGYO>        default: Q_UNREACHABLE(); assert(!""""); break;<KAIGYO>        case V4IR::OpGt: setOp(op, opName, __qmljs_cmp_gt); break;<KAIGYO>        case V4IR::OpLt: setOp(op, opName, __qmljs_cmp_lt); break;<KAIGYO>        case V4IR::OpGe: setOp(op, opName, __qmljs_cmp_ge); break;<KAIGYO>        case V4IR::OpLe: setOp(op, opName, __qmljs_cmp_le); break;<KAIGYO>        case V4IR::OpEqual: setOp(op, opName, __qmljs_cmp_eq); break;<KAIGYO>        case V4IR::OpNotEqual: setOp(op, opName, __qmljs_cmp_ne); break;<KAIGYO>        case V4IR::OpStrictEqual: setOp(op, opName, __qmljs_cmp_se); break;<KAIGYO>        case V4IR::OpStrictNotEqual: setOp(op, opName, __qmljs_cmp_sne); break;<KAIGYO>        case V4IR::OpInstanceof: setOpContext(op, opName, __qmljs_cmp_instanceof); break;<KAIGYO>        case V4IR::OpIn: setOpContext(op, opName, __qmljs_cmp_in); break;<KAIGYO>        } // switch<KAIGYO>        // TODO: in SSA optimization, do constant expression evaluation.<KAIGYO>        // The case here is, for example:<KAIGYO>        //   if (true === true) .....<KAIGYO>        // Of course, after folding the CJUMP to a JUMP, dead-code (dead-basic-block)<KAIGYO>        // elimination (which isn\'t there either) would remove the whole else block.<KAIGYO>        if (opContext)<KAIGYO>            _as->generateFunctionCallImp(Assembler::ReturnValueRegister, opName, opContext,<KAIGYO>                                         Assembler::ContextRegister,<KAIGYO>                                         Assembler::PointerToValue(b->left),<KAIGYO>                                         Assembler::PointerToValue(b->right));<KAIGYO>        else<KAIGYO>            _as->generateFunctionCallImp(Assembler::ReturnValueRegister, opName, op,<KAIGYO>                                         Assembler::PointerToValue(b->left),<KAIGYO>                                         Assembler::PointerToValue(b->right));<KAIGYO>        Assembler::Jump target = _as->branch32(Assembler::NotEqual, Assembler::ReturnValueRegister,<KAIGYO>                                               Assembler::TrustedImm32(0));<KAIGYO>        _as->addPatch(s->iftrue, target);<KAIGYO>        _as->jumpToBlock(_block, s->iffalse);<KAIGYO>        return;<KAIGYO>        if (t->kind == V4IR::Temp::PhysicalRegister) {<KAIGYO>            if (t->type == V4IR::DoubleType) {<KAIGYO>                _as->moveDoubleTo64((Assembler::FPRegisterID) t->index,<KAIGYO>                                    Assembler::ReturnValueRegister);<KAIGYO>            } else {<KAIGYO>                _as->zeroExtend32ToPtr((Assembler::RegisterID) t->index,<KAIGYO>                                       Assembler::ReturnValueRegister);<KAIGYO>                QV4::Value upper;<KAIGYO>                switch (t->type) {<KAIGYO>                case V4IR::SInt32Type:<KAIGYO>                case V4IR::UInt32Type:<KAIGYO>                    upper = QV4::Value::fromInt32(0);<KAIGYO>                    break;<KAIGYO>                case V4IR::BoolType:<KAIGYO>                    upper = QV4::Value::fromBoolean(false);<KAIGYO>                    break;<KAIGYO>                default:<KAIGYO>                    upper = QV4::Value::undefinedValue();<KAIGYO>                    Q_UNIMPLEMENTED();<KAIGYO>                }<KAIGYO>                _as->or64(Assembler::TrustedImm64(((int64_t) upper.tag) << 32),<KAIGYO>                          Assembler::ReturnValueRegister);<KAIGYO>            }<KAIGYO>        } else {<KAIGYO>            _as->copyValue(Assembler::ReturnValueRegister, t);<KAIGYO>        }<KAIGYO>    _as->leaveStandardStackFrame(/*withLocals*/': 14, '    _as->leaveStandardStackFrame(/*locals*/false);<KAIGYO>    Q_ASSERT(arg);<KAIGYO>    Q_ASSERT(result);<KAIGYO><KAIGYO>    Q_ASSERT(arg);<KAIGYO>    Q_ASSERT(result);<KAIGYO><KAIGYO>    Q_ASSERT(arg);<KAIGYO><KAIGYO>    Q_ASSERT(object);<KAIGYO>    Q_ASSERT(getter);<KAIGYO>    Q_ASSERT(setter);<KAIGYO>void InstructionSelection::callBuiltinDefineProperty(V4IR::Temp *object, const QString &name,<KAIGYO>                                                     V4IR::Expr *value)<KAIGYO>    Q_ASSERT(object);<KAIGYO>    Q_ASSERT(value->asTemp() || value->asConst());<KAIGYO><KAIGYO>    generateFunctionCall(Assembler::Void, __qmljs_builtin_define_property,<KAIGYO>                         Assembler::ContextRegister, Assembler::Reference(object), Assembler::PointerToString(name),<KAIGYO>                         Assembler::PointerToValue(value));<KAIGYO>    Q_ASSERT(result);<KAIGYO><KAIGYO>                         Assembler::PointerToValue(result), baseAddressForCallArguments(),<KAIGYO>                         Assembler::TrustedImm32(length));<KAIGYO>    Q_ASSERT(result);<KAIGYO><KAIGYO>        _as->copyValue(_as->stackLayout().argumentAddressForCall(argc++), it->expr);<KAIGYO>            _as->copyValue(_as->stackLayout().argumentAddressForCall(argc++), it->expr);<KAIGYO>    Q_ASSERT(value);<KAIGYO><KAIGYO>    _as->load64(Pointer(Assembler::ContextRegister, offsetof(ExecutionContext, thisObject)),<KAIGYO>                Assembler::ReturnValueRegister);<KAIGYO>    if (targetTemp->kind == V4IR::Temp::PhysicalRegister) {<KAIGYO>        if (targetTemp->type == V4IR::DoubleType) {<KAIGYO>            Q_ASSERT(sourceConst->type == V4IR::DoubleType);<KAIGYO>            _as->toDoubleRegister(sourceConst, (Assembler::FPRegisterID) targetTemp->index);<KAIGYO>        } else if (targetTemp->type == V4IR::SInt32Type) {<KAIGYO>            Q_ASSERT(sourceConst->type == V4IR::SInt32Type);<KAIGYO>            _as->toInt32Register(sourceConst, (Assembler::RegisterID) targetTemp->index);<KAIGYO>        } else if (targetTemp->type == V4IR::UInt32Type) {<KAIGYO>            Q_ASSERT(sourceConst->type == V4IR::UInt32Type);<KAIGYO>            _as->toUInt32Register(sourceConst, (Assembler::RegisterID) targetTemp->index);<KAIGYO>        } else if (targetTemp->type == V4IR::BoolType) {<KAIGYO>            Q_ASSERT(sourceConst->type == V4IR::BoolType);<KAIGYO>            _as->move(Assembler::TrustedImm32(convertToValue(sourceConst).int_32),<KAIGYO>                      (Assembler::RegisterID) targetTemp->index);<KAIGYO>        } else {<KAIGYO>            Q_UNIMPLEMENTED();<KAIGYO>        }<KAIGYO>    } else {<KAIGYO>        _as->storeValue(convertToValue(sourceConst), targetTemp);<KAIGYO>    }<KAIGYO>void InstructionSelection::setActivationProperty(V4IR::Expr *source, const QString &targetName)<KAIGYO>                         Assembler::ContextRegister, Assembler::PointerToString(targetName), Assembler::PointerToValue(source));<KAIGYO>void InstructionSelection::getProperty(V4IR::Expr *base, const QString &name, V4IR::Temp *target)<KAIGYO>                           Assembler::PointerToValue(base));<KAIGYO>        generateFunctionCall(Assembler::Void, __qmljs_get_property, Assembler::ContextRegister,<KAIGYO>                             Assembler::PointerToValue(target), Assembler::PointerToValue(base),<KAIGYO>                             Assembler::PointerToString(name));<KAIGYO>void InstructionSelection::setProperty(V4IR::Expr *source, V4IR::Expr *targetBase,<KAIGYO>                                       const QString &targetName)<KAIGYO>        generateLookupCall(index, offsetof(QV4::Lookup, setter),<KAIGYO>                           Assembler::PointerToValue(targetBase),<KAIGYO>                           Assembler::PointerToValue(source));<KAIGYO>                             Assembler::PointerToValue(targetBase), Assembler::PointerToString(targetName),<KAIGYO>                             Assembler::PointerToValue(source));<KAIGYO>void InstructionSelection::getElement(V4IR::Expr *base, V4IR::Expr *index, V4IR::Temp *target)<KAIGYO>                         Assembler::PointerToValue(target), Assembler::PointerToValue(base),<KAIGYO>                         Assembler::PointerToValue(index));<KAIGYO>void InstructionSelection::setElement(V4IR::Expr *source, V4IR::Expr *targetBase, V4IR::Expr *targetIndex)<KAIGYO>                         Assembler::PointerToValue(targetBase), Assembler::PointerToValue(targetIndex),<KAIGYO>                         Assembler::PointerToValue(source));<KAIGYO>    if (*sourceTemp == *targetTemp)<KAIGYO>        return;<KAIGYO><KAIGYO>    if (sourceTemp->kind == V4IR::Temp::PhysicalRegister) {<KAIGYO>        if (targetTemp->kind == V4IR::Temp::PhysicalRegister) {<KAIGYO>            if (sourceTemp->type == V4IR::DoubleType)<KAIGYO>                _as->moveDouble((Assembler::FPRegisterID) sourceTemp->index,<KAIGYO>                                (Assembler::FPRegisterID) targetTemp->index);<KAIGYO>            else<KAIGYO>                _as->move((Assembler::RegisterID) sourceTemp->index,<KAIGYO>                          (Assembler::RegisterID) targetTemp->index);<KAIGYO>            return;<KAIGYO>        } else {<KAIGYO>            Assembler::Pointer addr = _as->loadTempAddress(Assembler::ScratchRegister, targetTemp);<KAIGYO>            switch (sourceTemp->type) {<KAIGYO>            case V4IR::DoubleType:<KAIGYO>                _as->storeDouble((Assembler::FPRegisterID) sourceTemp->index, addr);<KAIGYO>                break;<KAIGYO>            case V4IR::SInt32Type:<KAIGYO>                _as->storeInt32((Assembler::RegisterID) sourceTemp->index, addr);<KAIGYO>                break;<KAIGYO>            case V4IR::UInt32Type:<KAIGYO>                _as->storeUInt32((Assembler::RegisterID) sourceTemp->index, addr);<KAIGYO>                break;<KAIGYO>            case V4IR::BoolType:<KAIGYO>                _as->storeBool((Assembler::RegisterID) sourceTemp->index, addr);<KAIGYO>                break;<KAIGYO>            default:<KAIGYO>                Q_ASSERT(!"""");<KAIGYO>                break;<KAIGYO>            }<KAIGYO>            return;<KAIGYO>        }<KAIGYO>    } else if (targetTemp->kind == V4IR::Temp::PhysicalRegister) {<KAIGYO>        switch (targetTemp->type) {<KAIGYO>        case V4IR::DoubleType:<KAIGYO>            Q_ASSERT(sourceTemp->type == V4IR::DoubleType);<KAIGYO>            _as->toDoubleRegister(sourceTemp, (Assembler::FPRegisterID) targetTemp->index);<KAIGYO>            return;<KAIGYO>        case V4IR::BoolType:<KAIGYO>            Q_ASSERT(sourceTemp->type == V4IR::BoolType);<KAIGYO>            _as->toInt32Register(sourceTemp, (Assembler::RegisterID) targetTemp->index);<KAIGYO>            return;<KAIGYO>        case V4IR::SInt32Type:<KAIGYO>            Q_ASSERT(sourceTemp->type == V4IR::SInt32Type);<KAIGYO>            _as->toInt32Register(sourceTemp, (Assembler::RegisterID) targetTemp->index);<KAIGYO>            return;<KAIGYO>        case V4IR::UInt32Type:<KAIGYO>            Q_ASSERT(sourceTemp->type == V4IR::UInt32Type);<KAIGYO>            _as->toUInt32Register(sourceTemp, (Assembler::RegisterID) targetTemp->index);<KAIGYO>            return;<KAIGYO>        default:<KAIGYO>            Q_ASSERT(!"""");<KAIGYO>            break;<KAIGYO>        }<KAIGYO>    }<KAIGYO><KAIGYO>void InstructionSelection::swapValues(V4IR::Temp *sourceTemp, V4IR::Temp *targetTemp)<KAIGYO>{<KAIGYO>    Q_ASSERT(sourceTemp->type == targetTemp->type);<KAIGYO><KAIGYO>    if (sourceTemp->kind == V4IR::Temp::PhysicalRegister) {<KAIGYO>        if (targetTemp->kind == V4IR::Temp::PhysicalRegister) {<KAIGYO>            if (sourceTemp->type == V4IR::DoubleType) {<KAIGYO>                _as->moveDouble((Assembler::FPRegisterID) targetTemp->index, Assembler::FPGpr0);<KAIGYO>                _as->moveDouble((Assembler::FPRegisterID) sourceTemp->index,<KAIGYO>                                (Assembler::FPRegisterID) targetTemp->index);<KAIGYO>                _as->moveDouble(Assembler::FPGpr0, (Assembler::FPRegisterID) sourceTemp->index);<KAIGYO>            } else {<KAIGYO>                _as->swap((Assembler::RegisterID) sourceTemp->index,<KAIGYO>                          (Assembler::RegisterID) targetTemp->index);<KAIGYO>            }<KAIGYO>            return;<KAIGYO>        }<KAIGYO>    } else if (sourceTemp->kind == V4IR::Temp::StackSlot) {<KAIGYO>        if (targetTemp->kind == V4IR::Temp::StackSlot) {<KAIGYO>            Assembler::FPRegisterID tReg = _as->toDoubleRegister(targetTemp);<KAIGYO>#if CPU(X86_64)<KAIGYO>            _as->load64(_as->stackSlotPointer(sourceTemp), Assembler::ScratchRegister);<KAIGYO>            _as->store64(Assembler::ScratchRegister, _as->stackSlotPointer(targetTemp));<KAIGYO>#else<KAIGYO>            Assembler::Pointer sAddr = _as->stackSlotPointer(sourceTemp);<KAIGYO>            Assembler::Pointer tAddr = _as->stackSlotPointer(targetTemp);<KAIGYO>            _as->load32(sAddr, Assembler::ScratchRegister);<KAIGYO>            _as->store32(Assembler::ScratchRegister, tAddr);<KAIGYO>            sAddr.offset += 4;<KAIGYO>            tAddr.offset += 4;<KAIGYO>            _as->load32(sAddr, Assembler::ScratchRegister);<KAIGYO>            _as->store32(Assembler::ScratchRegister, tAddr);<KAIGYO>#endif<KAIGYO>            _as->storeDouble(tReg, _as->stackSlotPointer(sourceTemp));<KAIGYO>            return;<KAIGYO>        }<KAIGYO>    }<KAIGYO><KAIGYO>    // FIXME: TODO!<KAIGYO>    Q_UNIMPLEMENTED();<KAIGYO>}<KAIGYO><KAIGYO>    if (op) {<KAIGYO>        _as->generateFunctionCallImp(Assembler::Void, opName, op,<KAIGYO>                                     Assembler::PointerToValue(targetTemp),<KAIGYO>                                     Assembler::PointerToValue(sourceTemp));<KAIGYO>        storeTarget(0, targetTemp);<KAIGYO>    }<KAIGYO>    const Assembler::BinaryOperationInfo& info = Assembler::binaryOperation(oper);<KAIGYO>    if (info.fallbackImplementation) {<KAIGYO>        _as->generateFunctionCallImp(Assembler::Void, info.name, info.fallbackImplementation,<KAIGYO>                                     Assembler::PointerToValue(target),<KAIGYO>                                     Assembler::PointerToValue(leftSource),<KAIGYO>                                     Assembler::PointerToValue(rightSource));<KAIGYO>        storeTarget(0, target);<KAIGYO>    } else if (info.contextImplementation) {<KAIGYO>        _as->generateFunctionCallImp(Assembler::Void, info.name, info.contextImplementation,<KAIGYO>                                     Assembler::ContextRegister,<KAIGYO>                                     Assembler::PointerToValue(target),<KAIGYO>                                     Assembler::PointerToValue(leftSource),<KAIGYO>                                     Assembler::PointerToValue(rightSource));<KAIGYO>        storeTarget(1, target);<KAIGYO>    } else {<KAIGYO>        assert(!"""");<KAIGYO>    }<KAIGYO>void InstructionSelection::callProperty(V4IR::Expr *base, const QString &name, V4IR::ExprList *args,<KAIGYO>                                        V4IR::Temp *result)<KAIGYO>                             Assembler::PointerToValue(base), Assembler::TrustedImm32(index),<KAIGYO>        generateFunctionCall(Assembler::Void, __qmljs_call_property, Assembler::ContextRegister,<KAIGYO>                             Assembler::PointerToValue(result), Assembler::PointerToValue(base), Assembler::PointerToString(name),<KAIGYO>                             baseAddressForCallArguments(), Assembler::TrustedImm32(argc));<KAIGYO>void InstructionSelection::callSubscript(V4IR::Expr *base, V4IR::Expr *index, V4IR::ExprList *args,<KAIGYO>                                         V4IR::Temp *result)<KAIGYO>    generateFunctionCall(Assembler::Void, __qmljs_call_element, Assembler::ContextRegister,<KAIGYO>                         Assembler::PointerToValue(result), Assembler::PointerToValue(base),<KAIGYO>                         Assembler::PointerToValue(index), baseAddressForCallArguments(),<KAIGYO>    if (target->type & V4IR::NumberType)<KAIGYO>    else if (target->type == V4IR::BoolType) {<KAIGYO>        generateFunctionCall(Assembler::ReturnValueRegister, __qmljs_to_boolean,<KAIGYO>                             Assembler::PointerToValue(source));<KAIGYO>        _as->storeBool(Assembler::ReturnValueRegister, target);<KAIGYO>    } else<KAIGYO>        Assembler::RegisterID reg;<KAIGYO>        if (t->kind == V4IR::Temp::PhysicalRegister) {<KAIGYO>            Q_ASSERT(t->type == V4IR::BoolType);<KAIGYO>            reg = (Assembler::RegisterID) t->index;<KAIGYO>        } else if (t->kind == V4IR::Temp::StackSlot && t->type == V4IR::BoolType) {<KAIGYO>            reg = Assembler::ReturnValueRegister;<KAIGYO>            _as->toInt32Register(t, reg);<KAIGYO>        } else {<KAIGYO>            Address temp = _as->loadTempAddress(Assembler::ScratchRegister, t);<KAIGYO>            Address tag = temp;<KAIGYO>            tag.offset += offsetof(QV4::Value, tag);<KAIGYO>            Assembler::Jump booleanConversion = _as->branch32(Assembler::NotEqual, tag, Assembler::TrustedImm32(QV4::Value::Boolean_Type));<KAIGYO>            Address data = temp;<KAIGYO>            data.offset += offsetof(QV4::Value, int_32);<KAIGYO>            _as->load32(data, Assembler::ReturnValueRegister);<KAIGYO>            Assembler::Jump testBoolean = _as->jump();<KAIGYO>            booleanConversion.link(_as);<KAIGYO>            reg = Assembler::ReturnValueRegister;<KAIGYO>            generateFunctionCall(reg, __qmljs_to_boolean, Assembler::Reference(t));<KAIGYO>            testBoolean.link(_as);<KAIGYO>        }<KAIGYO>        Assembler::Jump target = _as->branch32(Assembler::NotEqual, reg, Assembler::TrustedImm32(0));<KAIGYO>        _as->addPatch(s->iftrue, target);<KAIGYO>        _as->jumpToBlock(_block, s->iffalse);<KAIGYO>        return;<KAIGYO>    } else if (V4IR::Const *c = s->cond->asConst()) {<KAIGYO>        // TODO: SSA optimization for constant condition evaluation should remove this.<KAIGYO>        // See also visitCJump() in RegAllocInfo.<KAIGYO>        generateFunctionCall(Assembler::ReturnValueRegister, __qmljs_to_boolean,<KAIGYO>                             Assembler::PointerToValue(c));<KAIGYO>        Assembler::Jump target = _as->branch32(Assembler::NotEqual, Assembler::ReturnValueRegister,<KAIGYO>                                               Assembler::TrustedImm32(0));<KAIGYO>        _as->addPatch(s->iftrue, target);<KAIGYO>        CmpOp op = 0;<KAIGYO>        CmpOpContext opContext = 0;<KAIGYO>        const char *opName = 0;<KAIGYO>        switch (b->op) {<KAIGYO>        default: Q_UNREACHABLE(); assert(!""""); break;<KAIGYO>        case V4IR::OpGt: setOp(op, opName, __qmljs_cmp_gt); break;<KAIGYO>        case V4IR::OpLt: setOp(op, opName, __qmljs_cmp_lt); break;<KAIGYO>        case V4IR::OpGe: setOp(op, opName, __qmljs_cmp_ge); break;<KAIGYO>        case V4IR::OpLe: setOp(op, opName, __qmljs_cmp_le); break;<KAIGYO>        case V4IR::OpEqual: setOp(op, opName, __qmljs_cmp_eq); break;<KAIGYO>        case V4IR::OpNotEqual: setOp(op, opName, __qmljs_cmp_ne); break;<KAIGYO>        case V4IR::OpStrictEqual: setOp(op, opName, __qmljs_cmp_se); break;<KAIGYO>        case V4IR::OpStrictNotEqual: setOp(op, opName, __qmljs_cmp_sne); break;<KAIGYO>        case V4IR::OpInstanceof: setOpContext(op, opName, __qmljs_cmp_instanceof); break;<KAIGYO>        case V4IR::OpIn: setOpContext(op, opName, __qmljs_cmp_in); break;<KAIGYO>        } // switch<KAIGYO>        // TODO: in SSA optimization, do constant expression evaluation.<KAIGYO>        // The case here is, for example:<KAIGYO>        //   if (true === true) .....<KAIGYO>        // Of course, after folding the CJUMP to a JUMP, dead-code (dead-basic-block)<KAIGYO>        // elimination (which isn\'t there either) would remove the whole else block.<KAIGYO>        if (opContext)<KAIGYO>            _as->generateFunctionCallImp(Assembler::ReturnValueRegister, opName, opContext,<KAIGYO>                                         Assembler::ContextRegister,<KAIGYO>                                         Assembler::PointerToValue(b->left),<KAIGYO>                                         Assembler::PointerToValue(b->right));<KAIGYO>        else<KAIGYO>            _as->generateFunctionCallImp(Assembler::ReturnValueRegister, opName, op,<KAIGYO>                                         Assembler::PointerToValue(b->left),<KAIGYO>                                         Assembler::PointerToValue(b->right));<KAIGYO>        Assembler::Jump target = _as->branch32(Assembler::NotEqual, Assembler::ReturnValueRegister,<KAIGYO>                                               Assembler::TrustedImm32(0));<KAIGYO>        _as->addPatch(s->iftrue, target);<KAIGYO>        _as->jumpToBlock(_block, s->iffalse);<KAIGYO>        return;<KAIGYO>        if (t->kind == V4IR::Temp::PhysicalRegister) {<KAIGYO>            if (t->type == V4IR::DoubleType) {<KAIGYO>                _as->moveDoubleTo64((Assembler::FPRegisterID) t->index,<KAIGYO>                                    Assembler::ReturnValueRegister);<KAIGYO>            } else {<KAIGYO>                _as->zeroExtend32ToPtr((Assembler::RegisterID) t->index,<KAIGYO>                                       Assembler::ReturnValueRegister);<KAIGYO>                QV4::Value upper;<KAIGYO>                switch (t->type) {<KAIGYO>                case V4IR::SInt32Type:<KAIGYO>                case V4IR::UInt32Type:<KAIGYO>                    upper = QV4::Value::fromInt32(0);<KAIGYO>                    break;<KAIGYO>                case V4IR::BoolType:<KAIGYO>                    upper = QV4::Value::fromBoolean(false);<KAIGYO>                    break;<KAIGYO>                default:<KAIGYO>                    upper = QV4::Value::undefinedValue();<KAIGYO>                    Q_UNIMPLEMENTED();<KAIGYO>                }<KAIGYO>                _as->or64(Assembler::TrustedImm64(((int64_t) upper.tag) << 32),<KAIGYO>                          Assembler::ReturnValueRegister);<KAIGYO>            }<KAIGYO>        } else {<KAIGYO>            _as->copyValue(Assembler::ReturnValueRegister, t);<KAIGYO>        }<KAIGYO>    _as->leaveStandardStackFrame(/*withLocals*/': 15, '    _as->leaveStandardStackFrame(/*locals*/false);<KAIGYO>    Q_ASSERT(arg);<KAIGYO>    Q_ASSERT(result);<KAIGYO><KAIGYO>    Q_ASSERT(arg);<KAIGYO>    Q_ASSERT(result);<KAIGYO><KAIGYO>    Q_ASSERT(arg);<KAIGYO><KAIGYO>    Q_ASSERT(object);<KAIGYO>    Q_ASSERT(getter);<KAIGYO>    Q_ASSERT(setter);<KAIGYO>void InstructionSelection::callBuiltinDefineProperty(V4IR::Temp *object, const QString &name,<KAIGYO>                                                     V4IR::Expr *value)<KAIGYO>    Q_ASSERT(object);<KAIGYO>    Q_ASSERT(value->asTemp() || value->asConst());<KAIGYO><KAIGYO>    generateFunctionCall(Assembler::Void, __qmljs_builtin_define_property,<KAIGYO>                         Assembler::ContextRegister, Assembler::Reference(object), Assembler::PointerToString(name),<KAIGYO>                         Assembler::PointerToValue(value));<KAIGYO>    Q_ASSERT(result);<KAIGYO><KAIGYO>                         Assembler::PointerToValue(result), baseAddressForCallArguments(),<KAIGYO>                         Assembler::TrustedImm32(length));<KAIGYO>    Q_ASSERT(result);<KAIGYO><KAIGYO>        _as->copyValue(_as->stackLayout().argumentAddressForCall(argc++), it->expr);<KAIGYO>            _as->copyValue(_as->stackLayout().argumentAddressForCall(argc++), it->expr);<KAIGYO>    Q_ASSERT(value);<KAIGYO><KAIGYO>    _as->load64(Pointer(Assembler::ContextRegister, offsetof(ExecutionContext, thisObject)),<KAIGYO>                Assembler::ReturnValueRegister);<KAIGYO>    if (targetTemp->kind == V4IR::Temp::PhysicalRegister) {<KAIGYO>        if (targetTemp->type == V4IR::DoubleType) {<KAIGYO>            Q_ASSERT(sourceConst->type == V4IR::DoubleType);<KAIGYO>            _as->toDoubleRegister(sourceConst, (Assembler::FPRegisterID) targetTemp->index);<KAIGYO>        } else if (targetTemp->type == V4IR::SInt32Type) {<KAIGYO>            Q_ASSERT(sourceConst->type == V4IR::SInt32Type);<KAIGYO>            _as->toInt32Register(sourceConst, (Assembler::RegisterID) targetTemp->index);<KAIGYO>        } else if (targetTemp->type == V4IR::UInt32Type) {<KAIGYO>            Q_ASSERT(sourceConst->type == V4IR::UInt32Type);<KAIGYO>            _as->toUInt32Register(sourceConst, (Assembler::RegisterID) targetTemp->index);<KAIGYO>        } else if (targetTemp->type == V4IR::BoolType) {<KAIGYO>            Q_ASSERT(sourceConst->type == V4IR::BoolType);<KAIGYO>            _as->move(Assembler::TrustedImm32(convertToValue(sourceConst).int_32),<KAIGYO>                      (Assembler::RegisterID) targetTemp->index);<KAIGYO>        } else {<KAIGYO>            Q_UNIMPLEMENTED();<KAIGYO>        }<KAIGYO>    } else {<KAIGYO>        _as->storeValue(convertToValue(sourceConst), targetTemp);<KAIGYO>    }<KAIGYO>void InstructionSelection::setActivationProperty(V4IR::Expr *source, const QString &targetName)<KAIGYO>                         Assembler::ContextRegister, Assembler::PointerToString(targetName), Assembler::PointerToValue(source));<KAIGYO>void InstructionSelection::getProperty(V4IR::Expr *base, const QString &name, V4IR::Temp *target)<KAIGYO>                           Assembler::PointerToValue(base));<KAIGYO>        generateFunctionCall(Assembler::Void, __qmljs_get_property, Assembler::ContextRegister,<KAIGYO>                             Assembler::PointerToValue(target), Assembler::PointerToValue(base),<KAIGYO>                             Assembler::PointerToString(name));<KAIGYO>void InstructionSelection::setProperty(V4IR::Expr *source, V4IR::Expr *targetBase,<KAIGYO>                                       const QString &targetName)<KAIGYO>        generateLookupCall(index, offsetof(QV4::Lookup, setter),<KAIGYO>                           Assembler::PointerToValue(targetBase),<KAIGYO>                           Assembler::PointerToValue(source));<KAIGYO>                             Assembler::PointerToValue(targetBase), Assembler::PointerToString(targetName),<KAIGYO>                             Assembler::PointerToValue(source));<KAIGYO>void InstructionSelection::getElement(V4IR::Expr *base, V4IR::Expr *index, V4IR::Temp *target)<KAIGYO>                         Assembler::PointerToValue(target), Assembler::PointerToValue(base),<KAIGYO>                         Assembler::PointerToValue(index));<KAIGYO>void InstructionSelection::setElement(V4IR::Expr *source, V4IR::Expr *targetBase, V4IR::Expr *targetIndex)<KAIGYO>                         Assembler::PointerToValue(targetBase), Assembler::PointerToValue(targetIndex),<KAIGYO>                         Assembler::PointerToValue(source));<KAIGYO>    if (*sourceTemp == *targetTemp)<KAIGYO>        return;<KAIGYO><KAIGYO>    if (sourceTemp->kind == V4IR::Temp::PhysicalRegister) {<KAIGYO>        if (targetTemp->kind == V4IR::Temp::PhysicalRegister) {<KAIGYO>            if (sourceTemp->type == V4IR::DoubleType)<KAIGYO>                _as->moveDouble((Assembler::FPRegisterID) sourceTemp->index,<KAIGYO>                                (Assembler::FPRegisterID) targetTemp->index);<KAIGYO>            else<KAIGYO>                _as->move((Assembler::RegisterID) sourceTemp->index,<KAIGYO>                          (Assembler::RegisterID) targetTemp->index);<KAIGYO>            return;<KAIGYO>        } else {<KAIGYO>            Assembler::Pointer addr = _as->loadTempAddress(Assembler::ScratchRegister, targetTemp);<KAIGYO>            switch (sourceTemp->type) {<KAIGYO>            case V4IR::DoubleType:<KAIGYO>                _as->storeDouble((Assembler::FPRegisterID) sourceTemp->index, addr);<KAIGYO>                break;<KAIGYO>            case V4IR::SInt32Type:<KAIGYO>                _as->storeInt32((Assembler::RegisterID) sourceTemp->index, addr);<KAIGYO>                break;<KAIGYO>            case V4IR::UInt32Type:<KAIGYO>                _as->storeUInt32((Assembler::RegisterID) sourceTemp->index, addr);<KAIGYO>                break;<KAIGYO>            case V4IR::BoolType:<KAIGYO>                _as->storeBool((Assembler::RegisterID) sourceTemp->index, addr);<KAIGYO>                break;<KAIGYO>            default:<KAIGYO>                Q_ASSERT(!"""");<KAIGYO>                break;<KAIGYO>            }<KAIGYO>            return;<KAIGYO>        }<KAIGYO>    } else if (targetTemp->kind == V4IR::Temp::PhysicalRegister) {<KAIGYO>        switch (targetTemp->type) {<KAIGYO>        case V4IR::DoubleType:<KAIGYO>            Q_ASSERT(sourceTemp->type == V4IR::DoubleType);<KAIGYO>            _as->toDoubleRegister(sourceTemp, (Assembler::FPRegisterID) targetTemp->index);<KAIGYO>            return;<KAIGYO>        case V4IR::BoolType:<KAIGYO>            Q_ASSERT(sourceTemp->type == V4IR::BoolType);<KAIGYO>            _as->toInt32Register(sourceTemp, (Assembler::RegisterID) targetTemp->index);<KAIGYO>            return;<KAIGYO>        case V4IR::SInt32Type:<KAIGYO>            Q_ASSERT(sourceTemp->type == V4IR::SInt32Type);<KAIGYO>            _as->toInt32Register(sourceTemp, (Assembler::RegisterID) targetTemp->index);<KAIGYO>            return;<KAIGYO>        case V4IR::UInt32Type:<KAIGYO>            Q_ASSERT(sourceTemp->type == V4IR::UInt32Type);<KAIGYO>            _as->toUInt32Register(sourceTemp, (Assembler::RegisterID) targetTemp->index);<KAIGYO>            return;<KAIGYO>        default:<KAIGYO>            Q_ASSERT(!"""");<KAIGYO>            break;<KAIGYO>        }<KAIGYO>    }<KAIGYO><KAIGYO>void InstructionSelection::swapValues(V4IR::Temp *sourceTemp, V4IR::Temp *targetTemp)<KAIGYO>{<KAIGYO>    Q_ASSERT(sourceTemp->type == targetTemp->type);<KAIGYO><KAIGYO>    if (sourceTemp->kind == V4IR::Temp::PhysicalRegister) {<KAIGYO>        if (targetTemp->kind == V4IR::Temp::PhysicalRegister) {<KAIGYO>            if (sourceTemp->type == V4IR::DoubleType) {<KAIGYO>                _as->moveDouble((Assembler::FPRegisterID) targetTemp->index, Assembler::FPGpr0);<KAIGYO>                _as->moveDouble((Assembler::FPRegisterID) sourceTemp->index,<KAIGYO>                                (Assembler::FPRegisterID) targetTemp->index);<KAIGYO>                _as->moveDouble(Assembler::FPGpr0, (Assembler::FPRegisterID) sourceTemp->index);<KAIGYO>            } else {<KAIGYO>                _as->swap((Assembler::RegisterID) sourceTemp->index,<KAIGYO>                          (Assembler::RegisterID) targetTemp->index);<KAIGYO>            }<KAIGYO>            return;<KAIGYO>        }<KAIGYO>    } else if (sourceTemp->kind == V4IR::Temp::StackSlot) {<KAIGYO>        if (targetTemp->kind == V4IR::Temp::StackSlot) {<KAIGYO>            Assembler::FPRegisterID tReg = _as->toDoubleRegister(targetTemp);<KAIGYO>#if CPU(X86_64)<KAIGYO>            _as->load64(_as->stackSlotPointer(sourceTemp), Assembler::ScratchRegister);<KAIGYO>            _as->store64(Assembler::ScratchRegister, _as->stackSlotPointer(targetTemp));<KAIGYO>#else<KAIGYO>            Assembler::Pointer sAddr = _as->stackSlotPointer(sourceTemp);<KAIGYO>            Assembler::Pointer tAddr = _as->stackSlotPointer(targetTemp);<KAIGYO>            _as->load32(sAddr, Assembler::ScratchRegister);<KAIGYO>            _as->store32(Assembler::ScratchRegister, tAddr);<KAIGYO>            sAddr.offset += 4;<KAIGYO>            tAddr.offset += 4;<KAIGYO>            _as->load32(sAddr, Assembler::ScratchRegister);<KAIGYO>            _as->store32(Assembler::ScratchRegister, tAddr);<KAIGYO>#endif<KAIGYO>            _as->storeDouble(tReg, _as->stackSlotPointer(sourceTemp));<KAIGYO>            return;<KAIGYO>        }<KAIGYO>    }<KAIGYO><KAIGYO>    // FIXME: TODO!<KAIGYO>    Q_UNIMPLEMENTED();<KAIGYO>}<KAIGYO><KAIGYO>    if (op) {<KAIGYO>        _as->generateFunctionCallImp(Assembler::Void, opName, op,<KAIGYO>                                     Assembler::PointerToValue(targetTemp),<KAIGYO>                                     Assembler::PointerToValue(sourceTemp));<KAIGYO>        storeTarget(0, targetTemp);<KAIGYO>    }<KAIGYO>    const Assembler::BinaryOperationInfo& info = Assembler::binaryOperation(oper);<KAIGYO>    if (info.fallbackImplementation) {<KAIGYO>        _as->generateFunctionCallImp(Assembler::Void, info.name, info.fallbackImplementation,<KAIGYO>                                     Assembler::PointerToValue(target),<KAIGYO>                                     Assembler::PointerToValue(leftSource),<KAIGYO>                                     Assembler::PointerToValue(rightSource));<KAIGYO>        storeTarget(0, target);<KAIGYO>    } else if (info.contextImplementation) {<KAIGYO>        _as->generateFunctionCallImp(Assembler::Void, info.name, info.contextImplementation,<KAIGYO>                                     Assembler::ContextRegister,<KAIGYO>                                     Assembler::PointerToValue(target),<KAIGYO>                                     Assembler::PointerToValue(leftSource),<KAIGYO>                                     Assembler::PointerToValue(rightSource));<KAIGYO>        storeTarget(1, target);<KAIGYO>    } else {<KAIGYO>        assert(!"""");<KAIGYO>    }<KAIGYO>void InstructionSelection::callProperty(V4IR::Expr *base, const QString &name, V4IR::ExprList *args,<KAIGYO>                                        V4IR::Temp *result)<KAIGYO>                             Assembler::PointerToValue(base), Assembler::TrustedImm32(index),<KAIGYO>        generateFunctionCall(Assembler::Void, __qmljs_call_property, Assembler::ContextRegister,<KAIGYO>                             Assembler::PointerToValue(result), Assembler::PointerToValue(base), Assembler::PointerToString(name),<KAIGYO>                             baseAddressForCallArguments(), Assembler::TrustedImm32(argc));<KAIGYO>void InstructionSelection::callSubscript(V4IR::Expr *base, V4IR::Expr *index, V4IR::ExprList *args,<KAIGYO>                                         V4IR::Temp *result)<KAIGYO>    generateFunctionCall(Assembler::Void, __qmljs_call_element, Assembler::ContextRegister,<KAIGYO>                         Assembler::PointerToValue(result), Assembler::PointerToValue(base),<KAIGYO>                         Assembler::PointerToValue(index), baseAddressForCallArguments(),<KAIGYO>    if (target->type & V4IR::NumberType)<KAIGYO>    else if (target->type == V4IR::BoolType) {<KAIGYO>        generateFunctionCall(Assembler::ReturnValueRegister, __qmljs_to_boolean,<KAIGYO>                             Assembler::PointerToValue(source));<KAIGYO>        _as->storeBool(Assembler::ReturnValueRegister, target);<KAIGYO>    } else<KAIGYO>        Assembler::RegisterID reg;<KAIGYO>        if (t->kind == V4IR::Temp::PhysicalRegister) {<KAIGYO>            Q_ASSERT(t->type == V4IR::BoolType);<KAIGYO>            reg = (Assembler::RegisterID) t->index;<KAIGYO>        } else if (t->kind == V4IR::Temp::StackSlot && t->type == V4IR::BoolType) {<KAIGYO>            reg = Assembler::ReturnValueRegister;<KAIGYO>            _as->toInt32Register(t, reg);<KAIGYO>        } else {<KAIGYO>            Address temp = _as->loadTempAddress(Assembler::ScratchRegister, t);<KAIGYO>            Address tag = temp;<KAIGYO>            tag.offset += offsetof(QV4::Value, tag);<KAIGYO>            Assembler::Jump booleanConversion = _as->branch32(Assembler::NotEqual, tag, Assembler::TrustedImm32(QV4::Value::Boolean_Type));<KAIGYO>            Address data = temp;<KAIGYO>            data.offset += offsetof(QV4::Value, int_32);<KAIGYO>            _as->load32(data, Assembler::ReturnValueRegister);<KAIGYO>            Assembler::Jump testBoolean = _as->jump();<KAIGYO>            booleanConversion.link(_as);<KAIGYO>            reg = Assembler::ReturnValueRegister;<KAIGYO>            generateFunctionCall(reg, __qmljs_to_boolean, Assembler::Reference(t));<KAIGYO>            testBoolean.link(_as);<KAIGYO>        }<KAIGYO>        Assembler::Jump target = _as->branch32(Assembler::NotEqual, reg, Assembler::TrustedImm32(0));<KAIGYO>        _as->addPatch(s->iftrue, target);<KAIGYO>        _as->jumpToBlock(_block, s->iffalse);<KAIGYO>        return;<KAIGYO>    } else if (V4IR::Const *c = s->cond->asConst()) {<KAIGYO>        // TODO: SSA optimization for constant condition evaluation should remove this.<KAIGYO>        // See also visitCJump() in RegAllocInfo.<KAIGYO>        generateFunctionCall(Assembler::ReturnValueRegister, __qmljs_to_boolean,<KAIGYO>                             Assembler::PointerToValue(c));<KAIGYO>        Assembler::Jump target = _as->branch32(Assembler::NotEqual, Assembler::ReturnValueRegister,<KAIGYO>                                               Assembler::TrustedImm32(0));<KAIGYO>        _as->addPatch(s->iftrue, target);<KAIGYO>        CmpOp op = 0;<KAIGYO>        CmpOpContext opContext = 0;<KAIGYO>        const char *opName = 0;<KAIGYO>        switch (b->op) {<KAIGYO>        default: Q_UNREACHABLE(); assert(!""""); break;<KAIGYO>        case V4IR::OpGt: setOp(op, opName, __qmljs_cmp_gt); break;<KAIGYO>        case V4IR::OpLt: setOp(op, opName, __qmljs_cmp_lt); break;<KAIGYO>        case V4IR::OpGe: setOp(op, opName, __qmljs_cmp_ge); break;<KAIGYO>        case V4IR::OpLe: setOp(op, opName, __qmljs_cmp_le); break;<KAIGYO>        case V4IR::OpEqual: setOp(op, opName, __qmljs_cmp_eq); break;<KAIGYO>        case V4IR::OpNotEqual: setOp(op, opName, __qmljs_cmp_ne); break;<KAIGYO>        case V4IR::OpStrictEqual: setOp(op, opName, __qmljs_cmp_se); break;<KAIGYO>        case V4IR::OpStrictNotEqual: setOp(op, opName, __qmljs_cmp_sne); break;<KAIGYO>        case V4IR::OpInstanceof: setOpContext(op, opName, __qmljs_cmp_instanceof); break;<KAIGYO>        case V4IR::OpIn: setOpContext(op, opName, __qmljs_cmp_in); break;<KAIGYO>        } // switch<KAIGYO>        // TODO: in SSA optimization, do constant expression evaluation.<KAIGYO>        // The case here is, for example:<KAIGYO>        //   if (true === true) .....<KAIGYO>        // Of course, after folding the CJUMP to a JUMP, dead-code (dead-basic-block)<KAIGYO>        // elimination (which isn\'t there either) would remove the whole else block.<KAIGYO>        if (opContext)<KAIGYO>            _as->generateFunctionCallImp(Assembler::ReturnValueRegister, opName, opContext,<KAIGYO>                                         Assembler::ContextRegister,<KAIGYO>                                         Assembler::PointerToValue(b->left),<KAIGYO>                                         Assembler::PointerToValue(b->right));<KAIGYO>        else<KAIGYO>            _as->generateFunctionCallImp(Assembler::ReturnValueRegister, opName, op,<KAIGYO>                                         Assembler::PointerToValue(b->left),<KAIGYO>                                         Assembler::PointerToValue(b->right));<KAIGYO>        Assembler::Jump target = _as->branch32(Assembler::NotEqual, Assembler::ReturnValueRegister,<KAIGYO>                                               Assembler::TrustedImm32(0));<KAIGYO>        _as->addPatch(s->iftrue, target);<KAIGYO>        _as->jumpToBlock(_block, s->iffalse);<KAIGYO>        return;<KAIGYO>        if (t->kind == V4IR::Temp::PhysicalRegister) {<KAIGYO>            if (t->type == V4IR::DoubleType) {<KAIGYO>                _as->moveDoubleTo64((Assembler::FPRegisterID) t->index,<KAIGYO>                                    Assembler::ReturnValueRegister);<KAIGYO>            } else {<KAIGYO>                _as->zeroExtend32ToPtr((Assembler::RegisterID) t->index,<KAIGYO>                                       Assembler::ReturnValueRegister);<KAIGYO>                QV4::Value upper;<KAIGYO>                switch (t->type) {<KAIGYO>                case V4IR::SInt32Type:<KAIGYO>                case V4IR::UInt32Type:<KAIGYO>                    upper = QV4::Value::fromInt32(0);<KAIGYO>                    break;<KAIGYO>                case V4IR::BoolType:<KAIGYO>                    upper = QV4::Value::fromBoolean(false);<KAIGYO>                    break;<KAIGYO>                default:<KAIGYO>                    upper = QV4::Value::undefinedValue();<KAIGYO>                    Q_UNIMPLEMENTED();<KAIGYO>                }<KAIGYO>                _as->or64(Assembler::TrustedImm64(((int64_t) upper.tag) << 32),<KAIGYO>                          Assembler::ReturnValueRegister);<KAIGYO>            }<KAIGYO>        } else {<KAIGYO>            _as->copyValue(Assembler::ReturnValueRegister, t);<KAIGYO>        }<KAIGYO>    } else if (s->expr->asConst()) {<KAIGYO>        _as->copyValue(Assembler::ReturnValueRegister, s->expr);<KAIGYO>    _as->leaveStandardStackFrame(/*withLocals*/': 17, '    _as->leaveStandardStackFrame(/*locals*/false);<KAIGYO>    Q_ASSERT(arg);<KAIGYO>    Q_ASSERT(result);<KAIGYO><KAIGYO>    Q_ASSERT(arg);<KAIGYO>    Q_ASSERT(result);<KAIGYO><KAIGYO>    Q_ASSERT(arg);<KAIGYO><KAIGYO>    Q_ASSERT(object);<KAIGYO>    Q_ASSERT(getter);<KAIGYO>    Q_ASSERT(setter);<KAIGYO>void InstructionSelection::callBuiltinDefineProperty(V4IR::Temp *object, const QString &name,<KAIGYO>                                                     V4IR::Expr *value)<KAIGYO>    Q_ASSERT(object);<KAIGYO>    Q_ASSERT(value->asTemp() || value->asConst());<KAIGYO><KAIGYO>    generateFunctionCall(Assembler::Void, __qmljs_builtin_define_property,<KAIGYO>                         Assembler::ContextRegister, Assembler::Reference(object), Assembler::PointerToString(name),<KAIGYO>                         Assembler::PointerToValue(value));<KAIGYO>    Q_ASSERT(result);<KAIGYO><KAIGYO>                         Assembler::PointerToValue(result), baseAddressForCallArguments(),<KAIGYO>                         Assembler::TrustedImm32(length));<KAIGYO>    Q_ASSERT(result);<KAIGYO><KAIGYO>        _as->copyValue(_as->stackLayout().argumentAddressForCall(argc++), it->expr);<KAIGYO>            _as->copyValue(_as->stackLayout().argumentAddressForCall(argc++), it->expr);<KAIGYO>    Q_ASSERT(value);<KAIGYO><KAIGYO>    _as->load64(Pointer(Assembler::ContextRegister, offsetof(ExecutionContext, thisObject)),<KAIGYO>                Assembler::ReturnValueRegister);<KAIGYO>    if (targetTemp->kind == V4IR::Temp::PhysicalRegister) {<KAIGYO>        if (targetTemp->type == V4IR::DoubleType) {<KAIGYO>            Q_ASSERT(sourceConst->type == V4IR::DoubleType);<KAIGYO>            _as->toDoubleRegister(sourceConst, (Assembler::FPRegisterID) targetTemp->index);<KAIGYO>        } else if (targetTemp->type == V4IR::SInt32Type) {<KAIGYO>            Q_ASSERT(sourceConst->type == V4IR::SInt32Type);<KAIGYO>            _as->toInt32Register(sourceConst, (Assembler::RegisterID) targetTemp->index);<KAIGYO>        } else if (targetTemp->type == V4IR::UInt32Type) {<KAIGYO>            Q_ASSERT(sourceConst->type == V4IR::UInt32Type);<KAIGYO>            _as->toUInt32Register(sourceConst, (Assembler::RegisterID) targetTemp->index);<KAIGYO>        } else if (targetTemp->type == V4IR::BoolType) {<KAIGYO>            Q_ASSERT(sourceConst->type == V4IR::BoolType);<KAIGYO>            _as->move(Assembler::TrustedImm32(convertToValue(sourceConst).int_32),<KAIGYO>                      (Assembler::RegisterID) targetTemp->index);<KAIGYO>        } else {<KAIGYO>            Q_UNIMPLEMENTED();<KAIGYO>        }<KAIGYO>    } else {<KAIGYO>        _as->storeValue(convertToValue(sourceConst), targetTemp);<KAIGYO>    }<KAIGYO>void InstructionSelection::setActivationProperty(V4IR::Expr *source, const QString &targetName)<KAIGYO>                         Assembler::ContextRegister, Assembler::PointerToString(targetName), Assembler::PointerToValue(source));<KAIGYO>void InstructionSelection::getProperty(V4IR::Expr *base, const QString &name, V4IR::Temp *target)<KAIGYO>                           Assembler::PointerToValue(base));<KAIGYO>        generateFunctionCall(Assembler::Void, __qmljs_get_property, Assembler::ContextRegister,<KAIGYO>                             Assembler::PointerToValue(target), Assembler::PointerToValue(base),<KAIGYO>                             Assembler::PointerToString(name));<KAIGYO>void InstructionSelection::setProperty(V4IR::Expr *source, V4IR::Expr *targetBase,<KAIGYO>                                       const QString &targetName)<KAIGYO>        generateLookupCall(index, offsetof(QV4::Lookup, setter),<KAIGYO>                           Assembler::PointerToValue(targetBase),<KAIGYO>                           Assembler::PointerToValue(source));<KAIGYO>                             Assembler::PointerToValue(targetBase), Assembler::PointerToString(targetName),<KAIGYO>                             Assembler::PointerToValue(source));<KAIGYO>void InstructionSelection::getElement(V4IR::Expr *base, V4IR::Expr *index, V4IR::Temp *target)<KAIGYO>                         Assembler::PointerToValue(target), Assembler::PointerToValue(base),<KAIGYO>                         Assembler::PointerToValue(index));<KAIGYO>void InstructionSelection::setElement(V4IR::Expr *source, V4IR::Expr *targetBase, V4IR::Expr *targetIndex)<KAIGYO>                         Assembler::PointerToValue(targetBase), Assembler::PointerToValue(targetIndex),<KAIGYO>                         Assembler::PointerToValue(source));<KAIGYO>    if (*sourceTemp == *targetTemp)<KAIGYO>        return;<KAIGYO><KAIGYO>    if (sourceTemp->kind == V4IR::Temp::PhysicalRegister) {<KAIGYO>        if (targetTemp->kind == V4IR::Temp::PhysicalRegister) {<KAIGYO>            if (sourceTemp->type == V4IR::DoubleType)<KAIGYO>                _as->moveDouble((Assembler::FPRegisterID) sourceTemp->index,<KAIGYO>                                (Assembler::FPRegisterID) targetTemp->index);<KAIGYO>            else<KAIGYO>                _as->move((Assembler::RegisterID) sourceTemp->index,<KAIGYO>                          (Assembler::RegisterID) targetTemp->index);<KAIGYO>            return;<KAIGYO>        } else {<KAIGYO>            Assembler::Pointer addr = _as->loadTempAddress(Assembler::ScratchRegister, targetTemp);<KAIGYO>            switch (sourceTemp->type) {<KAIGYO>            case V4IR::DoubleType:<KAIGYO>                _as->storeDouble((Assembler::FPRegisterID) sourceTemp->index, addr);<KAIGYO>                break;<KAIGYO>            case V4IR::SInt32Type:<KAIGYO>                _as->storeInt32((Assembler::RegisterID) sourceTemp->index, addr);<KAIGYO>                break;<KAIGYO>            case V4IR::UInt32Type:<KAIGYO>                _as->storeUInt32((Assembler::RegisterID) sourceTemp->index, addr);<KAIGYO>                break;<KAIGYO>            case V4IR::BoolType:<KAIGYO>                _as->storeBool((Assembler::RegisterID) sourceTemp->index, addr);<KAIGYO>                break;<KAIGYO>            default:<KAIGYO>                Q_ASSERT(!"""");<KAIGYO>                break;<KAIGYO>            }<KAIGYO>            return;<KAIGYO>        }<KAIGYO>    } else if (targetTemp->kind == V4IR::Temp::PhysicalRegister) {<KAIGYO>        switch (targetTemp->type) {<KAIGYO>        case V4IR::DoubleType:<KAIGYO>            Q_ASSERT(sourceTemp->type == V4IR::DoubleType);<KAIGYO>            _as->toDoubleRegister(sourceTemp, (Assembler::FPRegisterID) targetTemp->index);<KAIGYO>            return;<KAIGYO>        case V4IR::BoolType:<KAIGYO>            Q_ASSERT(sourceTemp->type == V4IR::BoolType);<KAIGYO>            _as->toInt32Register(sourceTemp, (Assembler::RegisterID) targetTemp->index);<KAIGYO>            return;<KAIGYO>        case V4IR::SInt32Type:<KAIGYO>            Q_ASSERT(sourceTemp->type == V4IR::SInt32Type);<KAIGYO>            _as->toInt32Register(sourceTemp, (Assembler::RegisterID) targetTemp->index);<KAIGYO>            return;<KAIGYO>        case V4IR::UInt32Type:<KAIGYO>            Q_ASSERT(sourceTemp->type == V4IR::UInt32Type);<KAIGYO>            _as->toUInt32Register(sourceTemp, (Assembler::RegisterID) targetTemp->index);<KAIGYO>            return;<KAIGYO>        default:<KAIGYO>            Q_ASSERT(!"""");<KAIGYO>            break;<KAIGYO>        }<KAIGYO>    }<KAIGYO><KAIGYO>void InstructionSelection::swapValues(V4IR::Temp *sourceTemp, V4IR::Temp *targetTemp)<KAIGYO>{<KAIGYO>    Q_ASSERT(sourceTemp->type == targetTemp->type);<KAIGYO><KAIGYO>    if (sourceTemp->kind == V4IR::Temp::PhysicalRegister) {<KAIGYO>        if (targetTemp->kind == V4IR::Temp::PhysicalRegister) {<KAIGYO>            if (sourceTemp->type == V4IR::DoubleType) {<KAIGYO>                _as->moveDouble((Assembler::FPRegisterID) targetTemp->index, Assembler::FPGpr0);<KAIGYO>                _as->moveDouble((Assembler::FPRegisterID) sourceTemp->index,<KAIGYO>                                (Assembler::FPRegisterID) targetTemp->index);<KAIGYO>                _as->moveDouble(Assembler::FPGpr0, (Assembler::FPRegisterID) sourceTemp->index);<KAIGYO>            } else {<KAIGYO>                _as->swap((Assembler::RegisterID) sourceTemp->index,<KAIGYO>                          (Assembler::RegisterID) targetTemp->index);<KAIGYO>            }<KAIGYO>            return;<KAIGYO>        }<KAIGYO>    } else if (sourceTemp->kind == V4IR::Temp::StackSlot) {<KAIGYO>        if (targetTemp->kind == V4IR::Temp::StackSlot) {<KAIGYO>            Assembler::FPRegisterID tReg = _as->toDoubleRegister(targetTemp);<KAIGYO>#if CPU(X86_64)<KAIGYO>            _as->load64(_as->stackSlotPointer(sourceTemp), Assembler::ScratchRegister);<KAIGYO>            _as->store64(Assembler::ScratchRegister, _as->stackSlotPointer(targetTemp));<KAIGYO>#else<KAIGYO>            Assembler::Pointer sAddr = _as->stackSlotPointer(sourceTemp);<KAIGYO>            Assembler::Pointer tAddr = _as->stackSlotPointer(targetTemp);<KAIGYO>            _as->load32(sAddr, Assembler::ScratchRegister);<KAIGYO>            _as->store32(Assembler::ScratchRegister, tAddr);<KAIGYO>            sAddr.offset += 4;<KAIGYO>            tAddr.offset += 4;<KAIGYO>            _as->load32(sAddr, Assembler::ScratchRegister);<KAIGYO>            _as->store32(Assembler::ScratchRegister, tAddr);<KAIGYO>#endif<KAIGYO>            _as->storeDouble(tReg, _as->stackSlotPointer(sourceTemp));<KAIGYO>            return;<KAIGYO>        }<KAIGYO>    }<KAIGYO><KAIGYO>    // FIXME: TODO!<KAIGYO>    Q_UNIMPLEMENTED();<KAIGYO>}<KAIGYO><KAIGYO>    if (op) {<KAIGYO>        _as->generateFunctionCallImp(Assembler::Void, opName, op,<KAIGYO>                                     Assembler::PointerToValue(targetTemp),<KAIGYO>                                     Assembler::PointerToValue(sourceTemp));<KAIGYO>        storeTarget(0, targetTemp);<KAIGYO>    }<KAIGYO>    const Assembler::BinaryOperationInfo& info = Assembler::binaryOperation(oper);<KAIGYO>    if (info.fallbackImplementation) {<KAIGYO>        _as->generateFunctionCallImp(Assembler::Void, info.name, info.fallbackImplementation,<KAIGYO>                                     Assembler::PointerToValue(target),<KAIGYO>                                     Assembler::PointerToValue(leftSource),<KAIGYO>                                     Assembler::PointerToValue(rightSource));<KAIGYO>        storeTarget(0, target);<KAIGYO>    } else if (info.contextImplementation) {<KAIGYO>        _as->generateFunctionCallImp(Assembler::Void, info.name, info.contextImplementation,<KAIGYO>                                     Assembler::ContextRegister,<KAIGYO>                                     Assembler::PointerToValue(target),<KAIGYO>                                     Assembler::PointerToValue(leftSource),<KAIGYO>                                     Assembler::PointerToValue(rightSource));<KAIGYO>        storeTarget(1, target);<KAIGYO>    } else {<KAIGYO>        assert(!"""");<KAIGYO>    }<KAIGYO>void InstructionSelection::callProperty(V4IR::Expr *base, const QString &name, V4IR::ExprList *args,<KAIGYO>                                        V4IR::Temp *result)<KAIGYO>                             Assembler::PointerToValue(base), Assembler::TrustedImm32(index),<KAIGYO>        generateFunctionCall(Assembler::Void, __qmljs_call_property, Assembler::ContextRegister,<KAIGYO>                             Assembler::PointerToValue(result), Assembler::PointerToValue(base), Assembler::PointerToString(name),<KAIGYO>                             baseAddressForCallArguments(), Assembler::TrustedImm32(argc));<KAIGYO>void InstructionSelection::callSubscript(V4IR::Expr *base, V4IR::Expr *index, V4IR::ExprList *args,<KAIGYO>                                         V4IR::Temp *result)<KAIGYO>    generateFunctionCall(Assembler::Void, __qmljs_call_element, Assembler::ContextRegister,<KAIGYO>                         Assembler::PointerToValue(result), Assembler::PointerToValue(base),<KAIGYO>                         Assembler::PointerToValue(index), baseAddressForCallArguments(),<KAIGYO>    if (target->type & V4IR::NumberType)<KAIGYO>    else if (target->type == V4IR::BoolType) {<KAIGYO>        generateFunctionCall(Assembler::ReturnValueRegister, __qmljs_to_boolean,<KAIGYO>                             Assembler::PointerToValue(source));<KAIGYO>        _as->storeBool(Assembler::ReturnValueRegister, target);<KAIGYO>    } else<KAIGYO>        Assembler::RegisterID reg;<KAIGYO>        if (t->kind == V4IR::Temp::PhysicalRegister) {<KAIGYO>            Q_ASSERT(t->type == V4IR::BoolType);<KAIGYO>            reg = (Assembler::RegisterID) t->index;<KAIGYO>        } else if (t->kind == V4IR::Temp::StackSlot && t->type == V4IR::BoolType) {<KAIGYO>            reg = Assembler::ReturnValueRegister;<KAIGYO>            _as->toInt32Register(t, reg);<KAIGYO>        } else {<KAIGYO>            Address temp = _as->loadTempAddress(Assembler::ScratchRegister, t);<KAIGYO>            Address tag = temp;<KAIGYO>            tag.offset += offsetof(QV4::Value, tag);<KAIGYO>            Assembler::Jump booleanConversion = _as->branch32(Assembler::NotEqual, tag, Assembler::TrustedImm32(QV4::Value::Boolean_Type));<KAIGYO>            Address data = temp;<KAIGYO>            data.offset += offsetof(QV4::Value, int_32);<KAIGYO>            _as->load32(data, Assembler::ReturnValueRegister);<KAIGYO>            Assembler::Jump testBoolean = _as->jump();<KAIGYO>            booleanConversion.link(_as);<KAIGYO>            reg = Assembler::ReturnValueRegister;<KAIGYO>            generateFunctionCall(reg, __qmljs_to_boolean, Assembler::Reference(t));<KAIGYO>            testBoolean.link(_as);<KAIGYO>        }<KAIGYO>        Assembler::Jump target = _as->branch32(Assembler::NotEqual, reg, Assembler::TrustedImm32(0));<KAIGYO>        _as->addPatch(s->iftrue, target);<KAIGYO>        _as->jumpToBlock(_block, s->iffalse);<KAIGYO>        return;<KAIGYO>    } else if (V4IR::Const *c = s->cond->asConst()) {<KAIGYO>        // TODO: SSA optimization for constant condition evaluation should remove this.<KAIGYO>        // See also visitCJump() in RegAllocInfo.<KAIGYO>        generateFunctionCall(Assembler::ReturnValueRegister, __qmljs_to_boolean,<KAIGYO>                             Assembler::PointerToValue(c));<KAIGYO>        Assembler::Jump target = _as->branch32(Assembler::NotEqual, Assembler::ReturnValueRegister,<KAIGYO>                                               Assembler::TrustedImm32(0));<KAIGYO>        _as->addPatch(s->iftrue, target);<KAIGYO>        CmpOp op = 0;<KAIGYO>        CmpOpContext opContext = 0;<KAIGYO>        const char *opName = 0;<KAIGYO>        switch (b->op) {<KAIGYO>        default: Q_UNREACHABLE(); assert(!""""); break;<KAIGYO>        case V4IR::OpGt: setOp(op, opName, __qmljs_cmp_gt); break;<KAIGYO>        case V4IR::OpLt: setOp(op, opName, __qmljs_cmp_lt); break;<KAIGYO>        case V4IR::OpGe: setOp(op, opName, __qmljs_cmp_ge); break;<KAIGYO>        case V4IR::OpLe: setOp(op, opName, __qmljs_cmp_le); break;<KAIGYO>        case V4IR::OpEqual: setOp(op, opName, __qmljs_cmp_eq); break;<KAIGYO>        case V4IR::OpNotEqual: setOp(op, opName, __qmljs_cmp_ne); break;<KAIGYO>        case V4IR::OpStrictEqual: setOp(op, opName, __qmljs_cmp_se); break;<KAIGYO>        case V4IR::OpStrictNotEqual: setOp(op, opName, __qmljs_cmp_sne); break;<KAIGYO>        case V4IR::OpInstanceof: setOpContext(op, opName, __qmljs_cmp_instanceof); break;<KAIGYO>        case V4IR::OpIn: setOpContext(op, opName, __qmljs_cmp_in); break;<KAIGYO>        } // switch<KAIGYO>        // TODO: in SSA optimization, do constant expression evaluation.<KAIGYO>        // The case here is, for example:<KAIGYO>        //   if (true === true) .....<KAIGYO>        // Of course, after folding the CJUMP to a JUMP, dead-code (dead-basic-block)<KAIGYO>        // elimination (which isn\'t there either) would remove the whole else block.<KAIGYO>        if (opContext)<KAIGYO>            _as->generateFunctionCallImp(Assembler::ReturnValueRegister, opName, opContext,<KAIGYO>                                         Assembler::ContextRegister,<KAIGYO>                                         Assembler::PointerToValue(b->left),<KAIGYO>                                         Assembler::PointerToValue(b->right));<KAIGYO>        else<KAIGYO>            _as->generateFunctionCallImp(Assembler::ReturnValueRegister, opName, op,<KAIGYO>                                         Assembler::PointerToValue(b->left),<KAIGYO>                                         Assembler::PointerToValue(b->right));<KAIGYO>        Assembler::Jump target = _as->branch32(Assembler::NotEqual, Assembler::ReturnValueRegister,<KAIGYO>                                               Assembler::TrustedImm32(0));<KAIGYO>        _as->addPatch(s->iftrue, target);<KAIGYO>        _as->jumpToBlock(_block, s->iffalse);<KAIGYO>        return;<KAIGYO>        if (t->kind == V4IR::Temp::PhysicalRegister) {<KAIGYO>            if (t->type == V4IR::DoubleType) {<KAIGYO>                _as->moveDoubleTo64((Assembler::FPRegisterID) t->index,<KAIGYO>                                    Assembler::ReturnValueRegister);<KAIGYO>            } else {<KAIGYO>                _as->zeroExtend32ToPtr((Assembler::RegisterID) t->index,<KAIGYO>                                       Assembler::ReturnValueRegister);<KAIGYO>                QV4::Value upper;<KAIGYO>                switch (t->type) {<KAIGYO>                case V4IR::SInt32Type:<KAIGYO>                case V4IR::UInt32Type:<KAIGYO>                    upper = QV4::Value::fromInt32(0);<KAIGYO>                    break;<KAIGYO>                case V4IR::BoolType:<KAIGYO>                    upper = QV4::Value::fromBoolean(false);<KAIGYO>                    break;<KAIGYO>                default:<KAIGYO>                    upper = QV4::Value::undefinedValue();<KAIGYO>                    Q_UNIMPLEMENTED();<KAIGYO>                }<KAIGYO>                _as->or64(Assembler::TrustedImm64(((int64_t) upper.tag) << 32),<KAIGYO>                          Assembler::ReturnValueRegister);<KAIGYO>            }<KAIGYO>        } else {<KAIGYO>            _as->copyValue(Assembler::ReturnValueRegister, t);<KAIGYO>        }<KAIGYO>    } else if (s->expr->asConst()) {<KAIGYO>#if defined(RETURN_VALUE_IN_REGISTER)<KAIGYO>#if CPU(X86)<KAIGYO>        _as->loadPtr(addressForArgument(0), Assembler::ReturnValueRegister);<KAIGYO>        Address addr(Assembler::ReturnValueRegister, 0);<KAIGYO>        _as->copyValue(addr, s->expr);<KAIGYO>        _as->load32(addr, JSC::X86Registers::eax);<KAIGYO>        addr.offset += 4;<KAIGYO>        _as->load32(addr, JSC::X86Registers::edx);<KAIGYO>#else<KAIGYO>        _as->copyValue(Assembler::ReturnValueRegister, s->expr);<KAIGYO>#endif<KAIGYO>#else // !RETURN_VALUE_IN_REGISTER<KAIGYO>        _as->loadPtr(addressForArgument(0), Assembler::ReturnValueRegister);<KAIGYO>        _as->copyValue(Address(Assembler::ReturnValueRegister, 0), s->expr);<KAIGYO>#endif<KAIGYO>    _as->leaveStandardStackFrame(/*withLocals*/': 18, '    _as->leaveStandardStackFrame(/*locals*/false);<KAIGYO>    Q_ASSERT(arg);<KAIGYO>    Q_ASSERT(result);<KAIGYO><KAIGYO>    Q_ASSERT(arg);<KAIGYO>    Q_ASSERT(result);<KAIGYO><KAIGYO>    Q_ASSERT(arg);<KAIGYO><KAIGYO>    Q_ASSERT(object);<KAIGYO>    Q_ASSERT(getter);<KAIGYO>    Q_ASSERT(setter);<KAIGYO>void InstructionSelection::callBuiltinDefineProperty(V4IR::Temp *object, const QString &name,<KAIGYO>                                                     V4IR::Expr *value)<KAIGYO>    Q_ASSERT(object);<KAIGYO>    Q_ASSERT(value->asTemp() || value->asConst());<KAIGYO><KAIGYO>    generateFunctionCall(Assembler::Void, __qmljs_builtin_define_property,<KAIGYO>                         Assembler::ContextRegister, Assembler::Reference(object), Assembler::PointerToString(name),<KAIGYO>                         Assembler::PointerToValue(value));<KAIGYO>    Q_ASSERT(result);<KAIGYO><KAIGYO>                         Assembler::PointerToValue(result), baseAddressForCallArguments(),<KAIGYO>                         Assembler::TrustedImm32(length));<KAIGYO>    Q_ASSERT(result);<KAIGYO><KAIGYO>        _as->copyValue(_as->stackLayout().argumentAddressForCall(argc++), it->expr);<KAIGYO>            _as->copyValue(_as->stackLayout().argumentAddressForCall(argc++), it->expr);<KAIGYO>    Q_ASSERT(value);<KAIGYO><KAIGYO>    _as->load64(Pointer(Assembler::ContextRegister, offsetof(ExecutionContext, thisObject)),<KAIGYO>                Assembler::ReturnValueRegister);<KAIGYO>    if (targetTemp->kind == V4IR::Temp::PhysicalRegister) {<KAIGYO>        if (targetTemp->type == V4IR::DoubleType) {<KAIGYO>            Q_ASSERT(sourceConst->type == V4IR::DoubleType);<KAIGYO>            _as->toDoubleRegister(sourceConst, (Assembler::FPRegisterID) targetTemp->index);<KAIGYO>        } else if (targetTemp->type == V4IR::SInt32Type) {<KAIGYO>            Q_ASSERT(sourceConst->type == V4IR::SInt32Type);<KAIGYO>            _as->toInt32Register(sourceConst, (Assembler::RegisterID) targetTemp->index);<KAIGYO>        } else if (targetTemp->type == V4IR::UInt32Type) {<KAIGYO>            Q_ASSERT(sourceConst->type == V4IR::UInt32Type);<KAIGYO>            _as->toUInt32Register(sourceConst, (Assembler::RegisterID) targetTemp->index);<KAIGYO>        } else if (targetTemp->type == V4IR::BoolType) {<KAIGYO>            Q_ASSERT(sourceConst->type == V4IR::BoolType);<KAIGYO>            _as->move(Assembler::TrustedImm32(convertToValue(sourceConst).int_32),<KAIGYO>                      (Assembler::RegisterID) targetTemp->index);<KAIGYO>        } else {<KAIGYO>            Q_UNIMPLEMENTED();<KAIGYO>        }<KAIGYO>    } else {<KAIGYO>        _as->storeValue(convertToValue(sourceConst), targetTemp);<KAIGYO>    }<KAIGYO>void InstructionSelection::setActivationProperty(V4IR::Expr *source, const QString &targetName)<KAIGYO>                         Assembler::ContextRegister, Assembler::PointerToString(targetName), Assembler::PointerToValue(source));<KAIGYO>void InstructionSelection::getProperty(V4IR::Expr *base, const QString &name, V4IR::Temp *target)<KAIGYO>                           Assembler::PointerToValue(base));<KAIGYO>        generateFunctionCall(Assembler::Void, __qmljs_get_property, Assembler::ContextRegister,<KAIGYO>                             Assembler::PointerToValue(target), Assembler::PointerToValue(base),<KAIGYO>                             Assembler::PointerToString(name));<KAIGYO>void InstructionSelection::setProperty(V4IR::Expr *source, V4IR::Expr *targetBase,<KAIGYO>                                       const QString &targetName)<KAIGYO>        generateLookupCall(index, offsetof(QV4::Lookup, setter),<KAIGYO>                           Assembler::PointerToValue(targetBase),<KAIGYO>                           Assembler::PointerToValue(source));<KAIGYO>                             Assembler::PointerToValue(targetBase), Assembler::PointerToString(targetName),<KAIGYO>                             Assembler::PointerToValue(source));<KAIGYO>void InstructionSelection::getElement(V4IR::Expr *base, V4IR::Expr *index, V4IR::Temp *target)<KAIGYO>                         Assembler::PointerToValue(target), Assembler::PointerToValue(base),<KAIGYO>                         Assembler::PointerToValue(index));<KAIGYO>void InstructionSelection::setElement(V4IR::Expr *source, V4IR::Expr *targetBase, V4IR::Expr *targetIndex)<KAIGYO>                         Assembler::PointerToValue(targetBase), Assembler::PointerToValue(targetIndex),<KAIGYO>                         Assembler::PointerToValue(source));<KAIGYO>    if (*sourceTemp == *targetTemp)<KAIGYO>        return;<KAIGYO><KAIGYO>    if (sourceTemp->kind == V4IR::Temp::PhysicalRegister) {<KAIGYO>        if (targetTemp->kind == V4IR::Temp::PhysicalRegister) {<KAIGYO>            if (sourceTemp->type == V4IR::DoubleType)<KAIGYO>                _as->moveDouble((Assembler::FPRegisterID) sourceTemp->index,<KAIGYO>                                (Assembler::FPRegisterID) targetTemp->index);<KAIGYO>            else<KAIGYO>                _as->move((Assembler::RegisterID) sourceTemp->index,<KAIGYO>                          (Assembler::RegisterID) targetTemp->index);<KAIGYO>            return;<KAIGYO>        } else {<KAIGYO>            Assembler::Pointer addr = _as->loadTempAddress(Assembler::ScratchRegister, targetTemp);<KAIGYO>            switch (sourceTemp->type) {<KAIGYO>            case V4IR::DoubleType:<KAIGYO>                _as->storeDouble((Assembler::FPRegisterID) sourceTemp->index, addr);<KAIGYO>                break;<KAIGYO>            case V4IR::SInt32Type:<KAIGYO>                _as->storeInt32((Assembler::RegisterID) sourceTemp->index, addr);<KAIGYO>                break;<KAIGYO>            case V4IR::UInt32Type:<KAIGYO>                _as->storeUInt32((Assembler::RegisterID) sourceTemp->index, addr);<KAIGYO>                break;<KAIGYO>            case V4IR::BoolType:<KAIGYO>                _as->storeBool((Assembler::RegisterID) sourceTemp->index, addr);<KAIGYO>                break;<KAIGYO>            default:<KAIGYO>                Q_ASSERT(!"""");<KAIGYO>                break;<KAIGYO>            }<KAIGYO>            return;<KAIGYO>        }<KAIGYO>    } else if (targetTemp->kind == V4IR::Temp::PhysicalRegister) {<KAIGYO>        switch (targetTemp->type) {<KAIGYO>        case V4IR::DoubleType:<KAIGYO>            Q_ASSERT(sourceTemp->type == V4IR::DoubleType);<KAIGYO>            _as->toDoubleRegister(sourceTemp, (Assembler::FPRegisterID) targetTemp->index);<KAIGYO>            return;<KAIGYO>        case V4IR::BoolType:<KAIGYO>            Q_ASSERT(sourceTemp->type == V4IR::BoolType);<KAIGYO>            _as->toInt32Register(sourceTemp, (Assembler::RegisterID) targetTemp->index);<KAIGYO>            return;<KAIGYO>        case V4IR::SInt32Type:<KAIGYO>            Q_ASSERT(sourceTemp->type == V4IR::SInt32Type);<KAIGYO>            _as->toInt32Register(sourceTemp, (Assembler::RegisterID) targetTemp->index);<KAIGYO>            return;<KAIGYO>        case V4IR::UInt32Type:<KAIGYO>            Q_ASSERT(sourceTemp->type == V4IR::UInt32Type);<KAIGYO>            _as->toUInt32Register(sourceTemp, (Assembler::RegisterID) targetTemp->index);<KAIGYO>            return;<KAIGYO>        default:<KAIGYO>            Q_ASSERT(!"""");<KAIGYO>            break;<KAIGYO>        }<KAIGYO>    }<KAIGYO><KAIGYO>void InstructionSelection::swapValues(V4IR::Temp *sourceTemp, V4IR::Temp *targetTemp)<KAIGYO>{<KAIGYO>    Q_ASSERT(sourceTemp->type == targetTemp->type);<KAIGYO><KAIGYO>    if (sourceTemp->kind == V4IR::Temp::PhysicalRegister) {<KAIGYO>        if (targetTemp->kind == V4IR::Temp::PhysicalRegister) {<KAIGYO>            if (sourceTemp->type == V4IR::DoubleType) {<KAIGYO>                _as->moveDouble((Assembler::FPRegisterID) targetTemp->index, Assembler::FPGpr0);<KAIGYO>                _as->moveDouble((Assembler::FPRegisterID) sourceTemp->index,<KAIGYO>                                (Assembler::FPRegisterID) targetTemp->index);<KAIGYO>                _as->moveDouble(Assembler::FPGpr0, (Assembler::FPRegisterID) sourceTemp->index);<KAIGYO>            } else {<KAIGYO>                _as->swap((Assembler::RegisterID) sourceTemp->index,<KAIGYO>                          (Assembler::RegisterID) targetTemp->index);<KAIGYO>            }<KAIGYO>            return;<KAIGYO>        }<KAIGYO>    } else if (sourceTemp->kind == V4IR::Temp::StackSlot) {<KAIGYO>        if (targetTemp->kind == V4IR::Temp::StackSlot) {<KAIGYO>            Assembler::FPRegisterID tReg = _as->toDoubleRegister(targetTemp);<KAIGYO>#if CPU(X86_64)<KAIGYO>            _as->load64(_as->stackSlotPointer(sourceTemp), Assembler::ScratchRegister);<KAIGYO>            _as->store64(Assembler::ScratchRegister, _as->stackSlotPointer(targetTemp));<KAIGYO>#else<KAIGYO>            Assembler::Pointer sAddr = _as->stackSlotPointer(sourceTemp);<KAIGYO>            Assembler::Pointer tAddr = _as->stackSlotPointer(targetTemp);<KAIGYO>            _as->load32(sAddr, Assembler::ScratchRegister);<KAIGYO>            _as->store32(Assembler::ScratchRegister, tAddr);<KAIGYO>            sAddr.offset += 4;<KAIGYO>            tAddr.offset += 4;<KAIGYO>            _as->load32(sAddr, Assembler::ScratchRegister);<KAIGYO>            _as->store32(Assembler::ScratchRegister, tAddr);<KAIGYO>#endif<KAIGYO>            _as->storeDouble(tReg, _as->stackSlotPointer(sourceTemp));<KAIGYO>            return;<KAIGYO>        }<KAIGYO>    }<KAIGYO><KAIGYO>    // FIXME: TODO!<KAIGYO>    Q_UNIMPLEMENTED();<KAIGYO>}<KAIGYO><KAIGYO>    if (op) {<KAIGYO>        _as->generateFunctionCallImp(Assembler::Void, opName, op,<KAIGYO>                                     Assembler::PointerToValue(targetTemp),<KAIGYO>                                     Assembler::PointerToValue(sourceTemp));<KAIGYO>        storeTarget(0, targetTemp);<KAIGYO>    }<KAIGYO>    const Assembler::BinaryOperationInfo& info = Assembler::binaryOperation(oper);<KAIGYO>    if (info.fallbackImplementation) {<KAIGYO>        _as->generateFunctionCallImp(Assembler::Void, info.name, info.fallbackImplementation,<KAIGYO>                                     Assembler::PointerToValue(target),<KAIGYO>                                     Assembler::PointerToValue(leftSource),<KAIGYO>                                     Assembler::PointerToValue(rightSource));<KAIGYO>        storeTarget(0, target);<KAIGYO>    } else if (info.contextImplementation) {<KAIGYO>        _as->generateFunctionCallImp(Assembler::Void, info.name, info.contextImplementation,<KAIGYO>                                     Assembler::ContextRegister,<KAIGYO>                                     Assembler::PointerToValue(target),<KAIGYO>                                     Assembler::PointerToValue(leftSource),<KAIGYO>                                     Assembler::PointerToValue(rightSource));<KAIGYO>        storeTarget(1, target);<KAIGYO>    } else {<KAIGYO>        assert(!"""");<KAIGYO>    }<KAIGYO>void InstructionSelection::callProperty(V4IR::Expr *base, const QString &name, V4IR::ExprList *args,<KAIGYO>                                        V4IR::Temp *result)<KAIGYO>                             Assembler::PointerToValue(base), Assembler::TrustedImm32(index),<KAIGYO>        generateFunctionCall(Assembler::Void, __qmljs_call_property, Assembler::ContextRegister,<KAIGYO>                             Assembler::PointerToValue(result), Assembler::PointerToValue(base), Assembler::PointerToString(name),<KAIGYO>                             baseAddressForCallArguments(), Assembler::TrustedImm32(argc));<KAIGYO>void InstructionSelection::callSubscript(V4IR::Expr *base, V4IR::Expr *index, V4IR::ExprList *args,<KAIGYO>                                         V4IR::Temp *result)<KAIGYO>    generateFunctionCall(Assembler::Void, __qmljs_call_element, Assembler::ContextRegister,<KAIGYO>                         Assembler::PointerToValue(result), Assembler::PointerToValue(base),<KAIGYO>                         Assembler::PointerToValue(index), baseAddressForCallArguments(),<KAIGYO>    if (target->type & V4IR::NumberType)<KAIGYO>    else if (target->type == V4IR::BoolType) {<KAIGYO>        generateFunctionCall(Assembler::ReturnValueRegister, __qmljs_to_boolean,<KAIGYO>                             Assembler::PointerToValue(source));<KAIGYO>        _as->storeBool(Assembler::ReturnValueRegister, target);<KAIGYO>    } else<KAIGYO>        Assembler::RegisterID reg;<KAIGYO>        if (t->kind == V4IR::Temp::PhysicalRegister) {<KAIGYO>            Q_ASSERT(t->type == V4IR::BoolType);<KAIGYO>            reg = (Assembler::RegisterID) t->index;<KAIGYO>        } else if (t->kind == V4IR::Temp::StackSlot && t->type == V4IR::BoolType) {<KAIGYO>            reg = Assembler::ReturnValueRegister;<KAIGYO>            _as->toInt32Register(t, reg);<KAIGYO>        } else {<KAIGYO>            Address temp = _as->loadTempAddress(Assembler::ScratchRegister, t);<KAIGYO>            Address tag = temp;<KAIGYO>            tag.offset += offsetof(QV4::Value, tag);<KAIGYO>            Assembler::Jump booleanConversion = _as->branch32(Assembler::NotEqual, tag, Assembler::TrustedImm32(QV4::Value::Boolean_Type));<KAIGYO>            Address data = temp;<KAIGYO>            data.offset += offsetof(QV4::Value, int_32);<KAIGYO>            _as->load32(data, Assembler::ReturnValueRegister);<KAIGYO>            Assembler::Jump testBoolean = _as->jump();<KAIGYO>            booleanConversion.link(_as);<KAIGYO>            reg = Assembler::ReturnValueRegister;<KAIGYO>            generateFunctionCall(reg, __qmljs_to_boolean, Assembler::Reference(t));<KAIGYO>            testBoolean.link(_as);<KAIGYO>        }<KAIGYO>        Assembler::Jump target = _as->branch32(Assembler::NotEqual, reg, Assembler::TrustedImm32(0));<KAIGYO>        _as->addPatch(s->iftrue, target);<KAIGYO>        _as->jumpToBlock(_block, s->iffalse);<KAIGYO>        return;<KAIGYO>    } else if (V4IR::Const *c = s->cond->asConst()) {<KAIGYO>        // TODO: SSA optimization for constant condition evaluation should remove this.<KAIGYO>        // See also visitCJump() in RegAllocInfo.<KAIGYO>        generateFunctionCall(Assembler::ReturnValueRegister, __qmljs_to_boolean,<KAIGYO>                             Assembler::PointerToValue(c));<KAIGYO>        Assembler::Jump target = _as->branch32(Assembler::NotEqual, Assembler::ReturnValueRegister,<KAIGYO>                                               Assembler::TrustedImm32(0));<KAIGYO>        _as->addPatch(s->iftrue, target);<KAIGYO>        CmpOp op = 0;<KAIGYO>        CmpOpContext opContext = 0;<KAIGYO>        const char *opName = 0;<KAIGYO>        switch (b->op) {<KAIGYO>        default: Q_UNREACHABLE(); assert(!""""); break;<KAIGYO>        case V4IR::OpGt: setOp(op, opName, __qmljs_cmp_gt); break;<KAIGYO>        case V4IR::OpLt: setOp(op, opName, __qmljs_cmp_lt); break;<KAIGYO>        case V4IR::OpGe: setOp(op, opName, __qmljs_cmp_ge); break;<KAIGYO>        case V4IR::OpLe: setOp(op, opName, __qmljs_cmp_le); break;<KAIGYO>        case V4IR::OpEqual: setOp(op, opName, __qmljs_cmp_eq); break;<KAIGYO>        case V4IR::OpNotEqual: setOp(op, opName, __qmljs_cmp_ne); break;<KAIGYO>        case V4IR::OpStrictEqual: setOp(op, opName, __qmljs_cmp_se); break;<KAIGYO>        case V4IR::OpStrictNotEqual: setOp(op, opName, __qmljs_cmp_sne); break;<KAIGYO>        case V4IR::OpInstanceof: setOpContext(op, opName, __qmljs_cmp_instanceof); break;<KAIGYO>        case V4IR::OpIn: setOpContext(op, opName, __qmljs_cmp_in); break;<KAIGYO>        } // switch<KAIGYO>        // TODO: in SSA optimization, do constant expression evaluation.<KAIGYO>        // The case here is, for example:<KAIGYO>        //   if (true === true) .....<KAIGYO>        // Of course, after folding the CJUMP to a JUMP, dead-code (dead-basic-block)<KAIGYO>        // elimination (which isn\'t there either) would remove the whole else block.<KAIGYO>        if (opContext)<KAIGYO>            _as->generateFunctionCallImp(Assembler::ReturnValueRegister, opName, opContext,<KAIGYO>                                         Assembler::ContextRegister,<KAIGYO>                                         Assembler::PointerToValue(b->left),<KAIGYO>                                         Assembler::PointerToValue(b->right));<KAIGYO>        else<KAIGYO>            _as->generateFunctionCallImp(Assembler::ReturnValueRegister, opName, op,<KAIGYO>                                         Assembler::PointerToValue(b->left),<KAIGYO>                                         Assembler::PointerToValue(b->right));<KAIGYO>        Assembler::Jump target = _as->branch32(Assembler::NotEqual, Assembler::ReturnValueRegister,<KAIGYO>                                               Assembler::TrustedImm32(0));<KAIGYO>        _as->addPatch(s->iftrue, target);<KAIGYO>        _as->jumpToBlock(_block, s->iffalse);<KAIGYO>        return;<KAIGYO>        if (t->kind == V4IR::Temp::PhysicalRegister) {<KAIGYO>            if (t->type == V4IR::DoubleType) {<KAIGYO>                _as->moveDoubleTo64((Assembler::FPRegisterID) t->index,<KAIGYO>                                    Assembler::ReturnValueRegister);<KAIGYO>            } else {<KAIGYO>                _as->zeroExtend32ToPtr((Assembler::RegisterID) t->index,<KAIGYO>                                       Assembler::ReturnValueRegister);<KAIGYO>                QV4::Value upper;<KAIGYO>                switch (t->type) {<KAIGYO>                case V4IR::SInt32Type:<KAIGYO>                case V4IR::UInt32Type:<KAIGYO>                    upper = QV4::Value::fromInt32(0);<KAIGYO>                    break;<KAIGYO>                case V4IR::BoolType:<KAIGYO>                    upper = QV4::Value::fromBoolean(false);<KAIGYO>                    break;<KAIGYO>                default:<KAIGYO>                    upper = QV4::Value::undefinedValue();<KAIGYO>                    Q_UNIMPLEMENTED();<KAIGYO>                }<KAIGYO>                _as->or64(Assembler::TrustedImm64(((int64_t) upper.tag) << 32),<KAIGYO>                          Assembler::ReturnValueRegister);<KAIGYO>            }<KAIGYO>        } else {<KAIGYO>            _as->copyValue(Assembler::ReturnValueRegister, t);<KAIGYO>        }<KAIGYO>    } else if (s->expr->asConst()) {<KAIGYO>#if defined(RETURN_VALUE_IN_REGISTER)<KAIGYO>#if CPU(X86)<KAIGYO>        _as->loadPtr(addressForArgument(0), Assembler::ReturnValueRegister);<KAIGYO>        Address addr(Assembler::ReturnValueRegister, 0);<KAIGYO>        _as->copyValue(addr, s->expr);<KAIGYO>        _as->load32(addr, JSC::X86Registers::eax);<KAIGYO>        addr.offset += 4;<KAIGYO>        _as->load32(addr, JSC::X86Registers::edx);<KAIGYO>#else<KAIGYO>        _as->copyValue(Assembler::ReturnValueRegister, s->expr->asConst());<KAIGYO>#endif<KAIGYO>#else // !RETURN_VALUE_IN_REGISTER<KAIGYO>        _as->loadPtr(addressForArgument(0), Assembler::ReturnValueRegister);<KAIGYO>        _as->copyValue(Address(Assembler::ReturnValueRegister, 0), s->expr);<KAIGYO>#endif<KAIGYO>    _as->leaveStandardStackFrame(/*withLocals*/': 20, '    _as->leaveStandardStackFrame(/*locals*/false);<KAIGYO>    Q_ASSERT(arg);<KAIGYO>    Q_ASSERT(result);<KAIGYO><KAIGYO>    Q_ASSERT(arg);<KAIGYO>    Q_ASSERT(result);<KAIGYO><KAIGYO>    Q_ASSERT(arg);<KAIGYO><KAIGYO>    Q_ASSERT(object);<KAIGYO>    Q_ASSERT(getter);<KAIGYO>    Q_ASSERT(setter);<KAIGYO>void InstructionSelection::callBuiltinDefineProperty(V4IR::Temp *object, const QString &name,<KAIGYO>                                                     V4IR::Expr *value)<KAIGYO>    Q_ASSERT(object);<KAIGYO>    Q_ASSERT(value->asTemp() || value->asConst());<KAIGYO><KAIGYO>    generateFunctionCall(Assembler::Void, __qmljs_builtin_define_property,<KAIGYO>                         Assembler::ContextRegister, Assembler::Reference(object), Assembler::PointerToString(name),<KAIGYO>                         Assembler::PointerToValue(value));<KAIGYO>    Q_ASSERT(result);<KAIGYO><KAIGYO>                         Assembler::PointerToValue(result), baseAddressForCallArguments(),<KAIGYO>                         Assembler::TrustedImm32(length));<KAIGYO>    Q_ASSERT(result);<KAIGYO><KAIGYO>        _as->copyValue(_as->stackLayout().argumentAddressForCall(argc++), it->expr);<KAIGYO>            _as->copyValue(_as->stackLayout().argumentAddressForCall(argc++), it->expr);<KAIGYO>    Q_ASSERT(value);<KAIGYO><KAIGYO>    _as->load64(Pointer(Assembler::ContextRegister, offsetof(ExecutionContext, thisObject)),<KAIGYO>                Assembler::ReturnValueRegister);<KAIGYO>    if (targetTemp->kind == V4IR::Temp::PhysicalRegister) {<KAIGYO>        if (targetTemp->type == V4IR::DoubleType) {<KAIGYO>            Q_ASSERT(sourceConst->type == V4IR::DoubleType);<KAIGYO>            _as->toDoubleRegister(sourceConst, (Assembler::FPRegisterID) targetTemp->index);<KAIGYO>        } else if (targetTemp->type == V4IR::SInt32Type) {<KAIGYO>            Q_ASSERT(sourceConst->type == V4IR::SInt32Type);<KAIGYO>            _as->toInt32Register(sourceConst, (Assembler::RegisterID) targetTemp->index);<KAIGYO>        } else if (targetTemp->type == V4IR::UInt32Type) {<KAIGYO>            Q_ASSERT(sourceConst->type == V4IR::UInt32Type);<KAIGYO>            _as->toUInt32Register(sourceConst, (Assembler::RegisterID) targetTemp->index);<KAIGYO>        } else if (targetTemp->type == V4IR::BoolType) {<KAIGYO>            Q_ASSERT(sourceConst->type == V4IR::BoolType);<KAIGYO>            _as->move(Assembler::TrustedImm32(convertToValue(sourceConst).int_32),<KAIGYO>                      (Assembler::RegisterID) targetTemp->index);<KAIGYO>        } else {<KAIGYO>            Q_UNIMPLEMENTED();<KAIGYO>        }<KAIGYO>    } else {<KAIGYO>        _as->storeValue(convertToValue(sourceConst), targetTemp);<KAIGYO>    }<KAIGYO>void InstructionSelection::setActivationProperty(V4IR::Expr *source, const QString &targetName)<KAIGYO>                         Assembler::ContextRegister, Assembler::PointerToString(targetName), Assembler::PointerToValue(source));<KAIGYO>void InstructionSelection::getProperty(V4IR::Expr *base, const QString &name, V4IR::Temp *target)<KAIGYO>                           Assembler::PointerToValue(base));<KAIGYO>        generateFunctionCall(Assembler::Void, __qmljs_get_property, Assembler::ContextRegister,<KAIGYO>                             Assembler::PointerToValue(target), Assembler::PointerToValue(base),<KAIGYO>                             Assembler::PointerToString(name));<KAIGYO>void InstructionSelection::setProperty(V4IR::Expr *source, V4IR::Expr *targetBase,<KAIGYO>                                       const QString &targetName)<KAIGYO>        generateLookupCall(index, offsetof(QV4::Lookup, setter),<KAIGYO>                           Assembler::PointerToValue(targetBase),<KAIGYO>                           Assembler::PointerToValue(source));<KAIGYO>                             Assembler::PointerToValue(targetBase), Assembler::PointerToString(targetName),<KAIGYO>                             Assembler::PointerToValue(source));<KAIGYO>void InstructionSelection::getElement(V4IR::Expr *base, V4IR::Expr *index, V4IR::Temp *target)<KAIGYO>                         Assembler::PointerToValue(target), Assembler::PointerToValue(base),<KAIGYO>                         Assembler::PointerToValue(index));<KAIGYO>void InstructionSelection::setElement(V4IR::Expr *source, V4IR::Expr *targetBase, V4IR::Expr *targetIndex)<KAIGYO>                         Assembler::PointerToValue(targetBase), Assembler::PointerToValue(targetIndex),<KAIGYO>                         Assembler::PointerToValue(source));<KAIGYO>    if (*sourceTemp == *targetTemp)<KAIGYO>        return;<KAIGYO><KAIGYO>    if (sourceTemp->kind == V4IR::Temp::PhysicalRegister) {<KAIGYO>        if (targetTemp->kind == V4IR::Temp::PhysicalRegister) {<KAIGYO>            if (sourceTemp->type == V4IR::DoubleType)<KAIGYO>                _as->moveDouble((Assembler::FPRegisterID) sourceTemp->index,<KAIGYO>                                (Assembler::FPRegisterID) targetTemp->index);<KAIGYO>            else<KAIGYO>                _as->move((Assembler::RegisterID) sourceTemp->index,<KAIGYO>                          (Assembler::RegisterID) targetTemp->index);<KAIGYO>            return;<KAIGYO>        } else {<KAIGYO>            Assembler::Pointer addr = _as->loadTempAddress(Assembler::ScratchRegister, targetTemp);<KAIGYO>            switch (sourceTemp->type) {<KAIGYO>            case V4IR::DoubleType:<KAIGYO>                _as->storeDouble((Assembler::FPRegisterID) sourceTemp->index, addr);<KAIGYO>                break;<KAIGYO>            case V4IR::SInt32Type:<KAIGYO>                _as->storeInt32((Assembler::RegisterID) sourceTemp->index, addr);<KAIGYO>                break;<KAIGYO>            case V4IR::UInt32Type:<KAIGYO>                _as->storeUInt32((Assembler::RegisterID) sourceTemp->index, addr);<KAIGYO>                break;<KAIGYO>            case V4IR::BoolType:<KAIGYO>                _as->storeBool((Assembler::RegisterID) sourceTemp->index, addr);<KAIGYO>                break;<KAIGYO>            default:<KAIGYO>                Q_ASSERT(!"""");<KAIGYO>                break;<KAIGYO>            }<KAIGYO>            return;<KAIGYO>        }<KAIGYO>    } else if (targetTemp->kind == V4IR::Temp::PhysicalRegister) {<KAIGYO>        switch (targetTemp->type) {<KAIGYO>        case V4IR::DoubleType:<KAIGYO>            Q_ASSERT(sourceTemp->type == V4IR::DoubleType);<KAIGYO>            _as->toDoubleRegister(sourceTemp, (Assembler::FPRegisterID) targetTemp->index);<KAIGYO>            return;<KAIGYO>        case V4IR::BoolType:<KAIGYO>            Q_ASSERT(sourceTemp->type == V4IR::BoolType);<KAIGYO>            _as->toInt32Register(sourceTemp, (Assembler::RegisterID) targetTemp->index);<KAIGYO>            return;<KAIGYO>        case V4IR::SInt32Type:<KAIGYO>            Q_ASSERT(sourceTemp->type == V4IR::SInt32Type);<KAIGYO>            _as->toInt32Register(sourceTemp, (Assembler::RegisterID) targetTemp->index);<KAIGYO>            return;<KAIGYO>        case V4IR::UInt32Type:<KAIGYO>            Q_ASSERT(sourceTemp->type == V4IR::UInt32Type);<KAIGYO>            _as->toUInt32Register(sourceTemp, (Assembler::RegisterID) targetTemp->index);<KAIGYO>            return;<KAIGYO>        default:<KAIGYO>            Q_ASSERT(!"""");<KAIGYO>            break;<KAIGYO>        }<KAIGYO>    }<KAIGYO><KAIGYO>void InstructionSelection::swapValues(V4IR::Temp *sourceTemp, V4IR::Temp *targetTemp)<KAIGYO>{<KAIGYO>    Q_ASSERT(sourceTemp->type == targetTemp->type);<KAIGYO><KAIGYO>    if (sourceTemp->kind == V4IR::Temp::PhysicalRegister) {<KAIGYO>        if (targetTemp->kind == V4IR::Temp::PhysicalRegister) {<KAIGYO>            if (sourceTemp->type == V4IR::DoubleType) {<KAIGYO>                _as->moveDouble((Assembler::FPRegisterID) targetTemp->index, Assembler::FPGpr0);<KAIGYO>                _as->moveDouble((Assembler::FPRegisterID) sourceTemp->index,<KAIGYO>                                (Assembler::FPRegisterID) targetTemp->index);<KAIGYO>                _as->moveDouble(Assembler::FPGpr0, (Assembler::FPRegisterID) sourceTemp->index);<KAIGYO>            } else {<KAIGYO>                _as->swap((Assembler::RegisterID) sourceTemp->index,<KAIGYO>                          (Assembler::RegisterID) targetTemp->index);<KAIGYO>            }<KAIGYO>            return;<KAIGYO>        }<KAIGYO>    } else if (sourceTemp->kind == V4IR::Temp::StackSlot) {<KAIGYO>        if (targetTemp->kind == V4IR::Temp::StackSlot) {<KAIGYO>            Assembler::FPRegisterID tReg = _as->toDoubleRegister(targetTemp);<KAIGYO>#if CPU(X86_64)<KAIGYO>            _as->load64(_as->stackSlotPointer(sourceTemp), Assembler::ScratchRegister);<KAIGYO>            _as->store64(Assembler::ScratchRegister, _as->stackSlotPointer(targetTemp));<KAIGYO>#else<KAIGYO>            Assembler::Pointer sAddr = _as->stackSlotPointer(sourceTemp);<KAIGYO>            Assembler::Pointer tAddr = _as->stackSlotPointer(targetTemp);<KAIGYO>            _as->load32(sAddr, Assembler::ScratchRegister);<KAIGYO>            _as->store32(Assembler::ScratchRegister, tAddr);<KAIGYO>            sAddr.offset += 4;<KAIGYO>            tAddr.offset += 4;<KAIGYO>            _as->load32(sAddr, Assembler::ScratchRegister);<KAIGYO>            _as->store32(Assembler::ScratchRegister, tAddr);<KAIGYO>#endif<KAIGYO>            _as->storeDouble(tReg, _as->stackSlotPointer(sourceTemp));<KAIGYO>            return;<KAIGYO>        }<KAIGYO>    }<KAIGYO><KAIGYO>    // FIXME: TODO!<KAIGYO>    Q_UNIMPLEMENTED();<KAIGYO>}<KAIGYO><KAIGYO>    if (op) {<KAIGYO>        _as->generateFunctionCallImp(Assembler::Void, opName, op,<KAIGYO>                                     Assembler::PointerToValue(targetTemp),<KAIGYO>                                     Assembler::PointerToValue(sourceTemp));<KAIGYO>        storeTarget(0, targetTemp);<KAIGYO>    }<KAIGYO>    const Assembler::BinaryOperationInfo& info = Assembler::binaryOperation(oper);<KAIGYO>    if (info.fallbackImplementation) {<KAIGYO>        _as->generateFunctionCallImp(Assembler::Void, info.name, info.fallbackImplementation,<KAIGYO>                                     Assembler::PointerToValue(target),<KAIGYO>                                     Assembler::PointerToValue(leftSource),<KAIGYO>                                     Assembler::PointerToValue(rightSource));<KAIGYO>        storeTarget(0, target);<KAIGYO>    } else if (info.contextImplementation) {<KAIGYO>        _as->generateFunctionCallImp(Assembler::Void, info.name, info.contextImplementation,<KAIGYO>                                     Assembler::ContextRegister,<KAIGYO>                                     Assembler::PointerToValue(target),<KAIGYO>                                     Assembler::PointerToValue(leftSource),<KAIGYO>                                     Assembler::PointerToValue(rightSource));<KAIGYO>        storeTarget(1, target);<KAIGYO>    } else {<KAIGYO>        assert(!"""");<KAIGYO>    }<KAIGYO>void InstructionSelection::callProperty(V4IR::Expr *base, const QString &name, V4IR::ExprList *args,<KAIGYO>                                        V4IR::Temp *result)<KAIGYO>                             Assembler::PointerToValue(base), Assembler::TrustedImm32(index),<KAIGYO>        generateFunctionCall(Assembler::Void, __qmljs_call_property, Assembler::ContextRegister,<KAIGYO>                             Assembler::PointerToValue(result), Assembler::PointerToValue(base), Assembler::PointerToString(name),<KAIGYO>                             baseAddressForCallArguments(), Assembler::TrustedImm32(argc));<KAIGYO>void InstructionSelection::callSubscript(V4IR::Expr *base, V4IR::Expr *index, V4IR::ExprList *args,<KAIGYO>                                         V4IR::Temp *result)<KAIGYO>    generateFunctionCall(Assembler::Void, __qmljs_call_element, Assembler::ContextRegister,<KAIGYO>                         Assembler::PointerToValue(result), Assembler::PointerToValue(base),<KAIGYO>                         Assembler::PointerToValue(index), baseAddressForCallArguments(),<KAIGYO>    if (target->type & V4IR::NumberType)<KAIGYO>    else if (target->type == V4IR::BoolType) {<KAIGYO>        generateFunctionCall(Assembler::ReturnValueRegister, __qmljs_to_boolean,<KAIGYO>                             Assembler::PointerToValue(source));<KAIGYO>        _as->storeBool(Assembler::ReturnValueRegister, target);<KAIGYO>    } else<KAIGYO>        Assembler::RegisterID reg;<KAIGYO>        if (t->kind == V4IR::Temp::PhysicalRegister) {<KAIGYO>            Q_ASSERT(t->type == V4IR::BoolType);<KAIGYO>            reg = (Assembler::RegisterID) t->index;<KAIGYO>        } else if (t->kind == V4IR::Temp::StackSlot && t->type == V4IR::BoolType) {<KAIGYO>            reg = Assembler::ReturnValueRegister;<KAIGYO>            _as->toInt32Register(t, reg);<KAIGYO>        } else {<KAIGYO>            Address temp = _as->loadTempAddress(Assembler::ScratchRegister, t);<KAIGYO>            Address tag = temp;<KAIGYO>            tag.offset += offsetof(QV4::Value, tag);<KAIGYO>            Assembler::Jump booleanConversion = _as->branch32(Assembler::NotEqual, tag, Assembler::TrustedImm32(QV4::Value::Boolean_Type));<KAIGYO>            Address data = temp;<KAIGYO>            data.offset += offsetof(QV4::Value, int_32);<KAIGYO>            _as->load32(data, Assembler::ReturnValueRegister);<KAIGYO>            Assembler::Jump testBoolean = _as->jump();<KAIGYO>            booleanConversion.link(_as);<KAIGYO>            reg = Assembler::ReturnValueRegister;<KAIGYO>            generateFunctionCall(reg, __qmljs_to_boolean, Assembler::Reference(t));<KAIGYO>            testBoolean.link(_as);<KAIGYO>        }<KAIGYO>        Assembler::Jump target = _as->branch32(Assembler::NotEqual, reg, Assembler::TrustedImm32(0));<KAIGYO>        _as->addPatch(s->iftrue, target);<KAIGYO>        _as->jumpToBlock(_block, s->iffalse);<KAIGYO>        return;<KAIGYO>    } else if (V4IR::Const *c = s->cond->asConst()) {<KAIGYO>        // TODO: SSA optimization for constant condition evaluation should remove this.<KAIGYO>        // See also visitCJump() in RegAllocInfo.<KAIGYO>        generateFunctionCall(Assembler::ReturnValueRegister, __qmljs_to_boolean,<KAIGYO>                             Assembler::PointerToValue(c));<KAIGYO>        Assembler::Jump target = _as->branch32(Assembler::NotEqual, Assembler::ReturnValueRegister,<KAIGYO>                                               Assembler::TrustedImm32(0));<KAIGYO>        _as->addPatch(s->iftrue, target);<KAIGYO>        CmpOp op = 0;<KAIGYO>        CmpOpContext opContext = 0;<KAIGYO>        const char *opName = 0;<KAIGYO>        switch (b->op) {<KAIGYO>        default: Q_UNREACHABLE(); assert(!""""); break;<KAIGYO>        case V4IR::OpGt: setOp(op, opName, __qmljs_cmp_gt); break;<KAIGYO>        case V4IR::OpLt: setOp(op, opName, __qmljs_cmp_lt); break;<KAIGYO>        case V4IR::OpGe: setOp(op, opName, __qmljs_cmp_ge); break;<KAIGYO>        case V4IR::OpLe: setOp(op, opName, __qmljs_cmp_le); break;<KAIGYO>        case V4IR::OpEqual: setOp(op, opName, __qmljs_cmp_eq); break;<KAIGYO>        case V4IR::OpNotEqual: setOp(op, opName, __qmljs_cmp_ne); break;<KAIGYO>        case V4IR::OpStrictEqual: setOp(op, opName, __qmljs_cmp_se); break;<KAIGYO>        case V4IR::OpStrictNotEqual: setOp(op, opName, __qmljs_cmp_sne); break;<KAIGYO>        case V4IR::OpInstanceof: setOpContext(op, opName, __qmljs_cmp_instanceof); break;<KAIGYO>        case V4IR::OpIn: setOpContext(op, opName, __qmljs_cmp_in); break;<KAIGYO>        } // switch<KAIGYO>        // TODO: in SSA optimization, do constant expression evaluation.<KAIGYO>        // The case here is, for example:<KAIGYO>        //   if (true === true) .....<KAIGYO>        // Of course, after folding the CJUMP to a JUMP, dead-code (dead-basic-block)<KAIGYO>        // elimination (which isn\'t there either) would remove the whole else block.<KAIGYO>        if (opContext)<KAIGYO>            _as->generateFunctionCallImp(Assembler::ReturnValueRegister, opName, opContext,<KAIGYO>                                         Assembler::ContextRegister,<KAIGYO>                                         Assembler::PointerToValue(b->left),<KAIGYO>                                         Assembler::PointerToValue(b->right));<KAIGYO>        else<KAIGYO>            _as->generateFunctionCallImp(Assembler::ReturnValueRegister, opName, op,<KAIGYO>                                         Assembler::PointerToValue(b->left),<KAIGYO>                                         Assembler::PointerToValue(b->right));<KAIGYO>        Assembler::Jump target = _as->branch32(Assembler::NotEqual, Assembler::ReturnValueRegister,<KAIGYO>                                               Assembler::TrustedImm32(0));<KAIGYO>        _as->addPatch(s->iftrue, target);<KAIGYO>        _as->jumpToBlock(_block, s->iffalse);<KAIGYO>        return;<KAIGYO>        if (t->kind == V4IR::Temp::PhysicalRegister) {<KAIGYO>            if (t->type == V4IR::DoubleType) {<KAIGYO>                _as->moveDoubleTo64((Assembler::FPRegisterID) t->index,<KAIGYO>                                    Assembler::ReturnValueRegister);<KAIGYO>            } else {<KAIGYO>                _as->zeroExtend32ToPtr((Assembler::RegisterID) t->index,<KAIGYO>                                       Assembler::ReturnValueRegister);<KAIGYO>                QV4::Value upper;<KAIGYO>                switch (t->type) {<KAIGYO>                case V4IR::SInt32Type:<KAIGYO>                case V4IR::UInt32Type:<KAIGYO>                    upper = QV4::Value::fromInt32(0);<KAIGYO>                    break;<KAIGYO>                case V4IR::BoolType:<KAIGYO>                    upper = QV4::Value::fromBoolean(false);<KAIGYO>                    break;<KAIGYO>                default:<KAIGYO>                    upper = QV4::Value::undefinedValue();<KAIGYO>                    Q_UNIMPLEMENTED();<KAIGYO>                }<KAIGYO>                _as->or64(Assembler::TrustedImm64(((int64_t) upper.tag) << 32),<KAIGYO>                          Assembler::ReturnValueRegister);<KAIGYO>            }<KAIGYO>        } else {<KAIGYO>            _as->copyValue(Assembler::ReturnValueRegister, t);<KAIGYO>        }<KAIGYO>    } else if (s->expr->asConst()) {<KAIGYO>#if defined(RETURN_VALUE_IN_REGISTER)<KAIGYO>#if CPU(X86)<KAIGYO>        _as->loadPtr(addressForArgument(0), Assembler::ScratchRegister);<KAIGYO>        Address addr(Assembler::ScratchRegister, 0);<KAIGYO>        _as->copyValue(addr, s->expr);<KAIGYO>        _as->load32(addr, JSC::X86Registers::eax);<KAIGYO>        addr.offset += 4;<KAIGYO>        _as->load32(addr, JSC::X86Registers::edx);<KAIGYO>#else<KAIGYO>        _as->copyValue(Assembler::ReturnValueRegister, s->expr);<KAIGYO>#endif<KAIGYO>#else // !RETURN_VALUE_IN_REGISTER<KAIGYO>        _as->loadPtr(addressForArgument(0), Assembler::ReturnValueRegister);<KAIGYO>        _as->copyValue(Address(Assembler::ReturnValueRegister, 0), s->expr);<KAIGYO>#endif<KAIGYO>    _as->leaveStandardStackFrame(/*withLocals*/': 23, '    _as->leaveStandardStackFrame(/*locals*/false);<KAIGYO>    Q_ASSERT(arg);<KAIGYO>    Q_ASSERT(result);<KAIGYO><KAIGYO>    Q_ASSERT(arg);<KAIGYO>    Q_ASSERT(result);<KAIGYO><KAIGYO>    Q_ASSERT(arg);<KAIGYO><KAIGYO>    Q_ASSERT(object);<KAIGYO>    Q_ASSERT(getter);<KAIGYO>    Q_ASSERT(setter);<KAIGYO>void InstructionSelection::callBuiltinDefineProperty(V4IR::Temp *object, const QString &name,<KAIGYO>                                                     V4IR::Expr *value)<KAIGYO>    Q_ASSERT(object);<KAIGYO>    Q_ASSERT(value->asTemp() || value->asConst());<KAIGYO><KAIGYO>    generateFunctionCall(Assembler::Void, __qmljs_builtin_define_property,<KAIGYO>                         Assembler::ContextRegister, Assembler::Reference(object), Assembler::PointerToString(name),<KAIGYO>                         Assembler::PointerToValue(value));<KAIGYO>    Q_ASSERT(result);<KAIGYO><KAIGYO>                         Assembler::PointerToValue(result), baseAddressForCallArguments(),<KAIGYO>                         Assembler::TrustedImm32(length));<KAIGYO>    Q_ASSERT(result);<KAIGYO><KAIGYO>        _as->copyValue(_as->stackLayout().argumentAddressForCall(argc++), it->expr);<KAIGYO>            _as->copyValue(_as->stackLayout().argumentAddressForCall(argc++), it->expr);<KAIGYO>    Q_ASSERT(value);<KAIGYO><KAIGYO>    _as->load64(Pointer(Assembler::ContextRegister, offsetof(ExecutionContext, thisObject)),<KAIGYO>                Assembler::ReturnValueRegister);<KAIGYO>    if (targetTemp->kind == V4IR::Temp::PhysicalRegister) {<KAIGYO>        if (targetTemp->type == V4IR::DoubleType) {<KAIGYO>            Q_ASSERT(sourceConst->type == V4IR::DoubleType);<KAIGYO>            _as->toDoubleRegister(sourceConst, (Assembler::FPRegisterID) targetTemp->index);<KAIGYO>        } else if (targetTemp->type == V4IR::SInt32Type) {<KAIGYO>            Q_ASSERT(sourceConst->type == V4IR::SInt32Type);<KAIGYO>            _as->toInt32Register(sourceConst, (Assembler::RegisterID) targetTemp->index);<KAIGYO>        } else if (targetTemp->type == V4IR::UInt32Type) {<KAIGYO>            Q_ASSERT(sourceConst->type == V4IR::UInt32Type);<KAIGYO>            _as->toUInt32Register(sourceConst, (Assembler::RegisterID) targetTemp->index);<KAIGYO>        } else if (targetTemp->type == V4IR::BoolType) {<KAIGYO>            Q_ASSERT(sourceConst->type == V4IR::BoolType);<KAIGYO>            _as->move(Assembler::TrustedImm32(convertToValue(sourceConst).int_32),<KAIGYO>                      (Assembler::RegisterID) targetTemp->index);<KAIGYO>        } else {<KAIGYO>            Q_UNIMPLEMENTED();<KAIGYO>        }<KAIGYO>    } else {<KAIGYO>        _as->storeValue(convertToValue(sourceConst), targetTemp);<KAIGYO>    }<KAIGYO>void InstructionSelection::setActivationProperty(V4IR::Expr *source, const QString &targetName)<KAIGYO>                         Assembler::ContextRegister, Assembler::PointerToString(targetName), Assembler::PointerToValue(source));<KAIGYO>void InstructionSelection::getProperty(V4IR::Expr *base, const QString &name, V4IR::Temp *target)<KAIGYO>                           Assembler::PointerToValue(base));<KAIGYO>        generateFunctionCall(Assembler::Void, __qmljs_get_property, Assembler::ContextRegister,<KAIGYO>                             Assembler::PointerToValue(target), Assembler::PointerToValue(base),<KAIGYO>                             Assembler::PointerToString(name));<KAIGYO>void InstructionSelection::setProperty(V4IR::Expr *source, V4IR::Expr *targetBase,<KAIGYO>                                       const QString &targetName)<KAIGYO>        generateLookupCall(index, offsetof(QV4::Lookup, setter),<KAIGYO>                           Assembler::PointerToValue(targetBase),<KAIGYO>                           Assembler::PointerToValue(source));<KAIGYO>                             Assembler::PointerToValue(targetBase), Assembler::PointerToString(targetName),<KAIGYO>                             Assembler::PointerToValue(source));<KAIGYO>void InstructionSelection::getElement(V4IR::Expr *base, V4IR::Expr *index, V4IR::Temp *target)<KAIGYO>                         Assembler::PointerToValue(target), Assembler::PointerToValue(base),<KAIGYO>                         Assembler::PointerToValue(index));<KAIGYO>void InstructionSelection::setElement(V4IR::Expr *source, V4IR::Expr *targetBase, V4IR::Expr *targetIndex)<KAIGYO>                         Assembler::PointerToValue(targetBase), Assembler::PointerToValue(targetIndex),<KAIGYO>                         Assembler::PointerToValue(source));<KAIGYO>    if (*sourceTemp == *targetTemp)<KAIGYO>        return;<KAIGYO><KAIGYO>    if (sourceTemp->kind == V4IR::Temp::PhysicalRegister) {<KAIGYO>        if (targetTemp->kind == V4IR::Temp::PhysicalRegister) {<KAIGYO>            if (sourceTemp->type == V4IR::DoubleType)<KAIGYO>                _as->moveDouble((Assembler::FPRegisterID) sourceTemp->index,<KAIGYO>                                (Assembler::FPRegisterID) targetTemp->index);<KAIGYO>            else<KAIGYO>                _as->move((Assembler::RegisterID) sourceTemp->index,<KAIGYO>                          (Assembler::RegisterID) targetTemp->index);<KAIGYO>            return;<KAIGYO>        } else {<KAIGYO>            Assembler::Pointer addr = _as->loadTempAddress(Assembler::ScratchRegister, targetTemp);<KAIGYO>            switch (sourceTemp->type) {<KAIGYO>            case V4IR::DoubleType:<KAIGYO>                _as->storeDouble((Assembler::FPRegisterID) sourceTemp->index, addr);<KAIGYO>                break;<KAIGYO>            case V4IR::SInt32Type:<KAIGYO>                _as->storeInt32((Assembler::RegisterID) sourceTemp->index, addr);<KAIGYO>                break;<KAIGYO>            case V4IR::UInt32Type:<KAIGYO>                _as->storeUInt32((Assembler::RegisterID) sourceTemp->index, addr);<KAIGYO>                break;<KAIGYO>            case V4IR::BoolType:<KAIGYO>                _as->storeBool((Assembler::RegisterID) sourceTemp->index, addr);<KAIGYO>                break;<KAIGYO>            default:<KAIGYO>                Q_ASSERT(!"""");<KAIGYO>                break;<KAIGYO>            }<KAIGYO>            return;<KAIGYO>        }<KAIGYO>    } else if (targetTemp->kind == V4IR::Temp::PhysicalRegister) {<KAIGYO>        switch (targetTemp->type) {<KAIGYO>        case V4IR::DoubleType:<KAIGYO>            Q_ASSERT(sourceTemp->type == V4IR::DoubleType);<KAIGYO>            _as->toDoubleRegister(sourceTemp, (Assembler::FPRegisterID) targetTemp->index);<KAIGYO>            return;<KAIGYO>        case V4IR::BoolType:<KAIGYO>            Q_ASSERT(sourceTemp->type == V4IR::BoolType);<KAIGYO>            _as->toInt32Register(sourceTemp, (Assembler::RegisterID) targetTemp->index);<KAIGYO>            return;<KAIGYO>        case V4IR::SInt32Type:<KAIGYO>            Q_ASSERT(sourceTemp->type == V4IR::SInt32Type);<KAIGYO>            _as->toInt32Register(sourceTemp, (Assembler::RegisterID) targetTemp->index);<KAIGYO>            return;<KAIGYO>        case V4IR::UInt32Type:<KAIGYO>            Q_ASSERT(sourceTemp->type == V4IR::UInt32Type);<KAIGYO>            _as->toUInt32Register(sourceTemp, (Assembler::RegisterID) targetTemp->index);<KAIGYO>            return;<KAIGYO>        default:<KAIGYO>            Q_ASSERT(!"""");<KAIGYO>            break;<KAIGYO>        }<KAIGYO>    }<KAIGYO><KAIGYO>void InstructionSelection::swapValues(V4IR::Temp *sourceTemp, V4IR::Temp *targetTemp)<KAIGYO>{<KAIGYO>    Q_ASSERT(sourceTemp->type == targetTemp->type);<KAIGYO><KAIGYO>    if (sourceTemp->kind == V4IR::Temp::PhysicalRegister) {<KAIGYO>        if (targetTemp->kind == V4IR::Temp::PhysicalRegister) {<KAIGYO>            if (sourceTemp->type == V4IR::DoubleType) {<KAIGYO>                _as->moveDouble((Assembler::FPRegisterID) targetTemp->index, Assembler::FPGpr0);<KAIGYO>                _as->moveDouble((Assembler::FPRegisterID) sourceTemp->index,<KAIGYO>                                (Assembler::FPRegisterID) targetTemp->index);<KAIGYO>                _as->moveDouble(Assembler::FPGpr0, (Assembler::FPRegisterID) sourceTemp->index);<KAIGYO>            } else {<KAIGYO>                _as->swap((Assembler::RegisterID) sourceTemp->index,<KAIGYO>                          (Assembler::RegisterID) targetTemp->index);<KAIGYO>            }<KAIGYO>            return;<KAIGYO>        }<KAIGYO>    } else if (sourceTemp->kind == V4IR::Temp::StackSlot) {<KAIGYO>        if (targetTemp->kind == V4IR::Temp::StackSlot) {<KAIGYO>            Assembler::FPRegisterID tReg = _as->toDoubleRegister(targetTemp);<KAIGYO>#if CPU(X86_64)<KAIGYO>            _as->load64(_as->stackSlotPointer(sourceTemp), Assembler::ScratchRegister);<KAIGYO>            _as->store64(Assembler::ScratchRegister, _as->stackSlotPointer(targetTemp));<KAIGYO>#else<KAIGYO>            Assembler::Pointer sAddr = _as->stackSlotPointer(sourceTemp);<KAIGYO>            Assembler::Pointer tAddr = _as->stackSlotPointer(targetTemp);<KAIGYO>            _as->load32(sAddr, Assembler::ScratchRegister);<KAIGYO>            _as->store32(Assembler::ScratchRegister, tAddr);<KAIGYO>            sAddr.offset += 4;<KAIGYO>            tAddr.offset += 4;<KAIGYO>            _as->load32(sAddr, Assembler::ScratchRegister);<KAIGYO>            _as->store32(Assembler::ScratchRegister, tAddr);<KAIGYO>#endif<KAIGYO>            _as->storeDouble(tReg, _as->stackSlotPointer(sourceTemp));<KAIGYO>            return;<KAIGYO>        }<KAIGYO>    }<KAIGYO><KAIGYO>    // FIXME: TODO!<KAIGYO>    Q_UNIMPLEMENTED();<KAIGYO>}<KAIGYO><KAIGYO>    if (op) {<KAIGYO>        _as->generateFunctionCallImp(Assembler::Void, opName, op,<KAIGYO>                                     Assembler::PointerToValue(targetTemp),<KAIGYO>                                     Assembler::PointerToValue(sourceTemp));<KAIGYO>        storeTarget(0, targetTemp);<KAIGYO>    }<KAIGYO>    const Assembler::BinaryOperationInfo& info = Assembler::binaryOperation(oper);<KAIGYO>    if (info.fallbackImplementation) {<KAIGYO>        _as->generateFunctionCallImp(Assembler::Void, info.name, info.fallbackImplementation,<KAIGYO>                                     Assembler::PointerToValue(target),<KAIGYO>                                     Assembler::PointerToValue(leftSource),<KAIGYO>                                     Assembler::PointerToValue(rightSource));<KAIGYO>        storeTarget(0, target);<KAIGYO>    } else if (info.contextImplementation) {<KAIGYO>        _as->generateFunctionCallImp(Assembler::Void, info.name, info.contextImplementation,<KAIGYO>                                     Assembler::ContextRegister,<KAIGYO>                                     Assembler::PointerToValue(target),<KAIGYO>                                     Assembler::PointerToValue(leftSource),<KAIGYO>                                     Assembler::PointerToValue(rightSource));<KAIGYO>        storeTarget(1, target);<KAIGYO>    } else {<KAIGYO>        assert(!"""");<KAIGYO>    }<KAIGYO>void InstructionSelection::callProperty(V4IR::Expr *base, const QString &name, V4IR::ExprList *args,<KAIGYO>                                        V4IR::Temp *result)<KAIGYO>                             Assembler::PointerToValue(base), Assembler::TrustedImm32(index),<KAIGYO>        generateFunctionCall(Assembler::Void, __qmljs_call_property, Assembler::ContextRegister,<KAIGYO>                             Assembler::PointerToValue(result), Assembler::PointerToValue(base), Assembler::PointerToString(name),<KAIGYO>                             baseAddressForCallArguments(), Assembler::TrustedImm32(argc));<KAIGYO>void InstructionSelection::callSubscript(V4IR::Expr *base, V4IR::Expr *index, V4IR::ExprList *args,<KAIGYO>                                         V4IR::Temp *result)<KAIGYO>    generateFunctionCall(Assembler::Void, __qmljs_call_element, Assembler::ContextRegister,<KAIGYO>                         Assembler::PointerToValue(result), Assembler::PointerToValue(base),<KAIGYO>                         Assembler::PointerToValue(index), baseAddressForCallArguments(),<KAIGYO>    if (target->type & V4IR::NumberType)<KAIGYO>    else if (target->type == V4IR::BoolType) {<KAIGYO>        generateFunctionCall(Assembler::ReturnValueRegister, __qmljs_to_boolean,<KAIGYO>                             Assembler::PointerToValue(source));<KAIGYO>        _as->storeBool(Assembler::ReturnValueRegister, target);<KAIGYO>    } else<KAIGYO>        Assembler::RegisterID reg;<KAIGYO>        if (t->kind == V4IR::Temp::PhysicalRegister) {<KAIGYO>            Q_ASSERT(t->type == V4IR::BoolType);<KAIGYO>            reg = (Assembler::RegisterID) t->index;<KAIGYO>        } else if (t->kind == V4IR::Temp::StackSlot && t->type == V4IR::BoolType) {<KAIGYO>            reg = Assembler::ReturnValueRegister;<KAIGYO>            _as->toInt32Register(t, reg);<KAIGYO>        } else {<KAIGYO>            Address temp = _as->loadTempAddress(Assembler::ScratchRegister, t);<KAIGYO>            Address tag = temp;<KAIGYO>            tag.offset += offsetof(QV4::Value, tag);<KAIGYO>            Assembler::Jump booleanConversion = _as->branch32(Assembler::NotEqual, tag, Assembler::TrustedImm32(QV4::Value::Boolean_Type));<KAIGYO>            Address data = temp;<KAIGYO>            data.offset += offsetof(QV4::Value, int_32);<KAIGYO>            _as->load32(data, Assembler::ReturnValueRegister);<KAIGYO>            Assembler::Jump testBoolean = _as->jump();<KAIGYO>            booleanConversion.link(_as);<KAIGYO>            reg = Assembler::ReturnValueRegister;<KAIGYO>            generateFunctionCall(reg, __qmljs_to_boolean, Assembler::Reference(t));<KAIGYO>            testBoolean.link(_as);<KAIGYO>        }<KAIGYO>        Assembler::Jump target = _as->branch32(Assembler::NotEqual, reg, Assembler::TrustedImm32(0));<KAIGYO>        _as->addPatch(s->iftrue, target);<KAIGYO>        _as->jumpToBlock(_block, s->iffalse);<KAIGYO>        return;<KAIGYO>    } else if (V4IR::Const *c = s->cond->asConst()) {<KAIGYO>        // TODO: SSA optimization for constant condition evaluation should remove this.<KAIGYO>        // See also visitCJump() in RegAllocInfo.<KAIGYO>        generateFunctionCall(Assembler::ReturnValueRegister, __qmljs_to_boolean,<KAIGYO>                             Assembler::PointerToValue(c));<KAIGYO>        Assembler::Jump target = _as->branch32(Assembler::NotEqual, Assembler::ReturnValueRegister,<KAIGYO>                                               Assembler::TrustedImm32(0));<KAIGYO>        _as->addPatch(s->iftrue, target);<KAIGYO>        CmpOp op = 0;<KAIGYO>        CmpOpContext opContext = 0;<KAIGYO>        const char *opName = 0;<KAIGYO>        switch (b->op) {<KAIGYO>        default: Q_UNREACHABLE(); assert(!""""); break;<KAIGYO>        case V4IR::OpGt: setOp(op, opName, __qmljs_cmp_gt); break;<KAIGYO>        case V4IR::OpLt: setOp(op, opName, __qmljs_cmp_lt); break;<KAIGYO>        case V4IR::OpGe: setOp(op, opName, __qmljs_cmp_ge); break;<KAIGYO>        case V4IR::OpLe: setOp(op, opName, __qmljs_cmp_le); break;<KAIGYO>        case V4IR::OpEqual: setOp(op, opName, __qmljs_cmp_eq); break;<KAIGYO>        case V4IR::OpNotEqual: setOp(op, opName, __qmljs_cmp_ne); break;<KAIGYO>        case V4IR::OpStrictEqual: setOp(op, opName, __qmljs_cmp_se); break;<KAIGYO>        case V4IR::OpStrictNotEqual: setOp(op, opName, __qmljs_cmp_sne); break;<KAIGYO>        case V4IR::OpInstanceof: setOpContext(op, opName, __qmljs_cmp_instanceof); break;<KAIGYO>        case V4IR::OpIn: setOpContext(op, opName, __qmljs_cmp_in); break;<KAIGYO>        } // switch<KAIGYO>        // TODO: in SSA optimization, do constant expression evaluation.<KAIGYO>        // The case here is, for example:<KAIGYO>        //   if (true === true) .....<KAIGYO>        // Of course, after folding the CJUMP to a JUMP, dead-code (dead-basic-block)<KAIGYO>        // elimination (which isn\'t there either) would remove the whole else block.<KAIGYO>        if (opContext)<KAIGYO>            _as->generateFunctionCallImp(Assembler::ReturnValueRegister, opName, opContext,<KAIGYO>                                         Assembler::ContextRegister,<KAIGYO>                                         Assembler::PointerToValue(b->left),<KAIGYO>                                         Assembler::PointerToValue(b->right));<KAIGYO>        else<KAIGYO>            _as->generateFunctionCallImp(Assembler::ReturnValueRegister, opName, op,<KAIGYO>                                         Assembler::PointerToValue(b->left),<KAIGYO>                                         Assembler::PointerToValue(b->right));<KAIGYO>        Assembler::Jump target = _as->branch32(Assembler::NotEqual, Assembler::ReturnValueRegister,<KAIGYO>                                               Assembler::TrustedImm32(0));<KAIGYO>        _as->addPatch(s->iftrue, target);<KAIGYO>        _as->jumpToBlock(_block, s->iffalse);<KAIGYO>        return;<KAIGYO>        if (t->kind == V4IR::Temp::PhysicalRegister) {<KAIGYO>            if (t->type == V4IR::DoubleType) {<KAIGYO>                _as->moveDoubleTo64((Assembler::FPRegisterID) t->index,<KAIGYO>                                    Assembler::ReturnValueRegister);<KAIGYO>            } else {<KAIGYO>                _as->zeroExtend32ToPtr((Assembler::RegisterID) t->index,<KAIGYO>                                       Assembler::ReturnValueRegister);<KAIGYO>                QV4::Value upper;<KAIGYO>                switch (t->type) {<KAIGYO>                case V4IR::SInt32Type:<KAIGYO>                case V4IR::UInt32Type:<KAIGYO>                    upper = QV4::Value::fromInt32(0);<KAIGYO>                    break;<KAIGYO>                case V4IR::BoolType:<KAIGYO>                    upper = QV4::Value::fromBoolean(false);<KAIGYO>                    break;<KAIGYO>                default:<KAIGYO>                    upper = QV4::Value::undefinedValue();<KAIGYO>                    Q_UNIMPLEMENTED();<KAIGYO>                }<KAIGYO>                _as->or64(Assembler::TrustedImm64(((int64_t) upper.tag) << 32),<KAIGYO>                          Assembler::ReturnValueRegister);<KAIGYO>            }<KAIGYO>        } else {<KAIGYO>            _as->copyValue(Assembler::ReturnValueRegister, t);<KAIGYO>        }<KAIGYO>        QV4::Value retVal = convertToValue(c);<KAIGYO>#if defined(RETURN_VALUE_IN_REGISTER)<KAIGYO>#if CPU(X86)<KAIGYO>        _as->move(Assembler::TrustedImm32(retVal.int_32), JSC::X86Registers::eax);<KAIGYO>        _as->move(Assembler::TrustedImm32(retVal.tag), JSC::X86Registers::edx);<KAIGYO>#else<KAIGYO>        _as->move(Assembler::TrustedImm64(retVal.val), Assembler::ReturnValueRegister);<KAIGYO>#endif<KAIGYO>#else // !RETURN_VALUE_IN_REGISTER<KAIGYO>        _as->storeValue(retVal, Assembler::Address(Assembler::ReturnValueRegister));<KAIGYO>#endif<KAIGYO>    _as->leaveStandardStackFrame(/*withLocals*/': 24, '    _as->leaveStandardStackFrame(/*locals*/false);<KAIGYO>    Q_ASSERT(arg);<KAIGYO>    Q_ASSERT(result);<KAIGYO><KAIGYO>    Q_ASSERT(arg);<KAIGYO>    Q_ASSERT(result);<KAIGYO><KAIGYO>    Q_ASSERT(arg);<KAIGYO><KAIGYO>    Q_ASSERT(object);<KAIGYO>    Q_ASSERT(getter);<KAIGYO>    Q_ASSERT(setter);<KAIGYO>void InstructionSelection::callBuiltinDefineProperty(V4IR::Temp *object, const QString &name,<KAIGYO>                                                     V4IR::Expr *value)<KAIGYO>    Q_ASSERT(object);<KAIGYO>    Q_ASSERT(value->asTemp() || value->asConst());<KAIGYO><KAIGYO>    generateFunctionCall(Assembler::Void, __qmljs_builtin_define_property,<KAIGYO>                         Assembler::ContextRegister, Assembler::Reference(object), Assembler::PointerToString(name),<KAIGYO>                         Assembler::PointerToValue(value));<KAIGYO>    Q_ASSERT(result);<KAIGYO><KAIGYO>                         Assembler::PointerToValue(result), baseAddressForCallArguments(),<KAIGYO>                         Assembler::TrustedImm32(length));<KAIGYO>    Q_ASSERT(result);<KAIGYO><KAIGYO>        _as->copyValue(_as->stackLayout().argumentAddressForCall(argc++), it->expr);<KAIGYO>            _as->copyValue(_as->stackLayout().argumentAddressForCall(argc++), it->expr);<KAIGYO>    Q_ASSERT(value);<KAIGYO><KAIGYO>    _as->load64(Pointer(Assembler::ContextRegister, offsetof(ExecutionContext, thisObject)),<KAIGYO>                Assembler::ReturnValueRegister);<KAIGYO>    if (targetTemp->kind == V4IR::Temp::PhysicalRegister) {<KAIGYO>        if (targetTemp->type == V4IR::DoubleType) {<KAIGYO>            Q_ASSERT(sourceConst->type == V4IR::DoubleType);<KAIGYO>            _as->toDoubleRegister(sourceConst, (Assembler::FPRegisterID) targetTemp->index);<KAIGYO>        } else if (targetTemp->type == V4IR::SInt32Type) {<KAIGYO>            Q_ASSERT(sourceConst->type == V4IR::SInt32Type);<KAIGYO>            _as->toInt32Register(sourceConst, (Assembler::RegisterID) targetTemp->index);<KAIGYO>        } else if (targetTemp->type == V4IR::UInt32Type) {<KAIGYO>            Q_ASSERT(sourceConst->type == V4IR::UInt32Type);<KAIGYO>            _as->toUInt32Register(sourceConst, (Assembler::RegisterID) targetTemp->index);<KAIGYO>        } else if (targetTemp->type == V4IR::BoolType) {<KAIGYO>            Q_ASSERT(sourceConst->type == V4IR::BoolType);<KAIGYO>            _as->move(Assembler::TrustedImm32(convertToValue(sourceConst).int_32),<KAIGYO>                      (Assembler::RegisterID) targetTemp->index);<KAIGYO>        } else {<KAIGYO>            Q_UNIMPLEMENTED();<KAIGYO>        }<KAIGYO>    } else {<KAIGYO>        _as->storeValue(convertToValue(sourceConst), targetTemp);<KAIGYO>    }<KAIGYO>void InstructionSelection::setActivationProperty(V4IR::Expr *source, const QString &targetName)<KAIGYO>                         Assembler::ContextRegister, Assembler::PointerToString(targetName), Assembler::PointerToValue(source));<KAIGYO>void InstructionSelection::getProperty(V4IR::Expr *base, const QString &name, V4IR::Temp *target)<KAIGYO>                           Assembler::PointerToValue(base));<KAIGYO>        generateFunctionCall(Assembler::Void, __qmljs_get_property, Assembler::ContextRegister,<KAIGYO>                             Assembler::PointerToValue(target), Assembler::PointerToValue(base),<KAIGYO>                             Assembler::PointerToString(name));<KAIGYO>void InstructionSelection::setProperty(V4IR::Expr *source, V4IR::Expr *targetBase,<KAIGYO>                                       const QString &targetName)<KAIGYO>        generateLookupCall(index, offsetof(QV4::Lookup, setter),<KAIGYO>                           Assembler::PointerToValue(targetBase),<KAIGYO>                           Assembler::PointerToValue(source));<KAIGYO>                             Assembler::PointerToValue(targetBase), Assembler::PointerToString(targetName),<KAIGYO>                             Assembler::PointerToValue(source));<KAIGYO>void InstructionSelection::getElement(V4IR::Expr *base, V4IR::Expr *index, V4IR::Temp *target)<KAIGYO>                         Assembler::PointerToValue(target), Assembler::PointerToValue(base),<KAIGYO>                         Assembler::PointerToValue(index));<KAIGYO>void InstructionSelection::setElement(V4IR::Expr *source, V4IR::Expr *targetBase, V4IR::Expr *targetIndex)<KAIGYO>                         Assembler::PointerToValue(targetBase), Assembler::PointerToValue(targetIndex),<KAIGYO>                         Assembler::PointerToValue(source));<KAIGYO>    if (*sourceTemp == *targetTemp)<KAIGYO>        return;<KAIGYO><KAIGYO>    if (sourceTemp->kind == V4IR::Temp::PhysicalRegister) {<KAIGYO>        if (targetTemp->kind == V4IR::Temp::PhysicalRegister) {<KAIGYO>            if (sourceTemp->type == V4IR::DoubleType)<KAIGYO>                _as->moveDouble((Assembler::FPRegisterID) sourceTemp->index,<KAIGYO>                                (Assembler::FPRegisterID) targetTemp->index);<KAIGYO>            else<KAIGYO>                _as->move((Assembler::RegisterID) sourceTemp->index,<KAIGYO>                          (Assembler::RegisterID) targetTemp->index);<KAIGYO>            return;<KAIGYO>        } else {<KAIGYO>            Assembler::Pointer addr = _as->loadTempAddress(Assembler::ScratchRegister, targetTemp);<KAIGYO>            switch (sourceTemp->type) {<KAIGYO>            case V4IR::DoubleType:<KAIGYO>                _as->storeDouble((Assembler::FPRegisterID) sourceTemp->index, addr);<KAIGYO>                break;<KAIGYO>            case V4IR::SInt32Type:<KAIGYO>                _as->storeInt32((Assembler::RegisterID) sourceTemp->index, addr);<KAIGYO>                break;<KAIGYO>            case V4IR::UInt32Type:<KAIGYO>                _as->storeUInt32((Assembler::RegisterID) sourceTemp->index, addr);<KAIGYO>                break;<KAIGYO>            case V4IR::BoolType:<KAIGYO>                _as->storeBool((Assembler::RegisterID) sourceTemp->index, addr);<KAIGYO>                break;<KAIGYO>            default:<KAIGYO>                Q_ASSERT(!"""");<KAIGYO>                break;<KAIGYO>            }<KAIGYO>            return;<KAIGYO>        }<KAIGYO>    } else if (targetTemp->kind == V4IR::Temp::PhysicalRegister) {<KAIGYO>        switch (targetTemp->type) {<KAIGYO>        case V4IR::DoubleType:<KAIGYO>            Q_ASSERT(sourceTemp->type == V4IR::DoubleType);<KAIGYO>            _as->toDoubleRegister(sourceTemp, (Assembler::FPRegisterID) targetTemp->index);<KAIGYO>            return;<KAIGYO>        case V4IR::BoolType:<KAIGYO>            Q_ASSERT(sourceTemp->type == V4IR::BoolType);<KAIGYO>            _as->toInt32Register(sourceTemp, (Assembler::RegisterID) targetTemp->index);<KAIGYO>            return;<KAIGYO>        case V4IR::SInt32Type:<KAIGYO>            Q_ASSERT(sourceTemp->type == V4IR::SInt32Type);<KAIGYO>            _as->toInt32Register(sourceTemp, (Assembler::RegisterID) targetTemp->index);<KAIGYO>            return;<KAIGYO>        case V4IR::UInt32Type:<KAIGYO>            Q_ASSERT(sourceTemp->type == V4IR::UInt32Type);<KAIGYO>            _as->toUInt32Register(sourceTemp, (Assembler::RegisterID) targetTemp->index);<KAIGYO>            return;<KAIGYO>        default:<KAIGYO>            Q_ASSERT(!"""");<KAIGYO>            break;<KAIGYO>        }<KAIGYO>    }<KAIGYO><KAIGYO>void InstructionSelection::swapValues(V4IR::Temp *sourceTemp, V4IR::Temp *targetTemp)<KAIGYO>{<KAIGYO>    Q_ASSERT(sourceTemp->type == targetTemp->type);<KAIGYO><KAIGYO>    if (sourceTemp->kind == V4IR::Temp::PhysicalRegister) {<KAIGYO>        if (targetTemp->kind == V4IR::Temp::PhysicalRegister) {<KAIGYO>            if (sourceTemp->type == V4IR::DoubleType) {<KAIGYO>                _as->moveDouble((Assembler::FPRegisterID) targetTemp->index, Assembler::FPGpr0);<KAIGYO>                _as->moveDouble((Assembler::FPRegisterID) sourceTemp->index,<KAIGYO>                                (Assembler::FPRegisterID) targetTemp->index);<KAIGYO>                _as->moveDouble(Assembler::FPGpr0, (Assembler::FPRegisterID) sourceTemp->index);<KAIGYO>            } else {<KAIGYO>                _as->swap((Assembler::RegisterID) sourceTemp->index,<KAIGYO>                          (Assembler::RegisterID) targetTemp->index);<KAIGYO>            }<KAIGYO>            return;<KAIGYO>        }<KAIGYO>    } else if (sourceTemp->kind == V4IR::Temp::StackSlot) {<KAIGYO>        if (targetTemp->kind == V4IR::Temp::StackSlot) {<KAIGYO>            Assembler::FPRegisterID tReg = _as->toDoubleRegister(targetTemp);<KAIGYO>#if CPU(X86_64)<KAIGYO>            _as->load64(_as->stackSlotPointer(sourceTemp), Assembler::ScratchRegister);<KAIGYO>            _as->store64(Assembler::ScratchRegister, _as->stackSlotPointer(targetTemp));<KAIGYO>#else<KAIGYO>            Assembler::Pointer sAddr = _as->stackSlotPointer(sourceTemp);<KAIGYO>            Assembler::Pointer tAddr = _as->stackSlotPointer(targetTemp);<KAIGYO>            _as->load32(sAddr, Assembler::ScratchRegister);<KAIGYO>            _as->store32(Assembler::ScratchRegister, tAddr);<KAIGYO>            sAddr.offset += 4;<KAIGYO>            tAddr.offset += 4;<KAIGYO>            _as->load32(sAddr, Assembler::ScratchRegister);<KAIGYO>            _as->store32(Assembler::ScratchRegister, tAddr);<KAIGYO>#endif<KAIGYO>            _as->storeDouble(tReg, _as->stackSlotPointer(sourceTemp));<KAIGYO>            return;<KAIGYO>        }<KAIGYO>    }<KAIGYO><KAIGYO>    // FIXME: TODO!<KAIGYO>    Q_UNIMPLEMENTED();<KAIGYO>}<KAIGYO><KAIGYO>    if (op) {<KAIGYO>        _as->generateFunctionCallImp(Assembler::Void, opName, op,<KAIGYO>                                     Assembler::PointerToValue(targetTemp),<KAIGYO>                                     Assembler::PointerToValue(sourceTemp));<KAIGYO>        storeTarget(0, targetTemp);<KAIGYO>    }<KAIGYO>    const Assembler::BinaryOperationInfo& info = Assembler::binaryOperation(oper);<KAIGYO>    if (info.fallbackImplementation) {<KAIGYO>        _as->generateFunctionCallImp(Assembler::Void, info.name, info.fallbackImplementation,<KAIGYO>                                     Assembler::PointerToValue(target),<KAIGYO>                                     Assembler::PointerToValue(leftSource),<KAIGYO>                                     Assembler::PointerToValue(rightSource));<KAIGYO>        storeTarget(0, target);<KAIGYO>    } else if (info.contextImplementation) {<KAIGYO>        _as->generateFunctionCallImp(Assembler::Void, info.name, info.contextImplementation,<KAIGYO>                                     Assembler::ContextRegister,<KAIGYO>                                     Assembler::PointerToValue(target),<KAIGYO>                                     Assembler::PointerToValue(leftSource),<KAIGYO>                                     Assembler::PointerToValue(rightSource));<KAIGYO>        storeTarget(1, target);<KAIGYO>    } else {<KAIGYO>        assert(!"""");<KAIGYO>    }<KAIGYO>void InstructionSelection::callProperty(V4IR::Expr *base, const QString &name, V4IR::ExprList *args,<KAIGYO>                                        V4IR::Temp *result)<KAIGYO>                             Assembler::PointerToValue(base), Assembler::TrustedImm32(index),<KAIGYO>        generateFunctionCall(Assembler::Void, __qmljs_call_property, Assembler::ContextRegister,<KAIGYO>                             Assembler::PointerToValue(result), Assembler::PointerToValue(base), Assembler::PointerToString(name),<KAIGYO>                             baseAddressForCallArguments(), Assembler::TrustedImm32(argc));<KAIGYO>void InstructionSelection::callSubscript(V4IR::Expr *base, V4IR::Expr *index, V4IR::ExprList *args,<KAIGYO>                                         V4IR::Temp *result)<KAIGYO>    generateFunctionCall(Assembler::Void, __qmljs_call_element, Assembler::ContextRegister,<KAIGYO>                         Assembler::PointerToValue(result), Assembler::PointerToValue(base),<KAIGYO>                         Assembler::PointerToValue(index), baseAddressForCallArguments(),<KAIGYO>    if (target->type & V4IR::NumberType)<KAIGYO>    else if (target->type == V4IR::BoolType) {<KAIGYO>        generateFunctionCall(Assembler::ReturnValueRegister, __qmljs_to_boolean,<KAIGYO>                             Assembler::PointerToValue(source));<KAIGYO>        _as->storeBool(Assembler::ReturnValueRegister, target);<KAIGYO>    } else<KAIGYO>        Assembler::RegisterID reg;<KAIGYO>        if (t->kind == V4IR::Temp::PhysicalRegister) {<KAIGYO>            Q_ASSERT(t->type == V4IR::BoolType);<KAIGYO>            reg = (Assembler::RegisterID) t->index;<KAIGYO>        } else if (t->kind == V4IR::Temp::StackSlot && t->type == V4IR::BoolType) {<KAIGYO>            reg = Assembler::ReturnValueRegister;<KAIGYO>            _as->toInt32Register(t, reg);<KAIGYO>        } else {<KAIGYO>            Address temp = _as->loadTempAddress(Assembler::ScratchRegister, t);<KAIGYO>            Address tag = temp;<KAIGYO>            tag.offset += offsetof(QV4::Value, tag);<KAIGYO>            Assembler::Jump booleanConversion = _as->branch32(Assembler::NotEqual, tag, Assembler::TrustedImm32(QV4::Value::Boolean_Type));<KAIGYO>            Address data = temp;<KAIGYO>            data.offset += offsetof(QV4::Value, int_32);<KAIGYO>            _as->load32(data, Assembler::ReturnValueRegister);<KAIGYO>            Assembler::Jump testBoolean = _as->jump();<KAIGYO>            booleanConversion.link(_as);<KAIGYO>            reg = Assembler::ReturnValueRegister;<KAIGYO>            generateFunctionCall(reg, __qmljs_to_boolean, Assembler::Reference(t));<KAIGYO>            testBoolean.link(_as);<KAIGYO>        }<KAIGYO>        Assembler::Jump target = _as->branch32(Assembler::NotEqual, reg, Assembler::TrustedImm32(0));<KAIGYO>        _as->addPatch(s->iftrue, target);<KAIGYO>        _as->jumpToBlock(_block, s->iffalse);<KAIGYO>        return;<KAIGYO>    } else if (V4IR::Const *c = s->cond->asConst()) {<KAIGYO>        // TODO: SSA optimization for constant condition evaluation should remove this.<KAIGYO>        // See also visitCJump() in RegAllocInfo.<KAIGYO>        generateFunctionCall(Assembler::ReturnValueRegister, __qmljs_to_boolean,<KAIGYO>                             Assembler::PointerToValue(c));<KAIGYO>        Assembler::Jump target = _as->branch32(Assembler::NotEqual, Assembler::ReturnValueRegister,<KAIGYO>                                               Assembler::TrustedImm32(0));<KAIGYO>        _as->addPatch(s->iftrue, target);<KAIGYO>        CmpOp op = 0;<KAIGYO>        CmpOpContext opContext = 0;<KAIGYO>        const char *opName = 0;<KAIGYO>        switch (b->op) {<KAIGYO>        default: Q_UNREACHABLE(); assert(!""""); break;<KAIGYO>        case V4IR::OpGt: setOp(op, opName, __qmljs_cmp_gt); break;<KAIGYO>        case V4IR::OpLt: setOp(op, opName, __qmljs_cmp_lt); break;<KAIGYO>        case V4IR::OpGe: setOp(op, opName, __qmljs_cmp_ge); break;<KAIGYO>        case V4IR::OpLe: setOp(op, opName, __qmljs_cmp_le); break;<KAIGYO>        case V4IR::OpEqual: setOp(op, opName, __qmljs_cmp_eq); break;<KAIGYO>        case V4IR::OpNotEqual: setOp(op, opName, __qmljs_cmp_ne); break;<KAIGYO>        case V4IR::OpStrictEqual: setOp(op, opName, __qmljs_cmp_se); break;<KAIGYO>        case V4IR::OpStrictNotEqual: setOp(op, opName, __qmljs_cmp_sne); break;<KAIGYO>        case V4IR::OpInstanceof: setOpContext(op, opName, __qmljs_cmp_instanceof); break;<KAIGYO>        case V4IR::OpIn: setOpContext(op, opName, __qmljs_cmp_in); break;<KAIGYO>        } // switch<KAIGYO>        // TODO: in SSA optimization, do constant expression evaluation.<KAIGYO>        // The case here is, for example:<KAIGYO>        //   if (true === true) .....<KAIGYO>        // Of course, after folding the CJUMP to a JUMP, dead-code (dead-basic-block)<KAIGYO>        // elimination (which isn\'t there either) would remove the whole else block.<KAIGYO>        if (opContext)<KAIGYO>            _as->generateFunctionCallImp(Assembler::ReturnValueRegister, opName, opContext,<KAIGYO>                                         Assembler::ContextRegister,<KAIGYO>                                         Assembler::PointerToValue(b->left),<KAIGYO>                                         Assembler::PointerToValue(b->right));<KAIGYO>        else<KAIGYO>            _as->generateFunctionCallImp(Assembler::ReturnValueRegister, opName, op,<KAIGYO>                                         Assembler::PointerToValue(b->left),<KAIGYO>                                         Assembler::PointerToValue(b->right));<KAIGYO>        Assembler::Jump target = _as->branch32(Assembler::NotEqual, Assembler::ReturnValueRegister,<KAIGYO>                                               Assembler::TrustedImm32(0));<KAIGYO>        _as->addPatch(s->iftrue, target);<KAIGYO>        _as->jumpToBlock(_block, s->iffalse);<KAIGYO>        return;<KAIGYO>        if (t->kind == V4IR::Temp::PhysicalRegister) {<KAIGYO>            if (t->type == V4IR::DoubleType) {<KAIGYO>                _as->moveDoubleTo64((Assembler::FPRegisterID) t->index,<KAIGYO>                                    Assembler::ReturnValueRegister);<KAIGYO>            } else {<KAIGYO>                _as->zeroExtend32ToPtr((Assembler::RegisterID) t->index,<KAIGYO>                                       Assembler::ReturnValueRegister);<KAIGYO>                QV4::Value upper;<KAIGYO>                switch (t->type) {<KAIGYO>                case V4IR::SInt32Type:<KAIGYO>                case V4IR::UInt32Type:<KAIGYO>                    upper = QV4::Value::fromInt32(0);<KAIGYO>                    break;<KAIGYO>                case V4IR::BoolType:<KAIGYO>                    upper = QV4::Value::fromBoolean(false);<KAIGYO>                    break;<KAIGYO>                default:<KAIGYO>                    upper = QV4::Value::undefinedValue();<KAIGYO>                    Q_UNIMPLEMENTED();<KAIGYO>                }<KAIGYO>                _as->or64(Assembler::TrustedImm64(((int64_t) upper.tag) << 32),<KAIGYO>                          Assembler::ReturnValueRegister);<KAIGYO>            }<KAIGYO>        } else {<KAIGYO>            _as->copyValue(Assembler::ReturnValueRegister, t);<KAIGYO>        }<KAIGYO>        QV4::Value retVal = convertToValue(c);<KAIGYO>#if defined(RETURN_VALUE_IN_REGISTER)<KAIGYO>#if CPU(X86)<KAIGYO>        _as->move(Assembler::TrustedImm32(retVal.int_32), JSC::X86Registers::eax);<KAIGYO>        _as->move(Assembler::TrustedImm32(retVal.tag), JSC::X86Registers::edx);<KAIGYO>#else<KAIGYO>        _as->move(Assembler::TrustedImm64(retVal.val), Assembler::ReturnValueRegister);<KAIGYO>#endif<KAIGYO>#else // !RETURN_VALUE_IN_REGISTER<KAIGYO>        _as->loadPtr(addressForArgument(0), Assembler::ReturnValueRegister);<KAIGYO>        _as->storeValue(retVal, Assembler::Address(Assembler::ReturnValueRegister));<KAIGYO>#endif<KAIGYO>    _as->leaveStandardStackFrame(/*withLocals*/': 25}",1.0,{'// TODO: masm cannot handle registers yet.': 1},1.0,{}
23,63004.0,3.0,4.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/63004,Move the masm compilation unit entirely into qv4isel_masm,1.0,{},0.0,{'// ### Move to masm': 1},1.0,{}
70,63196.0,2.0,3.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/63196,Get rid of the functions list in QV4::ExecutionEngine,1.0,{},0.0,{'// ### move to masm compilation unit': 1},1.0,{}
83,63219.0,1.0,1.0,0.0,DEFERRED,False,https://codereview.qt-project.org/#/c/63219,initial coffeescript implementation,1.0,{'// ### TODO: AST for initializer': 1},1.0,{'// ### TODO: AST for initializer': 1},1.0,{}
111,63252.0,9.0,15.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/63252,Generate code conversion to double.,1.0,{'// TODO: change masm to generate code': 1},1.0,"{'// FIXME: do something more useful with this info': 1, '// TODO: change masm to generate code': 1}",1.0,{}
99,63254.0,6.0,10.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/63254,Generate code for conversion to signed int32.,1.0,{'// TODO: change masm to generate code': 1},1.0,"{'// TODO: do not generate a call (meaning: block all registers), but annotate the conversion with registers that need to be saved and have masm take care of that.<KAIGYO>// TODO: verify this method<KAIGYO>// TODO: change masm to generate code': 1}",1.0,{}
124,63256.0,11.0,42.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/63256,V4 JIT: generate code for binary expressions.,1.0,"{'// TODO: More constant binary expression evaluation<KAIGYO>// TODO: If the result of the move is only used in one single cjump, then<KAIGYO>//       inline the binop into the cjump.': 5, '// TODO?': 7}",1.0,"{'// TODO: More constant binary expression evaluation': 5, '// TODO: Constant binary expression evaluation': 5}",1.0,{}
92,63275.0,1.0,4.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/63275,prune unused obsolete tests,1.0,{},0.0,"{""// FIXME: This probably should use some yet-to-be-invented<KAIGYO>// binary interface to 'lupdate' instead of playing around<KAIGYO>// with the filesystem,"": 1}",1.0,{}
117,63451.0,2.0,4.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/63451,Cleanup: Separate JS environment scanner class declaration from definition,1.0,{'// TODO: give a warning.': 1},1.0,{'// TODO: give a warning.': 1},1.0,{}
147,63572.0,5.0,14.0,2.0,ABANDONED,False,https://codereview.qt-project.org/#/c/63572,Support statically linked module plugins,1.0,{'// things on the engine (eg. adding new global objects) have to be done for every<KAIGYO>// engine.<KAIGYO>// XXX protect against double initialization': 1},1.0,{'// things on the engine (eg. adding new global objects) have to be done for every <KAIGYO>// engine.  <KAIGYO>// XXX protect against double initialization': 1},1.0,{}
144,63615.0,2.0,9.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/63615,Interpreter fixes.,1.0,{},0.0,{'// FIXME: support Const exprs in Phi nodes.': 1},1.0,{}
188,63706.0,1.0,10.0,0.0,ABANDONED,False,https://codereview.qt-project.org/#/c/63706,Linux: The refactoring of availablePorts() method,1.0,{'// TODO: Implement me.<KAIGYO>// Q_OS_LINUX': 1},1.0,{'// TODO: Implement me.': 1},1.0,{}
211,63828.0,1.0,2.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/63828,Change AttachedDataContainer implementation to something slightly smarter,1.0,{'// TODO replace by something smarter so we can use pointers instead of index.': 1},1.0,"{'class AttachedDataContainer: public QHash<QString /* object id */, EnginioModelPrivateAttachedData><KAIGYO>    // TODO QHash is not the right structure, we need to index by id, row and we want to make<KAIGYO>    // bulk update of the data.<KAIGYO>    typedef QHash<QString /* object id */': 1, '// TODO optimize it': 1, '// TODO optimize it is almost O(n log(n))': 1}",1.0,{}
223,63838.0,1.0,2.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/63838,"Separate create operation from ""catch all replies"" handler",1.0,{'// TODO add a signal here so a developer can ask an user for a conflict<KAIGYO>// resolution.': 1},1.0,"{'// Updating a removed row. Change operation type to remove, so the cache can<KAIGYO>// be in sync with the server again.<KAIGYO>// TODO add a signal here so a developer can ask an user for a conflict<KAIGYO>// resolution.': 1}",1.0,{}
228,63840.0,1.0,2.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/63840,"Separate incremental update operation from ""catch all replies"" handler",1.0,{},0.0,{'// ### TODO proper error handling<KAIGYO>// this kind of response happens when the backend id/secret is missing': 1},1.0,{}
229,63843.0,1.0,3.0,2.0,MERGED,True,https://codereview.qt-project.org/#/c/63843,Reduce EnginioModel latency,1.0,{},0.0,"{'// ignore own requests, we will handle them in finished signal handler<KAIGYO>// TODO it woudl be better to handle them in the faster way<KAIGYO>// it should not matter how we got confirmation': 1}",1.0,{}
275,63874.0,22.0,145.0,129.0,MERGED,True,https://codereview.qt-project.org/#/c/63874,Use sysfs on Linux when available,1.0,{'// TODO: Implement me.': 1},1.0,{'// TODO: Implement me.': 1},1.0,{}
254,63924.0,1.0,6.0,0.0,DEFERRED,False,https://codereview.qt-project.org/#/c/63924,Reduce unnecessary enabled changes,1.0,{},0.0,"{'// XXX todo - Should the effective enable of an element with no parent just be the current<KAIGYO>// effective enable?  This would prevent pointless re-processing in the case of an element<KAIGYO>// moving to/from a no-parent situation, but it is different from what graphics view does.': 1}",1.0,{}
19,64157.0,1.0,17.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/64157,V4: fix inferred types of 30&&true and 30||true.,1.0,{},0.0,{'// TODO: check & double check the next condition!': 1},1.0,{}
31,64158.0,7.0,28.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/64158,V4 JIT: finish swapValues.,1.0,{},0.0,{'// FIXME: TODO!': 1},1.0,{}
36,64161.0,7.0,28.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/64161,V4 regalloc: correct life-time hole handling.,1.0,{},0.0,{'// TODO: check isStructurallyValidLanguageTag': 1},1.0,{}
157,64323.0,8.0,30.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/64323,V4: Fix SSA decomposition when no regalloc is used.,1.0,{},0.0,"{'/*<KAIGYO> * Quick function to convert out of SSA, so we can put the stuff through the ISel phases. This<KAIGYO> * has to be replaced by a phase in the specific ISel back-ends and do register allocation at the<KAIGYO> * same time. That way the huge number of redundant moves generated by this function are eliminated.<KAIGYO> */': 1}",1.0,{}
107,64565.0,2.0,15.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/64565,V4 regalloc: loading this never needs/needed a call.,1.0,{},0.0,{'// FIXME: propagate this': 1},1.0,{}
135,64594.0,6.0,31.0,12.0,MERGED,True,https://codereview.qt-project.org/#/c/64594,qmlplugindump: Add support for composite types,1.0,{'// Also eliminate meta objects with the same classname.<KAIGYO>// This is required because extended objects seem not to share<KAIGYO>// a single meta object instance.': 1},1.0,{'// TODO actually handle composite types': 1},1.0,{}
121,64600.0,1.0,2.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/64600,Skip notification tests,1.0,{},0.0,{'// FIXME: As soon as this functionality is deployed to the production server<KAIGYO>// this test has to be changed to use EnginioTests::TESTAPP_STAGING_URL.': 1},1.0,{}
20,65052.0,3.0,5.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/65052,V4 IR: rename ObjectType to VarType,1.0,"{'// Constant unary expression evaluation:<KAIGYO>// TODO: if the result of a unary not operation is only used in a cjump,<KAIGYO>//       then inline it.': 1, '// TODO: if the expression is an unary not operation, lift the expression, and switch<KAIGYO>//       the then/else blocks.': 1}",1.0,{'// TODO: VERIFY THIS!': 1},1.0,{}
14,65055.0,3.0,5.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/65055,V4 interpreter: inline add/sub/mul on numbers.,1.0,{},0.0,{'// TODO: add Temp+Const variation on the topic.': 1},1.0,{}
45,65114.0,5.0,18.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/65114,QmlDebugging: Replace QV8DebugService with QV4DebugService,1.0,{'// TODO: pause debugger': 1},1.0,"{'/* ### FIXME: v4<KAIGYO>void DebugMessageHandler(const v8::Debug::Message& message)<KAIGYO>{<KAIGYO>    v8::DebugEvent event = message.GetEvent();<KAIGYO><KAIGYO>    if (message.IsEvent()) {<KAIGYO>        if (event == v8::AfterCompile || event == v8::BeforeCompile)<KAIGYO>            return;<KAIGYO>    } else if (event != v8::Break && event != v8::Exception &&<KAIGYO>               event != v8::AfterCompile && event != v8::BeforeCompile) {<KAIGYO>        return;<KAIGYO>    }<KAIGYO><KAIGYO>    v8ServiceInstancePtr->debugMessageHandler(QJSConverter::toString(message.GetJSON()));<KAIGYO>}<KAIGYO>*/': 2, '// ### FIXME: v4': 2, '//    ### FIXME: v4<KAIGYO>//    if (schedule)<KAIGYO>//        v8::Debug::DebugBreak();<KAIGYO>//    else<KAIGYO>//        v8::Debug::CancelDebugBreak();': 2, '//  ### FIXME: v4  v8::Debug::ProcessDebugMessages();': 2}",1.0,{}
32,65162.0,1.0,1.0,0.0,ABANDONED,False,https://codereview.qt-project.org/#/c/65162,Support statically linked module plugins,1.0,{'// things on the engine (eg. adding new global objects) have to be done for every<KAIGYO>// engine.<KAIGYO>// XXX protect against double initialization': 1},1.0,{'// things on the engine (eg. adding new global objects) have to be done for every <KAIGYO>// engine.  <KAIGYO>// XXX protect against double initialization': 1},1.0,{}
66,65214.0,5.0,5.0,0.0,ABANDONED,False,https://codereview.qt-project.org/#/c/65214,WIP: Throw a foreign exception when using the common cxxabi,1.0,{},0.0,"{""/*<KAIGYO> * This is a little bit hacky as it relies on the fact that exceptions are<KAIGYO> * reference counted in libstdc++ and that affects the layout of the standardized<KAIGYO> * cxa_exception, making it bigger. LLVM's libcxxabi stores the reference count<KAIGYO> * differently, so this here is entirely GNU libstdc++ specific.<KAIGYO> *<KAIGYO> * Eliminating this dependency is doable but requires replacing the use of C++ exceptions<KAIGYO> * with foreign exceptions (a different exception class) and then using __cxa_get_globals<KAIGYO> * to get hold of the exception inside the catch (...). AFAICS that would be portable.<KAIGYO> */"": 1}",1.0,{}
91,65382.0,3.0,30.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/65382,These files are not used anywhere.,1.0,{},0.0,"{'// Assuming 16 bits per vector component.': 1, ""// element doesn't split itself."": 1}",1.0,{}
109,65439.0,2.0,7.0,3.0,MERGED,True,https://codereview.qt-project.org/#/c/65439,Use a better way of initializing QJSEngine pointer.,1.0,{},0.0,{'// TODO maybe _value.toString().toUtf8()?': 1},1.0,{}
128,65484.0,1.0,11.0,0.0,ABANDONED,False,https://codereview.qt-project.org/#/c/65484,Merge branch 'stable' into dev,1.0,{},0.0,"{'// oxygen style needs this hack': 1, '// Qt draws an ugly line here so I ignore it': 1, ""// Unhack QMacStyle's hack"": 1}",1.0,{}
138,65507.0,3.0,21.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/65507,[new compiler] Add support for finalization callbacks,1.0,{'// XXX should only be allowed during begin': 1},1.0,{'// ###<KAIGYO>// XXX should only be allowed during begin': 1},1.0,{}
186,65687.0,2.0,8.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/65687,Merge branch 'stable' into dev,1.0,{},0.0,"{'// oxygen style needs this hack': 1, '// Qt draws an ugly line here so I ignore it': 1, ""// Unhack QMacStyle's hack"": 1}",1.0,{}
203,65718.0,2.0,8.0,2.0,MERGED,True,https://codereview.qt-project.org/#/c/65718,Lower the verbosity of bluetooth,1.0,"{'//TODO implement this<KAIGYO>//qDebug() << """" << in0.path() << in1;<KAIGYO>//TODO implement this<KAIGYO>//qDebug() << Q_FUNC_INFO;<KAIGYO>//TODO implement this<KAIGYO>//qDebug() << Q_FUNC_INFO;': 1, '//TODO implement this<KAIGYO>//qDebug() << Q_FUNC_INFO << in0;': 1, '//TODO implement this<KAIGYO>//qDebug() << Q_FUNC_INFO << in0.path() << in1 << in2;<KAIGYO>//qDebug() << Q_FUNC_INFO;': 1, '//TODO Try if this actually works<KAIGYO>//TODO Try if this actually works': 1, '//TODO propaget this error to the user': 1}",1.0,{'//TODO Try if this actually works<KAIGYO>//TODO Try if this actually works': 1},1.0,{}
198,65761.0,4.0,7.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/65761,Break inheritance model of EnginioQmlReply.,1.0,{},0.0,"{""// Enginio doesn't need this reply anymore, so now we need to figure out how to<KAIGYO>// delete it. There are two cases:<KAIGYO>//  - finished and error signals are not connected => nobody really cares about<KAIGYO>//    this reply we can safely delete it.<KAIGYO>//  - at least one of finished and error signals is connected => we assume that<KAIGYO>//    the connection is done from QML, so we transfer reply ownership to it. C++<KAIGYO>//    developers needs to take care of such situation and addapt."": 1, '// TODO it will not work because of: httpsbugreports.qt-project.org/browse/QTBUG-32340': 1}",1.0,{}
221,65784.0,5.0,24.0,22.0,ABANDONED,False,https://codereview.qt-project.org/#/c/65784,Remove QtWidgets dependencies from QtMacExtras.,1.0,{'//    setSelectedItem(qobject_cast<QMacToolButton*>(sender()));<KAIGYO>//### TODO- re-implement': 2},1.0,"{""// TODO: add the QToolBar's QWidgets to the Mac toolbar once it supports this"": 1}",1.0,{}
222,65812.0,5.0,34.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/65812,QtWebKit should not require SQLite version to 3.6.16.,1.0,"{'// FIXME: This overload helps us compile with older versions of SQLite 3, but things like quotas will not work.': 1}",1.0,{'// SQLite 3.6.16 makes sqlite3_prepare_v2 automatically retry preparing the statement<KAIGYO>// once if the database scheme has changed. We rely on this behavior.': 1},1.0,{}
209,66357.0,2.0,11.0,1.0,MERGED,True,https://codereview.qt-project.org/#/c/66357,Remove QtWidgets dependencies from QtMacExtras.,1.0,{'//    setSelectedItem(qobject_cast<QMacToolButton*>(sender()));<KAIGYO>//### TODO- re-implement': 1},1.0,"{""// TODO: add the QToolBar's QWidgets to the Mac toolbar once it supports this"": 1}",1.0,{}
299,66608.0,1.0,2.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/66608,Update fakeReply tests.,1.0,{},0.0,"{'// TODO change it to EnginioReply.BackendError': 1, '// TODO add checks fro network errors': 1}",1.0,{}
322,66650.0,1.0,4.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/66650,Remove code that doesn't do anything.,1.0,{},0.0,{'// ####TODO Properly #ifdef this class to use #define symbols actually defined<KAIGYO>// by OpenGL/ES includes': 1},1.0,{}
326,66653.0,1.0,3.0,2.0,MERGED,True,https://codereview.qt-project.org/#/c/66653,Fix crash when a delayed request is finished after initial query.,1.0,{},0.0,{'// TODO fix me please.': 1},1.0,{}
377,66706.0,4.0,10.0,0.0,ABANDONED,False,https://codereview.qt-project.org/#/c/66706,eglfs: Support multiple OpenGL windows,1.0,{},0.0,"{'// move to the end of the list, to be on top': 1}",1.0,{}
383,66742.0,3.0,5.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/66742,Update the internal alignment when an item *changes* its alignment,1.0,{},0.0,"{'// Workaround, force full invalidation (QTBUG-33773)': 2}",1.0,{}
396,66803.0,1.0,2.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/66803,Added TODOs for extra tests,1.0,{'//TODO: test valid UTF8 sequences (see UC 6.2)<KAIGYO>//TODO: test for AutoBahn testcase 5<KAIGYO>//TODO: test for AutoBahn testcase 6.1<KAIGYO>//TODO: test for AutoBahn testcase 6.3 (fragmentation test)<KAIGYO>//TODO: test for AutoBahn testcase 6.4 (fragmentation test)<KAIGYO>//void goodHeaders();   //test all valid control codes': 1},1.0,{'//TODO: test valid UTF8 sequences': 1},1.0,{}
437,66829.0,1.0,5.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/66829,V4: remove inplace operations,1.0,"{""// TODO: `this' should be a builtin."": 1}",1.0,"{'// TODO: verify the rest of the function for when op == OpInvalid': 1, ""// TODO: `this' should be a builtin."": 1, '// TODO: remove this!': 1}",1.0,{}
445,66854.0,1.0,2.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/66854,moved class to separate file,1.0,{'//Most significant bit must be set to 0 as per httptools.ietf.org/html/rfc6455#section-5.2<KAIGYO>//TODO: Do we check for that? Now we just strip off the highest bit': 1},1.0,{'//Most significant bit must be set to 0 as per httptools.ietf.org/html/rfc6455#section-5.2<KAIGYO>//TODO: Do we check for that? Now we just strip off the highest bit': 1},1.0,{}
8,67025.0,4.0,11.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/67025,V4 IR: fix dead-code elimination.,1.0,"{""// TODO: prune parts that don't have a side-effect. For example, in:<KAIGYO>//   function f(x) { +x+1; return 0; }<KAIGYO>// we can prune the binop and leave the unop/conversion."": 1, '// TODO: there are built-in functions that have no side effect.': 1, '// TODO: there are built-in types that have no side effect.<KAIGYO>// dead code elimination:': 1}",1.0,"{'// TODO: check if this can be moved to IR building.': 1, '// TODO: see if we can have subscript accesses without side effect': 1, '// TODO: see if we can have member accesses without side effect': 1, '// TODO: there are built-in functions that have no side effect.<KAIGYO>// TODO: there are built-in types that have no side effect.': 1}",1.0,{}
54,67030.0,10.0,27.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/67030,Change v4 exceptions to use the common C++ ABIs foreign exceptions,1.0,{},0.0,"{""/*<KAIGYO> * This is a little bit hacky as it relies on the fact that exceptions are<KAIGYO> * reference counted in libstdc++ and that affects the layout of the standardized<KAIGYO> * cxa_exception, making it bigger. LLVM's libcxxabi stores the reference count<KAIGYO> * differently, so this here is entirely GNU libstdc++ specific.<KAIGYO> *<KAIGYO> * Eliminating this dependency is doable but requires replacing the use of C++ exceptions<KAIGYO> * with foreign exceptions (a different exception class) and then using __cxa_get_globals<KAIGYO> * to get hold of the exception inside the catch (...). AFAICS that would be portable.<KAIGYO> */"": 1}",1.0,{}
72,67047.0,7.0,14.0,3.0,MERGED,True,https://codereview.qt-project.org/#/c/67047,V4 debugger: retrieve formals and locals.,1.0,{'// XXX TODO!': 1},1.0,{'// maybe check something on the Managed object?': 2},1.0,{}
111,67268.0,1.0,6.0,1.0,MERGED,True,https://codereview.qt-project.org/#/c/67268,Fix regression in pressDelay behavior.,1.0,"{'// As we moved pass the drag threshold, we should never receive the press': 1}",1.0,{'// A move beyond the threshold replays the press to give nested Flickables<KAIGYO>// the opportunity to grab the gesture.': 1},1.0,{}
117,67282.0,2.0,5.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/67282,Add EnginioQmlReply isError and isFinished properties.,1.0,{},0.0,{'// FIXME: make isError available to QML<KAIGYO>//verify(!reply.isError)': 1},1.0,{}
123,67286.0,2.0,6.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/67286,Move EnginioModelPrivate to a separate header file.,1.0,{},0.0,"{""    typedef QHash<RequestId, QPair<int /*ref*/, StorageIndex> > RequestIdIndex;<KAIGYO>    RequestIdIndex _requestIdIndex;<KAIGYO><KAIGYO>    typedef QHash<StorageIndex, AttachedData> Storage;<KAIGYO>    QVector<AttachedData> _storage; // TODO replace by something smarter so we can use pointers instead of index.<KAIGYO><KAIGYO>    enum { InvalidStorageIndex = InvalidRow };<KAIGYO><KAIGYO>    StorageIndex append(const AttachedData &data)<KAIGYO>    {<KAIGYO>        _storage.append(data);<KAIGYO>        StorageIndex idx = _storage.count() - 1;<KAIGYO>        _rowIndex.insert(data.row, idx);<KAIGYO>        _objectIdIndex.insert(data.id, idx);<KAIGYO>        return idx;<KAIGYO>    }<KAIGYO><KAIGYO>public:<KAIGYO>    bool contains(const ObjectId &id) const<KAIGYO>    {<KAIGYO>        return _objectIdIndex.contains(id);<KAIGYO>    }<KAIGYO><KAIGYO>    Row rowFromObjectId(const ObjectId &id) const<KAIGYO>    {<KAIGYO>        Q_ASSERT(contains(id));<KAIGYO>        StorageIndex idx = _objectIdIndex.value(id, InvalidStorageIndex);<KAIGYO>        return idx == InvalidStorageIndex ? InvalidRow : _storage[idx].row;<KAIGYO>    }<KAIGYO><KAIGYO>    Row rowFromRequestId(const RequestId &id) const<KAIGYO>    {<KAIGYO>        StorageIndex idx = _requestIdIndex.value(id, qMakePair(0, InvalidStorageIndex)).second;<KAIGYO>        return idx == InvalidStorageIndex ? InvalidRow : _storage[idx].row;<KAIGYO>    }<KAIGYO><KAIGYO>    bool isSynced(Row row) const<KAIGYO>    {<KAIGYO>        return _storage[_rowIndex.value(row)].ref == 0;<KAIGYO>    }<KAIGYO><KAIGYO>    void updateAllDataAfterRowRemoval(const int row) {<KAIGYO>        _rowIndex.clear();<KAIGYO>        _rowIndex.reserve(_storage.count());<KAIGYO>        for (StorageIndex i = 0; i < _storage.count() ; ++i) {<KAIGYO>            AttachedData &data = _storage[i];<KAIGYO>            if (data.row > row)<KAIGYO>                --data.row;<KAIGYO>            else if (data.row == row)<KAIGYO>                data.row = DeletedRow;<KAIGYO>            _rowIndex.insert(data.row, i);<KAIGYO>        }<KAIGYO>    }<KAIGYO><KAIGYO>    AttachedData &ref(const ObjectId &id, Row row)<KAIGYO>    {<KAIGYO>        StorageIndex idx = _objectIdIndex.value(id, InvalidStorageIndex);<KAIGYO>        if (idx == InvalidStorageIndex) {<KAIGYO>            AttachedData data(row, id);<KAIGYO>            idx = append(data);<KAIGYO>        }<KAIGYO>        AttachedData &data = _storage[idx];<KAIGYO>        ++data.ref;<KAIGYO>        Q_ASSERT(_storage[idx].ref == 1 || _storage[idx].row == row);<KAIGYO>        data.row = row;<KAIGYO>        return data;<KAIGYO>    }<KAIGYO><KAIGYO>    AttachedData &ref(Row row)<KAIGYO>    {<KAIGYO>        StorageIndex idx = _rowIndex.value(row, InvalidStorageIndex);<KAIGYO>        Q_ASSERT(idx != InvalidStorageIndex);<KAIGYO>        AttachedData &data = _storage[idx];<KAIGYO>        ++data.ref;<KAIGYO>        return data;<KAIGYO>    }<KAIGYO><KAIGYO>    AttachedData &deref(const ObjectId &id)<KAIGYO>    {<KAIGYO>        StorageIndex idx = _objectIdIndex.value(id, InvalidStorageIndex);<KAIGYO>        Q_ASSERT(idx != InvalidStorageIndex);<KAIGYO>        AttachedData &attachedData = _storage[idx];<KAIGYO>        if (!--attachedData.ref && id[0] == 't') {<KAIGYO>            // TODO it is last ref to a tmp id we should remove it<KAIGYO>        }<KAIGYO>        return attachedData;<KAIGYO>    }<KAIGYO><KAIGYO>    void insert(const AttachedData &data)<KAIGYO>    {<KAIGYO>        _storage.append(data);<KAIGYO>        StorageIndex idx = _storage.count() - 1;<KAIGYO>        _rowIndex.insert(data.row, idx);<KAIGYO>        _objectIdIndex.insert(data.id, idx);<KAIGYO>    }<KAIGYO><KAIGYO>    void insertRequestId(const RequestId &id, Row row)<KAIGYO>    {<KAIGYO>        StorageIndex idx = _rowIndex.value(row, InvalidStorageIndex);<KAIGYO>        Q_ASSERT(idx != InvalidStorageIndex);<KAIGYO>        _requestIdIndex.insert(id, qMakePair(2, idx));<KAIGYO>    }<KAIGYO><KAIGYO>    /*!<KAIGYO>      \\internal<KAIGYO>      returns true if the request was already handled<KAIGYO>    */"": 1, '// TODO replace by a sparse array, and add laziness': 1, '// TODO it allows to use notification only on staging<KAIGYO>// TODO reuse the connecton object': 1, '// TODO think about it, it means that not all queries are valid': 1, '// TODO if refcount is > 1 then do not emit dataChanged': 1, '// TODO add a signal here so a developer can ask an user for a conflict<KAIGYO>// resolution.': 1, '// Try to rollback the change.<KAIGYO>// TODO it is not perfect httpsgithub.com/enginio/enginio-qt/issues/200': 1, '// TODO it expects certain data structure in all objects, add way to specify roles': 1, '// TODO Use a proper name, can we make it an attached property in qml? Does it make sense to try?': 1, '// TODO this is not optimal, but happen once, do we want to do something about it?': 1}",1.0,{}
134,67316.0,4.0,6.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/67316,V4 JIT: generate some strict (not) equal conditions,1.0,"{'// TODO: inline var===null and var!==null': 1, '// neither operands are statically typed as bool, so bail out.': 3}",1.0,{'// TODO: change masm to generate code': 3},1.0,{}
163,67371.0,1.0,2.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/67371,Added some tests,1.0,{'//TODO: test for valid control frames<KAIGYO>//DONE: test close frame with no close code and reason': 1},1.0,{'//TODO: test for valid opcodes<KAIGYO>//TODO: test close frame with no close code and reason<KAIGYO>//TODO: still to test with no close code and no close reason (is valid)': 1},1.0,{}
297,67383.0,9.0,30.0,16.0,MERGED,True,https://codereview.qt-project.org/#/c/67383,Allow non-character codes in utf8 strings,1.0,"{""// TODO: fails at the moment -- don't bother"": 4}",1.0,"{""// TODO: fails at the moment -- don't bother"": 4}",1.0,{}
244,67546.0,2.0,5.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/67546,Store EnginioModel::query in a native type.,1.0,"{'// TODO that is sooo bad, that I can not look at this.<KAIGYO>// TODO trace all calls and try to remove them': 1}",1.0,"{'// TODO that is sooo bad, that I can not look at this.': 1, '// TODO use EnginioModelPrivate1': 1}",1.0,{}
264,67570.0,2.0,9.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/67570,eglfs: Separate compositor and improve raster window support,1.0,{},0.0,"{'// move to the end of the list, to be on top': 1}",1.0,{}
294,67670.0,2.0,8.0,1.0,MERGED,True,https://codereview.qt-project.org/#/c/67670,V4 JIT: clean-up conversion functions and add toUInt32.,1.0,"{'// not an int, maybe a double:': 1}",1.0,"{'// TODO: change masm to generate code': 1, '// this might need a call<KAIGYO>// TODO: change masm to generate code': 2}",1.0,{}
299,67681.0,3.0,19.0,2.0,MERGED,True,https://codereview.qt-project.org/#/c/67681,When creating QVariant(QPolygonF()) this should be a null variant,1.0,{'// This class is a hack that customizes access to QPolygon and QPolygonF': 1},1.0,{'// This class is a hack that customizes access to QPolygon': 1},1.0,{}
315,67738.0,2.0,5.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/67738,Fix and re-enable constantUpdateOnWindow test.,1.0,{},0.0,"{""// We should expect 60, but under loaded conditions we could be skipping<KAIGYO>// frames, so don't expect too much."": 1}",1.0,{}
365,67848.0,1.0,2.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/67848,Added boundary checks on string lists,1.0,{'//TODO: authentication field': 1},1.0,{'//TODO: authentication field': 1},1.0,{}
382,67849.0,3.0,4.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/67849,Added checks for valid control frames,1.0,{},0.0,"{'//TODO: test for valid control frames<KAIGYO>//void goodControlFrame();': 1, '//TODO: CorsCheck: give list in constructor or use CorsAuthenticator object<KAIGYO>//in QNetworkAccessManager the signal cannot be connected to a queued signal, because it waits for the signal to return': 3, '//TODO: test for valid control frames<KAIGYO>//DONE: test for valid close codes<KAIGYO>//DONE: test close frame with no close code and reason<KAIGYO>//DONE: test invalid UTF8 sequences<KAIGYO>//DONE: test invalid UTF8 sequences in control/close frames<KAIGYO>//DONE: test for invalid fields<KAIGYO>//DONE: test for invalid opcodes<KAIGYO>//DONE: test continuation frames for too big payload<KAIGYO>//DONE: test continuation frames for too small frame<KAIGYO>//DONE: test continuation frames for bad rsv fields, etc.<KAIGYO>//DONE: test continuation frames for incomplete payload<KAIGYO>//DONE: test close frame with payload length 1 (is either 0, if no close code, or at least 2, close code + optional reason)<KAIGYO>//DONE: besides spying on errors, we should also check if the frame and message signals are not emitted (or partially emitted)<KAIGYO>//void goodControlFrame();': 3}",1.0,{}
438,67855.0,7.0,58.0,34.0,MERGED,True,https://codereview.qt-project.org/#/c/67855,Add support for BB10 input method framework,1.0,{},0.0,"{'/** TODO:<KAIGYO>    Support inputMethodHints to restrict input (needs additional features in IMF).<KAIGYO>*/': 1, ""// TODO: How can we set the cursor position it's not part of the API."": 1, '// Move the specified text into a preedit string.': 1}",1.0,{}
388,67879.0,1.0,1.0,0.0,ABANDONED,False,https://codereview.qt-project.org/#/c/67879,WIP: Compute reduced stringdata size,1.0,{},0.0,{'// TODO this algorithm is not efficient and has small succsess rate': 1},1.0,{}
394,67911.0,1.0,1.0,0.0,ABANDONED,False,https://codereview.qt-project.org/#/c/67911,Support statically linked module plugins,1.0,{'// things on the engine (eg. adding new global objects) have to be done for every<KAIGYO>// engine.<KAIGYO>// XXX protect against double initialization': 1},1.0,{'// things on the engine (eg. adding new global objects) have to be done for every <KAIGYO>// engine.  <KAIGYO>// XXX protect against double initialization': 1},1.0,{}
396,67915.0,1.0,4.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/67915,Support statically linked module plugins,1.0,{'// things on the engine (eg. adding new global objects) have to be done for every<KAIGYO>// engine.<KAIGYO>// XXX protect against double initialization': 1},1.0,{'// things on the engine (eg. adding new global objects) have to be done for every <KAIGYO>// engine.  <KAIGYO>// XXX protect against double initialization': 1},1.0,{}
7,68024.0,1.0,1.0,0.0,ABANDONED,False,https://codereview.qt-project.org/#/c/68024,Fixed failing unit tests,1.0,"{""// TODO: fails at the moment -- don't bother"": 1}",1.0,"{""// TODO: fails at the moment -- don't bother"": 1}",1.0,{}
10,68032.0,1.0,2.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/68032,Added remaining tests,1.0,{},0.0,"{'//happy flow<KAIGYO>//TODO: test valid UTF8 sequences (see UC 6.2)<KAIGYO>//TODO: test on masking correctness<KAIGYO>//TODO: test for valid fields<KAIGYO>//TODO: test if opcode is correct after processing of a continuation frame (text and binary frames)': 1, '//TODO: test valid frame sequences': 1, '//rainy-day flow<KAIGYO>//TODO: test invalid masks<KAIGYO>//TODO: test for AutoBahn testcase 5<KAIGYO>//TODO: test for AutoBahn testcase 6.1<KAIGYO>//TODO: test for AutoBahn testcase 6.3 (fragmentation test)<KAIGYO>//TODO: test for AutoBahn testcase 6.4 (fragmentation test)': 1, '//TODO: test invalid frame sequences': 1, '//TODO: qstrdup - memory leak! qstrdup is necessary because once QString goes out of scope we have garbage': 1}",1.0,{}
38,68057.0,2.0,3.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/68057,Completed unit tests for handshake request,1.0,{'//TODO: authentication field': 2},1.0,{'//TODO: authentication field': 2},1.0,{}
49,68063.0,4.0,4.0,0.0,ABANDONED,False,https://codereview.qt-project.org/#/c/68063,Replaced getter methods of HandshakeResponse to be in line with Qt,1.0,{'//TODO: should set or emit error': 1},1.0,{'//TODO: should set or emit error': 1},1.0,{}
31,68064.0,1.0,2.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/68064,Replaced getter methods of HandshakeResponse to be in line with Qt,1.0,{'//TODO: should set or emit error': 1},1.0,{'//TODO: should set or emit error': 1},1.0,{}
144,68263.0,3.0,9.0,0.0,ABANDONED,False,https://codereview.qt-project.org/#/c/68263,V4 SSA: speed up dominator calculations.,1.0,{},0.0,{'// TODO: verify this!': 1},1.0,{}
242,68505.0,5.0,10.0,10.0,MERGED,True,https://codereview.qt-project.org/#/c/68505,Menu: Extract QQuickMenuPopupWindow core popup behavior,1.0,{'// Initial mouse release counts as move.': 1},1.0,{'// Initial mouse release counts as move.': 1},1.0,{}
228,68525.0,1.0,3.0,1.0,MERGED,True,https://codereview.qt-project.org/#/c/68525,Remove old data when a query is changed to an empty or invalid object.,1.0,{},0.0,"{'//            tryCompare(modelRowCount, """", 0) TODO FIXME<KAIGYO>//            tryCompare(modelRowCount, """", initialRowCountChangedCounter + 3)TODO FIXME': 1}",1.0,{}
343,68780.0,2.0,4.0,2.0,MERGED,True,https://codereview.qt-project.org/#/c/68780,Templetaize identity tests.,1.0,{},0.0,"{'// This may be fragile, we need real network reply to catch the header.': 1}",1.0,{}
371,68838.0,1.0,4.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/68838,Remove TODOs which are outdated.,1.0,{},0.0,"{'// TODO it expects certain data structure in all objects, add way to specify roles<KAIGYO>// TODO remove as soon as we have a sparse array.<KAIGYO>// TODO remove as soon as we have a sparse array.': 1}",1.0,{}
420,68955.0,2.0,18.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/68955,qdoc: Update qdoc's QML parser,1.0,{'// ### TODO: AST for initializer': 1},1.0,{'// ### TODO: AST for initializer': 1},1.0,{}
446,68999.0,11.0,16.0,20.0,ABANDONED,False,https://codereview.qt-project.org/#/c/68999,WIP: register shadowing,1.0,"{'// FIXME: check if the value happens to be equal to MirrorMagic': 1, '// TODO: do not convert to double, but to any numeric type:': 5, '// TODO: optimize by detecting if the var is already a number.': 6, ""// TODO: optimize the cases below:<KAIGYO>//       - if either leftSource or rightSource are const, a lot of the code doesn't need to be generated.<KAIGYO>//       - if the target is a register, and is not the same as rightSource, it can be used instead of ReturnValueRegister"": 6, '// TODO: optimize by detecting if the var is a double.': 11}",1.0,{'// FIXME: This routine needs more tuning!': 1},1.0,{}
57,69036.0,3.0,7.0,1.0,MERGED,True,https://codereview.qt-project.org/#/c/69036,Use finalUrl in QQmlTypeLoader::Blob::addPragma to fix a bug.,1.0,{},0.0,{'//This should be switched over once a proper QML settings API exists': 1},1.0,{}
72,69164.0,3.0,8.0,1.0,MERGED,True,https://codereview.qt-project.org/#/c/69164,Do not byteswap RGBA8888 formats,1.0,"{'// Ideally more formats would be converted directly to an RGBA8888 format,<KAIGYO>// but we are only guaranteed to have a fast conversion to an ARGB format.': 1}",1.0,{'// Performance could be improved by skipping qgl_byteSwapImage().': 1},1.0,{}
137,69223.0,15.0,45.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/69223,Propagate bool/int/double/string types from QML into the IR,1.0,{},0.0,"{'// TODO: for QML, try to do a static lookup': 1}",1.0,{}
105,69250.0,1.0,8.0,9.0,ABANDONED,False,https://codereview.qt-project.org/#/c/69250,Delete the readFromBuffer() from the QSerialPortPrivate,1.0,{},0.0,{'// TODO: Implement me': 1},1.0,{}
110,69253.0,5.0,16.0,18.0,ABANDONED,False,https://codereview.qt-project.org/#/c/69253,Create separate instance for each notifier,1.0,"{'// Workaround for standard CDC ACM serial ports, for which triggered an<KAIGYO>// unexpected event EV_TXEMPTY at data transmission.': 1}",1.0,"{'// Workaround for standard CDC ACM serial ports, for which triggered an<KAIGYO>// unexpected event EV_TXEMPTY at data transmission.': 1}",1.0,{}
173,69300.0,2.0,2.0,0.0,ABANDONED,False,https://codereview.qt-project.org/#/c/69300,WIP: make setUnifiedTitleAndToolBarOn Mac work again,1.0,"{""// TODO: add the QToolBar's QWidgets to the Mac toolbar once it supports this"": 1}",1.0,"{'// Check if we REALLY need to update the geometry below. If we only have items in the<KAIGYO>// unified toolbar, all the docks will be empty, so there\'s very little point<KAIGYO>// in doing the geometry as Apple will do it (we also avoid flicker in Cocoa as well).<KAIGYO>// FWIW, layoutState.toolBarAreaLayout.visible and the state of the unified toolbar<KAIGYO>// visibility can get out of sync. I really don\'t think it\'s a big issue. It is kept<KAIGYO>// to a minimum because we only change the visibility if we absolutely must.<KAIGYO>// update the """"': 2}",1.0,{}
339,69418.0,13.0,43.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/69418,Implement loading of resolved imported scripts,1.0,"{""// TODO: We can't do fast lookup for these yet."": 1}",1.0,"{""// TODO: We can't do fast lookup for these yet."": 1}",1.0,{}
258,69429.0,2.0,7.0,9.0,MERGED,True,https://codereview.qt-project.org/#/c/69429,Modify SameGame to use QML Singleton,1.0,{},0.0,{'//This should be switched over once a proper QML settings API exists': 1},1.0,{}
208,69467.0,1.0,6.0,0.0,ABANDONED,False,https://codereview.qt-project.org/#/c/69467,Move the communication notifier handler to the QSerialPortPrivate,1.0,"{'// FIXME: here required the error processing': 1, '// Workaround for standard CDC ACM serial ports, for which triggered an<KAIGYO>// unexpected event EV_TXEMPTY at data transmission.': 1}",1.0,"{'// Workaround for standard CDC ACM serial ports, for which triggered an<KAIGYO>// unexpected event EV_TXEMPTY at data transmission.': 1}",1.0,{}
209,69468.0,2.0,12.0,0.0,ABANDONED,False,https://codereview.qt-project.org/#/c/69468,Add error handling for WaitCommEvent(),1.0,{},0.0,{'// FIXME: here required the error processing': 1},1.0,{}
250,69474.0,4.0,9.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/69474,Rework parameter handling for moth,1.0,{},0.0,{'// The non-temp case might need some tweaking for QML: there it would probably be a value instead of a local.': 1},1.0,{}
292,69652.0,3.0,4.0,0.0,ABANDONED,False,https://codereview.qt-project.org/#/c/69652,WIP: QQuickWindow: fix hover move event propagation,1.0,"{'// TODO: this must be a list of items visually stacked below, not just parents!': 2, '//TODO: accepted = d->clearHover();<KAIGYO>// TODO: optimize...': 3, '// TODO: kill the obsolete param...': 3}",1.0,"{'//move': 3, ""//Not entering a new Item<KAIGYO>// ### Shouldn't we send moves for the parent items as well?"": 3}",1.0,{}
441,69894.0,4.0,5.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/69894,Refactor QWebChannel to use a custom WebSocket server implementation.,1.0,"{'///TODO: handle?': 1, '//TODO: implement this properly - see httptools.ietf.org/html/rfc6455#page-36': 1}",1.0,{'///FIXME: this should be rewritten using a proper web socket approach': 1},1.0,{}
465,69979.0,9.0,59.0,5.0,ABANDONED,False,https://codereview.qt-project.org/#/c/69979,Add/update benchmarks for the UTF-8 codec,1.0,{},0.0,"{'// average comparison length: 9.7492<KAIGYO>// cache-line crosses: 296 (2.8%)<KAIGYO>// alignment histogram:<KAIGYO>//   0xXXX0 = 4778 (45.3%) strings, 2389 (50.0%) of which same-aligned<KAIGYO>//   0xXXX1 = 30 (0.3%) strings, 15 (50.0%) of which same-aligned<KAIGYO>//   0xXXX2 = 52 (0.5%) strings, 26 (50.0%) of which same-aligned<KAIGYO>//   0xXXX3 = 58 (0.5%) strings, 29 (50.0%) of which same-aligned<KAIGYO>//   0xXXX4 = 322 (3.1%) strings, 161 (50.0%) of which same-aligned<KAIGYO>//   0xXXX5 = 48 (0.5%) strings, 24 (50.0%) of which same-aligned<KAIGYO>//   0xXXX6 = 38 (0.4%) strings, 19 (50.0%) of which same-aligned<KAIGYO>//   0xXXX7 = 34 (0.3%) strings, 17 (50.0%) of which same-aligned<KAIGYO>//   0xXXX8 = 4882 (46.3%) strings, 2441 (50.0%) of which same-aligned<KAIGYO>//   0xXXX9 = 44 (0.4%) strings, 22 (50.0%) of which same-aligned<KAIGYO>//   0xXXXa = 56 (0.5%) strings, 28 (50.0%) of which same-aligned<KAIGYO>//   0xXXXb = 30 (0.3%) strings, 15 (50.0%) of which same-aligned<KAIGYO>//   0xXXXc = 54 (0.5%) strings, 27 (50.0%) of which same-aligned<KAIGYO>//   0xXXXd = 38 (0.4%) strings, 19 (50.0%) of which same-aligned<KAIGYO>//   0xXXXe = 42 (0.4%) strings, 21 (50.0%) of which same-aligned<KAIGYO>//   0xXXXf = 44 (0.4%) strings, 22 (50.0%) of which same-aligned<KAIGYO>//   total  = 10550 (100%) strings, 5275 (50.0%) of which same-aligned': 1, '// This is the same code as above, but for stateless UTF-8 conversion<KAIGYO>// no other improvements': 1, '// average comparison length: 17.8291<KAIGYO>// cache-line crosses: 2902 (19.8%)<KAIGYO>// alignment histogram:<KAIGYO>//   0xXXX0 = 3786 (25.8%) strings, 1893 (50.0%) of which same-aligned<KAIGYO>//   0xXXX1 = 300 (2.0%) strings, 150 (50.0%) of which same-aligned<KAIGYO>//   0xXXX2 = 430 (2.9%) strings, 215 (50.0%) of which same-aligned<KAIGYO>//   0xXXX3 = 326 (2.2%) strings, 163 (50.0%) of which same-aligned<KAIGYO>//   0xXXX4 = 450 (3.1%) strings, 225 (50.0%) of which same-aligned<KAIGYO>//   0xXXX5 = 292 (2.0%) strings, 146 (50.0%) of which same-aligned<KAIGYO>//   0xXXX6 = 220 (1.5%) strings, 110 (50.0%) of which same-aligned<KAIGYO>//   0xXXX7 = 806 (5.5%) strings, 403 (50.0%) of which same-aligned<KAIGYO>//   0xXXX8 = 1748 (11.9%) strings, 874 (50.0%) of which same-aligned<KAIGYO>//   0xXXX9 = 326 (2.2%) strings, 163 (50.0%) of which same-aligned<KAIGYO>//   0xXXXa = 320 (2.2%) strings, 160 (50.0%) of which same-aligned<KAIGYO>//   0xXXXb = 250 (1.7%) strings, 125 (50.0%) of which same-aligned<KAIGYO>//   0xXXXc = 2506 (17.1%) strings, 1253 (50.0%) of which same-aligned<KAIGYO>//   0xXXXd = 1128 (7.7%) strings, 564 (50.0%) of which same-aligned<KAIGYO>//   0xXXXe = 1400 (9.5%) strings, 700 (50.0%) of which same-aligned<KAIGYO>//   0xXXXf = 376 (2.6%) strings, 188 (50.0%) of which same-aligned<KAIGYO>//   total  = 14664 (100%) strings, 7332 (50.0%) of which same-aligned': 4}",1.0,{}
195,70289.0,4.0,27.0,3.0,MERGED,True,https://codereview.qt-project.org/#/c/70289,"Revert ""Add tracing to logging framework""",1.0,{},0.0,"{'// Both aspects and the base class could be combined into<KAIGYO>// a single tracer serving both purposes, but are split<KAIGYO>// here for clarity.': 1}",1.0,{}
138,70291.0,1.0,3.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/70291,Fix fullscreen support with GStreamer,1.0,{},0.0,{'// FIXME: Port to Qt 5.': 1},1.0,{}
140,70316.0,1.0,3.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/70316,Add QWebSocketConfiguration to pre-cache socket settings,1.0,{'//for more efficient string concatenation': 1},1.0,{'//for more efficient string concatenation': 1},1.0,{}
251,70523.0,1.0,3.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/70523,Sanitize include directives,1.0,{'//for more efficient string concatenation': 1},1.0,{'//for more efficient string concatenation': 1},1.0,{}
270,70530.0,6.0,15.0,3.0,MERGED,True,https://codereview.qt-project.org/#/c/70530,Use direct access to the read buffer,1.0,{},0.0,{'// TODO: Implement me': 2},1.0,{}
291,70564.0,3.0,4.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/70564,"Cleanup sources, mostly by removing QtCreator generated bloat.",1.0,{},0.0,{'# The .cpp file which was generated for your project. Feel free to hack it.': 1},1.0,{}
297,70664.0,1.0,3.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/70664,Migrate Enginio replies private classes to QObjectPrivate concept,1.0,"{'// FIXME it is ugly, and breaks encapsulation': 1}",1.0,"{'// FIXME it is ugly, and breaks encapsulation': 1}",1.0,{}
388,70849.0,1.0,1.0,0.0,ABANDONED,False,https://codereview.qt-project.org/#/c/70849,V4 interpreter: remove stack-slot allocator.,1.0,{},0.0,"{'// TODO: extend to optimize out temp-to-temp moves, where the lifetime of one temp ends at that statement.<KAIGYO>//       To handle that, add a hint when such a move will occur, and add a stmt for the hint.<KAIGYO>//       Then when asked for a register, check if the active statement is the terminating statement, and if so, apply the hint.<KAIGYO>//       This generalises the hint usage for Phi removal too, when the phi is passed in there as the current statement.': 1}",1.0,{}
418,70906.0,1.0,4.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/70906,V4 interpreter: remove stack-slot allocator.,1.0,{},0.0,"{'// TODO: extend to optimize out temp-to-temp moves, where the lifetime of one temp ends at that statement.<KAIGYO>//       To handle that, add a hint when such a move will occur, and add a stmt for the hint.<KAIGYO>//       Then when asked for a register, check if the active statement is the terminating statement, and if so, apply the hint.<KAIGYO>//       This generalises the hint usage for Phi removal too, when the phi is passed in there as the current statement.': 1}",1.0,{}
449,70957.0,4.0,25.0,1.0,MERGED,True,https://codereview.qt-project.org/#/c/70957,V4 SSA: speed up dominator calculations.,1.0,{},0.0,{'// TODO: verify this!': 1},1.0,{}
170,71387.0,2.0,20.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/71387,Remove QMacStyle titlebar height + 4 adjustment and consequences,1.0,{},0.0,"{'// ### Remove this after the mac style has been fixed': 1, '// ### Fix mac style, the +4 pixels hack is not necessary anymore': 1, '// ### Remove this after mac style has been fixed': 2}",1.0,{}
158,71405.0,1.0,3.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/71405,Make code a bit more verbose.,1.0,{},0.0,{'// FIXME it is ugly': 1},1.0,{}
222,71531.0,1.0,1.0,0.0,ABANDONED,False,https://codereview.qt-project.org/#/c/71531,Remove QMacStyle titlebar height + 4 adjustment and consequences,1.0,{},0.0,"{'// ### Remove this after the mac style has been fixed': 1, '// ### Fix mac style, the +4 pixels hack is not necessary anymore': 1, '// ### Remove this after mac style has been fixed': 1}",1.0,{}
227,71547.0,2.0,2.0,0.0,DEFERRED,False,https://codereview.qt-project.org/#/c/71547,WIP: Rework hover event propagation,1.0,"{'//TODO: accepted = d->clearHover();<KAIGYO>// TODO: optimize...': 1, '// TODO: kill the obsolete param...': 1, '// TODO: optimize...': 2}",1.0,"{'//move': 1, ""//Not entering a new Item<KAIGYO>// ### Shouldn't we send moves for the parent items as well?"": 1, '//take care of any exits': 2}",1.0,{}
273,71593.0,5.0,20.0,48.0,MERGED,True,https://codereview.qt-project.org/#/c/71593,Use the signals/slots for internal events handling on Windows,1.0,"{'// Workaround for standard CDC ACM serial ports, for which triggered an<KAIGYO>// unexpected event EV_TXEMPTY at data transmission.': 1}",1.0,"{'// Workaround for standard CDC ACM serial ports, for which triggered an<KAIGYO>// unexpected event EV_TXEMPTY at data transmission.': 1}",1.0,{}
346,71829.0,3.0,25.0,3.0,MERGED,True,https://codereview.qt-project.org/#/c/71829,QNX: avoid composition when possible,1.0,{},0.0,"{""// Blend the window with Source Over Porter-Duff behavior onto whatever's<KAIGYO>// behind it.<KAIGYO>//<KAIGYO>// If the desired use-case is opaque, the Widget painting framework will<KAIGYO>// already fill in the alpha channel with full opacity."": 1}",1.0,{}
393,71871.0,13.0,33.0,25.0,ABANDONED,False,https://codereview.qt-project.org/#/c/71871,Use the QWinOverlappedIoNotifier instead of the QWinEventNotifier,1.0,"{'// Workaround for standard CDC ACM serial ports, for which triggered an<KAIGYO>// unexpected event EV_TXEMPTY at data transmission.': 1, '// FIXME !!!': 7}",1.0,"{'// Workaround for standard CDC ACM serial ports, for which triggered an<KAIGYO>// unexpected event EV_TXEMPTY at data transmission.': 1}",1.0,{}
357,71880.0,2.0,9.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/71880,Don't store the QSGNode pointer,1.0,{'//TODO: Staggered loading (as emitted)': 1},1.0,{'//TODO: Staggered loading (as emitted)': 1},1.0,{}
44,72048.0,4.0,15.0,1.0,MERGED,True,https://codereview.qt-project.org/#/c/72048,Add support for accelerated property access to QML types and namespace support,1.0,"{'// TODO: remember the index and replace with subscript later.': 1, ""// TODO: Propagate singleton information, so that it is loaded // through the singleton getter in the run-time. Until then we // can't accelerate access :("": 1, '// Make sure the run-time loads this through the more efficient singleton getter.': 1}",1.0,"{""// TODO: We can't do fast lookup for these yet."": 1}",1.0,{}
174,72145.0,6.0,30.0,6.0,MERGED,True,https://codereview.qt-project.org/#/c/72145,Remove the unnecessary and noisy comments for the serial port info files,1.0,"{'// TODO: Obtain more information': 4, '// FIXME: Obtain more information': 4}",1.0,"{""// Q_OS_MAC<KAIGYO>// TODO: Implement me.<KAIGYO>// Platform 'pseudo' bus for legacy device.<KAIGYO>// Skip this devices because this type of subsystem does<KAIGYO>// not include a real physical serial device."": 4, ""// White list for devices without a parent<KAIGYO>// USB bus type<KAIGYO>// Append this devices and try get additional information about them.<KAIGYO>// PNP bus type<KAIGYO>// Append this device.<KAIGYO>// FIXME: How to get additional information about serial devices<KAIGYO>// with this subsystem?<KAIGYO>// Platform 'pseudo' bus for legacy device.<KAIGYO>// Skip this devices because this type of subsystem does<KAIGYO>// not include a real physical serial device."": 4, '// Others types of subsystems.<KAIGYO>// Append this devices because we believe that any other types of<KAIGYO>// subsystems provide a real serial devices. For example, for devices<KAIGYO>// such as ttyGSx, its driver provide an empty subsystem name, but it<KAIGYO>// devices is a real physical serial devices.<KAIGYO>// FIXME: How to get additional information about serial devices<KAIGYO>// with this subsystems?<KAIGYO>// Devices without a parent<KAIGYO>// Bluetooth device<KAIGYO>// Check for an unsigned decimal integer at the end of the device name: """"<KAIGYO>// devices with negative and invalid numbers in the name are rejected<KAIGYO>// Q_OS_MAC': 4, ""// Q_OS_MAC<KAIGYO>// Here for other *nix OS.<KAIGYO>// TODO: Implement me.<KAIGYO>// Platform 'pseudo' bus for legacy device.<KAIGYO>// Skip this devices because this type of subsystem does<KAIGYO>// not include a real physical serial device."": 5, '// Q_OS_MAC<KAIGYO>// Here for other *nix OS.<KAIGYO>// TODO: Implement me.<KAIGYO>// Platform \'pseudo\' bus for legacy device.<KAIGYO>// Skip this devices because this type of subsystem does<KAIGYO>// not include a real physical serial device.<KAIGYO>// unknown types of devices<KAIGYO>// White list for devices without a parent<KAIGYO>// USB bus type<KAIGYO>// Append this devices and try get additional information about them.<KAIGYO>// PNP bus type<KAIGYO>// Append this device.<KAIGYO>// FIXME: How to get additional information about serial devices<KAIGYO>// with this subsystem?<KAIGYO>// Platform \'pseudo\' bus for legacy device.<KAIGYO>// Skip this devices because this type of subsystem does<KAIGYO>// not include a real physical serial device.<KAIGYO>// Others types of subsystems.<KAIGYO>// Append this devices because we believe that any other types of<KAIGYO>// subsystems provide a real serial devices. For example, for devices<KAIGYO>// such as ttyGSx, its driver provide an empty subsystem name, but it<KAIGYO>// devices is a real physical serial devices.<KAIGYO>// FIXME: How to get additional information about serial devices<KAIGYO>// with this subsystems?<KAIGYO>// Devices without a parent<KAIGYO>// Bluetooth device<KAIGYO>// Check for an unsigned decimal integer at the end of the device name: """"<KAIGYO>// devices with negative and invalid numbers in the name are rejected<KAIGYO>// Q_OS_MAC': 6}",1.0,{}
46,72145.0,6.0,30.0,6.0,MERGED,True,https://codereview.qt-project.org/#/c/72145,Remove the unnecessary and noisy comments for the serial port info files,1.0,"{'// TODO: Obtain more information': 4, '// FIXME: Obtain more information': 4}",1.0,"{""// Q_OS_MAC // TODO: Implement me. // Platform 'pseudo' bus for legacy device. // Skip this devices because this type of subsystem does // not include a real physical serial device."": 4, ""// White list for devices without a parent // USB bus type // Append this devices and try get additional information about them. // PNP bus type // Append this device. // FIXME: How to get additional information about serial devices // with this subsystem? // Platform 'pseudo' bus for legacy device. // Skip this devices because this type of subsystem does // not include a real physical serial device."": 4, '// Others types of subsystems. // Append this devices because we believe that any other types of // subsystems provide a real serial devices. For example, for devices // such as ttyGSx, its driver provide an empty subsystem name, but it // devices is a real physical serial devices. // FIXME: How to get additional information about serial devices // with this subsystems? // Devices without a parent // Bluetooth device // Check for an unsigned decimal integer at the end of the device name: ""rfcomm0"", ""rfcomm15"" // devices with negative and invalid numbers in the name are rejected // Q_OS_MAC': 4, ""// Q_OS_MAC // Here for other *nix OS. // TODO: Implement me. // Platform 'pseudo' bus for legacy device. // Skip this devices because this type of subsystem does // not include a real physical serial device."": 5, '// Q_OS_MAC // Here for other *nix OS. // TODO: Implement me. // Platform \'pseudo\' bus for legacy device. // Skip this devices because this type of subsystem does // not include a real physical serial device. // unknown types of devices // White list for devices without a parent // USB bus type // Append this devices and try get additional information about them. // PNP bus type // Append this device. // FIXME: How to get additional information about serial devices // with this subsystem? // Platform \'pseudo\' bus for legacy device. // Skip this devices because this type of subsystem does // not include a real physical serial device. // Others types of subsystems. // Append this devices because we believe that any other types of // subsystems provide a real serial devices. For example, for devices // such as ttyGSx, its driver provide an empty subsystem name, but it // devices is a real physical serial devices. // FIXME: How to get additional information about serial devices // with this subsystems? // Devices without a parent // Bluetooth device // Check for an unsigned decimal integer at the end of the device name: ""rfcomm0"", ""rfcomm15"" // devices with negative and invalid numbers in the name are rejected // Q_OS_MAC': 6}",1.0,{}
74,72147.0,5.0,16.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/72147,"Eliminate the ""canAppendToList"" variable usage",1.0,{},0.0,{'// TODO: Implement me.': 1},1.0,{}
23,72147.0,5.0,16.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/72147,"Eliminate the ""canAppendToList"" variable usage",1.0,{},0.0,{'// TODO: Implement me.': 1},1.0,{}
30,72173.0,4.0,9.0,4.0,MERGED,True,https://codereview.qt-project.org/#/c/72173,"Implemented QNX API for device ""connected"" status",1.0,{},0.0,{'//TODO: implement': 1},1.0,{}
94,72173.0,4.0,9.0,4.0,MERGED,True,https://codereview.qt-project.org/#/c/72173,"Implemented QNX API for device ""connected"" status",1.0,{},0.0,{'//TODO: implement': 1},1.0,{}
146,72298.0,3.0,9.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/72298,Move EnginioModelBase::Roles to Enginio::Roles,1.0,"{'// TODO Use a proper name, can we make it an attached property in qml? Does it make sense to try?': 1}",1.0,"{'// TODO Use a proper name, can we make it an attached property in qml? Does it make sense to try?': 1}",1.0,{}
34,72298.0,3.0,9.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/72298,Move EnginioModelBase::Roles to Enginio::Roles,1.0,"{'// TODO Use a proper name, can we make it an attached property in qml? Does it make sense to try?': 1}",1.0,"{'// TODO Use a proper name, can we make it an attached property in qml? Does it make sense to try?': 1}",1.0,{}
222,72300.0,8.0,13.0,3.0,MERGED,True,https://codereview.qt-project.org/#/c/72300,Improve the Canvas threading model,1.0,"{""        /* When rendering happens on the render thread, the fbo's texture is<KAIGYO>         * used directly for display. If we are on the GUI thread or a<KAIGYO>         * dedicated Canvas render thread, we need to decouple the FBO from<KAIGYO>         * the texture we are displaying in the SG rendering thread to avoid<KAIGYO>         * stalls and read/write issues in the GL pipeline as the FBO's texture<KAIGYO>         * could then potentially be used in different threads.<KAIGYO>         *<KAIGYO>         * We could have gotten away with only one display texture, but this<KAIGYO>         * would have implied that beginPainting would have to wait for SG<KAIGYO>         * to release that texture.<KAIGYO>         */"": 4, '//TODO: generate shadow blur with shaders': 6}",1.0,{'//TODO: generate shadow blur with shaders': 6},1.0,{}
36,72300.0,8.0,13.0,3.0,MERGED,True,https://codereview.qt-project.org/#/c/72300,Improve the Canvas threading model,1.0,{'//TODO: generate shadow blur with shaders': 6},1.0,{'//TODO: generate shadow blur with shaders': 6},1.0,{}
25,72443.0,2.0,6.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/72443,ComboBox: Call resolveTextValue() after any model change,1.0,{},0.0,{'// FIXME The use-case before this change should work.': 1},1.0,{}
201,72443.0,2.0,6.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/72443,ComboBox: Call resolveTextValue() after any model change,1.0,{},0.0,{'// FIXME The use-case before this change should work.': 1},1.0,{}
1,72518.0,1.0,5.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/72518,"Revert ""Qt Designer: Temporarily disable loading of QDeclarativeView plugin.""",1.0,{},0.0,{'// ###fixme: Temporary workaround for QTCREATORBUG-10273': 1},1.0,{}
220,72518.0,1.0,5.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/72518,"Revert ""Qt Designer: Temporarily disable loading of QDeclarativeView plugin.""",1.0,{},0.0,{'// ###fixme: Temporary workaround for QTCREATORBUG-10273': 1},1.0,{}
357,72796.0,4.0,9.0,15.0,MERGED,True,https://codereview.qt-project.org/#/c/72796,Update EnginioClient docs,1.0,{},0.0,"{'// TODO it creates a finished EnginioReplyBase, there will be no finished signal<KAIGYO>// TODO does ereply leak? Yes potentially. We need to think about the ownership': 2, '// TODO it creates a finished EnginioReplyState, there will be no finished signal<KAIGYO>// TODO does ereply leak? Yes potentially. We need to think about the ownership': 3}",1.0,{}
51,72796.0,4.0,9.0,15.0,MERGED,True,https://codereview.qt-project.org/#/c/72796,Update EnginioClient docs,1.0,{},0.0,"{'// TODO it creates a finished EnginioReplyBase, there will be no finished signal // TODO does ereply leak? Yes potentially. We need to think about the ownership': 2, '// TODO it creates a finished EnginioReplyState, there will be no finished signal // TODO does ereply leak? Yes potentially. We need to think about the ownership': 3}",1.0,{}
53,72798.0,3.0,4.0,0.0,ABANDONED,False,https://codereview.qt-project.org/#/c/72798,Improve the Canvas threading model.,1.0,{'//TODO: generate shadow blur with shaders': 1},1.0,{'//TODO: generate shadow blur with shaders': 1},1.0,{}
376,72798.0,3.0,4.0,0.0,ABANDONED,False,https://codereview.qt-project.org/#/c/72798,Improve the Canvas threading model.,1.0,"{'//TODO: generate shadow blur with shaders': 1, ""        /* When rendering happens on the render thread, the fbo's texture is<KAIGYO>         * used directly for display. If we are on the GUI thread or a<KAIGYO>         * dedicated Canvas render thread, we need to decouple the FBO from<KAIGYO>         * the texture we are displaying in the SG rendering thread to avoid<KAIGYO>         * stalls and read/write issues in the GL pipeline as the FBO's texture<KAIGYO>         * could then potentially be used in different threads.<KAIGYO>         *<KAIGYO>         * We could have gotten away with only one display texture, but this<KAIGYO>         * would have implied that beginPainting would have to wait for SG<KAIGYO>         * to release that texture.<KAIGYO>         */"": 1}",1.0,{'//TODO: generate shadow blur with shaders': 1},1.0,{}
424,72801.0,4.0,12.0,6.0,MERGED,True,https://codereview.qt-project.org/#/c/72801,Remove our forked version of QGridLayoutEngine,1.0,{},0.0,"{'        /*<KAIGYO>            Even for styles that define a uniform spacing, we cheat a<KAIGYO>            bit and use the window margin as the spacing. This<KAIGYO>            significantly improves the look of dialogs.<KAIGYO>        */': 1}",1.0,{}
416,72836.0,2.0,5.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/72836,Rename EnginioReplyBase to EnginioReplyState,1.0,"{'// TODO it creates a finished EnginioReplyState, there will be no finished signal': 1}",1.0,"{'// TODO it creates a finished EnginioReplyBase, there will be no finished signal': 1}",1.0,{}
5,72836.0,2.0,5.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/72836,Rename EnginioReplyBase to EnginioReplyState,1.0,"{'// TODO it creates a finished EnginioReplyState, there will be no finished signal': 1}",1.0,"{'// TODO it creates a finished EnginioReplyBase, there will be no finished signal': 1}",1.0,{}
137,73134.0,5.0,42.0,23.0,MERGED,True,https://codereview.qt-project.org/#/c/73134,QNX: Fix focus handling for secondary screen,1.0,{},0.0,"{'// TODO: Tell screen to set keyboard focus to this window.<KAIGYO>// Notify that we gained focus.': 1, '// TODO: Tell screen to set keyboard focus to this window.': 2}",1.0,{}
114,73183.0,2.0,6.0,5.0,ABANDONED,False,https://codereview.qt-project.org/#/c/73183,QPrinter - Clean up Print Engine Key defaults and tests,1.0,"{'// TODO Add value preservation support by using local variable': 1, '// TODO Add support using DEVMODE.dmDuplex': 1, '// The following keys are properties and settings that are supported by the Windows PrintEngine<KAIGYO>// The following keys are settings that are unsupported by the Windows PrintEngine<KAIGYO>// Return sensible default values to ensure consistent behaviour across platforms<KAIGYO>// TODO Add support using DEVMODE.dmCollate to match setting': 1, '// Test default<KAIGYO>// TODO Printer specific, need QPrinterInfo::colorMode()<KAIGYO>//QCOMPARE(native.colorMode(), QPrinter::Color);': 1, '// Test default<KAIGYO>// TODO Printer specific, need QPrinterInfo::duplex()<KAIGYO>//QCOMPARE(native.duplex(), QPrinter::DuplexNone);': 1, '// Test default<KAIGYO>// TODO Printer specific, need QPrinterInfo::duplex()<KAIGYO>//QCOMPARE(native.doubleSidedPrinting(), false);': 1, '// Test default<KAIGYO>// TODO Printer specific, need QPrinterInfo::orientation()<KAIGYO>//QCOMPARE(native.orientation(), QPrinter::Portrait);': 1, '// Test default<KAIGYO>// TODO Printer specific, need QPrinterInfo::paperSize()<KAIGYO>//QCOMPARE(native.pageSize(), QPrinter::A4);': 1, '// Test default<KAIGYO>// TODO Printer specific, need QPrinterInfo::paperSize()<KAIGYO>//QCOMPARE(native.paperSize(), QPrinter::A4);': 1, '// Test default<KAIGYO>// TODO Printer specific, need QPrinterInfo::paperSource()<KAIGYO>//QCOMPARE(native.paperSource(), QPrinter::Auto);': 1, ""// printerSelectionOption() / setPrinterSelectionOption() / PPK_SelectionOption<KAIGYO>// PdfFormat: Supported<KAIGYO>// NativeFormat, Cups: Supported<KAIGYO>// NativeFormat, Win: Unsupported, ifdef'd out TODO remove ifdef, always QString()<KAIGYO>// NativeFormat, Mac: Unsupported, always QString()"": 1, '// Test default<KAIGYO>// TODO Printer specific, need QPrinterInfo::resolution()<KAIGYO>//QCOMPARE(native.resolution(), 300);': 1, ""// supportedPaperSources() / PPK_PaperSources<KAIGYO>// PdfFormat: ifdef'd out TODO remove ifdef<KAIGYO>// NativeFormat, Cups: ifdef'd out TODO remove ifdef<KAIGYO>// NativeFormat, Win: Supported, defaults to printer default<KAIGYO>// NativeFormat, Mac: ifdef'd out TODO remove ifdef"": 1, ""// winPageSize() / setWinPageSize() / PPK_WindowsPageSize<KAIGYO>// PdfFormat: ifdef'd out TODO remove ifdef<KAIGYO>// NativeFormat, Cups: ifdef'd out TODO remove ifdef<KAIGYO>// NativeFormat, Win: Supported, defaults to printer default<KAIGYO>// NativeFormat, Mac: ifdef'd out TODO remove ifdef"": 1, '// The following keys are properties and settings that are supported by the Windows PrintEngine<KAIGYO>// The following keys are settings that are unsupported by the Windows PrintEngine<KAIGYO>// Return sensible default values to ensure consistent behavior across platforms<KAIGYO>// TODO Add support using DEVMODE.dmCollate to match setting': 2}",1.0,{'// TODO: Correct?': 1},1.0,{}
253,73486.0,6.0,34.0,7.0,ABANDONED,False,https://codereview.qt-project.org/#/c/73486,Retain bind port when QUdpSocket::connectToHost is called,1.0,{'// hope that the next address is better': 1},1.0,{'// hope that the next address is better': 1},1.0,{}
373,73526.0,10.0,29.0,15.0,MERGED,True,https://codereview.qt-project.org/#/c/73526,Rewrite the Mac native toolbar classes.,1.0,{'// ### hackety hack': 4},1.0,"{'// ### hackety hack': 4, '//### TODO- re-implement': 4}",1.0,{}
343,73538.0,17.0,28.0,4.0,ABANDONED,False,https://codereview.qt-project.org/#/c/73538,Improve TableView performance by caching row-delegates,1.0,"{'// these properties are exposed to the row delegate<KAIGYO>// Note: these properties should be mirrored in the row filler as well': 1, '//    property var crap: Rectangle {<KAIGYO>//        parent: listView.parent.parent<KAIGYO>//        color: """"<KAIGYO>//        width: 100<KAIGYO>//        anchors.right: parent.right<KAIGYO>//        height: parent.height<KAIGYO>//        ListView {<KAIGYO>//            anchors.fill: parent<KAIGYO>//            model: listView.itemCount<KAIGYO>//            delegate: Rectangle {<KAIGYO>//                height: 20<KAIGYO>//                width: parent.width<KAIGYO>//                Text { text: index }<KAIGYO>//                color: listView.cacheIndex == index  ? """"<KAIGYO>//            }<KAIGYO>//        }<KAIGYO>//    }': 4, '// move forward or backward in cache': 5, '// move the rowItem back in cache': 11}",1.0,{'// these properties are exposed to the row delegate<KAIGYO>// Note: these properties should be mirrored in the row filler as well': 1},1.0,{}
311,73650.0,1.0,3.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/73650,Fix broken Maroon game / regression in PropertyChanges {} element,1.0,{},0.0,{'// ### TODO': 1},1.0,{}
348,73734.0,1.0,3.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/73734,Android: Initiate and monitor pairing requests,1.0,{},0.0,{'//TODO': 1},1.0,{}
386,73746.0,2.0,5.0,2.0,MERGED,True,https://codereview.qt-project.org/#/c/73746,Restructure sources and assimilate to Qt module structure.,1.0,{'# TODO: running tests without requiring make install': 1},1.0,"{""/// TODO: test with C++ methods that don't take a QVariant as arg<KAIGYO>///       also test conversions"": 1}",1.0,{}
411,73761.0,7.0,7.0,0.0,ABANDONED,False,https://codereview.qt-project.org/#/c/73761,Interface for Javascript profiler,1.0,{},0.0,"{'// ### FIXME: v4': 1, '// ### FIXME: v4<KAIGYO>//    void takeSnapshot(v8::HeapSnapshot::Type);<KAIGYO>//    void printProfileTree(const v8::CpuProfileNode *node, int level = 0);<KAIGYO>//    void sendMessages();<KAIGYO>//    v8::Handle<v8::String> v8title = v8::String::New(reinterpret_cast<const uint16_t*>(title.data()), title.size());<KAIGYO>// ### FIXME: v4<KAIGYO>//    v8::CpuProfiler::StartProfiling(v8title);': 1, '//    Q_D(QV4ProfilerService);<KAIGYO>// ### FIXME: v4<KAIGYO>//    d->takeSnapshot(v8::HeapSnapshot::kFull);<KAIGYO>// ### FIXME: v4<KAIGYO>//    v8::HeapProfiler::DeleteAllSnapshots();<KAIGYO>//    Q_D(QV4ProfilerService);<KAIGYO>// ### FIXME: v4<KAIGYO>//    d->sendMessages();': 1, '// ### FIXME: v4<KAIGYO>//    void takeSnapshot(v8::HeapSnapshot::Type);<KAIGYO>//    void printProfileTree(const v8::CpuProfileNode *node, int level = 0);<KAIGYO>//    void sendMessages();': 2, '//    v8::Handle<v8::String> v8title = v8::String::New(reinterpret_cast<const uint16_t*>(title.data()), title.size());<KAIGYO>// ### FIXME: v4<KAIGYO>//    v8::CpuProfiler::StartProfiling(v8title);': 2, '//    Q_D(QV4ProfilerService);<KAIGYO>// ### FIXME: v4<KAIGYO>//    d->takeSnapshot(v8::HeapSnapshot::kFull);': 2, '// ### FIXME: v4<KAIGYO>//    v8::HeapProfiler::DeleteAllSnapshots();<KAIGYO>//    Q_D(QV4ProfilerService);<KAIGYO>// ### FIXME: v4<KAIGYO>//    d->sendMessages();': 2}",1.0,{}
399,73825.0,2.0,4.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/73825,Android: Implement pairing/pin notifications and acceptance,1.0,{},0.0,{'//TODO': 1},1.0,{}
404,73869.0,2.0,9.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/73869,Merge remote-tracking branch 'origin/release' into stable,1.0,{'// FIXME: Obtain more information': 2},1.0,"{""// PNP bus type<KAIGYO>// Append this device.<KAIGYO>// FIXME: How to get additional information about serial devices<KAIGYO>// with this subsystem?<KAIGYO>// Platform 'pseudo' bus for legacy device.<KAIGYO>// Skip this devices because this type of subsystem does<KAIGYO>// not include a real physical serial device."": 1, '// Others types of subsystems.<KAIGYO>// Append this devices because we believe that any other types of<KAIGYO>// subsystems provide a real serial devices. For example, for devices<KAIGYO>// such as ttyGSx, its driver provide an empty subsystem name, but it<KAIGYO>// devices is a real physical serial devices.<KAIGYO>// FIXME: How to get additional information about serial devices<KAIGYO>// with this subsystems?': 1, ""// FIXME: Obtain more information<KAIGYO>// PNP bus type<KAIGYO>// Append this device.<KAIGYO>// FIXME: How to get additional information about serial devices<KAIGYO>// with this subsystem?<KAIGYO>// Platform 'pseudo' bus for legacy device.<KAIGYO>// Skip this devices because this type of subsystem does<KAIGYO>// not include a real physical serial device."": 2}",1.0,{}
459,73961.0,8.0,34.0,3.0,MERGED,True,https://codereview.qt-project.org/#/c/73961,Merge qMemEquals and ucstrncmp,1.0,{},0.0,"{'// Benchmarking indicates that doing memcmp is much slower than<KAIGYO>// executing the comparison ourselves.<KAIGYO>//<KAIGYO>// The profiling was done on a population of calls to qMemEquals, generated<KAIGYO>// during a run of the demo browser. The profile of the data (32-bit x86<KAIGYO>// Linux) was:<KAIGYO>//<KAIGYO>//  total number of comparisons: 21353<KAIGYO>//  longest string compared: 95<KAIGYO>//  average comparison length: 14.8786<KAIGYO>//  cache-line crosses: 5661 (13.3%)<KAIGYO>//  alignment histogram:<KAIGYO>//   0xXXX0 = 512 (1.2%) strings, 0 (0.0%) of which same-aligned<KAIGYO>//   0xXXX2 = 15087 (35.3%) strings, 5145 (34.1%) of which same-aligned<KAIGYO>//   0xXXX4 = 525 (1.2%) strings, 0 (0.0%) of which same-aligned<KAIGYO>//   0xXXX6 = 557 (1.3%) strings, 6 (1.1%) of which same-aligned<KAIGYO>//   0xXXX8 = 509 (1.2%) strings, 0 (0.0%) of which same-aligned<KAIGYO>//   0xXXXa = 24358 (57.0%) strings, 9901 (40.6%) of which same-aligned<KAIGYO>//   0xXXXc = 557 (1.3%) strings, 0 (0.0%) of which same-aligned<KAIGYO>//   0xXXXe = 601 (1.4%) strings, 15 (2.5%) of which same-aligned<KAIGYO>//   total  = 42706 (100%) strings, 15067 (35.3%) of which same-aligned<KAIGYO>//<KAIGYO>// 92% of the strings have alignment of 2 or 10, which is due to malloc on<KAIGYO>// 32-bit Linux returning values aligned to 8 bytes, and offsetof(array, QString::Data) == 18.<KAIGYO>//<KAIGYO>// The profile on 64-bit will be different since offsetof(array, QString::Data) == 26.<KAIGYO>//<KAIGYO>// The benchmark results were, for a Core-i7 @ 2.67 GHz 32-bit, compiled with -O3 -funroll-loops:<KAIGYO>//   16-bit loads only:           872,301 CPU ticks [Qt 4.5 / memcmp]<KAIGYO>//   32- and 16-bit loads:        773,362 CPU ticks [Qt 4.6]<KAIGYO>//   SSE2 """" 128-bit loads: 618,736 CPU ticks<KAIGYO>//   SSE3 """" 128-bit loads:  619,954 CPU ticks<KAIGYO>//   SSSE3 """" corrections: 852,147 CPU ticks<KAIGYO>//   SSE4.2 """":          738,702 CPU ticks<KAIGYO>//<KAIGYO>// The same benchmark on an Atom N450 @ 1.66 GHz, is:<KAIGYO>//  16-bit loads only:            2,185,882 CPU ticks<KAIGYO>//  32- and 16-bit loads:         1,805,060 CPU ticks<KAIGYO>//  SSE2 """" 128-bit loads:  2,529,843 CPU ticks<KAIGYO>//  SSE3 """" 128-bit loads:   2,514,858 CPU ticks<KAIGYO>//  SSSE3 """" corrections:  2,160,325 CPU ticks<KAIGYO>//  SSE4.2 not available<KAIGYO>//<KAIGYO>// The conclusion we reach is that alignment the SSE2 unaligned code can gain<KAIGYO>// 20% improvement in performance in some systems, but suffers a penalty due<KAIGYO>// to the unaligned loads on others.': 1}",1.0,{}
473,73982.0,8.0,39.0,27.0,MERGED,True,https://codereview.qt-project.org/#/c/73982,OS X QSettings auto test/writing check update,1.0,"{""// work around what seems to be a bug in CFPreferences:<KAIGYO>// don't report an error if there are no preferences for the application"": 5}",1.0,"{""// work around what seems to be a bug in CFPreferences:<KAIGYO>// don't report an error if there are no preferences for the application"": 5}",1.0,{}
476,73995.0,6.0,26.0,1.0,MERGED,True,https://codereview.qt-project.org/#/c/73995,Rework array handling for JS objects,1.0,{'// ### FIXME': 4},1.0,"{'// ### FIXME': 4, '// ### FIXME: We need to allocate the array data to avoid crashes other places<KAIGYO>// This should rather be done when required': 4}",1.0,{}
31,74021.0,2.0,7.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/74021,Android: QBluetoothDeviceDiscoveryAgent implementation,1.0,{'//TODO change to new error enum InvalidBluetoothAdapterError': 1},1.0,"{'void DeviceDiscoveryBroadcastReceiver::onReceive(JNIEnv *env, jobject /*context*/, jobject intent)<KAIGYO>    __android_log_print(ANDROID_LOG_DEBUG,"""");<KAIGYO>    // Cannot be static unfortunately because Android moves memory around now.<KAIGYO>    /*static */': 1, '//TODO: remove/shift function': 1, '//TODO': 1, '//    JNIThreadHelper env;<KAIGYO>//    jmethodID isDiscoveringID = env->GetMethodID(btAdapterClass, """");<KAIGYO>//    jboolean ret = env->CallBooleanMethod(btAdapterObject, isDiscoveringID);<KAIGYO>//    return ret;<KAIGYO>//TODO': 1}",1.0,{}
114,74051.0,2.0,7.0,1.0,MERGED,True,https://codereview.qt-project.org/#/c/74051,Use QLoggingCategory to categorize the various debug output streams,1.0,{'//TODO Try if this actually works': 1},1.0,{'//TODO Try if this actually works': 1},1.0,{}
199,74066.0,33.0,45.0,4.0,MERGED,True,https://codereview.qt-project.org/#/c/74066,FileDialog: new features in DefaultFileDialog.qml,1.0,"{'// TODO actual row implicit height': 1, '// TODO                    showFiles: !root.selectFolder': 1, '// TODO should not need to create a whole new component just to customize the text value<KAIGYO>// TODO something like textFormat: function(text) { return view.model.get(styleData.row, """" : text }': 1, '// TODO should not need to create a whole new component just to customize the text value<KAIGYO>// something like textFormat: function(text) { return view.model.get(styleData.row, """" : text }': 27}",1.0,{'// TODO: QTBUG-29817 geometry from AbstractFileDialog': 1},1.0,{}
136,74281.0,1.0,3.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/74281,Port MetaObjectPublisher benchmarks to C++.,1.0,{},0.0,"{'    /**<KAIGYO>     * Given a QVariant containing a QObject*, wrap the object and register for property updates<KAIGYO>     * return the objects class information.<KAIGYO>     *<KAIGYO>     * All other input types are returned as-is.<KAIGYO>     *<KAIGYO>     * TODO: support wrapping of initially-registered objects<KAIGYO>     */': 1}",1.0,{}
344,74348.0,7.0,30.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/74348,Add optimizations,1.0,{},0.0,"{'//TODO: create a QByteArray from message, and directly call doWriteFrames<KAIGYO>//now the data is converted to a string, and then converted back to a bytearray': 1, '//TODO: really necessary?': 1}",1.0,{}
209,74385.0,2.0,7.0,7.0,ABANDONED,False,https://codereview.qt-project.org/#/c/74385,Remove all code related with the policies processing,1.0,{},0.0,"{'// TODO: Implement me': 1, '// FIXME: Maybe need disable read notifier?': 1}",1.0,{}
216,74392.0,5.0,18.0,33.0,MERGED,True,https://codereview.qt-project.org/#/c/74392,Refactor ICNS plugin to prepare it for icon variants support,1.0,"{'// TODO: Add parsing of png/jp2 headers to enable feature reporting by plugin?': 1, '// We have a formula mismatch in a 32bit icon there, probably RLE24': 1}",1.0,{'// TODO: Add parsing of png/jp2 headers to enable feature reporting by plugin?': 1},1.0,{}
234,74446.0,1.0,3.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/74446,Optimize: Use property-indices instead of names for notifications.,1.0,{},0.0,{'// TODO: use property indices': 1},1.0,{}
264,74451.0,2.0,5.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/74451,Simplify usage of QWebChannel on the server side.,1.0,"{'// TODO: can we get rid of the int <-> string conversions here?': 1, '// TODO: wrap (new) objects on the fly': 1}",1.0,"{'// TODO: can we get rid of the int <-> string conversions here?': 1, '// TODO: wrap (new) objects on the fly': 1}",1.0,{}
307,74555.0,1.0,4.0,0.0,ABANDONED,False,https://codereview.qt-project.org/#/c/74555,Move ArrayData class into it's own file,1.0,{'// ### FIXME': 1},1.0,{'// ### FIXME': 1},1.0,{}
490,74587.0,13.0,36.0,19.0,ABANDONED,False,https://codereview.qt-project.org/#/c/74587,Unify calls to profiler service event methods.,1.0,{},0.0,"{'/*<KAIGYO>    Either send the message directly, or queue up<KAIGYO>    a list of messages to send later (via sendMessages)<KAIGYO>*/': 4}",1.0,{}
388,74625.0,3.0,3.0,0.0,ABANDONED,False,https://codereview.qt-project.org/#/c/74625,Hide more of the implementation details of ArrayData,1.0,{},0.0,{'// ### FIXME: We need to allocate the array data to avoid crashes other places<KAIGYO>// This should rather be done when required': 3},1.0,{}
355,74648.0,2.0,19.0,9.0,MERGED,True,https://codereview.qt-project.org/#/c/74648,QNX: Expand on Virtual Keyboard Support,1.0,{},0.0,"{'// HUGE hack, should be removed ASAP.<KAIGYO>// We want to ignore the 8 pixel shadow above the keyboard. (PR 88400)': 1, '// Huge hack for keyboard shadow (see QNX PR 88400). Should be removed ASAP.': 2}",1.0,{}
374,74674.0,2.0,7.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/74674,Adapt to Qt coding style,1.0,"{'//TODO: waitForReadyRead should really be changed<KAIGYO>//now, when a websocket is used in a GUI thread<KAIGYO>//the GUI will hang for at most 5 seconds<KAIGYO>//maybe, a QStateMachine should be used': 1}",1.0,"{'//TODO: waitForReadyRead should really be changed<KAIGYO>//now, when a websocket is used in a GUI thread<KAIGYO>//the GUI will hang for at most 5 seconds<KAIGYO>//maybe, a QStateMachine should be used': 1}",1.0,{}
375,74692.0,1.0,11.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/74692,WinRT: Clean up core event dispatcher,1.0,{},0.0,{'// ###TODO: is there any thing to wake up?': 1},1.0,{}
407,74742.0,2.0,5.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/74742,Remove workaround for ownership issue with newly created tabs,1.0,{},0.0,"{""// 'loader' parent is a pending workaround while waiting for:<KAIGYO>// httpscodereview.qt-project.org/#change,65788"": 1}",1.0,{}
417,74753.0,1.0,1.0,0.0,ABANDONED,False,https://codereview.qt-project.org/#/c/74753,Move ArrayData::reserve() into the array vtable.,1.0,{'// ### FIXME': 1},1.0,{'// ### FIXME': 1},1.0,{}
496,74867.0,5.0,8.0,10.0,ABANDONED,False,https://codereview.qt-project.org/#/c/74867,Javascript profiler for V4,1.0,"{'//TODO: synchronize timers if possible': 1, '//TODO: synchronize with QML profiler timer if possible': 4}",1.0,"{'// ### FIXME: v4': 1, '// ### FIXME: v4<KAIGYO>//    void takeSnapshot(v8::HeapSnapshot::Type);<KAIGYO>//    void printProfileTree(const v8::CpuProfileNode *node, int level = 0);<KAIGYO>//    void sendMessages();': 1, '//    v8::Handle<v8::String> v8title = v8::String::New(reinterpret_cast<const uint16_t*>(title.data()), title.size());<KAIGYO>// ### FIXME: v4<KAIGYO>//    v8::CpuProfiler::StartProfiling(v8title);': 1, '//    Q_D(QV4ProfilerService);<KAIGYO>// ### FIXME: v4<KAIGYO>//    d->takeSnapshot(v8::HeapSnapshot::kFull);': 1, '// ### FIXME: v4<KAIGYO>//    v8::HeapProfiler::DeleteAllSnapshots();<KAIGYO>//    Q_D(QV4ProfilerService);<KAIGYO>// ### FIXME: v4<KAIGYO>//    d->sendMessages();': 1}",1.0,{}
45,75116.0,1.0,1.0,0.0,ABANDONED,False,https://codereview.qt-project.org/#/c/75116,WIP: other patches,1.0,{},0.0,{'// ### FIXME': 1},1.0,{}
60,75128.0,4.0,14.0,1.0,MERGED,True,https://codereview.qt-project.org/#/c/75128,Mac: Implement unified toolbar look for QTabBar,1.0,"{'// Extend the unified title and toolbar area to cover the tab bar iff<KAIGYO>// 1) the tab bar is in document mode<KAIGYO>// 2) the tab bar is directly below an """" area.<KAIGYO>// The extending itself is done in the Cocoa platform plugin and Mac style,<KAIGYO>// this function registers geometry and visibility state for the tab bar.<KAIGYO>// Calculate geometry': 3}",1.0,"{'// TODO: get metrics to preserve the bottom value<KAIGYO>// TODO: test tab bar position': 2, ""// In Cocoa we need to keep track of the drawRect method.<KAIGYO>// If documentMode is enabled we need to change it, unless<KAIGYO>// a toolbar is present.<KAIGYO>// Notice that all the information is kept in the window,<KAIGYO>// that's why we get the private widget for it instead of<KAIGYO>// the private widget for this widget."": 2, '// Since in Cocoa there is no simple way to remove the baseline, so we just ask the<KAIGYO>// top level to do the magic for us.': 2}",1.0,{}
68,75147.0,4.0,20.0,8.0,ABANDONED,False,https://codereview.qt-project.org/#/c/75147,Share strings in moc generated output.,1.0,"{'// This is the first time we read string data, we need to construct the string index.<KAIGYO>// The index is a hash from bytearray to its position in the generated string table.<KAIGYO>// The position consists of two variables: index in the table and offset if<KAIGYO>// the bytearray could be expressed as a suffix of a longer array.<KAIGYO>// TODO This algorithm is quite complex in terms of O notation complexity We can improve<KAIGYO>// it in many ways like storing strings in buckets or sorting not only by length<KAIGYO>// but also by suffix content.': 1}",1.0,{'// TODO we need to add +1 because the class name has to be the first string': 3},1.0,{}
71,75148.0,4.0,13.0,3.0,MERGED,True,https://codereview.qt-project.org/#/c/75148,Do not assume that a class name is the first string in metaobject.,1.0,{},0.0,{'// TODO we need to add +1 because the class name has to be the first string': 1},1.0,{}
88,75149.0,3.0,6.0,2.0,ABANDONED,False,https://codereview.qt-project.org/#/c/75149,Extract StringTable class from Generator in moc.,1.0,"{'// This is the first time we read string data, we need to construct the string index.<KAIGYO>// The index is a hash from bytearray to its position in the generated string table.<KAIGYO>// The position consists of two variables: index in the table and offset if<KAIGYO>// the bytearray could be expressed as a suffix of a longer array.<KAIGYO>// TODO This algorithm is quite complex in terms of O notation complexity We can improve<KAIGYO>// it in many ways like storing strings in buckets or sorting not only by length<KAIGYO>// but also by suffix content.': 1}",1.0,"{'// This is the first time we read string data, we need to construct the string index.<KAIGYO>// The index is a hash from bytearray to its position in the generated string table.<KAIGYO>// The position consists of two variables: index in the table and offset if<KAIGYO>// the bytearray could be expressed as a suffix of a longer array.<KAIGYO>// TODO This algorithm is quite complex in terms of O notation complexity We can improve<KAIGYO>// it in many ways like storing strings in buckets or sorting not only by length<KAIGYO>// but also by suffix content.': 1}",1.0,{}
169,75235.0,4.0,10.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/75235,Update the Unicode Data and Algorithms up to Unicode 6.3.0,1.0,{'//    Other      CR       LF    Newline   Extend    RI    Katakana HLetter  ALetter  SQuote   DQuote  MidNumLet MidLetter MidNum  Numeric  ExtendNumLet<KAIGYO>// Other<KAIGYO>// CR<KAIGYO>// LF<KAIGYO>// Newline<KAIGYO>// Extend<KAIGYO>// RegionalIndicator<KAIGYO>// Katakana<KAIGYO>// HebrewLetter<KAIGYO>// ALetter<KAIGYO>// SingleQuote<KAIGYO>// DoubleQuote<KAIGYO>// MidNumLet<KAIGYO>// MidLetter<KAIGYO>// MidNum<KAIGYO>// Numeric<KAIGYO>// ExtendNumLet<KAIGYO>// we keep the pre-5.1 behavior by remapping these characters in the Unicode tables generator<KAIGYO>// and this code is needed to pass the coverage tests; remove once the issue is fixed.': 1},1.0,{'//    Other      CR       LF    Newline   Extend    RI    Katakana ALetter MidNumLet MidLetter MidNum  Numeric  ExtendNumLet<KAIGYO>// Other<KAIGYO>// CR<KAIGYO>// LF<KAIGYO>// Newline<KAIGYO>// Extend<KAIGYO>// RegionalIndicator<KAIGYO>// Katakana<KAIGYO>// ALetter<KAIGYO>// MidNumLet<KAIGYO>// MidLetter<KAIGYO>// MidNum<KAIGYO>// Numeric<KAIGYO>// ExtendNumLet<KAIGYO>// by remapping those characters in the Unicode tables generator.<KAIGYO>// this code is needed to pass the coverage tests; remove once the issue is fixed.': 1},1.0,{}
286,75451.0,5.0,6.0,0.0,ABANDONED,False,https://codereview.qt-project.org/#/c/75451,WIP: QGtk3StylePlugin,1.0,"{'// TODO: GdkRectangle gtkCliprect = {0, 0, rect.width(), rect.height()};': 1, '// TODO: &gtkCliprect,': 1, '// Note the widget arg should ideally use the widget path, though would compromise performance': 2, '// TODO:<KAIGYO>//        QApplicationPrivate::setSystemPalette(standardPalette());<KAIGYO>//        QApplicationPrivate::setSystemFont(d->getThemeFont());': 2, '// Drawing the entire itemview frame is very expensive, especially on the native X11 engine<KAIGYO>// Instead we cheat a bit and draw a border image without the center part, hence only scaling<KAIGYO>// thin rectangular images': 2, '// ### this mess should move to subcontrolrect': 2, '// See httpsbugzilla.mozilla.org/show_bug.cgi?id=405421 for info about this hack': 2, '// TODO: ifndef QT_NO_COMBOBOX': 2, '// TODO:<KAIGYO>//    case CC_Dial:<KAIGYO>//        if (const QStyleOptionSlider *dial = qstyleoption_cast<const QStyleOptionSlider *>(option))<KAIGYO>//            QStyleHelper::drawDial(dial, painter);<KAIGYO>//        break;': 2, '// Since Qt does not currently allow filling the entire background<KAIGYO>// we use a hack for this by making a complete menubar each time and<KAIGYO>// paint with the correct offset inside it. Pixmap caching should resolve<KAIGYO>// most of the performance penalty.': 2, '// """" is actually hardcoded and fails on hardy (see gtk+-2.12/gtkmenuitem.c)<KAIGYO>// though the current documentation states otherwise': 2, '// Workaround for bug in QProgressBar': 2, '// adjust the font and add the difference in size.<KAIGYO>// it would be better if the font could be adjusted in the initStyleOption qmenu func!!': 2, '// This file is responsible for resolving all GTK functions we use<KAIGYO>// dynamically. This is done to avoid link-time dependancy on GTK<KAIGYO>// as well as crashes occurring due to usage of the GTK_QT engines<KAIGYO>//<KAIGYO>// Additionally we create a map of common GTK widgets that we can pass<KAIGYO>// to the GTK theme engine as many engines resort to querying the<KAIGYO>// actual widget pointers for details that are not covered by the<KAIGYO>// state flags': 2, ""// the following is necessary to work around breakage in many versions<KAIGYO>// of XFree86's Xlib.h still in use<KAIGYO>// ### which versions?<KAIGYO>// crude hack, but..."": 2, '// Only do this the first time since this will also<KAIGYO>// generate applicationPaletteChange events<KAIGYO>// TODO:<KAIGYO>//        if (!qt_app_palettes_hash() ||  qt_app_palettes_hash()->isEmpty()) {<KAIGYO>//            stylePrivate->applyCustomPaletteHash();<KAIGYO>//        }': 2, '// TODO:<KAIGYO>//    static QString oldTheme(QLS(""""));<KAIGYO>//    QPixmapCache::clear();': 2, '// This file is responsible for resolving all GTK functions we use<KAIGYO>// dynamically. This is done to avoid link-time dependency on GTK<KAIGYO>// as well as crashes occurring due to usage of the GTK_QT engines<KAIGYO>//<KAIGYO>// Additionally we create a map of common GTK widgets that we can pass<KAIGYO>// to the GTK theme engine as many engines resort to querying the<KAIGYO>// actual widget pointers for details that are not covered by the<KAIGYO>// state flags': 5}",1.0,{'// TODO: choose between gtk2 and gtk3': 1},1.0,{}
299,75452.0,4.0,18.0,0.0,ABANDONED,False,https://codereview.qt-project.org/#/c/75452,Add/update benchmarks for ucstrncmp,1.0,{},0.0,"{'// average comparison length: 12.0922<KAIGYO>// cache-line crosses: 6 (2.1%)<KAIGYO>// alignment histogram:<KAIGYO>//   0xXXX2 = 188 (66.7%) strings, 57 (30.3%) of which same-aligned<KAIGYO>//   0xXXXa = 94 (33.3%) strings, 10 (10.6%) of which same-aligned<KAIGYO>//   total  = 282 (100%) strings, 67 (23.8%) of which same-aligned': 1, ""// yes, so we mustn't do the final 128-bit load"": 1}",1.0,{}
244,75516.0,1.0,3.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/75516,don't turn = into += in cumulative mode,1.0,"{'// FIXME: add check+warning about accidental value removal.<KAIGYO>// This may be a bit too noisy, though.': 1}",1.0,"{'// FIXME: add check+warning about accidental value removal.<KAIGYO>// This may be a bit too noisy, though.': 1}",1.0,{}
246,75518.0,1.0,5.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/75518,don't turn = into += in cumulative mode,1.0,"{'// FIXME: add check+warning about accidental value removal.<KAIGYO>// This may be a bit too noisy, though.': 1}",1.0,"{'// FIXME: add check+warning about accidental value removal.<KAIGYO>// This may be a bit too noisy, though.': 1}",1.0,{}
284,75547.0,4.0,22.0,0.0,ABANDONED,False,https://codereview.qt-project.org/#/c/75547,Remove some magic code,1.0,{},0.0,{'//  it is way too hardcore for me :) !<KAIGYO>//    QPoint screenOffset(geometry().topLeft());<KAIGYO>//    for (int rectIndex = 0; rectIndex < m_repaintRegion.rectCount(); rectIndex++) {<KAIGYO>//        QRegion rectRegion = rects[rectIndex];<KAIGYO>//        for (int i = 0; i < m_cachedRects.length(); i++) {<KAIGYO>//            QRect screenSubRect = m_cachedRects[i].first;<KAIGYO>//            int layer = m_cachedRects[i].second;<KAIGYO>//            QRegion intersect = rectRegion.intersected(screenSubRect);': 1},1.0,{}
283,75554.0,4.0,4.0,0.0,DEFERRED,False,https://codereview.qt-project.org/#/c/75554,WIP: Windows: Handle WM_ENDSESSION from hook.,1.0,"{'// we receive the message for each toplevel window included internal hidden ones,<KAIGYO>// but the aboutToQuit signal should be emitted only once.': 1}",1.0,"{'// we receive the message for each toplevel window included internal hidden ones,<KAIGYO>// but the aboutToQuit signal should be emitted only once.': 1}",1.0,{}
274,75562.0,1.0,6.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/75562,[new compiler] Add support for type and enum resolution for custom parsers,1.0,{},0.0,"{'// Similar logic to above, but not knowing target property.': 1}",1.0,{}
395,75738.0,4.0,14.0,7.0,MERGED,True,https://codereview.qt-project.org/#/c/75738,Unify calls to profiler service event methods.,1.0,{},0.0,"{'/*<KAIGYO>    Either send the message directly, or queue up<KAIGYO>    a list of messages to send later (via sendMessages)<KAIGYO>*/': 1}",1.0,{}
397,75771.0,4.0,10.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/75771,Add a SimpleArrayData class,1.0,{},0.0,{'// ### FIXME': 1},1.0,{}
385,75786.0,1.0,3.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/75786,Merge remote-tracking branch 'origin/stable' into dev,1.0,{},0.0,{'// TODO: QTBUG-29817 geometry from AbstractFileDialog': 1},1.0,{}
446,75899.0,1.0,11.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/75899,Merge remote-tracking branch 'origin/stable' into dev,1.0,{},0.0,"{'        /*<KAIGYO>            Even for styles that define a uniform spacing, we cheat a<KAIGYO>            bit and use the window margin as the spacing. This<KAIGYO>            significantly improves the look of dialogs.<KAIGYO>        */': 1}",1.0,{}
463,75959.0,2.0,23.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/75959,QNX: Fixed window opacity,1.0,{},0.0,"{'// TODO: How to handle children of this window? If we change all the visibilities, then<KAIGYO>//       the transparency will look wrong...': 1}",1.0,{}
476,75975.0,2.0,11.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/75975,QPrinter - Clean up Print Engine Key defaults and tests,1.0,"{'// TODO Add value preservation support by using local variable': 1, '// TODO Add support using DEVMODE.dmDuplex': 1, '// The following keys are settings that are unsupported by the Windows PrintEngine<KAIGYO>// Return sensible default values to ensure consistent behavior across platforms<KAIGYO>// TODO Add support using DEVMODE.dmCollate to match setting': 1, '// Test default<KAIGYO>// TODO Printer specific, need QPrinterInfo::colorMode()<KAIGYO>//QCOMPARE(native.colorMode(), QPrinter::Color);': 1, '// Test default<KAIGYO>// TODO Printer specific, need QPrinterInfo::duplex()<KAIGYO>//QCOMPARE(native.duplex(), QPrinter::DuplexNone);': 1, '// Test default<KAIGYO>// TODO Printer specific, need QPrinterInfo::duplex()<KAIGYO>//QCOMPARE(native.doubleSidedPrinting(), false);': 1, '// Test default<KAIGYO>// TODO Printer specific, need QPrinterInfo::orientation()<KAIGYO>//QCOMPARE(native.orientation(), QPrinter::Portrait);': 1, '// Test default<KAIGYO>// TODO Printer specific, need QPrinterInfo::paperSize()<KAIGYO>//QCOMPARE(native.pageSize(), QPrinter::A4);': 1, '// Test default<KAIGYO>// TODO Printer specific, need QPrinterInfo::paperSize()<KAIGYO>//QCOMPARE(native.paperSize(), QPrinter::A4);': 1, '// Test default<KAIGYO>// TODO Printer specific, need QPrinterInfo::paperSource()<KAIGYO>//QCOMPARE(native.paperSource(), QPrinter::Auto);': 1, ""// printerSelectionOption() / setPrinterSelectionOption() / PPK_SelectionOption<KAIGYO>// PdfFormat: Supported<KAIGYO>// NativeFormat, Cups: Supported<KAIGYO>// NativeFormat, Win: Unsupported, ifdef'd out TODO remove ifdef, always QString()<KAIGYO>// NativeFormat, Mac: Unsupported, always QString()"": 1, '// Test default<KAIGYO>// TODO Printer specific, need QPrinterInfo::resolution()<KAIGYO>//QCOMPARE(native.resolution(), 300);': 1, ""// supportedPaperSources() / PPK_PaperSources<KAIGYO>// PdfFormat: ifdef'd out TODO remove ifdef<KAIGYO>// NativeFormat, Cups: ifdef'd out TODO remove ifdef<KAIGYO>// NativeFormat, Win: Supported, defaults to printer default<KAIGYO>// NativeFormat, Mac: ifdef'd out TODO remove ifdef"": 1, ""// winPageSize() / setWinPageSize() / PPK_WindowsPageSize<KAIGYO>// PdfFormat: ifdef'd out TODO remove ifdef<KAIGYO>// NativeFormat, Cups: ifdef'd out TODO remove ifdef<KAIGYO>// NativeFormat, Win: Supported, defaults to printer default<KAIGYO>// NativeFormat, Mac: ifdef'd out TODO remove ifdef"": 1}",1.0,{'// TODO: Correct?': 1},1.0,{}
480,75977.0,3.0,12.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/75977,QPrintEngine - Fix PPK_CollateCopies,1.0,{},0.0,{'// TODO Add support using DEVMODE.dmCollate to match setting': 1},1.0,{}
477,75978.0,3.0,12.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/75978,QPrintEngne - Fix PPK_Creator,1.0,{},0.0,{'// TODO Add value preservation support by using local variable': 1},1.0,{}
483,75979.0,3.0,12.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/75979,QPrinter - Fix Printer Selection option on Windows,1.0,{},0.0,"{""// NativeFormat, Win: Unsupported, ifdef'd out TODO remove ifdef, always QString()"": 1}",1.0,{}
492,75991.0,11.0,53.0,64.0,MERGED,True,https://codereview.qt-project.org/#/c/75991,[QNX] Introduce proper screen error handling,1.0,{'// Move window to proper screen/display': 1},1.0,{'// Move window to proper screen/display': 1},1.0,{}
14,76037.0,2.0,8.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/76037,Use pkg-config to find the prefix for X11 install,1.0,{},0.0,"{'// AFAICT there is no way to know the exact location<KAIGYO>// of the compose files. It depends on how Xlib was configured<KAIGYO>// on a specific platform. During the """" process<KAIGYO>// xlib generates a config.h file which contains a bunch of defines,<KAIGYO>// including XLOCALEDIR which points to the location of the compose file dir.': 2}",1.0,{}
27,76067.0,1.0,1.0,0.0,ABANDONED,False,https://codereview.qt-project.org/#/c/76067,Use pkg-config to find the prefix for X11 install,1.0,{},0.0,"{'// AFAICT there is no way to know the exact location<KAIGYO>// of the compose files. It depends on how Xlib was configured<KAIGYO>// on a specific platform. During the """" process<KAIGYO>// xlib generates a config.h file which contains a bunch of defines,<KAIGYO>// including XLOCALEDIR which points to the location of the compose file dir.': 1}",1.0,{}
67,76083.0,3.0,4.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/76083,Add grid line functionality.,1.0,{'// TODO: fix the reason behind + 1 stopping the flickableness..<KAIGYO>// might have something to do with the header': 1},1.0,{'// TODO: fix the reason behind + 1 stopping the flickableness..<KAIGYO>// might have something to do with the header': 1},1.0,{}
78,76181.0,2.0,11.0,6.0,MERGED,True,https://codereview.qt-project.org/#/c/76181,Remove an unnecessary boolean interim variable,1.0,"{'// TODO: Obtain more information': 2, '// TODO: Obtain more information about the device': 2}",1.0,"{'// TODO: Obtain more information': 2, '// TODO: Obtain more information about the device': 2}",1.0,{}
79,76201.0,1.0,4.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/76201,Use setNSToolbar from the cocoa platform plugin,1.0,{'// ### hackety hack': 1},1.0,{'// ### hackety hack': 1},1.0,{}
177,76394.0,1.0,3.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/76394,Use new InvalidBluetoothAdapterError where appropriate,1.0,{},0.0,{'//TODO change to new error enum InvalidBluetoothAdapterError': 1},1.0,{}
220,76395.0,3.0,5.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/76395,Android: First working QBluetoothSocket implementation.,1.0,"{'//TODO use setSocketError<KAIGYO>//TODO use setSocketError': 1, '//TODO Convert uuid paramter to const reference (affects QNX too)': 1, '//TODO this is bad, we need proper blocking detection': 2, '//TODO implement buffered behavior (so far only unbuffered)<KAIGYO>//TODO check that readData and writeData return -1 on error (on all platforms)': 2, '//TODO Convert uuid parameter to const reference (affects QNX too)': 3}",1.0,{'// TODO: is this all we need to do?': 2},1.0,{}
189,76397.0,1.0,7.0,3.0,MERGED,True,https://codereview.qt-project.org/#/c/76397,Use a fake directory model instead of QDirModel in item view tests.,1.0,"{""// for empty directories (no way to go 'right'), next one should move down"": 1}",1.0,{'// next one should move down': 1},1.0,{}
378,76469.0,23.0,50.0,24.0,MERGED,True,https://codereview.qt-project.org/#/c/76469,Infrastructure for supporting multiple profilers in qqmlprofilerservice,1.0,"{'// TODO: This is pretty barren. We probably want to have names for the engines.': 2, ""// We need to wake the engines waiting on registration also if they aren't supposed to start<KAIGYO>// profiling right away."": 6, '// No need to lock here. If any engine or global profiler is still trying to register at this<KAIGYO>// point we have a nasty bug anyway.': 22}",1.0,{'// TODO: This is problematic as the service could be enabled at a later point in time. In that<KAIGYO>//       case we might miss the callback registration.': 12},1.0,{}
442,76471.0,19.0,34.0,5.0,MERGED,True,https://codereview.qt-project.org/#/c/76471,Move QtQuick profiling to own profiler adapter,1.0,{},0.0,{'// TODO: This is problematic as the service could be enabled at a later point in time. In that<KAIGYO>//       case we might miss the callback registration.': 13},1.0,{}
284,76601.0,1.0,1.0,0.0,ABANDONED,False,https://codereview.qt-project.org/#/c/76601,WIP Optimize registry property access,1.0,{},0.0,{'// TODO: error handling with GetLastError': 1},1.0,{}
356,76721.0,6.0,14.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/76721,Move Direct2D paint engine on top of QPaintEngineEx,1.0,"{'// TODO: reduce code duplication between painterPathToPathGeometry and vectorPathToID2D1PathGeometry': 3, '// XXX reduce code duplication between painterPathToPathGeometry and<KAIGYO>// vectorPathToID2D1PathGeometry, the two are quite similar': 5, '// XXX are we choosing the right d2d interpolation modes?': 5, '// XXX Are we generating a lot of cache misses here?': 5, '// XXX Should we negate the y value like for static text items?': 5}",1.0,"{""// Try to fit Qt's and Direct2D's idea of zero length line<KAIGYO>// handling together nicely."": 1, '// XXX': 1}",1.0,{}
492,76732.0,30.0,145.0,71.0,MERGED,True,https://codereview.qt-project.org/#/c/76732,Dynamic GL switch on Windows,1.0,"{'// TODO: Consider matching GL_APPLE_texture_format_BGRA8888 as well, but it needs testing.': 1, '// be nice to people who mix OpenGL 1.x code with QPainter commands<KAIGYO>// by setting modelview and projection matrices to mirror the GL 1<KAIGYO>// paint engine': 3, '/*!<KAIGYO>  Returns the platform-specific handle for the OpenGL implementation that<KAIGYO>  is currently in use. (for example, a HMODULE on Windows)<KAIGYO><KAIGYO>  On platforms that do not use dynamic GL switch the return value is null.<KAIGYO><KAIGYO>  The library might be GL-only, meaning that windowing system interface<KAIGYO>  functions (for example EGL) may live in another, separate library.<KAIGYO><KAIGYO>  Always use platformGLType() before resolving any functions to check if the<KAIGYO>  library implements desktop OpenGL or OpenGL ES.<KAIGYO><KAIGYO>  \\sa platformGLType()<KAIGYO> */': 5, '/*!<KAIGYO>  Returns the platform-specific handle for the OpenGL implementation that<KAIGYO>  is currently in use. (for example, a HMODULE on Windows)<KAIGYO><KAIGYO>  On platforms that do not use dynamic GL switch the return value is null.<KAIGYO><KAIGYO>  The library might be GL-only, meaning that windowing system interface<KAIGYO>  functions (for example EGL) may live in another, separate library.<KAIGYO><KAIGYO>  Always use platformGLType() before resolving any functions to check if the<KAIGYO>  library implements desktop OpenGL or OpenGL ES.<KAIGYO><KAIGYO>  \\sa platformGLType()<KAIGYO><KAIGYO>  \\since 5.3<KAIGYO> */': 9}",1.0,"{'// TODO: Consider matching GL_APPLE_texture_format_BGRA8888 as well, but it needs testing.': 1, '// be nice to people who mix OpenGL 1.x code with QPainter commands<KAIGYO>// by setting modelview and projection matrices to mirror the GL 1<KAIGYO>// paint engine': 3, '// ####TODO Properly #ifdef this class to use #define symbols actually defined<KAIGYO>// by OpenGL/ES includes': 4}",1.0,{}
415,76866.0,5.0,15.0,2.0,ABANDONED,False,https://codereview.qt-project.org/#/c/76866,Add explicit error handling for some simple methods,1.0,{},0.0,{'// FIXME:': 2},1.0,{}
489,76912.0,21.0,44.0,8.0,ABANDONED,False,https://codereview.qt-project.org/#/c/76912,QPrintEngine - Switch Windows to QPlatformPrintDevice,1.0,"{'// TODO Do we need to check if the page size is valid on new printer?': 1, '// TODO Bypass direct compare until QPageSize used in QPrinter for consistency<KAIGYO>//QCOMPARE(sizes.at(i).second, printer.paperSize(QPrinter::Millimeter));': 1, '// TODO Bypass direct compare until QPageSize used in QPrinter for consistency<KAIGYO>//QCOMPARE(printer.paperSize(QPrinter::Millimeter), customSize);': 1}",1.0,"{""// Our sizes may not match the paper name's size exactly<KAIGYO>// So we treat it as custom so we know the paper size is correct"": 1}",1.0,{}
491,76915.0,22.0,27.0,0.0,ABANDONED,False,https://codereview.qt-project.org/#/c/76915,QPrinter - Fix winPageSize() on Mac and Linux,1.0,{},0.0,"{""// PdfFormat: ifdef'd out TODO remove ifdef<KAIGYO>// NativeFormat, Cups: ifdef'd out TODO remove ifdef<KAIGYO>// NativeFormat, Mac: ifdef'd out TODO remove ifdef"": 1}",1.0,{}
15,77044.0,1.0,4.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/77044,Windows: Fixed alert sound of QMessageBox.,1.0,{},0.0,"{'        /*      ### FIXME<KAIGYO>#ifndef QT_NO_MESSAGEBOX<KAIGYO>            QMessageBox *mb = qobject_cast<QMessageBox*>(o);<KAIGYO>            if (mb) {<KAIGYO>                switch (mb->icon()) {<KAIGYO>                case QMessageBox::Warning:<KAIGYO>                    soundName = QLatin1String("""");<KAIGYO>                    break;<KAIGYO>                case QMessageBox::Critical:<KAIGYO>                    soundName = QLatin1String("""");<KAIGYO>                    break;<KAIGYO>                case QMessageBox::Information:<KAIGYO>                    soundName = QLatin1String("""");<KAIGYO>                    break;<KAIGYO>                default:<KAIGYO>                    break;<KAIGYO>                }<KAIGYO>            } else<KAIGYO>#endif // QT_NO_MESSAGEBOX<KAIGYO>*/': 1}",1.0,{}
33,77053.0,6.0,28.0,1.0,MERGED,True,https://codereview.qt-project.org/#/c/77053,V4 JIT: enable register allocator on Linux/ARM.,1.0,{},0.0,{'// ### FIXME: remove unused registers.': 1},1.0,{}
69,77075.0,9.0,27.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/77075,Improve usage of the break state for the Tx line,1.0,"{'// TODO: Implement me (it is possible?)': 1, '// TODO: Implement me (it is possible) ?': 1}",1.0,{'// FIXME:': 1},1.0,{}
71,77107.0,3.0,12.0,2.0,MERGED,True,https://codereview.qt-project.org/#/c/77107,Port code to QtWebSockets.,1.0,"{'// FIXME: client->protocol() != QStringLiteral("""")<KAIGYO>// protocols are not supported in QtWebSockets yet...': 1}",1.0,"{'///TODO: handle?': 1, '//TODO: implement this properly - see httptools.ietf.org/html/rfc6455#page-36': 1}",1.0,{}
97,77138.0,9.0,49.0,46.0,MERGED,True,https://codereview.qt-project.org/#/c/77138,Add error handling to some missing functions,1.0,{},0.0,{'// FIXME:': 1},1.0,{}
112,77168.0,4.0,17.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/77168,Remove the unused SystemIn/OutputQueue size methods,1.0,{},0.0,{'// TODO: Implement me': 1},1.0,{}
131,77211.0,1.0,1.0,0.0,ABANDONED,False,https://codereview.qt-project.org/#/c/77211,[WIP] Fix gaps shown when calendar size is not perfect.,1.0,"{""        /*<KAIGYO>            This is here instead of CalendarStyle, because the interactive<KAIGYO>            stuff shouldn't be in the style, and because the various components<KAIGYO>            of the calendar need to be anchored around the grid.<KAIGYO>            TODO: is this still the case now that we're using a repeater and the<KAIGYO>            interactive stuff is handled by the calendar itself?<KAIGYO>        */"": 1}",1.0,{'// TODO: fix the reason behind + 1 stopping the flickableness..<KAIGYO>// might have something to do with the header': 1},1.0,{}
223,77369.0,3.0,9.0,6.0,ABANDONED,False,https://codereview.qt-project.org/#/c/77369,QTimeZone - Add QTimeZoneDatabase class,1.0,"{'/*!<KAIGYO>    \\class QTimeZoneDatabase<KAIGYO>    \\inmodule QtCore<KAIGYO>    \\since 5.3<KAIGYO>    \\brief The QTimeZoneDatabase class provides a database of available IANA time zones.<KAIGYO><KAIGYO>    \\threadsafe<KAIGYO><KAIGYO>    This class provides access to a database of IANA time zones, either the system<KAIGYO>    database on platforms that ship a native IANA database, such as Linux and Mac,<KAIGYO>    or a user supplied database.  This class will be most useful for applications<KAIGYO>    on Windows that wish to use their own copy of the IANA database rather than the<KAIGYO>    native Windows time zone database.  QTimeZone objects created from this database<KAIGYO>    can then be used in the creation of QDateTime objects.<KAIGYO><KAIGYO>    The QTimeZoneDatabase instance must be created with the path to the IANA database<KAIGYO>    root directory that contains the zone.tab file listing all the available time zones<KAIGYO>    and all the region subdirectories of time zone files.  The time zone files themselves<KAIGYO>    must be in the compiled IANA file format as produced by the zic utility.<KAIGYO><KAIGYO>    No caching is implemented in this class, it is left to the application to decide on<KAIGYO>    the best caching policy to use in their circumstances.  This means repeated requests<KAIGYO>    to a QTimeZoneDatabase instance for the same IANA ID will lead to the file being<KAIGYO>    reloaded from disk every time.<KAIGYO>*/': 1, '// TODO small risk may not match if tran times differ due to outdated files<KAIGYO>// TODO Some valid TZ names are not valid ICU names, use translation table?': 1, '// TODO Assume auto tests run from either qtbase directory or from qtimezone directory': 1}",1.0,{'// TODO AnyCountry': 1},1.0,{}
258,77474.0,2.0,4.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/77474,Merge QWebChannelSocket and QWebSocketTransport.,1.0,"{'// FIXME: client->protocol() != QStringLiteral("""")<KAIGYO>// protocols are not supported in QtWebSockets yet...': 1}",1.0,"{'// FIXME: client->protocol() != QStringLiteral("""")<KAIGYO>// protocols are not supported in QtWebSockets yet...': 1}",1.0,{}
372,77543.0,6.0,12.0,8.0,MERGED,True,https://codereview.qt-project.org/#/c/77543,Unify initial waiting of debug services,1.0,{'// TODO: This is problematic as the service could be enabled at a later point in time. In that<KAIGYO>//       case we might miss the callback registration.': 1},1.0,"{'// TODO: Later wait here for initialization.<KAIGYO>// TODO: Later wait here for cleanup': 1, '// TODO: Later wait here for initialization.': 4, '// TODO: Later wait here for cleanup': 4}",1.0,{}
313,77546.0,1.0,4.0,4.0,MERGED,True,https://codereview.qt-project.org/#/c/77546,Doc: Merge duplicated example directories,1.0,{},0.0,{'// Only show the scrollbars when the view is moving.': 1},1.0,{}
325,77619.0,1.0,14.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/77619,Windows: Restore maximized/full screen widgets to correct screen.,1.0,"{'// Setting a geometry on an already maximized window causes this to be<KAIGYO>// restored into a broken, half-maximized state, non-resizable state (QTBUG-4397).<KAIGYO>// Move the window in normal state if needed.': 1}",1.0,{'// Skip on windows: the window is restored into a broken<KAIGYO>// half-maximized state.': 1},1.0,{}
362,77673.0,1.0,3.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/77673,Android: Major code cleanup and QBluetothServer support feature complete,1.0,{},0.0,"{'//This runs inside the mutex and thread.<KAIGYO>//TODO this is bad, we need proper blocking detection': 1, '//    if (!d->socket) {<KAIGYO>//        d->m_lastError = UnknownError;<KAIGYO>//        emit error(d->m_lastError);<KAIGYO>//        return;<KAIGYO>//    }<KAIGYO>//    d->socket->close();<KAIGYO>//    delete d->socket;<KAIGYO>//    d->socket = 0;<KAIGYO>//    ppsSendControlMessage("""", 0x1101, d->m_uuid, QString(), QString(), 0);<KAIGYO>//    // force active object (socket) to run and shutdown socket.<KAIGYO>//    qApp->processEvents(QEventLoop::ExcludeUserInputEvents);<KAIGYO>//TODO': 1}",1.0,{}
363,77697.0,1.0,11.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/77697,Accessibility Linux: Report Active state,1.0,{},0.0,"{'// FIXME: figure out if this is a top level window and set its active state accordingly<KAIGYO>//        if (interface->object() && interface->object()->isWidgetType()) {<KAIGYO>//            QWidget *w = qobject_cast<QWidget*>(interface->object());<KAIGYO>//            if (w->topLevelWidget() && w->isActiveWindow()) {<KAIGYO>//                setSpiStateBit(&spiState, ATSPI_STATE_ACTIVE);<KAIGYO>//            }<KAIGYO>//        }': 1}",1.0,{}
386,77709.0,6.0,42.0,0.0,ABANDONED,False,https://codereview.qt-project.org/#/c/77709,Mask rhs of shift operations in the IR for constants,1.0,{},0.0,"{'// TODO: for constants, do this in the IR': 1}",1.0,{}
408,77714.0,7.0,22.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/77714,Add ascii_isspace to replace the locale-dependent isspace(3),1.0,{},0.0,"{""//  remove the locale_t parameter (though technically we shouldn't use isspace)"": 1}",1.0,{}
426,77777.0,3.0,5.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/77777,Android: Add missing implementation for QBluetoothServer,1.0,{},0.0,"{'//Q_D(QBluetoothServer);<KAIGYO>//TODO': 1, '//d->maxPendingConnections = numConnections; //Currently not used<KAIGYO>//TODO<KAIGYO>//not used<KAIGYO>//TODO<KAIGYO>//not used': 1, '//TODO may want to support secure RFCOMM': 2}",1.0,{}
500,77791.0,5.0,24.0,11.0,ABANDONED,False,https://codereview.qt-project.org/#/c/77791,Unify glyph format between QFontEngine and QFontEngineGlyphCache,1.0,"{'// texture, which makes me think that this is a drawingiver bug.': 1}",1.0,"{'// texture, which makes me think that this is a driver bug.': 1}",1.0,{}
452,77812.0,7.0,25.0,0.0,ABANDONED,False,https://codereview.qt-project.org/#/c/77812,Move the Assembler class into it's own file,1.0,"{'/* Platform/Calling convention/Architecture specific section */<KAIGYO><KAIGYO>#if CPU(X86_64)<KAIGYO>static const Assembler::RegisterID calleeSavedRegisters[] = {<KAIGYO>    // Not used: JSC::X86Registers::rbx,<KAIGYO>    // Not used: JSC::X86Registers::r10,<KAIGYO>    JSC::X86Registers::r12, // LocalsRegister<KAIGYO>    // Not used: JSC::X86Registers::r13,<KAIGYO>    JSC::X86Registers::r14 // ContextRegister<KAIGYO>    // Not used: JSC::X86Registers::r15,<KAIGYO>};<KAIGYO>#endif<KAIGYO><KAIGYO>#if CPU(X86)<KAIGYO>static const Assembler::RegisterID calleeSavedRegisters[] = {<KAIGYO>    // Not used: JSC::X86Registers::ebx,<KAIGYO>    JSC::X86Registers::esi, // ContextRegister<KAIGYO>    JSC::X86Registers::edi  // LocalsRegister<KAIGYO>};<KAIGYO>#endif<KAIGYO><KAIGYO>#if CPU(ARM)<KAIGYO>static const Assembler::RegisterID calleeSavedRegisters[] = {<KAIGYO>    // ### FIXME: remove unused registers.<KAIGYO>    JSC::ARMRegisters::r12,<KAIGYO>    JSC::ARMRegisters::r10,<KAIGYO>    JSC::ARMRegisters::r9,<KAIGYO>    JSC::ARMRegisters::r8,<KAIGYO>    JSC::ARMRegisters::r7,<KAIGYO>    JSC::ARMRegisters::r6,<KAIGYO>    JSC::ARMRegisters::r5,<KAIGYO>    JSC::ARMRegisters::r4<KAIGYO>};<KAIGYO>#endif<KAIGYO><KAIGYO>const int Assembler::calleeSavedRegisterCount = sizeof(calleeSavedRegisters) / sizeof(calleeSavedRegisters[0]);<KAIGYO><KAIGYO>/* End of platform/calling convention/architecture specific section */': 1, '// ### FIXME: Handle through calleeSavedRegisters mechanism<KAIGYO>// or eliminate StackFrameRegister altogether.': 1, ""// Work around bug in ARMv7Assembler.h where add32(imm, sp, sp) doesn't<KAIGYO>// work well for large immediates."": 1, '/* Platform/Calling convention/Architecture specific section */<KAIGYO><KAIGYO>#if CPU(X86_64)<KAIGYO>static const Assembler::RegisterID calleeSavedRegisters[] = {<KAIGYO>    // Not used: JSC::X86Registers::rbx,<KAIGYO>    // Not used: JSC::X86Registers::r10,<KAIGYO>    JSC::X86Registers::r12, // LocalsRegister<KAIGYO>    // Not used: JSC::X86Registers::r13,<KAIGYO>    JSC::X86Registers::r14 // ContextRegister<KAIGYO>    // Not used: JSC::X86Registers::r15,<KAIGYO>};<KAIGYO>#endif<KAIGYO><KAIGYO>#if CPU(X86)<KAIGYO>static const Assembler::RegisterID calleeSavedRegisters[] = {<KAIGYO>    JSC::X86Registers::ebx, // temporary register<KAIGYO>    JSC::X86Registers::esi, // ContextRegister<KAIGYO>    JSC::X86Registers::edi  // LocalsRegister<KAIGYO>};<KAIGYO>#endif<KAIGYO><KAIGYO>#if CPU(ARM)<KAIGYO>static const Assembler::RegisterID calleeSavedRegisters[] = {<KAIGYO>    // ### FIXME: remove unused registers.<KAIGYO>    JSC::ARMRegisters::r12,<KAIGYO>    JSC::ARMRegisters::r10,<KAIGYO>    JSC::ARMRegisters::r9,<KAIGYO>    JSC::ARMRegisters::r8,<KAIGYO>    JSC::ARMRegisters::r7,<KAIGYO>    JSC::ARMRegisters::r6,<KAIGYO>    JSC::ARMRegisters::r5,<KAIGYO>    JSC::ARMRegisters::r4<KAIGYO>};<KAIGYO>#endif<KAIGYO><KAIGYO>const int Assembler::calleeSavedRegisterCount = sizeof(calleeSavedRegisters) / sizeof(calleeSavedRegisters[0]);<KAIGYO><KAIGYO>/* End of platform/calling convention/architecture specific section */': 4}",1.0,"{'/* Platform/Calling convention/Architecture specific section */<KAIGYO><KAIGYO>#if CPU(X86_64)<KAIGYO>static const Assembler::RegisterID calleeSavedRegisters[] = {<KAIGYO>    // Not used: JSC::X86Registers::rbx,<KAIGYO>    // Not used: JSC::X86Registers::r10,<KAIGYO>    JSC::X86Registers::r12, // LocalsRegister<KAIGYO>    // Not used: JSC::X86Registers::r13,<KAIGYO>    JSC::X86Registers::r14 // ContextRegister<KAIGYO>    // Not used: JSC::X86Registers::r15,<KAIGYO>};<KAIGYO>#endif<KAIGYO><KAIGYO>#if CPU(X86)<KAIGYO>static const Assembler::RegisterID calleeSavedRegisters[] = {<KAIGYO>    // Not used: JSC::X86Registers::ebx,<KAIGYO>    JSC::X86Registers::esi, // ContextRegister<KAIGYO>    JSC::X86Registers::edi  // LocalsRegister<KAIGYO>};<KAIGYO>#endif<KAIGYO><KAIGYO>#if CPU(ARM)<KAIGYO>static const Assembler::RegisterID calleeSavedRegisters[] = {<KAIGYO>    // ### FIXME: remove unused registers.<KAIGYO>    JSC::ARMRegisters::r12,<KAIGYO>    JSC::ARMRegisters::r10,<KAIGYO>    JSC::ARMRegisters::r9,<KAIGYO>    JSC::ARMRegisters::r8,<KAIGYO>    JSC::ARMRegisters::r7,<KAIGYO>    JSC::ARMRegisters::r6,<KAIGYO>    JSC::ARMRegisters::r5,<KAIGYO>    JSC::ARMRegisters::r4<KAIGYO>};<KAIGYO>#endif<KAIGYO><KAIGYO>const int Assembler::calleeSavedRegisterCount = sizeof(calleeSavedRegisters) / sizeof(calleeSavedRegisters[0]);<KAIGYO><KAIGYO>/* End of platform/calling convention/architecture specific section */': 1, '// ### FIXME: Handle through calleeSavedRegisters mechanism<KAIGYO>// or eliminate StackFrameRegister altogether.': 1, ""// Work around bug in ARMv7Assembler.h where add32(imm, sp, sp) doesn't<KAIGYO>// work well for large immediates."": 1, '/* Platform/Calling convention/Architecture specific section */<KAIGYO><KAIGYO>#if CPU(X86_64)<KAIGYO>static const Assembler::RegisterID calleeSavedRegisters[] = {<KAIGYO>    // Not used: JSC::X86Registers::rbx,<KAIGYO>    // Not used: JSC::X86Registers::r10,<KAIGYO>    JSC::X86Registers::r12, // LocalsRegister<KAIGYO>    // Not used: JSC::X86Registers::r13,<KAIGYO>    JSC::X86Registers::r14 // ContextRegister<KAIGYO>    // Not used: JSC::X86Registers::r15,<KAIGYO>};<KAIGYO>#endif<KAIGYO><KAIGYO>#if CPU(X86)<KAIGYO>static const Assembler::RegisterID calleeSavedRegisters[] = {<KAIGYO>    JSC::X86Registers::ebx, // temporary register<KAIGYO>    JSC::X86Registers::esi, // ContextRegister<KAIGYO>    JSC::X86Registers::edi  // LocalsRegister<KAIGYO>};<KAIGYO>#endif<KAIGYO><KAIGYO>#if CPU(ARM)<KAIGYO>static const Assembler::RegisterID calleeSavedRegisters[] = {<KAIGYO>    // ### FIXME: remove unused registers.<KAIGYO>    JSC::ARMRegisters::r12,<KAIGYO>    JSC::ARMRegisters::r10,<KAIGYO>    JSC::ARMRegisters::r9,<KAIGYO>    JSC::ARMRegisters::r8,<KAIGYO>    JSC::ARMRegisters::r7,<KAIGYO>    JSC::ARMRegisters::r6,<KAIGYO>    JSC::ARMRegisters::r5,<KAIGYO>    JSC::ARMRegisters::r4<KAIGYO>};<KAIGYO>#endif<KAIGYO><KAIGYO>const int Assembler::calleeSavedRegisterCount = sizeof(calleeSavedRegisters) / sizeof(calleeSavedRegisters[0]);<KAIGYO><KAIGYO>/* End of platform/calling convention/architecture specific section */': 4}",1.0,{}
443,77847.0,2.0,11.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/77847,[new compiler] Implement compile time error handling for lists,1.0,{},0.0,{'// ### TODO: list error handling': 1},1.0,{}
517,77863.0,9.0,25.0,0.0,ABANDONED,False,https://codereview.qt-project.org/#/c/77863,Move binops out of the isel,1.0,"{'// TODO: inline var===null and var!==null': 1, '// TODO?': 2}",1.0,"{'// TODO: inline var===null and var!==null': 1, '// TODO?': 2}",1.0,{}
522,77899.0,5.0,28.0,3.0,MERGED,True,https://codereview.qt-project.org/#/c/77899,QOpenGLWidget and new-style compositing on eglfs,1.0,{},0.0,{'// TODO: implement support for locking': 1},1.0,{}
523,77995.0,1.0,1.0,0.0,ABANDONED,False,https://codereview.qt-project.org/#/c/77995,Dynamic GL switch on Windows,1.0,"{'// TODO: Consider matching GL_APPLE_texture_format_BGRA8888 as well, but it needs testing.': 1, '/*!<KAIGYO>  Returns the platform-specific handle for the OpenGL implementation that<KAIGYO>  is currently in use. (for example, a HMODULE on Windows)<KAIGYO><KAIGYO>  On platforms that do not use dynamic GL switch the return value is null.<KAIGYO><KAIGYO>  The library might be GL-only, meaning that windowing system interface<KAIGYO>  functions (for example EGL) may live in another, separate library.<KAIGYO><KAIGYO>  Always use platformGLType() before resolving any functions to check if the<KAIGYO>  library implements desktop OpenGL or OpenGL ES.<KAIGYO><KAIGYO>  \\sa platformGLType()<KAIGYO><KAIGYO>  \\since 5.3<KAIGYO> */': 1, '// be nice to people who mix OpenGL 1.x code with QPainter commands<KAIGYO>// by setting modelview and projection matrices to mirror the GL 1<KAIGYO>// paint engine': 1}",1.0,"{'// ####TODO Properly #ifdef this class to use #define symbols actually defined<KAIGYO>// by OpenGL/ES includes': 1, '// TODO: Consider matching GL_APPLE_texture_format_BGRA8888 as well, but it needs testing.': 1, '// be nice to people who mix OpenGL 1.x code with QPainter commands<KAIGYO>// by setting modelview and projection matrices to mirror the GL 1<KAIGYO>// paint engine': 1}",1.0,{}
47,78028.0,11.0,55.0,28.0,MERGED,True,https://codereview.qt-project.org/#/c/78028,Implement DownloadLocation retrieving using SHGetKnownFolderPath,1.0,{},0.0,{'// TODO implement with SHGetKnownFolderPath(FOLDERID_Downloads) (starting from Vista)': 1},1.0,{}
38,78123.0,2.0,7.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/78123,Use childAt() instead of cellIndexAt().,1.0,"{'// The cell index might be valid, but the date has to be too. We could let the<KAIGYO>// selected date validation take care of this, but then the selected date would<KAIGYO>// change to the earliest day if a day before the minimum date is clicked, for example.': 1}",1.0,"{'// The cell index might be valid, but the date has to be too. We could let the<KAIGYO>// selected date validation take care of this, but then the selected date would<KAIGYO>// change to the earliest day if a day before the minimum date is clicked, for example.': 1}",1.0,{}
177,78340.0,7.0,27.0,20.0,MERGED,True,https://codereview.qt-project.org/#/c/78340,Fix some BTLE service discovery issues,1.0,"{""//TODO The device discovery doesn't seem to detect BTLE only devices. why?"": 1, '//TODO this should be bit field and not string operations': 1, '//is BLE device<KAIGYO>//TODO there is the assumption here that a BLE device cannot have std Bt service. Is that true?': 1, '//is BLE device<KAIGYO>//TODO Investigate why BLE-only devices cannot run traditional service discovery': 3}",1.0,"{'//TODO if we abort here who deletes device?<KAIGYO>//TODO what happens to still pending discoveredDevices?': 1, '//TODO this should be bit field and not String operations': 1, '//is BLE device<KAIGYO>//TODO is is not correct why finish here? We have other devices to discover...<KAIGYO>//finished signal should not be emitted by this class<KAIGYO>//Furthermore there is the assumption here that a BLE device cannot have std Bt service. Is that true?': 1}",1.0,{}
206,78501.0,2.0,21.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/78501,Mask rhs of shift operations in the IR for constants,1.0,{},0.0,"{'// TODO: for constants, do this in the IR': 1}",1.0,{}
213,78507.0,3.0,19.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/78507,Move the Assembler class into it's own file,1.0,"{'// ### FIXME: Handle through calleeSavedRegisters mechanism<KAIGYO>// or eliminate StackFrameRegister altogether.': 1, ""// Work around bug in ARMv7Assembler.h where add32(imm, sp, sp) doesn't<KAIGYO>// work well for large immediates."": 1}",1.0,"{'// ### FIXME: Handle through calleeSavedRegisters mechanism<KAIGYO>// or eliminate StackFrameRegister altogether.': 1, ""// Work around bug in ARMv7Assembler.h where add32(imm, sp, sp) doesn't<KAIGYO>// work well for large immediates."": 1}",1.0,{}
217,78509.0,3.0,17.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/78509,Move binops out of the isel,1.0,"{'// TODO?': 1, '// TODO: inline var===null and var!==null': 1}",1.0,"{'// TODO: inline var===null and var!==null': 1, '// TODO?': 1}",1.0,{}
218,78531.0,1.0,7.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/78531,Improve TableView performance by caching row-delegates,1.0,"{'// move the rowItem back in cache': 1, '// these properties are exposed to the row delegate<KAIGYO>// Note: these properties should be mirrored in the row filler as well': 1}",1.0,{'// these properties are exposed to the row delegate<KAIGYO>// Note: these properties should be mirrored in the row filler as well': 1},1.0,{}
357,78730.0,8.0,22.0,23.0,MERGED,True,https://codereview.qt-project.org/#/c/78730,UUID filter for LE service implemented,1.0,{'//TODO Fix m_DeviceAdapterAddress may not be the actual address': 3},1.0,"{'//TODO this should be bit field and not string operations': 1, '//TODO where is the uuidFilter match -> uuidFilter could contain a BLE uuid': 1, '//TODO Fix m_DeviceAdapterAddress may not be the actual address': 3}",1.0,{}
57,79103.0,2.0,16.0,11.0,MERGED,True,https://codereview.qt-project.org/#/c/79103,Fix 16 bit mode for heart rate measurement,1.0,{},0.0,{'// The following flags are used to determine what kind of value is being sent from the device.<KAIGYO>// FLAGS field bit mask values<KAIGYO>// 0<KAIGYO>// 3': 1},1.0,{}
180,79411.0,1.0,4.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/79411,Don't create invalid LEServices on Bluez due to default adapter usage,1.0,{},0.0,{'//TODO Fix m_DeviceAdapterAddress may not be the actual address': 1},1.0,{}
235,79480.0,14.0,21.0,4.0,ABANDONED,False,https://codereview.qt-project.org/#/c/79480,Flickable: flickThreshold comes from QStyleHints::startFlickDistance(),1.0,{},0.0,"{'// FlickThreshold determines how far the mouse or finger must have moved<KAIGYO>// before we perform a flick.': 1, '// FlickThreshold determines how far the """" must have moved<KAIGYO>// before we perform a flick.': 12}",1.0,{}
215,79502.0,4.0,15.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/79502,"Revert ""Propagate synthesized mouse events in parallel (lock-step) with touch""",1.0,{},0.0,{'// Note it has to be a spontaneous event if we want the focus management<KAIGYO>// and input method support to behave properly. Quite some of the code<KAIGYO>// related to those aspect check for the spontaneous flag.': 1},1.0,{}
216,79507.0,1.0,1.0,0.0,ABANDONED,False,https://codereview.qt-project.org/#/c/79507,fix fullUpdatePending in QWidgetBackingstore,1.0,{},0.0,{'//### FIXME fullUpdatePending seems to be always false????': 1},1.0,{}
239,79543.0,2.0,4.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/79543,Enable changing the cursor for the QQuickWebView.,1.0,{},0.0,{'// FIXME: This is a temporary fix until we get cursor support in QML items.': 1},1.0,{}
257,79565.0,4.0,13.0,2.0,MERGED,True,https://codereview.qt-project.org/#/c/79565,Do no allow arbitrarily large buffer during loading,1.0,{'// FIXME: httpsbugs.webkit.org/show_bug.cgi?id=19793<KAIGYO>// -1 means we do not provide any data about transfer size to inspector so it would use<KAIGYO>// Content-Length headers or content size to show transfer size.': 1},1.0,{'// FIXME: httpsbugs.webkit.org/show_bug.cgi?id=19793<KAIGYO>// -1 means we do not provide any data about transfer size to inspector so it would use<KAIGYO>// Content-Length headers or content size to show transfer size.': 1},1.0,{}
325,79656.0,5.0,43.0,51.0,MERGED,True,https://codereview.qt-project.org/#/c/79656,Make it possible to set the port values before opening,1.0,{},0.0,"{'// yes, speed is really custom': 2}",1.0,{}
347,79758.0,1.0,6.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/79758,Windows Vista Style: Don't draw menubar item background for QQ Controls,1.0,{'// Not needed for QtQuick Controls<KAIGYO>//The rect adjustment is a workaround for the menu not really filling its background.': 1},1.0,{'//The rect adjustment is a workaround for the menu not really filling its background.': 1},1.0,{}
422,79799.0,3.0,20.0,3.0,MERGED,True,https://codereview.qt-project.org/#/c/79799,purge vestiges of opengl es 1 support,1.0,{},0.0,{'//Since OpenGL ES does not support glPush/PopAttrib(GL_ALL_ATTRIB_BITS)<KAIGYO>//we have to take care of the states ourselves': 1},1.0,{}
34,80076.0,1.0,5.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/80076,Tslib plugin: also apply missing release coordinate code to non-raw mode,1.0,{'// work around missing coordinates on mouse release': 1},1.0,{'// work around missing coordinates on mouse release in raw mode': 1},1.0,{}
72,80100.0,9.0,44.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/80100,QPrintEngine - Switch Windows to QPlatformPrintDevice,1.0,"{'// TODO Do we need to check if the page size is valid on new printer?': 1, '// TODO Bypass direct compare until QPageSize used in QPrinter for consistency<KAIGYO>//QCOMPARE(sizes.at(i).second, printer.paperSize(QPrinter::Millimeter));': 1, '// TODO Bypass direct compare until QPageSize used in QPrinter for consistency<KAIGYO>//QCOMPARE(printer.paperSize(QPrinter::Millimeter), customSize);': 1}",1.0,"{""// Our sizes may not match the paper name's size exactly<KAIGYO>// So we treat it as custom so we know the paper size is correct"": 1}",1.0,{}
141,80103.0,11.0,47.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/80103,QPrinter - Fix winPageSize() on Mac and Linux,1.0,{},0.0,"{""// PdfFormat: ifdef'd out TODO remove ifdef<KAIGYO>// NativeFormat, Cups: ifdef'd out TODO remove ifdef<KAIGYO>// NativeFormat, Mac: ifdef'd out TODO remove ifdef"": 1}",1.0,{}
81,80231.0,1.0,4.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/80231,"Use nativeResourceForIntegration ""rootWindow"" to get the appRootWindow",1.0,{},0.0,"{'// This looks like it should work, but gives the wrong value.': 1}",1.0,{}
172,80409.0,2.0,29.0,2.0,MERGED,True,https://codereview.qt-project.org/#/c/80409,correct send vs sent grammar,1.0,"{'// mouse move event should be sent. Lets test this:': 1, ""// mouse move event should be sent. Let's test this:"": 2}",1.0,{'// mouse move event should be sendt. Lets test this:': 1},1.0,{}
318,80651.0,8.0,8.0,0.0,ABANDONED,False,https://codereview.qt-project.org/#/c/80651,WIP: item.window and window.mouseGrabberItem exposed for debugging,1.0,"{'// TODO For now, this is only called from childMouseEventFilter so we assume<KAIGYO>// childMouseEventFilter.': 6}",1.0,"{'// TODO For now, this is only called from childTouchEventFilter so we assume<KAIGYO>// childTouchEventFilter.': 6}",1.0,{}
450,80738.0,9.0,17.0,46.0,MERGED,True,https://codereview.qt-project.org/#/c/80738,QNX BLE communication moved to controller class,1.0,"{'            /* BEGIN WORKAROUND - Temporary fix to address race condition */<KAIGYO>            int number = 0;<KAIGYO>            do {<KAIGYO>                number = bt_gatt_characteristics(instance, allCharacteristicList, num_characteristics);<KAIGYO>            } while ((number == -1) && (errno== EBUSY));<KAIGYO>            //Using sub to subscribe notification callback only once<KAIGYO>            bool sub = false;<KAIGYO>            int characteristicListSize = number;<KAIGYO><KAIGYO>            for (int i = 0; i < characteristicListSize; i++) {<KAIGYO>                qDebug() << """" << allCharacteristicList[i].properties;<KAIGYO>                QString charUuid = QString::fromLatin1(allCharacteristicList[i].uuid);<KAIGYO>                QString handleUuid;<KAIGYO>                handleUuid.setNum(allCharacteristicList[i].value_handle);<KAIGYO>                QBluetoothUuid characteristicUuid;<KAIGYO>                if (charUuid.toUShort(0,0) == 0) {<KAIGYO>                    charUuid = charUuid.remove(0,2);<KAIGYO>                    characteristicUuid = QBluetoothUuid(charUuid);<KAIGYO>                }<KAIGYO>                else<KAIGYO>                    characteristicUuid = QBluetoothUuid(charUuid.toUShort(0,0));<KAIGYO>                QVariantMap map;<KAIGYO>                QLowEnergyCharacteristicInfo characteristicInfo(characteristicUuid);<KAIGYO>                characteristicInfo.d_ptr->handle = handleUuid;<KAIGYO>                characteristicInfo.d_ptr->instance = instance;<KAIGYO>                characteristicInfo.d_ptr->characteristic = allCharacteristicList[i];<KAIGYO>                characteristicInfo.d_ptr->permission = allCharacteristicList[i].properties;<KAIGYO>                map[QStringLiteral("""")] = characteristicUuid.toString();<KAIGYO>                map[QStringLiteral("""")] = handleUuid;<KAIGYO>                map[QStringLiteral("""")] = characteristicInfo.d_ptr->permission;<KAIGYO>                characteristicInfo.d_ptr->properties = map;<KAIGYO>                characteristicInfo.d_ptr->readDescriptors();<KAIGYO><KAIGYO>                characteristicInfo.d_ptr->readValue();<KAIGYO>                //Subscribe only once since it is static function<KAIGYO>                if (sub == false) {<KAIGYO>                    int rc = bt_gatt_reg_notifications(instance, &(p->serviceNotification));<KAIGYO>                    if (rc != 0) {<KAIGYO>                        qCDebug(QT_BT_QNX) << """" << errno << strerror(errno);<KAIGYO>                        p->errorString = QString::fromLatin1(strerror(errno));<KAIGYO>                        p->q_ptr->error(p->m_leServices.at(index));<KAIGYO>                    }<KAIGYO>                    else<KAIGYO>                        qCDebug(QT_BT_QNX) << """";<KAIGYO>                    sub = true;<KAIGYO>                }<KAIGYO>                p->m_leServices.at(index).d_ptr->characteristicList.append(characteristicInfo);<KAIGYO><KAIGYO>            }<KAIGYO><KAIGYO>            if (allCharacteristicList != NULL) {<KAIGYO>                free(allCharacteristicList);<KAIGYO>                allCharacteristicList = NULL;<KAIGYO>            }<KAIGYO><KAIGYO>            /* END WORKAROUND */': 1, '            /* BEGIN WORKAROUND - Temporary fix to address race condition */<KAIGYO>            int number = 0;<KAIGYO>            do {<KAIGYO>                number = bt_gatt_characteristics(instance, allCharacteristicList, num_characteristics);<KAIGYO>            } while ((number == -1) && (errno== EBUSY));<KAIGYO>            //Using sub to subscribe notification callback only once<KAIGYO>            bool sub = false;<KAIGYO>            int characteristicListSize = number;<KAIGYO><KAIGYO>            for (int i = 0; i < characteristicListSize; i++) {<KAIGYO>                qCDebug(QT_BT_QNX) << """" << allCharacteristicList[i].properties;<KAIGYO>                QString charUuid = QString::fromLatin1(allCharacteristicList[i].uuid);<KAIGYO>                QString handleUuid;<KAIGYO>                handleUuid.setNum(allCharacteristicList[i].value_handle);<KAIGYO>                QBluetoothUuid characteristicUuid;<KAIGYO>                if (charUuid.toUShort(0,0) == 0) {<KAIGYO>                    charUuid = charUuid.remove(0,2);<KAIGYO>                    characteristicUuid = QBluetoothUuid(charUuid);<KAIGYO>                }<KAIGYO>                else<KAIGYO>                    characteristicUuid = QBluetoothUuid(charUuid.toUShort(0,0));<KAIGYO>                QVariantMap map;<KAIGYO>                QLowEnergyCharacteristicInfo characteristicInfo(characteristicUuid);<KAIGYO>                characteristicInfo.d_ptr->handle = handleUuid;<KAIGYO>                characteristicInfo.d_ptr->instance = instance;<KAIGYO>                characteristicInfo.d_ptr->characteristic = allCharacteristicList[i];<KAIGYO>                characteristicInfo.d_ptr->permission = allCharacteristicList[i].properties;<KAIGYO>                map[QStringLiteral("""")] = characteristicUuid.toString();<KAIGYO>                map[QStringLiteral("""")] = handleUuid;<KAIGYO>                map[QStringLiteral("""")] = characteristicInfo.d_ptr->permission;<KAIGYO>                characteristicInfo.d_ptr->properties = map;<KAIGYO>                p->readDescriptors(characteristicInfo);<KAIGYO>                p->readValue(characteristicInfo);<KAIGYO>                //Subscribe only once since it is static function<KAIGYO>                if (sub == false) {<KAIGYO>                    int rc = bt_gatt_reg_notifications(instance, &(p->serviceNotification));<KAIGYO>                    if (rc != 0) {<KAIGYO>                        qCDebug(QT_BT_QNX) << """" << errno << strerror(errno);<KAIGYO>                        p->errorString = QString::fromLatin1(strerror(errno));<KAIGYO>                        p->q_ptr->error(p->m_leServices.at(index));<KAIGYO>                    }<KAIGYO>                    else<KAIGYO>                        qCDebug(QT_BT_QNX) << """";<KAIGYO>                    sub = true;<KAIGYO>                }<KAIGYO>                p->m_leServices.at(index).d_ptr->characteristicList.append(characteristicInfo);<KAIGYO><KAIGYO>            }<KAIGYO><KAIGYO>            if (allCharacteristicList != NULL) {<KAIGYO>                free(allCharacteristicList);<KAIGYO>                allCharacteristicList = NULL;<KAIGYO>            }<KAIGYO><KAIGYO>            /* END WORKAROUND */': 2, '        /* BEGIN WORKAROUND - Temporary fix to address race condition */<KAIGYO>        int number = 0;<KAIGYO>        do {<KAIGYO>            number = bt_gatt_descriptors(characteristic.d_ptr->instance, &characteristic.d_ptr->characteristic, descriptorList, count);<KAIGYO>        } while ((number == -1) && (errno == EBUSY));<KAIGYO><KAIGYO>        count = number;<KAIGYO>        /* END WORKAROUND */': 2, '            /* BEGIN WORKAROUND - Temporary fix to address race condition */<KAIGYO>            int number = 0;<KAIGYO>            do {<KAIGYO>                number = bt_gatt_characteristics(instance, allCharacteristicList, num_characteristics);<KAIGYO>            } while ((number == -1) && (errno == EBUSY));<KAIGYO>            //Using sub to subscribe notification callback only once<KAIGYO>            bool sub = false;<KAIGYO>            int characteristicListSize = number;<KAIGYO><KAIGYO>            for (int i = 0; i < characteristicListSize; i++) {<KAIGYO>                qCDebug(QT_BT_QNX) << """"<KAIGYO>                                   << allCharacteristicList[i].uuid << """" << allCharacteristicList[i].handle<KAIGYO>                                   << """" << allCharacteristicList[i].value_handle<KAIGYO>                                   << """" << allCharacteristicList[i].properties;<KAIGYO>                QString charUuid = QString::fromLatin1(allCharacteristicList[i].uuid);<KAIGYO>                QString handleUuid;<KAIGYO>                handleUuid.setNum(allCharacteristicList[i].value_handle);<KAIGYO>                QBluetoothUuid characteristicUuid;<KAIGYO>                if (!charUuid.toUShort(0,0)) {<KAIGYO>                    charUuid = charUuid.remove(0,2);<KAIGYO>                    characteristicUuid = QBluetoothUuid(charUuid);<KAIGYO>                } else {<KAIGYO>                    characteristicUuid = QBluetoothUuid(charUuid.toUShort(0,0));<KAIGYO>                }<KAIGYO>                QVariantMap map;<KAIGYO>                QLowEnergyCharacteristicInfo characteristicInfo(characteristicUuid);<KAIGYO>                characteristicInfo.d_ptr->handle = handleUuid;<KAIGYO>                characteristicInfo.d_ptr->instance = instance;<KAIGYO>                characteristicInfo.d_ptr->characteristic = allCharacteristicList[i];<KAIGYO>                characteristicInfo.d_ptr->permission = allCharacteristicList[i].properties;<KAIGYO>                map[QStringLiteral("""")] = characteristicUuid.toString();<KAIGYO>                map[QStringLiteral("""")] = handleUuid;<KAIGYO>                map[QStringLiteral("""")] = characteristicInfo.d_ptr->permission;<KAIGYO>                characteristicInfo.d_ptr->properties = map;<KAIGYO>                p->readDescriptors(characteristicInfo);<KAIGYO>                p->readValue(characteristicInfo);<KAIGYO>                //Subscribe only once since it is static function<KAIGYO>                if (!sub) {<KAIGYO>                    int rc = bt_gatt_reg_notifications(instance, &(p->serviceNotification));<KAIGYO>                    if (!rc) {<KAIGYO>                        qCDebug(QT_BT_QNX) << """" << errno << qt_error_string(errno);<KAIGYO>                        p->errorString = QString::fromLatin1(qt_error_string(errno));<KAIGYO>                        p->q_ptr->error(p->m_leServices.at(index));<KAIGYO>                    } else {<KAIGYO>                        qCDebug(QT_BT_QNX) << """";<KAIGYO>                    }<KAIGYO>                    sub = true;<KAIGYO>                }<KAIGYO>                p->m_leServices.at(index).d_ptr->characteristicList.append(characteristicInfo);<KAIGYO><KAIGYO>            }<KAIGYO><KAIGYO>            if (!allCharacteristicList) {<KAIGYO>                free(allCharacteristicList);<KAIGYO>                allCharacteristicList = 0;<KAIGYO>            }<KAIGYO><KAIGYO>            /* END WORKAROUND */': 5, '            /* BEGIN WORKAROUND - Temporary fix to address race condition */<KAIGYO>            int number = 0;<KAIGYO>            do {<KAIGYO>                number = bt_gatt_characteristics(instance, allCharacteristicList, num_characteristics);<KAIGYO>            } while ((number == -1) && (errno == EBUSY));<KAIGYO>            //Using sub to subscribe notification callback only once<KAIGYO>            bool sub = false;<KAIGYO>            int characteristicListSize = number;<KAIGYO><KAIGYO>            for (int i = 0; i < characteristicListSize; i++) {<KAIGYO>                qCDebug(QT_BT_QNX) << """"<KAIGYO>                                   << allCharacteristicList[i].uuid << """" << allCharacteristicList[i].handle<KAIGYO>                                   << """" << allCharacteristicList[i].value_handle<KAIGYO>                                   << """" << allCharacteristicList[i].properties;<KAIGYO>                QString charUuid = QString::fromLatin1(allCharacteristicList[i].uuid);<KAIGYO>                QString handleUuid;<KAIGYO>                handleUuid.setNum(allCharacteristicList[i].value_handle);<KAIGYO>                QBluetoothUuid characteristicUuid;<KAIGYO>                if (!charUuid.toUShort(0,0)) {<KAIGYO>                    charUuid = charUuid.remove(0,2);<KAIGYO>                    characteristicUuid = QBluetoothUuid(charUuid);<KAIGYO>                } else {<KAIGYO>                    characteristicUuid = QBluetoothUuid(charUuid.toUShort(0,0));<KAIGYO>                }<KAIGYO>                QVariantMap map;<KAIGYO>                QLowEnergyCharacteristicInfo characteristicInfo(characteristicUuid);<KAIGYO>                characteristicInfo.d_ptr->handle = handleUuid;<KAIGYO>                characteristicInfo.d_ptr->instance = instance;<KAIGYO>                characteristicInfo.d_ptr->characteristic = allCharacteristicList[i];<KAIGYO>                characteristicInfo.d_ptr->permission = allCharacteristicList[i].properties;<KAIGYO>                map[QStringLiteral("""")] = characteristicUuid.toString();<KAIGYO>                map[QStringLiteral("""")] = handleUuid;<KAIGYO>                map[QStringLiteral("""")] = characteristicInfo.d_ptr->permission;<KAIGYO>                characteristicInfo.d_ptr->properties = map;<KAIGYO>                p->readDescriptors(characteristicInfo);<KAIGYO>                p->readValue(characteristicInfo);<KAIGYO>                //Subscribe only once since it is static function<KAIGYO>                if (!sub) {<KAIGYO>                    int rc = bt_gatt_reg_notifications(instance, &(p->serviceNotification));<KAIGYO>                    if (!rc) {<KAIGYO>                        qCDebug(QT_BT_QNX) << """" << errno << qt_error_string(errno);<KAIGYO>                        p->errorString = qt_error_string(errno);<KAIGYO>                        p->q_ptr->error(p->m_leServices.at(index));<KAIGYO>                    } else {<KAIGYO>                        qCDebug(QT_BT_QNX) << """";<KAIGYO>                    }<KAIGYO>                    sub = true;<KAIGYO>                }<KAIGYO>                p->m_leServices.at(index).d_ptr->characteristicList.append(characteristicInfo);<KAIGYO><KAIGYO>            }<KAIGYO><KAIGYO>            if (!allCharacteristicList) {<KAIGYO>                free(allCharacteristicList);<KAIGYO>                allCharacteristicList = 0;<KAIGYO>            }<KAIGYO><KAIGYO>            /* END WORKAROUND */': 6}",1.0,"{'        /* BEGIN WORKAROUND - Temporary fix to address race condition */<KAIGYO>        int number = 0;<KAIGYO>        do {<KAIGYO>            number = bt_gatt_characteristics(instance, allCharacteristicList, num_characteristics);<KAIGYO>        } while ((number == -1) && (errno== EBUSY));<KAIGYO>        //Using sub to subscribe notification callback only once<KAIGYO>        bool sub = false;<KAIGYO>        int characteristicListSize = number;<KAIGYO><KAIGYO>        for (int i = 0; i < characteristicListSize; i++) {<KAIGYO>            qCDebug(QT_BT_QNX) << """" << allCharacteristicList[i].properties;<KAIGYO>            QString charUuid = QString::fromLatin1(allCharacteristicList[i].uuid);<KAIGYO>            QString handleUuid;<KAIGYO>            handleUuid.setNum(allCharacteristicList[i].value_handle);<KAIGYO>            QBluetoothUuid characteristicUuid;<KAIGYO>            if (charUuid.toUShort(0,0) == 0) {<KAIGYO>                charUuid = charUuid.remove(0,2);<KAIGYO>                characteristicUuid = QBluetoothUuid(charUuid);<KAIGYO>            }<KAIGYO>            else<KAIGYO>                characteristicUuid = QBluetoothUuid(charUuid.toUShort(0,0));<KAIGYO>            QVariantMap map;<KAIGYO>            QLowEnergyCharacteristicInfo characteristicInfo(characteristicUuid);<KAIGYO>            characteristicInfo.d_ptr->handle = handleUuid;<KAIGYO>            characteristicInfo.d_ptr->instance = instance;<KAIGYO>            characteristicInfo.d_ptr->characteristic = allCharacteristicList[i];<KAIGYO>            characteristicInfo.d_ptr->permission = allCharacteristicList[i].properties;<KAIGYO>            map[QStringLiteral("""")] = characteristicUuid.toString();<KAIGYO>            map[QStringLiteral("""")] = handleUuid;<KAIGYO>            map[QStringLiteral("""")] = characteristicInfo.d_ptr->permission;<KAIGYO>            characteristicInfo.d_ptr->properties = map;<KAIGYO>            characteristicInfo.d_ptr->readDescriptors();<KAIGYO><KAIGYO>            characteristicInfo.d_ptr->readValue();<KAIGYO>            //Subscribe only once since it is static function<KAIGYO>            if (sub == false) {<KAIGYO>                int rc = bt_gatt_reg_notifications(instance, &(characteristicInfo.d_ptr->serviceNotification));<KAIGYO>                if (rc != 0) {<KAIGYO>                    qCDebug(QT_BT_QNX) << """" << errno << strerror(errno);<KAIGYO>                    p->errorString = QString::fromLatin1(strerror(errno));<KAIGYO>                    p->error(p->uuid);<KAIGYO>                }<KAIGYO>                else<KAIGYO>                    qCDebug(QT_BT_QNX) << """";<KAIGYO>                sub = true;<KAIGYO>            }<KAIGYO>            p->characteristicList.append(characteristicInfo);<KAIGYO><KAIGYO>        }<KAIGYO><KAIGYO>        if (allCharacteristicList != NULL) {<KAIGYO>            free(allCharacteristicList);<KAIGYO>            allCharacteristicList = NULL;<KAIGYO>        }<KAIGYO><KAIGYO>        /* END WORKAROUND */': 1, '        /* BEGIN WORKAROUND - Temporary fix to address race condition */<KAIGYO>        int number = 0;<KAIGYO>        do {<KAIGYO>            number = bt_gatt_descriptors(instance, &characteristic, descriptorList, count);<KAIGYO>        } while ((number == -1) && (errno == EBUSY));<KAIGYO><KAIGYO>        count = number;<KAIGYO>        /* END WORKAROUND */': 2}",1.0,{}
341,80760.0,2.0,5.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/80760,Fix a few TODOs around the source code and remove obsolete ones,1.0,{},0.0,"{'//TODO Remove line below - work around': 1, '//TODO check that readData and writeData return -1 on error (on all platforms)': 1, '// TODO: make more efficient': 1}",1.0,{}
327,80761.0,2.0,5.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/80761,Convert internal function parameter to const &,1.0,{},0.0,{'//TODO Convert uuid parameter to const reference (affects QNX too)': 1},1.0,{}
333,80762.0,3.0,5.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/80762,Android: Improve QBluetoothLocalDevice::connectedDevices(),1.0,{},0.0,{'//TODO Support BLuetoothManager::getConnectedDevices(int) from API 18 onwards': 1},1.0,{}
435,80936.0,4.0,16.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/80936,Enable constant propagation for all types,1.0,{},0.0,"{'// TODO: when propagating other constants, e.g. undefined, the other<KAIGYO>// optimization passes have to be changed to cope with them.': 1}",1.0,{}
74,81175.0,2.0,3.0,0.0,ABANDONED,False,https://codereview.qt-project.org/#/c/81175,Added timezone support for datetime fields in PSQL,1.0,{},0.0,"{'// strip the timezone<KAIGYO>// TODO: fix this when timestamp support comes into QDateTime': 1, '// remove the timezone<KAIGYO>// TODO: fix this when timestamp support comes into QDateTime': 1}",1.0,{}
75,81184.0,1.0,3.0,0.0,ABANDONED,False,https://codereview.qt-project.org/#/c/81184,Added timezone support for datetime fields in PSQL,1.0,{},0.0,"{'// strip the timezone<KAIGYO>// TODO: fix this when timestamp support comes into QDateTime': 1, '// remove the timezone<KAIGYO>// TODO: fix this when timestamp support comes into QDateTime': 1}",1.0,{}
349,81488.0,8.0,18.0,2.0,ABANDONED,False,https://codereview.qt-project.org/#/c/81488,V4 IR: clean up basic-block management and statement access.,1.0,{},0.0,"{'// Number all basic blocks, so we have nice numbers in the dumps:': 1, ""// TODO: change this to mark the block as deleted, but leave it alone so that other references<KAIGYO>//       won't be dangling pointers."": 2}",1.0,{}
315,81667.0,1.0,16.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/81667,Merge remote-tracking branch 'origin/stable' into dev,1.0,{},0.0,"{'//TODO: Not implemented': 1, '/*! Returns the text edit. */<KAIGYO>QTextEdit *QAccessibleTextEdit::textEdit() const<KAIGYO>{<KAIGYO>    return static_cast<QTextEdit *>(widget());<KAIGYO>}<KAIGYO><KAIGYO>QTextCursor QAccessibleTextEdit::textCursor() const<KAIGYO>{<KAIGYO>    return textEdit()->textCursor();<KAIGYO>}<KAIGYO><KAIGYO>QTextDocument *QAccessibleTextEdit::textDocument() const<KAIGYO>{<KAIGYO>    return textEdit()->document();<KAIGYO>}<KAIGYO><KAIGYO>void QAccessibleTextEdit::setTextCursor(const QTextCursor &textCursor)<KAIGYO>{<KAIGYO>    textEdit()->setTextCursor(textCursor);<KAIGYO>}<KAIGYO><KAIGYO>QWidget *QAccessibleTextEdit::viewport() const<KAIGYO>{<KAIGYO>    return textEdit()->viewport();<KAIGYO>}<KAIGYO><KAIGYO>QPoint QAccessibleTextEdit::scrollBarPosition() const<KAIGYO>{<KAIGYO>    QPoint result;<KAIGYO>    result.setX(textEdit()->horizontalScrollBar() ? textEdit()->horizontalScrollBar()->sliderPosition() : 0);<KAIGYO>    result.setY(textEdit()->verticalScrollBar() ? textEdit()->verticalScrollBar()->sliderPosition() : 0);<KAIGYO>    return result;<KAIGYO>}<KAIGYO><KAIGYO>QString QAccessibleTextEdit::text(QAccessible::Text t) const<KAIGYO>{<KAIGYO>    if (t == QAccessible::Value)<KAIGYO>        return textEdit()->toPlainText();<KAIGYO><KAIGYO>    return QAccessibleWidget::text(t);<KAIGYO>}<KAIGYO><KAIGYO>void QAccessibleTextEdit::setText(QAccessible::Text t, const QString &text)<KAIGYO>{<KAIGYO>    if (t != QAccessible::Value) {<KAIGYO>        QAccessibleWidget::setText(t, text);<KAIGYO>        return;<KAIGYO>    }<KAIGYO>    if (textEdit()->isReadOnly())<KAIGYO>        return;<KAIGYO><KAIGYO>    textEdit()->setText(text);<KAIGYO>}<KAIGYO><KAIGYO>QAccessible::State QAccessibleTextEdit::state() const<KAIGYO>{<KAIGYO>    QAccessible::State st = QAccessibleTextWidget::state();<KAIGYO>    if (textEdit()->isReadOnly())<KAIGYO>        st.readOnly = true;<KAIGYO>    else<KAIGYO>        st.editable = true;<KAIGYO>    return st;<KAIGYO>}<KAIGYO><KAIGYO>void *QAccessibleTextEdit::interface_cast(QAccessible::InterfaceType t)<KAIGYO>{<KAIGYO>    if (t == QAccessible::TextInterface)<KAIGYO>        return static_cast<QAccessibleTextInterface*>(this);<KAIGYO>    else if (t == QAccessible::EditableTextInterface)<KAIGYO>        return static_cast<QAccessibleEditableTextInterface*>(this);<KAIGYO>    return QAccessibleWidget::interface_cast(t);<KAIGYO>}<KAIGYO><KAIGYO>void QAccessibleTextEdit::scrollToSubstring(int startIndex, int endIndex)<KAIGYO>{<KAIGYO>    QTextEdit *edit = textEdit();<KAIGYO><KAIGYO>    QTextCursor cursor = textCursor();<KAIGYO>    cursor.setPosition(startIndex);<KAIGYO>    QRect r = edit->cursorRect(cursor);<KAIGYO><KAIGYO>    cursor.setPosition(endIndex);<KAIGYO>    r.setBottomRight(edit->cursorRect(cursor).bottomRight());<KAIGYO><KAIGYO>    r.moveTo(r.x() + edit->horizontalScrollBar()->value(),<KAIGYO>             r.y() + edit->verticalScrollBar()->value());<KAIGYO><KAIGYO>    // E V I L, but ensureVisible is not public<KAIGYO>    if (!QMetaObject::invokeMethod(edit, """", Q_ARG(QRectF, r)))<KAIGYO>        qWarning("""");<KAIGYO>}<KAIGYO><KAIGYO>#endif // QT_NO_TEXTEDIT && QT_NO_CURSOR<KAIGYO><KAIGYO>#ifndef QT_NO_STACKEDWIDGET<KAIGYO>QAccessibleStackedWidget::QAccessibleStackedWidget(QWidget *widget)<KAIGYO>    : QAccessibleWidget(widget, QAccessible::LayeredPane)<KAIGYO>{<KAIGYO>    Q_ASSERT(qobject_cast<QStackedWidget *>(widget));<KAIGYO>}<KAIGYO><KAIGYO>QAccessibleInterface *QAccessibleStackedWidget::childAt(int x, int y) const<KAIGYO>{<KAIGYO>    if (!stackedWidget()->isVisible())<KAIGYO>        return 0;<KAIGYO>    QWidget *currentWidget = stackedWidget()->currentWidget();<KAIGYO>    if (!currentWidget)<KAIGYO>        return 0;<KAIGYO>    QPoint position = currentWidget->mapFromGlobal(QPoint(x, y));<KAIGYO>    if (currentWidget->rect().contains(position))<KAIGYO>        return child(stackedWidget()->currentIndex());<KAIGYO>    return 0;<KAIGYO>}<KAIGYO><KAIGYO>int QAccessibleStackedWidget::childCount() const<KAIGYO>{<KAIGYO>    return stackedWidget()->count();<KAIGYO>}<KAIGYO><KAIGYO>int QAccessibleStackedWidget::indexOfChild(const QAccessibleInterface *child) const<KAIGYO>{<KAIGYO>    if (!child)<KAIGYO>        return -1;<KAIGYO><KAIGYO>    QWidget *widget = qobject_cast<QWidget*>(child->object());<KAIGYO>    return stackedWidget()->indexOf(widget);<KAIGYO>}<KAIGYO><KAIGYO>QAccessibleInterface *QAccessibleStackedWidget::child(int index) const<KAIGYO>{<KAIGYO>    if (index < 0 || index >= stackedWidget()->count())<KAIGYO>        return 0;<KAIGYO>    return QAccessible::queryAccessibleInterface(stackedWidget()->widget(index));<KAIGYO>}<KAIGYO><KAIGYO>QStackedWidget *QAccessibleStackedWidget::stackedWidget() const<KAIGYO>{<KAIGYO>    return static_cast<QStackedWidget *>(object());<KAIGYO>}<KAIGYO>#endif // QT_NO_STACKEDWIDGET<KAIGYO><KAIGYO>#ifndef QT_NO_TOOLBOX<KAIGYO>QAccessibleToolBox::QAccessibleToolBox(QWidget *widget)<KAIGYO>    : QAccessibleWidget(widget, QAccessible::LayeredPane)<KAIGYO>{<KAIGYO>    Q_ASSERT(qobject_cast<QToolBox *>(widget));<KAIGYO>}<KAIGYO><KAIGYO>QToolBox * QAccessibleToolBox::toolBox() const<KAIGYO>{<KAIGYO>    return static_cast<QToolBox *>(object());<KAIGYO>}<KAIGYO>#endif // QT_NO_TOOLBOX<KAIGYO><KAIGYO>#ifndef QT_NO_MDIAREA<KAIGYO>QAccessibleMdiArea::QAccessibleMdiArea(QWidget *widget)<KAIGYO>    : QAccessibleWidget(widget, QAccessible::LayeredPane)<KAIGYO>{<KAIGYO>    Q_ASSERT(qobject_cast<QMdiArea *>(widget));<KAIGYO>}<KAIGYO><KAIGYO>int QAccessibleMdiArea::childCount() const<KAIGYO>{<KAIGYO>    return mdiArea()->subWindowList().count();<KAIGYO>}<KAIGYO><KAIGYO>QAccessibleInterface *QAccessibleMdiArea::child(int index) const<KAIGYO>{<KAIGYO>    QList<QMdiSubWindow *> subWindows = mdiArea()->subWindowList();<KAIGYO>    QWidget *targetObject = subWindows.value(index);<KAIGYO>    if (!targetObject)<KAIGYO>       return 0;<KAIGYO>    return QAccessible::queryAccessibleInterface(targetObject);<KAIGYO>}<KAIGYO><KAIGYO><KAIGYO>int QAccessibleMdiArea::indexOfChild(const QAccessibleInterface *child) const<KAIGYO>{<KAIGYO>    if (!child || !child->object() || mdiArea()->subWindowList().isEmpty())<KAIGYO>        return -1;<KAIGYO>    if (QMdiSubWindow *window = qobject_cast<QMdiSubWindow *>(child->object())) {<KAIGYO>        return mdiArea()->subWindowList().indexOf(window);<KAIGYO>    }<KAIGYO>    return -1;<KAIGYO>}<KAIGYO><KAIGYO>QMdiArea *QAccessibleMdiArea::mdiArea() const<KAIGYO>{<KAIGYO>    return static_cast<QMdiArea *>(object());<KAIGYO>}<KAIGYO><KAIGYO>QAccessibleMdiSubWindow::QAccessibleMdiSubWindow(QWidget *widget)<KAIGYO>    : QAccessibleWidget(widget, QAccessible::Window)<KAIGYO>{<KAIGYO>    Q_ASSERT(qobject_cast<QMdiSubWindow *>(widget));<KAIGYO>}<KAIGYO><KAIGYO>QString QAccessibleMdiSubWindow::text(QAccessible::Text textType) const<KAIGYO>{<KAIGYO>    if (textType == QAccessible::Name) {<KAIGYO>        QString title = mdiSubWindow()->windowTitle();<KAIGYO>        title.replace(QLatin1String(""""));<KAIGYO>        return title;<KAIGYO>    }<KAIGYO>    return QAccessibleWidget::text(textType);<KAIGYO>}<KAIGYO><KAIGYO>void QAccessibleMdiSubWindow::setText(QAccessible::Text textType, const QString &text)<KAIGYO>{<KAIGYO>    if (textType == QAccessible::Name)<KAIGYO>        mdiSubWindow()->setWindowTitle(text);<KAIGYO>    else<KAIGYO>        QAccessibleWidget::setText(textType, text);<KAIGYO>}<KAIGYO><KAIGYO>QAccessible::State QAccessibleMdiSubWindow::state() const<KAIGYO>{<KAIGYO>    QAccessible::State state;<KAIGYO>    state.focusable = true;<KAIGYO>    if (!mdiSubWindow()->isMaximized()) {<KAIGYO>        state.movable = true;<KAIGYO>        state.sizeable = true;<KAIGYO>    }<KAIGYO>    if (mdiSubWindow()->isAncestorOf(QApplication::focusWidget())<KAIGYO>            || QApplication::focusWidget() == mdiSubWindow())<KAIGYO>        state.focused = true;<KAIGYO>    if (!mdiSubWindow()->isVisible())<KAIGYO>        state.invisible = true;<KAIGYO>    if (const QWidget *parent = mdiSubWindow()->parentWidget())<KAIGYO>        if (!parent->contentsRect().contains(mdiSubWindow()->geometry()))<KAIGYO>            state.offscreen = true;<KAIGYO>    if (!mdiSubWindow()->isEnabled())<KAIGYO>        state.disabled = true;<KAIGYO>    return state;<KAIGYO>}<KAIGYO><KAIGYO>int QAccessibleMdiSubWindow::childCount() const<KAIGYO>{<KAIGYO>    if (mdiSubWindow()->widget())<KAIGYO>        return 1;<KAIGYO>    return 0;<KAIGYO>}<KAIGYO><KAIGYO>QAccessibleInterface *QAccessibleMdiSubWindow::child(int index) const<KAIGYO>{<KAIGYO>    QMdiSubWindow *source = mdiSubWindow();<KAIGYO>    if (index != 0 || !source->widget())<KAIGYO>        return 0;<KAIGYO><KAIGYO>    return QAccessible::queryAccessibleInterface(source->widget());<KAIGYO>}<KAIGYO><KAIGYO>int QAccessibleMdiSubWindow::indexOfChild(const QAccessibleInterface *child) const<KAIGYO>{<KAIGYO>    if (child && child->object() && child->object() == mdiSubWindow()->widget())<KAIGYO>        return 0;<KAIGYO>    return -1;<KAIGYO>}<KAIGYO><KAIGYO>QRect QAccessibleMdiSubWindow::rect() const<KAIGYO>{<KAIGYO>    if (mdiSubWindow()->isHidden())<KAIGYO>        return QRect();<KAIGYO>    if (!mdiSubWindow()->parent())<KAIGYO>        return QAccessibleWidget::rect();<KAIGYO>    const QPoint pos = mdiSubWindow()->mapToGlobal(QPoint(0, 0));<KAIGYO>    return QRect(pos, mdiSubWindow()->size());<KAIGYO>}<KAIGYO><KAIGYO>QMdiSubWindow *QAccessibleMdiSubWindow::mdiSubWindow() const<KAIGYO>{<KAIGYO>    return static_cast<QMdiSubWindow *>(object());<KAIGYO>}<KAIGYO>#endif // QT_NO_MDIAREA<KAIGYO><KAIGYO>#ifndef QT_NO_DIALOGBUTTONBOX<KAIGYO>QAccessibleDialogButtonBox::QAccessibleDialogButtonBox(QWidget *widget)<KAIGYO>    : QAccessibleWidget(widget, QAccessible::Grouping)<KAIGYO>{<KAIGYO>    Q_ASSERT(qobject_cast<QDialogButtonBox*>(widget));<KAIGYO>}<KAIGYO><KAIGYO>#endif // QT_NO_DIALOGBUTTONBOX<KAIGYO><KAIGYO>#if !defined(QT_NO_TEXTBROWSER) && !defined(QT_NO_CURSOR)<KAIGYO>QAccessibleTextBrowser::QAccessibleTextBrowser(QWidget *widget)<KAIGYO>    : QAccessibleTextEdit(widget)<KAIGYO>{<KAIGYO>    Q_ASSERT(qobject_cast<QTextBrowser *>(widget));<KAIGYO>}<KAIGYO><KAIGYO>QAccessible::Role QAccessibleTextBrowser::role() const<KAIGYO>{<KAIGYO>    return QAccessible::StaticText;<KAIGYO>}<KAIGYO>#endif // QT_NO_TEXTBROWSER && QT_NO_CURSOR<KAIGYO><KAIGYO>#ifndef QT_NO_CALENDARWIDGET<KAIGYO>QAccessibleCalendarWidget::QAccessibleCalendarWidget(QWidget *widget)<KAIGYO>    : QAccessibleWidget(widget, QAccessible::Table)<KAIGYO>{<KAIGYO>    Q_ASSERT(qobject_cast<QCalendarWidget *>(widget));<KAIGYO>}<KAIGYO><KAIGYO>int QAccessibleCalendarWidget::childCount() const<KAIGYO>{<KAIGYO>   return calendarWidget()->isNavigationBarVisible() ? 2 : 1;<KAIGYO>}<KAIGYO><KAIGYO>int QAccessibleCalendarWidget::indexOfChild(const QAccessibleInterface *child) const<KAIGYO>{<KAIGYO>    if (!child || !child->object() || childCount() <= 0)<KAIGYO>        return -1;<KAIGYO>    if (qobject_cast<QAbstractItemView *>(child->object()))<KAIGYO>        return childCount() - 1; // FIXME<KAIGYO>    return 0;<KAIGYO>}<KAIGYO><KAIGYO>QAccessibleInterface *QAccessibleCalendarWidget::child(int index) const<KAIGYO>{<KAIGYO>    if (index < 0 || index >= childCount())<KAIGYO>        return 0;<KAIGYO><KAIGYO>    if (childCount() > 1 && index == 0)<KAIGYO>        return QAccessible::queryAccessibleInterface(navigationBar());<KAIGYO><KAIGYO>    return QAccessible::queryAccessibleInterface(calendarView());<KAIGYO>}<KAIGYO><KAIGYO>QCalendarWidget *QAccessibleCalendarWidget::calendarWidget() const<KAIGYO>{<KAIGYO>    return static_cast<QCalendarWidget *>(object());<KAIGYO>}<KAIGYO><KAIGYO>QAbstractItemView *QAccessibleCalendarWidget::calendarView() const<KAIGYO>{<KAIGYO>    foreach (QObject *child, calendarWidget()->children()) {<KAIGYO>        if (child->objectName() == QLatin1String(""""))<KAIGYO>            return static_cast<QAbstractItemView *>(child);<KAIGYO>    }<KAIGYO>    return 0;<KAIGYO>}<KAIGYO><KAIGYO>QWidget *QAccessibleCalendarWidget::navigationBar() const<KAIGYO>{<KAIGYO>    foreach (QObject *child, calendarWidget()->children()) {<KAIGYO>        if (child->objectName() == QLatin1String(""""))<KAIGYO>            return static_cast<QWidget *>(child);<KAIGYO>    }<KAIGYO>    return 0;<KAIGYO>}<KAIGYO>#endif // QT_NO_CALENDARWIDGET<KAIGYO><KAIGYO>#ifndef QT_NO_DOCKWIDGET<KAIGYO><KAIGYO>// Dock Widget - order of children:<KAIGYO>// - Content widget<KAIGYO>// - Float button<KAIGYO>// - Close button<KAIGYO>// If there is a custom title bar widget, that one becomes child 1, after the content 0<KAIGYO>// (in that case the buttons are ignored)<KAIGYO>QAccessibleDockWidget::QAccessibleDockWidget(QWidget *widget)<KAIGYO>    : QAccessibleWidget(widget, QAccessible::Window)<KAIGYO>{<KAIGYO>}<KAIGYO><KAIGYO>QDockWidgetLayout *QAccessibleDockWidget::dockWidgetLayout() const<KAIGYO>{<KAIGYO>    return qobject_cast<QDockWidgetLayout*>(dockWidget()->layout());<KAIGYO>}<KAIGYO><KAIGYO>int QAccessibleDockWidget::childCount() const<KAIGYO>{<KAIGYO>    if (dockWidget()->titleBarWidget()) {<KAIGYO>        return dockWidget()->widget() ? 2 : 1;<KAIGYO>    }<KAIGYO>    return dockWidgetLayout()->count();<KAIGYO>}<KAIGYO><KAIGYO>QAccessibleInterface *QAccessibleDockWidget::child(int index) const<KAIGYO>{<KAIGYO>    if (dockWidget()->titleBarWidget()) {<KAIGYO>        if ((!dockWidget()->widget() && index == 0) || (index == 1))<KAIGYO>            return QAccessible::queryAccessibleInterface(dockWidget()->titleBarWidget());<KAIGYO>        if (index == 0)<KAIGYO>            return QAccessible::queryAccessibleInterface(dockWidget()->widget());<KAIGYO>    } else {<KAIGYO>        QLayoutItem *item = dockWidgetLayout()->itemAt(index);<KAIGYO>        if (item)<KAIGYO>            return QAccessible::queryAccessibleInterface(item->widget());<KAIGYO>    }<KAIGYO>    return 0;<KAIGYO>}<KAIGYO><KAIGYO>int QAccessibleDockWidget::indexOfChild(const QAccessibleInterface *child) const<KAIGYO>{<KAIGYO>    if (!child || !child->object() || child->object()->parent() != object())<KAIGYO>        return -1;<KAIGYO><KAIGYO>    if (dockWidget()->titleBarWidget() == child->object()) {<KAIGYO>        return dockWidget()->widget() ? 1 : 0;<KAIGYO>    }<KAIGYO><KAIGYO>    return dockWidgetLayout()->indexOf(qobject_cast<QWidget*>(child->object()));<KAIGYO>}<KAIGYO><KAIGYO>QRect QAccessibleDockWidget::rect() const<KAIGYO>{<KAIGYO>    QRect rect;<KAIGYO><KAIGYO>    if (dockWidget()->isFloating()) {<KAIGYO>        rect = dockWidget()->frameGeometry();<KAIGYO>    } else {<KAIGYO>        rect = dockWidget()->rect();<KAIGYO>        rect.moveTopLeft(dockWidget()->mapToGlobal(rect.topLeft()));<KAIGYO>    }<KAIGYO><KAIGYO>    return rect;<KAIGYO>}<KAIGYO><KAIGYO>QDockWidget *QAccessibleDockWidget::dockWidget() const<KAIGYO>{<KAIGYO>    return static_cast<QDockWidget *>(object());<KAIGYO>}<KAIGYO><KAIGYO>QString QAccessibleDockWidget::text(QAccessible::Text t) const<KAIGYO>{<KAIGYO>    if (t == QAccessible::Name) {<KAIGYO>        return qt_accStripAmp(dockWidget()->windowTitle());<KAIGYO>    }<KAIGYO>    return QString();<KAIGYO>}<KAIGYO>#endif // QT_NO_DOCKWIDGET<KAIGYO><KAIGYO>#ifndef QT_NO_CURSOR<KAIGYO><KAIGYO>QAccessibleTextWidget::QAccessibleTextWidget(QWidget *o, QAccessible::Role r, const QString &name):<KAIGYO>    QAccessibleWidget(o, r, name)<KAIGYO>{<KAIGYO><KAIGYO>}<KAIGYO><KAIGYO>QAccessible::State QAccessibleTextWidget::state() const<KAIGYO>{<KAIGYO>    QAccessible::State s = QAccessibleWidget::state();<KAIGYO>    s.multiLine = true;<KAIGYO>    return s;<KAIGYO>}<KAIGYO><KAIGYO>QRect QAccessibleTextWidget::characterRect(int offset) const<KAIGYO>{<KAIGYO>    QTextBlock block = textDocument()->findBlock(offset);<KAIGYO>    if (!block.isValid())<KAIGYO>        return QRect();<KAIGYO><KAIGYO>    QTextLayout *layout = block.layout();<KAIGYO>    QPointF layoutPosition = layout->position();<KAIGYO>    int relativeOffset = offset - block.position();<KAIGYO>    QTextLine line = layout->lineForTextPosition(relativeOffset);<KAIGYO><KAIGYO>    QRect r;<KAIGYO><KAIGYO>    if (line.isValid()) {<KAIGYO>        qreal x = line.cursorToX(relativeOffset);<KAIGYO>        QFontMetrics fm(textCursor().charFormat().font());<KAIGYO>        const QString ch = text(offset, offset + 1);<KAIGYO>        if (!ch.isEmpty()) {<KAIGYO>            int w = fm.width(ch);<KAIGYO>            int h = fm.height();<KAIGYO>            r = QRect(layoutPosition.x() + x, layoutPosition.y() + line.y(),<KAIGYO>                      w, h);<KAIGYO>            r.moveTo(viewport()->mapToGlobal(r.topLeft()));<KAIGYO>        }<KAIGYO>        r.translate(-scrollBarPosition());<KAIGYO>    }<KAIGYO><KAIGYO>    return r;<KAIGYO>}<KAIGYO><KAIGYO>int QAccessibleTextWidget::offsetAtPoint(const QPoint &point) const<KAIGYO>{<KAIGYO>    QPoint p = viewport()->mapFromGlobal(point);<KAIGYO>    // convert to document coordinates<KAIGYO>    p += scrollBarPosition();<KAIGYO>    return textDocument()->documentLayout()->hitTest(p, Qt::ExactHit);<KAIGYO>}<KAIGYO><KAIGYO>int QAccessibleTextWidget::selectionCount() const<KAIGYO>{<KAIGYO>    return textCursor().hasSelection() ? 1 : 0;<KAIGYO>}<KAIGYO><KAIGYO>QString QAccessibleTextWidget::attributes(int offset, int *startOffset, int *endOffset) const<KAIGYO>{<KAIGYO>    /* The list of attributes can be found at:<KAIGYO>     httplinuxfoundation.org/collaborate/workgroups/accessibility/iaccessible2/textattributes<KAIGYO>    */': 1}",1.0,{}
384,81809.0,3.0,16.0,7.0,MERGED,True,https://codereview.qt-project.org/#/c/81809,Unite the documentation for qmath.h functions,1.0,{},0.0,"{'/*!<KAIGYO>    \\headerfile <QtMath><KAIGYO>    \\title Generic Math Declarations<KAIGYO>    \\ingroup funclists<KAIGYO><KAIGYO>    \\brief The <QtMath> header file includes generic math declarations.<KAIGYO><KAIGYO>    These functions are partly convenience definitions for basic<KAIGYO>    operations, for instance not available in the Standard Template Library et<KAIGYO>    al.<KAIGYO>*/': 1, '/*!<KAIGYO>    \\fn float qDegreesToRadians(float degrees)<KAIGYO>    \\relates <QtMath><KAIGYO>    \\since 5.1<KAIGYO><KAIGYO>    \\brief The function converts the \\a degrees in float to radians.<KAIGYO><KAIGYO>    The purpose of the function is to aid the conversion as such a convenient<KAIGYO>    function is not part of the Standard Template Library, i.e. in <cmath> or<KAIGYO>    elsewhere.<KAIGYO><KAIGYO>    Example:<KAIGYO><KAIGYO>    \\snippet code/src_corelib_kernel_qmath.cpp 0<KAIGYO><KAIGYO>    \\sa qRadiansToDegrees()<KAIGYO>*/': 1, '/*!<KAIGYO>    \\fn double qDegreesToRadians(double degrees)<KAIGYO>    \\relates <QtMath><KAIGYO>    \\since 5.1<KAIGYO><KAIGYO>    \\brief The function converts the \\a degrees in double to radians.<KAIGYO><KAIGYO>    The purpose of the function is to aid the conversion as such a convenient<KAIGYO>    function is not part of the Standard Template Library, i.e. in <cmath> or<KAIGYO>    elsewhere.<KAIGYO><KAIGYO>    Example:<KAIGYO><KAIGYO>    \\snippet code/src_corelib_kernel_qmath.cpp 1<KAIGYO><KAIGYO>    \\sa qRadiansToDegrees()<KAIGYO>*/': 1, '/*!<KAIGYO>    \\fn float qRadiansToDegrees(float radians)<KAIGYO>    \\relates <QtMath><KAIGYO>    \\since 5.1<KAIGYO><KAIGYO>    \\brief The function converts the \\a radians in float to degrees.<KAIGYO><KAIGYO>    The purpose of the function is to aid the conversion as such a convenient<KAIGYO>    function is not part of the Standard Template Library, i.e. in <cmath> or<KAIGYO>    elsewhere.<KAIGYO><KAIGYO>    Example:<KAIGYO><KAIGYO>    \\snippet code/src_corelib_kernel_qmath.cpp 2<KAIGYO><KAIGYO>    \\sa qDegreesToRadians()<KAIGYO>*/': 1, '/*!<KAIGYO>    \\fn double qRadiansToDegrees(double radians)<KAIGYO>    \\relates <QtMath><KAIGYO>    \\since 5.1<KAIGYO><KAIGYO>    \\brief The function converts the \\a radians in double to degrees.<KAIGYO><KAIGYO>    The purpose of the function is to aid the conversion as such a convenient<KAIGYO>    function is not part of the Standard Template Library, i.e. in <cmath> or<KAIGYO>    elsewhere.<KAIGYO><KAIGYO>    Example:<KAIGYO><KAIGYO>    \\snippet code/src_corelib_kernel_qmath.cpp 3<KAIGYO><KAIGYO>    \\sa qDegreesToRadians()<KAIGYO>*/': 1}",1.0,{}
66,82177.0,1.0,3.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/82177,Remove the noisy comments from the terminal example,1.0,{},0.0,"{'// fill baud rate (is not the entire list of available values,<KAIGYO>// desired values??, add your independently)<KAIGYO>// fill data bits<KAIGYO>// fill parity<KAIGYO>// fill stop bits<KAIGYO>// fill flow control<KAIGYO>// Baud Rate<KAIGYO>// custom baud rate<KAIGYO>// standard baud rate<KAIGYO>// Data bits<KAIGYO>// Parity<KAIGYO>// Stop bits<KAIGYO>// Flow control<KAIGYO>// Additional options': 1}",1.0,{}
245,82487.0,2.0,6.0,2.0,MERGED,True,https://codereview.qt-project.org/#/c/82487,Remove old Bluetooth tennis example,1.0,{},0.0,{'// why is y -1...otherwise we have a gap...': 1},1.0,{}
257,82552.0,2.0,6.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/82552,V4 IR: clean up basic-block management and statement access.,1.0,{},0.0,"{""// TODO: change this to mark the block as deleted, but leave it alone so that other references<KAIGYO>//       won't be dangling pointers."": 1, '// Number all basic blocks, so we have nice numbers in the dumps:': 1}",1.0,{}
240,82554.0,3.0,10.0,1.0,MERGED,True,https://codereview.qt-project.org/#/c/82554,V4 IR: replace QSets with QBitArray and QVector.,1.0,{},0.0,"{'// Actually, it is potentially dangerous: if that block was already<KAIGYO>// destroyed, this could result in a use-after-free.': 1}",1.0,{}
279,82658.0,2.0,11.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/82658,Remove spurious #ifdef from tst_QComplexText,1.0,{},0.0,"{'// Horrible hack, but this get this out of the way for now<KAIGYO>// Carlos Duclos, 2007-12-11': 1}",1.0,{}
373,82867.0,1.0,5.0,0.0,ABANDONED,False,https://codereview.qt-project.org/#/c/82867,Direct2D QPA: Improve gradient support,1.0,{},0.0,{'// We could probably natively support linear and radial gradients that have pad reflect': 1},1.0,{}
41,83015.0,1.0,2.0,0.0,ABANDONED,False,https://codereview.qt-project.org/#/c/83015,Dynamic GL in Quick,1.0,{},0.0,{'// ###TODO Remove once using Khronos OpenGL headers': 1},1.0,{}
47,83081.0,4.0,5.0,0.0,ABANDONED,False,https://codereview.qt-project.org/#/c/83081,Dialogs: implementation prop renamed to contentItem; API cleanup,1.0,{},0.0,"{'// For a pure QML implementation, there is no helper.<KAIGYO>// But m_implementation is probably either an Item or a Window at this point.': 1}",1.0,{}
39,83097.0,2.0,8.0,6.0,ABANDONED,False,https://codereview.qt-project.org/#/c/83097,qmlplugindump: correctly merge composite types,1.0,{},0.0,{'// Also eliminate meta objects with the same classname.<KAIGYO>// This is required because extended objects seem not to share<KAIGYO>// a single meta object instance.': 1},1.0,{}
58,83120.0,2.0,3.0,0.0,ABANDONED,False,https://codereview.qt-project.org/#/c/83120,WIP: WinRT: fix sockets for HTTP,1.0,{},0.0,{'// Continue reading ### TODO: read into offset!!!': 2},1.0,{}
61,83183.0,2.0,14.0,6.0,MERGED,True,https://codereview.qt-project.org/#/c/83183,qmlplugindump: correctly merge composite types,1.0,{},0.0,{'// Also eliminate meta objects with the same classname.<KAIGYO>// This is required because extended objects seem not to share<KAIGYO>// a single meta object instance.': 1},1.0,{}
91,83216.0,6.0,17.0,6.0,MERGED,True,https://codereview.qt-project.org/#/c/83216,WinRT: Fix TCP socket reads,1.0,{},0.0,"{'// Wait for connection to enter bound state - TODO: timeout, check result': 1, '// Continue reading ### TODO: read into offset!!!': 1, '// ### Set error message<KAIGYO>// ### Set error message<KAIGYO>// Wait for connection to enter bound state - TODO: timeout, check result': 2}",1.0,{}
222,83280.0,11.0,26.0,4.0,MERGED,True,https://codereview.qt-project.org/#/c/83280,Dialogs: implementation prop renamed to contentItem; API cleanup,1.0,{},0.0,"{'// For a pure QML implementation, there is no helper.<KAIGYO>// But m_implementation is probably either an Item or a Window at this point.': 1}",1.0,{}
155,83368.0,4.0,5.0,1.0,ABANDONED,False,https://codereview.qt-project.org/#/c/83368,V4 IR: change datastructure of the worklist used by type inference.,1.0,{},0.0,{'// TODO: the worklist handling looks a bit inefficient... check if there is something better': 1},1.0,{}
228,83514.0,2.0,9.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/83514,Direct2D QPA: Improve gradient support,1.0,{},0.0,{'// We could probably natively support linear and radial gradients that have pad reflect': 1},1.0,{}
249,83556.0,2.0,7.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/83556,Direct2D QPA: Refactor code to reduce code duplication,1.0,{},0.0,"{'// XXX reduce code duplication between painterPathToPathGeometry and<KAIGYO>// vectorPathToID2D1PathGeometry, the two are quite similar': 2}",1.0,{}
287,83636.0,2.0,2.0,0.0,ABANDONED,False,https://codereview.qt-project.org/#/c/83636,WIP stack slots,1.0,{},0.0,{'// TODO: patch stack size (the push instruction)': 1},1.0,{}
443,83760.0,3.0,20.0,39.0,MERGED,True,https://codereview.qt-project.org/#/c/83760,Fix coding style in QBluetooth,1.0,{'// TODO implement this<KAIGYO>// TODO implement this<KAIGYO>// TODO implement this<KAIGYO>// TODO implement this<KAIGYO>// TODO implement this': 1},1.0,"{'//TODO implement this<KAIGYO>//TODO implement this<KAIGYO>//TODO implement this': 1, '//TODO implement this<KAIGYO>//TODO implement this': 1}",1.0,{}
339,83783.0,3.0,9.0,8.0,MERGED,True,https://codereview.qt-project.org/#/c/83783,Fix crash in QDeclarativeBluetoothService,1.0,{'// TODO: propagate this error to the user': 1},1.0,{'//TODO propaget this error to the user': 1},1.0,{}
239,84435.0,12.0,65.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/84435,Convert QQuickParticleData to new data layout,1.0,{'//TODO: Guard needed?': 1},1.0,{'//TODO: Guard needed?': 1},1.0,{}
286,84527.0,4.0,5.0,0.0,ABANDONED,False,https://codereview.qt-project.org/#/c/84527,WIP: use debugsupport for standalone qmlprofiler,1.0,{},0.0,"{'/*!<KAIGYO>  \\class QPacketProtocol<KAIGYO>  \\internal<KAIGYO><KAIGYO>  \\brief The QPacketProtocol class encapsulates communicating discrete packets<KAIGYO>  across fragmented IO channels, such as TCP sockets.<KAIGYO><KAIGYO>  QPacketProtocol makes it simple to send arbitrary sized data """" across<KAIGYO>  fragmented transports such as TCP and UDP.<KAIGYO><KAIGYO>  As transmission boundaries are not respected, sending packets over protocols<KAIGYO>  like TCP frequently involves """" them back together at the receiver.<KAIGYO>  QPacketProtocol makes this easier by performing this task for you.  Packet<KAIGYO>  data sent using QPacketProtocol is prepended with a 4-byte size header<KAIGYO>  allowing the receiving QPacketProtocol to buffer the packet internally until<KAIGYO>  it has all been received.  QPacketProtocol does not perform any sanity<KAIGYO>  checking on the size or on the data, so this class should only be used in<KAIGYO>  prototyping or trusted situations where DOS attacks are unlikely.<KAIGYO><KAIGYO>  QPacketProtocol does not perform any communications itself.  Instead it can<KAIGYO>  operate on any QIODevice that supports the QIODevice::readyRead() signal.  A<KAIGYO>  logical """" is encapsulated by the companion QPacket class.  The<KAIGYO>  following example shows two ways to send data using QPacketProtocol.  The<KAIGYO>  transmitted data is equivalent in both.<KAIGYO><KAIGYO>  \\code<KAIGYO>  QTcpSocket socket;<KAIGYO>  // ... connect socket ...<KAIGYO><KAIGYO>  QPacketProtocol protocol(&socket);<KAIGYO><KAIGYO>  // Send packet the quick way<KAIGYO>  protocol.send() << """" << 123;<KAIGYO><KAIGYO>  // Send packet the longer way<KAIGYO>  QPacket packet;<KAIGYO>  packet << """" << 123;<KAIGYO>  protocol.send(packet);<KAIGYO>  \\endcode<KAIGYO><KAIGYO>  Likewise, the following shows how to read data from QPacketProtocol, assuming<KAIGYO>  that the QPacketProtocol::readyRead() signal has been emitted.<KAIGYO><KAIGYO>  \\code<KAIGYO>  // ... QPacketProtocol::readyRead() is emitted ...<KAIGYO><KAIGYO>  int a;<KAIGYO>  QByteArray b;<KAIGYO><KAIGYO>  // Receive packet the quick way<KAIGYO>  protocol.read() >> a >> b;<KAIGYO><KAIGYO>  // Receive packet the longer way<KAIGYO>  QPacket packet = protocol.read();<KAIGYO>  p >> a >> b;<KAIGYO>  \\endcode<KAIGYO><KAIGYO>  \\ingroup io<KAIGYO>  \\sa QPacket<KAIGYO>*/': 1}",1.0,{}
254,84533.0,3.0,8.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/84533,WinRT: Fix multi-touch on PC,1.0,{},0.0,{'// TODO: We may want to probe the device usage flags for more accurate values for these next two': 1},1.0,{}
280,84594.0,3.0,8.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/84594,Direct2D QPA: Speed up text rendering,1.0,{},0.0,"{'// XXX Are we generating a lot of cache misses here?<KAIGYO>// Most common cases are perspective transform and gradient brush as pen': 2, '// XXX Are we generating a lot of cache misses here?': 2}",1.0,{}
285,84595.0,2.0,12.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/84595,Move the WinCE implementation into separate module,1.0,{'// FIXME: Here the situation is not properly handled with zero timeout:<KAIGYO>// breaker can work out before you call a method WaitCommEvent()<KAIGYO>// and so it will loop forever!': 1},1.0,{'// FIXME: Here the situation is not properly handled with zero timeout:<KAIGYO>// breaker can work out before you call a method WaitCommEvent()<KAIGYO>// and so it will loop forever!': 1},1.0,{}
334,84700.0,7.0,23.0,14.0,MERGED,True,https://codereview.qt-project.org/#/c/84700,WinRT: Support High-DPI,1.0,{'// TODO: blit only the changed rectangle': 4},1.0,{'// TODO: blit only the changed rectangle': 4},1.0,{}
371,84827.0,1.0,4.0,0.0,ABANDONED,False,https://codereview.qt-project.org/#/c/84827,Remove V8 profiler service,1.0,{},0.0,"{'// ### FIXME: v4': 1, '// ### FIXME: v4<KAIGYO>//    void takeSnapshot(v8::HeapSnapshot::Type);<KAIGYO>//    void printProfileTree(const v8::CpuProfileNode *node, int level = 0);<KAIGYO>//    void sendMessages();': 1, '//    v8::Handle<v8::String> v8title = v8::String::New(reinterpret_cast<const uint16_t*>(title.data()), title.size());<KAIGYO>// ### FIXME: v4<KAIGYO>//    v8::CpuProfiler::StartProfiling(v8title);': 1, '//    Q_D(QV4ProfilerService);<KAIGYO>// ### FIXME: v4<KAIGYO>//    d->takeSnapshot(v8::HeapSnapshot::kFull);': 1, '// ### FIXME: v4<KAIGYO>//    v8::HeapProfiler::DeleteAllSnapshots();': 1, '//    Q_D(QV4ProfilerService);<KAIGYO>// Send messages to client<KAIGYO>// ### FIXME: v4<KAIGYO>//    d->sendMessages();': 1}",1.0,{}
16,85037.0,1.0,9.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/85037,Direct2D QPA: Choose linear interpolation for smooth pixmap transform,1.0,{},0.0,{'// XXX are we choosing the right d2d interpolation modes?': 1},1.0,{}
23,85047.0,1.0,4.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/85047,Remove V8 profiler service,1.0,{},0.0,"{'// ### FIXME: v4': 1, '// ### FIXME: v4<KAIGYO>//    void takeSnapshot(v8::HeapSnapshot::Type);<KAIGYO>//    void printProfileTree(const v8::CpuProfileNode *node, int level = 0);<KAIGYO>//    void sendMessages();': 1, '//    v8::Handle<v8::String> v8title = v8::String::New(reinterpret_cast<const uint16_t*>(title.data()), title.size());<KAIGYO>// ### FIXME: v4<KAIGYO>//    v8::CpuProfiler::StartProfiling(v8title);': 1, '//    Q_D(QV4ProfilerService);<KAIGYO>// ### FIXME: v4<KAIGYO>//    d->takeSnapshot(v8::HeapSnapshot::kFull);': 1, '// ### FIXME: v4<KAIGYO>//    v8::HeapProfiler::DeleteAllSnapshots();': 1, '//    Q_D(QV4ProfilerService);<KAIGYO>// Send messages to client<KAIGYO>// ### FIXME: v4<KAIGYO>//    d->sendMessages();': 1}",1.0,{}
103,85196.0,3.0,17.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/85196,qpa: Merge qgl_qpa.cpp into qgl.cpp,1.0,{'// a context may refere to more than 1 window.<KAIGYO>//but its better to point to 1 of them than none of them.': 1},1.0,{'// a context may refere to more than 1 window.<KAIGYO>//but its better to point to 1 of them than none of them.': 1},1.0,{}
107,85203.0,2.0,16.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/85203,qpa: Merge qdesktopwidget_qpa.cpp into qdesktopwidget.cpp,1.0,{'//even better would be closest screen': 1},1.0,{'//even better would be closest screen': 1},1.0,{}
137,85204.0,5.0,12.0,4.0,MERGED,True,https://codereview.qt-project.org/#/c/85204,Code cleanup: Avoid repeated service info duplication check,1.0,{},0.0,{'// TODO check for duplicates (wait until stable has merged due to related change)': 1},1.0,{}
112,85216.0,3.0,7.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/85216,Fix CalendarStyle's layouting and grid cell calculation.,1.0,"{'// The cell index might be valid, but the date has to be too. We could let the<KAIGYO>// selected date validation take care of this, but then the selected date would<KAIGYO>// change to the earliest day if a day before the minimum date is clicked, for example.': 1, '// TODO: still necessary after these changes?': 1, '// TODO: this will not be correct if the app is running when a new day begins.': 1, '// todo: pressed property here, clicked and doubleClicked in the control itself': 1}",1.0,"{'// The cell index might be valid, but the date has to be too. We could let the<KAIGYO>// selected date validation take care of this, but then the selected date would<KAIGYO>// change to the earliest day if a day before the minimum date is clicked, for example.': 1, '// TODO: this will not be correct if the app is running when a new day begins.': 1, '// todo: pressed property here, clicked and doubleClicked in the control itself': 1}",1.0,{}
113,85217.0,2.0,17.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/85217,qpa: Merge qwidget_qpa.cpp into qwidget.cpp,1.0,"{'// XXX': 1, '//the toplevel might have a context with a ""qglcontext associated with it. We need to<KAIGYO>//delete the qglcontext before we delete the qplatformopenglcontext.<KAIGYO>//One unfortunate thing about this is that we potentially create a glContext just to<KAIGYO>//delete it straight afterwards.': 1, '//### why do we have isMove as a parameter?': 1, '// Was the window moved by the Window system or QPlatformWindow::initialGeometry() ?': 1, '//### why does this have to be done in the _sys function???': 1}",1.0,"{'//### why does this have to be done in the _sys function???': 1, '// Was the window moved by the Window system or QPlatformWindow::initialGeometry() ?': 1, '//### why do we have isMove as a parameter?': 1, '// XXX': 1, '//the toplevel might have a context with a ""qglcontext associated with it. We need to<KAIGYO>//delete the qglcontext before we delete the qplatformopenglcontext.<KAIGYO>//One unfortunate thing about this is that we potentially create a glContext just to<KAIGYO>//delete it straight afterwards.': 1}",1.0,{}
128,85224.0,5.0,23.0,1.0,MERGED,True,https://codereview.qt-project.org/#/c/85224,qpa: Merge qapplication_qpa.cpp into qapplication.cpp,1.0,{'// #fixme: Remove.<KAIGYO>// display device context': 1},1.0,{'// #fixme: Remove.<KAIGYO>// display device context': 1},1.0,{}
118,85229.0,2.0,10.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/85229,Remove an unused workaround and fix up the comments in the glyph cache,1.0,"{'// The scanlines in mask are 32-bit aligned, even for mono or 8-bit formats. This<KAIGYO>// is good because it matches the default of 4 bytes for GL_UNPACK_ALIGNMENT.': 1}",1.0,"{""// glTexSubImage2D() might cause some garbage to appear in the texture if the mask width is<KAIGYO>// not a multiple of four bytes. The bug appeared on a computer with 32-bit Windows Vista<KAIGYO>// and nVidia GeForce 8500GT. GL_UNPACK_ALIGNMENT is set to four bytes, 'mask' has a<KAIGYO>// multiple of four bytes per line, and most of the glyph shows up correctly in the<KAIGYO>// texture, which makes me think that this is a driver bug.<KAIGYO>// One workaround is to make sure the mask width is a multiple of four bytes, for instance<KAIGYO>// by converting it to a format with four bytes per pixel. Another is to copy one line at a<KAIGYO>// time."": 1}",1.0,{}
127,85272.0,4.0,5.0,0.0,ABANDONED,False,https://codereview.qt-project.org/#/c/85272,Added support for PCI vendor/device information,1.0,{},0.0,{'// TODO: Obtain more information about the device': 1},1.0,{}
199,85435.0,3.0,14.0,12.0,MERGED,True,https://codereview.qt-project.org/#/c/85435,Add support for PCI vendor/device information,1.0,{},0.0,{'// TODO: Obtain more information about the device': 1},1.0,{}
203,85442.0,4.0,25.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/85442,V4 IR: change datastructure of the worklist used by type inference.,1.0,{},0.0,{'// TODO: the worklist handling looks a bit inefficient... check if there is something better': 1},1.0,{}
238,85449.0,5.0,14.0,1.0,MERGED,True,https://codereview.qt-project.org/#/c/85449,V4 IR: make statement numbering fixed and clean up statement worklists.,1.0,"{'//### TODO: check if this can be done in a more elegant way.': 1, '// Do not compare the result of find with the end iterator, because some libc++ versions<KAIGYO>// have a bug where the result of the ++operator is past-the-end of the vector, but unequal<KAIGYO>// to end().': 1}",1.0,"{'// For QVector efficiency reasons, we process statements from the back. However, it is more<KAIGYO>// effective to process the statements in ascending order. So we need to invert the<KAIGYO>// order.': 1}",1.0,{}
215,85457.0,1.0,3.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/85457,V4 IR: add def statements to the worklist when removing uses.,1.0,{'// dead code elimination:': 1},1.0,{'// dead code elimination:': 1},1.0,{}
218,85458.0,1.0,3.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/85458,V4 IR: Store positions for life-time intervals outside the statement.,1.0,{'// TODO: replace this class by DefUses': 1},1.0,{'//### TODO: check if this can be done in a more elegant way.': 1},1.0,{}
258,85459.0,5.0,13.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/85459,V4 RegAlloc: change life-time intervals from closed to half-open.,1.0,"{'//### TODO: use DefUses from the optimizer, because it already has all this information': 3}",1.0,{'// TODO: replace this class by DefUses': 3},1.0,{}
415,85516.0,27.0,35.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/85516,TextField & TextArea: add support for selection handles,1.0,"{'// moving down': 1, '// moving up': 1, '// TODO: parent: area.viewport': 1, '// TODO': 3, '// TODO:<KAIGYO>//pt.x = Math.max(0, Math.min(pt.x, editor.contentWidth - 1))<KAIGYO>//pt.y = Math.max(0, Math.min(pt.y, editor.contentHeight - 1))': 4, '    /*! The cursor handle. (TODO)<KAIGYO>        \\since QtQuick.Controls.Styles 1.3 */': 4, '    /*! The selection handle. (TODO)<KAIGYO>        \\since QtQuick.Controls.Styles 1.3 */': 4}",1.0,"{'// Workaround for QTBUG-36515<KAIGYO>// keep textcursor within scroll view': 1, '// moving down': 1, '// moving up': 1, '// Workaround for QTBUG-36515': 4}",1.0,{}
405,85881.0,5.0,14.0,5.0,MERGED,True,https://codereview.qt-project.org/#/c/85881,Move native subwidgets in QWidget::scroll().,1.0,{},0.0,{'// XXX': 4},1.0,{}
341,86048.0,2.0,7.0,0.0,ABANDONED,False,https://codereview.qt-project.org/#/c/86048,WIP: Use correct terminology esp. in relation to Apple platforms.,1.0,"{'//workaround for deadlock in __cxa_guard_acquire with webkit on OS X': 1, '// the metalhack boolean allows Qt/OS X to do a proper re-polish depending<KAIGYO>// On OS X we must set the cursor even if it is the ArrowCursor.': 1, '// - (OS X only) The window is higher than the available geometry. It must<KAIGYO>//### already hidden above ---> must probably do something smart on OS X': 1, '// widget do something else (lineedit cursor moves to home/end on OS X, for instance)': 1, '// Also move the scroll bars if they are covered by the native Cocoa size grip.<KAIGYO>// no corner widget. Also, on OS X we paint if there is a native': 1, ""//I don't know why it is not working on OS X"": 1, '// A very simple test, but OS X needs to have its format """" if the format is changed<KAIGYO>// NativeFormat, OS X: Supported, default true<KAIGYO>// NativeFormat, OS X: Unsupported, always QPrinter::Color<KAIGYO>// NativeFormat, OS X: Supported, multiple copies supported, default 1<KAIGYO>// NativeFormat, OS X: Supported, default QString()<KAIGYO>// NativeFormat, OS X: Supported, default QString()<KAIGYO>// NativeFormat, OS X: Unsupported, always QPrinter::DuplexNone<KAIGYO>// NativeFormat, OS X: Unsupported, always false<KAIGYO>// NativeFormat, OS X: Unsupported, always false<KAIGYO>// NativeFormat, OS X: Supported, default false<KAIGYO>// NativeFormat, OS X: Supported, default QPrinter::Portrait<KAIGYO>// NativeFormat, OS X: Supported, default QString()<KAIGYO>// NativeFormat, OS X: Unsupported, always QPrinter::FirstPageFirst<KAIGYO>// NativeFormat, OS X: Supported, must be supported size, defaults to printer default<KAIGYO>// NativeFormat, OS X: Supported, must be supported size, defaults to printer default<KAIGYO>// NativeFormat, OS X: Unsupported, always QPrinter::Auto<KAIGYO>// NativeFormat, OS X: Unsupported, always QString()<KAIGYO>// NativeFormat, OS X: Supported, default QPrinter::AllPages<KAIGYO>// NativeFormat, OS X: Supported, default printer<KAIGYO>// NativeFormat, OS X: Unsupported, always QString()<KAIGYO>// NativeFormat, OS X: Supported, but can only be value returned by supportedResolutions()<KAIGYO>// NativeFormat, OS X: ifdef\'d out TODO remove ifdef<KAIGYO>// NativeFormat, OS X: Supported, defaults to printer list<KAIGYO>// NativeFormat, OS X: Supported, defaults to printer default': 1, '// OS X has 3 different ways of accomplishing this (same for moving to the back)<KAIGYO>// Platform specific move. Home and End do nothing on OS X,': 1}",1.0,"{'//workaround for deadlock in __cxa_guard_acquire with webkit on macos x': 1, '// the metalhack boolean allows Qt/Mac to do a proper re-polish depending<KAIGYO>// On Mac we must set the cursor even if it is the ArrowCursor.': 1, '// - (Mac only) The window is higher than the available geometry. It must<KAIGYO>//### already hidden above ---> must probably do something smart on the mac': 1, '// widget do something else (lineedit cursor moves to home/end on mac, for instance)': 1, '// Also move the scroll bars if they are covered by the native Mac size grip.<KAIGYO>// no corner widget. Also, on the Mac we paint if there is a native': 1, ""//I don't know why it is not working on mac"": 1, '// A very simple test, but Mac needs to have its format """" if the format is changed<KAIGYO>// NativeFormat, Mac: Supported, default true<KAIGYO>// NativeFormat, Mac: Unsupported, always QPrinter::Color<KAIGYO>// NativeFormat, Mac: Supported, multiple copies supported, default 1<KAIGYO>// NativeFormat, Mac: Supported, default QString()<KAIGYO>// NativeFormat, Mac: Supported, default QString()<KAIGYO>// NativeFormat, Mac: Unsupported, always QPrinter::DuplexNone<KAIGYO>// NativeFormat, Mac: Unsupported, always false<KAIGYO>// NativeFormat, Mac: Unsupported, always false<KAIGYO>// NativeFormat, Mac: Supported, default false<KAIGYO>// NativeFormat, Mac: Supported, default QPrinter::Portrait<KAIGYO>// NativeFormat, Mac: Supported, default QString()<KAIGYO>// NativeFormat, Mac: Unsupported, always QPrinter::FirstPageFirst<KAIGYO>// NativeFormat, Mac: Supported, must be supported size, defaults to printer default<KAIGYO>// NativeFormat, Mac: Supported, must be supported size, defaults to printer default<KAIGYO>// NativeFormat, Mac: Unsupported, always QPrinter::Auto<KAIGYO>// NativeFormat, Mac: Unsupported, always QString()<KAIGYO>// NativeFormat, Mac: Supported, default QPrinter::AllPages<KAIGYO>// NativeFormat, Mac: Supported, default printer<KAIGYO>// NativeFormat, Mac: Unsupported, always QString()<KAIGYO>// NativeFormat, Mac: Supported, but can only be value returned by supportedResolutions()<KAIGYO>// NativeFormat, Mac: ifdef\'d out TODO remove ifdef<KAIGYO>// NativeFormat, Mac: Supported, defaults to printer list<KAIGYO>// NativeFormat, Mac: Supported, defaults to printer default': 1, '// Mac has 3 different ways of accomplishing this (same for moving to the back)<KAIGYO>// Platform specific move. Home and End do nothing on the Mac,': 1}",1.0,{}
146,86416.0,1.0,3.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/86416,Fix EllipseShape for Affectors in QtQuick.Particle,1.0,{},0.0,{'//TODO: Ellipse': 1},1.0,{}
172,86477.0,2.0,7.0,2.0,MERGED,True,https://codereview.qt-project.org/#/c/86477,Simplify of the availablePortsByUdev(),1.0,{},0.0,"{'// TODO: Obtain more information': 1, '// FIXME: Obtain more information': 1}",1.0,{}
224,86629.0,3.0,9.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/86629,Merge remote-tracking branch 'origin/stable' into dev,1.0,{},0.0,{'//### better way to check for signal property?': 3},1.0,{}
232,86706.0,1.0,3.0,0.0,ABANDONED,False,https://codereview.qt-project.org/#/c/86706,Convert the line-endings on Windows in the bootstrapped case too,1.0,"{""// FIXME: Qt's line end conversion on sequential files should really be fixed"": 1}",1.0,"{""// FIXME: Qt's line end conversion on sequential files should really be fixed"": 1}",1.0,{}
281,86814.0,2.0,21.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/86814,Merge remote-tracking branch 'origin/stable' into dev,1.0,{},0.0,"{'// XXX': 1, '//### why does this have to be done in the _sys function???': 1, '// Was the window moved by the Window system or QPlatformWindow::initialGeometry() ?': 1, '//### why do we have isMove as a parameter?': 1, '//the toplevel might have a context with a ""qglcontext associated with it. We need to<KAIGYO>//delete the qglcontext before we delete the qplatformopenglcontext.<KAIGYO>//One unfortunate thing about this is that we potentially create a glContext just to<KAIGYO>//delete it straight afterwards.': 1}",1.0,{}
16,87021.0,7.0,18.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/87021,winrt: Clean up QWinRTServices,1.0,{},0.0,{'// ### TODO: Replace with HStringReference when WP8.0 support is removed': 4},1.0,{}
24,87045.0,3.0,9.0,3.0,MERGED,True,https://codereview.qt-project.org/#/c/87045,Improve the ResourceError handling on Windows,1.0,{},0.0,"{'// Workaround for standard CDC ACM serial ports, for which triggered an<KAIGYO>// unexpected event EV_TXEMPTY at data transmission.': 1}",1.0,{}
92,87142.0,3.0,12.0,8.0,MERGED,True,https://codereview.qt-project.org/#/c/87142,Improve the serial number handling on Windows,1.0,{},0.0,{'// TODO: error handling with GetLastError': 1},1.0,{}
123,87251.0,3.0,18.0,0.0,ABANDONED,False,https://codereview.qt-project.org/#/c/87251,Merge remote-tracking branch 'origin/5.3' into dev,1.0,{},0.0,"{'//### why does this have to be done in the _sys function???': 1, '// Was the window moved by the Window system or QPlatformWindow::initialGeometry() ?': 1, '//### why do we have isMove as a parameter?': 1, '// XXX': 1, '//the toplevel might have a context with a ""qglcontext associated with it. We need to<KAIGYO>//delete the qglcontext before we delete the qplatformopenglcontext.<KAIGYO>//One unfortunate thing about this is that we potentially create a glContext just to<KAIGYO>//delete it straight afterwards.': 1}",1.0,{}
409,87405.0,12.0,49.0,0.0,ABANDONED,False,https://codereview.qt-project.org/#/c/87405,WIP: Replace direct pointers to heap objects with indirect pointers,1.0,{},0.0,{'//TODO: Guard needed?': 2},1.0,{}
169,87411.0,2.0,5.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/87411,Don't construct QBluetoothUuid via string parsing,1.0,{},0.0,"{""//    //TODO don't use string conversion but raw ints once QBluetoothUuid ctor is fixed<KAIGYO>//    quint128 qtdst;<KAIGYO>//    memcpy(&qtdst, &dst, sizeof(uint128_t));"": 1}",1.0,{}
336,87732.0,4.0,12.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/87732,Connect QLowEnergyService and QLowEnergyControllerNew classes,1.0,{'//TODO Implement discoverServiceDetails()': 1},1.0,{'//TODO discoverDetails': 1},1.0,{}
13,88007.0,4.0,9.0,0.0,ABANDONED,False,https://codereview.qt-project.org/#/c/88007,xcb: QTabletEvents and proximity events correctly identify the tool,1.0,"{'// TODO Intuos3 Art Pen and any others': 1, '// Workaround for httpsourceforge.net/p/linuxwacom/bugs/246/<KAIGYO>// e.g. on Thinkpad Helix, tool ID will be 0 and serial will be 1': 1, '// TODO maybe have a hash of tabletData->deviceId to device data so we can<KAIGYO>// look up the tablet name here, and distinguish multiple tablets': 1}",1.0,"{'// TODO: whether """" is rotation or tangential pressure depends on the tool in use': 4}",1.0,{}
34,88036.0,7.0,14.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/88036,Make QDom/QXmlSimpleReader reentrant.,1.0,{},0.0,"{""// Hack for letting QDom know where the skipped entity occurred<KAIGYO>// ### the use of this variable means the code isn't reentrant."": 1}",1.0,{}
70,88146.0,3.0,14.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/88146,Read characteristic values on Bluez,1.0,"{'//this should really be readable according to GATT Service spec': 1, '//TODO should be 1?': 1}",1.0,{'//TODO implement': 1},1.0,{}
98,88150.0,8.0,17.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/88150,Accessibility: improve text attribute ranges,1.0,"{'// note: color should probably always be part of the attributes': 1, '// FIXME': 1, ""// -1 doesn't make much sense here, but it's better to return something"": 2, ""// -1 doesn't make much sense here, but it's better to return something<KAIGYO>// screen readers may ask for text attributes at the cursor pos which may be equal to length"": 7}",1.0,{'// FIXME the new text is not there yet': 2},1.0,{}
145,88210.0,6.0,17.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/88210,Introduce QLowEnergyDescriptor,1.0,{'//TODO<KAIGYO>//d_ptr->m_value = value;': 5},1.0,"{'// TODO QLowEnergyCharacteristic::descriptors()': 1, '//TODO handle error': 1, '//        QCOMPARE(chars[0].descriptors().count(), 1);<KAIGYO>//<KAIGYO>//        QCOMPARE(chars[0].descriptors().at(0).handle(), 0x26u);<KAIGYO>//        QCOMPARE(chars[0].descriptors().at(0).uuid(), QBluetoothUuid(temp));<KAIGYO>//        QCOMPARE(chars[0].descriptors().at(0).value(), QByteArray(""""));<KAIGYO>//        temp = QString("""");<KAIGYO>//        QCOMPARE(QBluetoothUuid(chars[0].descriptors().at(0).type()), QBluetoothUuid(temp));<KAIGYO>//TODO should be 1?<KAIGYO>//        QCOMPARE(chars[0].descriptors().count(), 1);<KAIGYO>//        QCOMPARE(chars[0].descriptors().at(0).handle(), 0x2eu);<KAIGYO>//        QCOMPARE(chars[0].descriptors().at(0).uuid(), QBluetoothUuid(temp));<KAIGYO>//        QCOMPARE(chars[0].descriptors().at(0).value(), QByteArray(""""));<KAIGYO>//        temp = QString("""");<KAIGYO>//        QCOMPARE(QBluetoothUuid(chars[0].descriptors().at(0).type()), QBluetoothUuid(temp));': 1}",1.0,{}
177,88395.0,6.0,20.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/88395,Clean up neard implementation,1.0,{'// TODO We need a constructor that lets us select an adapter': 1},1.0,{'// TODO We need a constructor that lets us select a adapter': 1},1.0,{}
148,88410.0,1.0,2.0,0.0,DEFERRED,False,https://codereview.qt-project.org/#/c/88410,qmake: Fix compiler waring on Windows,1.0,{},0.0,"{""// We don't want to add a separator for DLLDESTDIR on Windows (###why?)"": 1}",1.0,{}
301,88649.0,6.0,10.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/88649,Rewrite Descriptor class unit test,1.0,{},0.0,{'//QLowEnergyDescriptorInfos share their internal data<KAIGYO>//for now enshrine this in the test<KAIGYO>//TODO do we really need this behavior as it is unusual for value types': 1},1.0,{}
280,88668.0,2.0,6.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/88668,Rewrite QLowEnergyCharacteristic unit test,1.0,{},0.0,{'//QLowEnergyCharacteristicInfos share their internal data<KAIGYO>//for now enshrine this in the test<KAIGYO>//TODO do we really need this behavior as it is unusual for value types': 1},1.0,{}
376,88837.0,7.0,14.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/88837,Make independent implementation of QSerialPortInfo for OS X,1.0,{},0.0,{'// FIXME': 1},1.0,{}
360,88853.0,2.0,3.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/88853,Fix crash in Flickable with pressDelay.,1.0,{'// Use the event handler that will take care of finding the proper item to propagate the event': 1},1.0,{'// Use the event handler that will take care of finding the proper item to propagate the event': 1},1.0,{}
364,88858.0,4.0,13.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/88858,winrt: Use physical window resolution,1.0,{},0.0,{'// TODO: move this to Window': 1},1.0,{}
366,88859.0,4.0,12.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/88859,winrt: Refactor backing store,1.0,"{'// TODO: when ANGLE GLES3 support is finished, use the glPixelStorei functions to minimize upload': 1}",1.0,"{""// Blitting the entire image width trades zero image copy/relayout for a larger texture upload.<KAIGYO>// Since we're blitting the whole width anyway, the boundingRect() is used in the assumption that<KAIGYO>// we don't repeat upload. This is of course dependent on the distance between update regions.<KAIGYO>// Ideally, we would use the GL_EXT_unpack_subimage extension, which should be possible to implement<KAIGYO>// since D3D11_MAPPED_SUBRESOURCE supports RowPitch (see below).<KAIGYO>// Note that single-line blits in a loop are *very* slow, so reducing calls to glTexSubImage2D<KAIGYO>// is probably a good idea anyway."": 1, '// TODO: Implement GL_EXT_unpack_subimage in ANGLE for more minimal uploads<KAIGYO>//glPixelStorei(GL_UNPACK_ROW_LENGTH, image->bytesPerLine());<KAIGYO>//glTexSubImage2D(GL_TEXTURE_2D, 0, bounds.x(), bounds.y(), bounds.width(), bounds.height(),<KAIGYO>//                GL_BGRA_EXT, GL_UNSIGNED_BYTE, image->scanLine(bounds.y()) + bounds.x() * 4);': 1, '// fast blit - TODO: perform the blit inside swap buffers instead': 1, '// TODO: blit only the changed rectangle': 1}",1.0,{}
404,88993.0,2.0,3.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/88993,Remove old API test from tst_qlowenergycontroller,1.0,{},0.0,"{'//this should really be readable according to GATT Service spec': 1, '//TODO should this really be false': 1, '//TODO should be 1?': 1}",1.0,{}
30,89084.0,2.0,13.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/89084,Accessibility Linux: Implement set focus action,1.0,{},0.0,"{'// FIXME: implement focus grabbing<KAIGYO>//        if (interface->object() && interface->object()->isWidgetType()) {<KAIGYO>//            QWidget* w = static_cast<QWidget*>(interface->object());<KAIGYO>//            w->setFocus(Qt::OtherFocusReason);<KAIGYO>//            sendReply(connection, message, true);<KAIGYO>//        }': 1}",1.0,{}
74,89086.0,9.0,43.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/89086,Integrate QWebChannel with QtWebKit.,1.0,"{'// TODO: use a distinct channel for the transport': 1, '// FIXME: should it work regardless of the thisObject?': 4, '// FIXME: needed?': 4, '// TODO: can we transmit the data as JS object, instead of as a string?': 4, '// TODO: can I convert a WKStringRef to a UTF8 QByteArray directly?': 7}",1.0,"{'// FIXME: should it work regardless of the thisObject?': 4, '// FIXME: needed?': 4}",1.0,{}
33,89104.0,2.0,5.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/89104,Merge remote-tracking branch 'origin/5.3' into dev,1.0,{},0.0,"{'//### why does this have to be done in the _sys function???': 1, '// Was the window moved by the Window system or QPlatformWindow::initialGeometry() ?': 1, '//### why do we have isMove as a parameter?': 1, '// XXX': 1, '//the toplevel might have a context with a ""qglcontext associated with it. We need to<KAIGYO>//delete the qglcontext before we delete the qplatformopenglcontext.<KAIGYO>//One unfortunate thing about this is that we potentially create a glContext just to<KAIGYO>//delete it straight afterwards.': 1}",1.0,{}
60,89109.0,3.0,6.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/89109,use after free in WebCore::DocumentOrderedMap::remove / WebCore::TreeScope::removeElementById,1.0,{},0.0,{'// FIXME: Should we fire this event asynchronoulsy via errorEventSender()?': 1},1.0,{}
147,89390.0,2.0,3.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/89390,Support writing of descriptors,1.0,{'//TODO not all descriptors are writable (how to deal with write errors)': 1},1.0,{'//TODO<KAIGYO>//d_ptr->m_value = value;': 1},1.0,{}
188,89519.0,2.0,5.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/89519,Remove useless QMetaType benchmarks,1.0,{},0.0,"{'// Tests how fast QMetaType can default-construct and destroy a Qt<KAIGYO>// core type. The purpose of this benchmark is to measure the overhead<KAIGYO>// of using type id-based creation compared to creating the type<KAIGYO>// directly (i.e. """").': 1, '// Tests how fast QMetaType can copy-construct and destroy a Qt core<KAIGYO>// type. The purpose of this benchmark is to measure the overhead of<KAIGYO>// using type id-based creation compared to creating the type directly<KAIGYO>// (i.e. """").': 1, '// Tests how fast QMetaType can default-construct and destroy a Qt GUI<KAIGYO>// type. The purpose of this benchmark is to measure the overhead of<KAIGYO>// using type id-based creation compared to creating the type directly<KAIGYO>// (i.e. """").': 1, '// Tests how fast QMetaType can copy-construct and destroy a Qt GUI<KAIGYO>// type. The purpose of this benchmark is to measure the overhead of<KAIGYO>// using type id-based creation compared to creating the type directly<KAIGYO>// (i.e. """").': 1}",1.0,{}
272,89796.0,3.0,5.0,0.0,ABANDONED,False,https://codereview.qt-project.org/#/c/89796,Inspector: Fix AppOnTop,1.0,{},0.0,{'// Hack for QTCREATORBUG-6295.<KAIGYO>// TODO: The root cause to be identified and fixed later.': 2},1.0,{}
311,89938.0,4.0,10.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/89938,Doc: Use \value command for documenting flags for QML properties,1.0,{},0.0,"{""/*!<KAIGYO>    \\li \\l StandardIcon.NoIcon<KAIGYO>    \\li \\l StandardIcon.Question<KAIGYO>    \\li \\l StandardIcon.Information<KAIGYO>    \\li \\l StandardIcon.Warning<KAIGYO>    \\li \\l StandardIcon.Critical<KAIGYO>// TODO after QTBUG-35019 is fixed: fix links to this module's enums<KAIGYO>// rather than linking to those in QMessageBox<KAIGYO>/*!<KAIGYO>    \\enum QQuickStandardButton::StandardButton<KAIGYO><KAIGYO>    This enum specifies a button with a standard label to be used on a dialog.<KAIGYO>*/"": 1}",1.0,{}
126,138546.0,5.0,10.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/138546,Merge remote-tracking branch 'origin/5.6' into dev,1.0,{},0.0,"{'/*!<KAIGYO>  Returns the sanitized file name without the path.<KAIGYO>  If the file is an html file, the html suffix<KAIGYO>  is removed. Why?<KAIGYO> */': 3, '            /*<KAIGYO>              ### hack for C++ to handle superfluous<KAIGYO>              """" prefixes gracefully<KAIGYO>            */': 3, '/*!<KAIGYO>  Find the module (Qt Core, Qt GUI, etc.) to which the class belongs.<KAIGYO>  We do this by obtaining the full path to the header file\'s location<KAIGYO>  and examine everything between """" and the filename.  This is<KAIGYO>  semi-dirty because we are assuming a particular directory structure.<KAIGYO><KAIGYO>  This function is only really useful if the class\'s module has not<KAIGYO>  been defined in the header file with a QT_MODULE macro or with an<KAIGYO>  \\inmodule command in the documentation.<KAIGYO>*/': 3, '/*!<KAIGYO>  Destroys the qdoc forest. This requires deleting<KAIGYO>  each Tree in the forest. Note that the forest has<KAIGYO>  been transferred into the search order array, so<KAIGYO>  what is really being used to destroy the forest<KAIGYO>  is the search order array.<KAIGYO> */': 3, ""    /*<KAIGYO>      If any trees remain in the forest, just add them<KAIGYO>      to the search order sequentially, because we don't<KAIGYO>      know any better at this point.<KAIGYO>     */"": 3}",1.0,{}
114,138562.0,1.0,1.0,0.0,ABANDONED,False,https://codereview.qt-project.org/#/c/138562,Major version check for composite types.,1.0,{},0.0,{'// TODO: check for same major version': 1},1.0,{}
224,138645.0,6.0,13.0,0.0,ABANDONED,False,https://codereview.qt-project.org/#/c/138645,Replace QQuickDialog::StandardButtons with QQuickButtonBox class,1.0,{'// TODO maybe: case QPlatformDialogHelper::AlternateRole:': 1},1.0,"{'// TODO maybe: insert gaps if the button requires it (destructive buttons only)': 1, '// TODO maybe: case QPlatformDialogHelper::AlternateRole:': 6}",1.0,{'// TODO maybe: case QPlatformDialogHelper::AlternateRole:': '1-6'}
248,138760.0,8.0,20.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/138760,"Tests: Remove empty init/cleanup slots, constructors and destructors.",1.0,{},0.0,"{'// TODO: Add initialization code here.<KAIGYO>// This will be executed immediately before each test is run.': 1, '// TODO: Add cleanup code here.<KAIGYO>// This will be executed immediately after each test is run.': 1, '// I can think of no other way to do this for the moment': 1, '// This will be executed immediately before each test is run.<KAIGYO>// TODO: Add initialization code here.': 1, '// This will be executed immediately after each test is run.<KAIGYO>// TODO: Add cleanup code here.': 1}",1.0,{}
189,138796.0,2.0,9.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/138796,Merge remote-tracking branch 'origin/5.5' into 5.6,1.0,{},0.0,"{""            /*<KAIGYO>              This is not read back in, so it probably<KAIGYO>              shouldn't be written out in the first place.<KAIGYO>            */"": 1}",1.0,{}
222,139051.0,15.0,46.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/139051,xcb: Fix artifacts on the tray background with lock screens,1.0,{},0.0,"{'// XXX: This is actually required, but breaks things (""QWidget::paintEngine: Should no<KAIGYO>// longer be called""). Why is this needed? When the widget is drawn, we use tricks to grab<KAIGYO>// the tray icon\'s background from the server. If the tray icon isn\'t visible (because<KAIGYO>// another window is on top of it), the trick fails and instead uses the content of that<KAIGYO>// other window as the background.<KAIGYO>// setAttribute(Qt::WA_PaintOnScreen);<KAIGYO>// If we have Qt::WA_TranslucentBackground set, during widget creation<KAIGYO>// we detected the systray visual supported an alpha channel': 1, '// XXX: This is actually required, but breaks things (""QWidget::paintEngine: Should no<KAIGYO>// longer be called""). Why is this needed? When the widget is drawn, we use tricks to grab<KAIGYO>// the tray icon\'s background from the server. If the tray icon isn\'t visible (because<KAIGYO>// another window is on top of it), the trick fails and instead uses the content of that<KAIGYO>// other window as the background.<KAIGYO>// setAttribute(Qt::WA_PaintOnScreen);': 4}",1.0,{}
43,139130.0,2.0,2.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/139130,QMakeGlobals::expandEnvVars: Make sane,1.0,{},0.0,"{'// MSVC doesn\'t seem to know the semantics of """" ...': 1}",1.0,{}
60,139254.0,5.0,11.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/139254,Core Bluetooth - give a user the second chance to enable Bluetooth,1.0,"{""// We probably had 'PoweredOff' before,<KAIGYO>// cancel the previous handlePoweredOffAfterDelay."": 3}",1.0,"{'// It\'s not clear if this thing can happen at all.<KAIGYO>// We had LE supported and now .. not anymore?<KAIGYO>// Report as an error.<KAIGYO>// We were able to start (isActive == true), so we had<KAIGYO>// powered ON and now the adapter is OFF.<KAIGYO>//<KAIGYO>// TODO: check if """" means UpdateState will<KAIGYO>// be called again with something more reasonable.': 3}",1.0,{}
71,139326.0,2.0,2.0,0.0,DEFERRED,False,https://codereview.qt-project.org/#/c/139326,WIP on qmlplugindump test: basic data-driven testing.,1.0,{'// Test Data<KAIGYO>// TODO: read data from files; use a better data structure.': 1},1.0,{'// TODOs:<KAIGYO>// compile and install the sample plugins<KAIGYO>// write the proper cleanups': 1},1.0,{}
100,139375.0,3.0,4.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/139375,qdoc: Fixed linking for overloaded functions,1.0,{},0.0,"{""    /*<KAIGYO>      Most \\l commands that link to functions don't include<KAIGYO>      the parameter declarations in the function signature,<KAIGYO>      so if the \\l is meant to go to a function that does<KAIGYO>      have parameters, the algorithm above won't find it.<KAIGYO>      Therefore we must return the pointer to the function<KAIGYO>      in the primary function map in the cases where the<KAIGYO>      parameters should have been specified in the \\l command.<KAIGYO>    */"": 1}",1.0,{}
92,139380.0,2.0,2.0,0.0,DEFERRED,False,https://codereview.qt-project.org/#/c/139380,WIP: data driven tests for qmlplugindump.,1.0,"{""// Read all files in `path' as test definitions.<KAIGYO>// They must json files that `createTest' can understand."": 1, '// TODO:<KAIGYO>// make it portable; remove dynamic library (*.so on unix)': 1}",1.0,"{'// Test Data<KAIGYO>// TODO: read data from files; use a better data structure.': 1, '/*<KAIGYO> * TODO:<KAIGYO> * make it portable;<KAIGYO> * remove also dynamic library (*.so on unix)<KAIGYO> */': 1}",1.0,{}
164,139501.0,3.0,10.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/139501,qdoc: Remove creation of redundant function & variable nodes,1.0,"{""        /*<KAIGYO>          If the node was not found, then search for it in the<KAIGYO>          open C++ namespaces. We don't expect this search to<KAIGYO>          be necessary often. Nor do we expect it to succeed<KAIGYO>          very often.<KAIGYO>        */"": 1}",1.0,"{""            /*<KAIGYO>              If the node was not found, then search for it in the<KAIGYO>              open C++ namespaces. We don't expect this search to<KAIGYO>              be necessary often. Nor do we expect it to succeed<KAIGYO>              very often.<KAIGYO>            */"": 1}",1.0,{}
120,139621.0,1.0,6.0,0.0,DEFERRED,False,https://codereview.qt-project.org/#/c/139621,WinRT: Fix the backingstore so that it flushes correctly,1.0,"{'// TODO: when ANGLE GLES3 support is finished, use the glPixelStorei functions to minimize upload': 1}",1.0,"{'// TODO: when ANGLE GLES3 support is finished, use the glPixelStorei functions to minimize upload': 1}",1.0,{}
131,139643.0,2.0,4.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/139643,qcoreapplication_win.cpp: Correct FIXME comment on qWinMain().,1.0,"{'// ### Qt6: FIXME: Consider removing this function. It is here for Active Qt<KAIGYO>// servers and for binary for compatibility to applications built with Qt 5.3<KAIGYO>// using qtmain.lib which calls it In Qt 5.4, qtmain.lib was changed to use<KAIGYO>// CommandLineToArgvW() without calling into Qt5Core.': 1}",1.0,"{'// ### Qt6: FIXME: Remove this function. It is only there since for binary<KAIGYO>// compatibility for applications built with Qt 5.3 using qtmain.lib which calls it.<KAIGYO>// In Qt 5.4, qtmain.lib was changed to use CommandLineToArgvW() without calling into Qt5Core.': 1}",1.0,{}
214,139904.0,1.0,17.0,0.0,ABANDONED,False,https://codereview.qt-project.org/#/c/139904,Utilize the cache in QAccessibleTree,1.0,{},0.0,{'// ### FIXME: get interfaces from the cache instead of re-creating them': 1},1.0,{}
242,139922.0,7.0,23.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/139922,Make DST-transition test more general.,1.0,{},0.0,"{""// This is a regression test for an old bug where starting with a date in<KAIGYO>// DST and then moving to a date outside it (or vice-versa) caused 1-hour<KAIGYO>// jumps in time when addSecs() was called.<KAIGYO>// WARNING: This test only works if there's a Daylight Savings Time change<KAIGYO>// in the current locale between 2006-11-06 and 2006-10-16<KAIGYO>// This is true for Central European Time"": 2}",1.0,{}
255,139950.0,10.0,24.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/139950,QmlDebug: Restructure QPacket and QPacketProtocol,1.0,{},0.0,"{'// Receive packet the quick way': 1, '// Receive packet the longer way': 1}",1.0,{}
21,140075.0,4.0,16.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/140075,"Revert ""qmlscene/qml tools: Temporarily disable High DPI options.""",1.0,{},0.0,{'// FIXME: 5.6: Re-enable once attribute naming is final (QTBUG-46615)': 1},1.0,{}
115,140427.0,6.0,28.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/140427,Don't pretend we know what DST to use for an offset date.,1.0,{},0.0,{'// FIXME: fails': 1},1.0,{}
145,140505.0,11.0,27.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/140505,QmlJs: separate dumping of Qt built-ins and QtQml.,1.0,{'// Also eliminate meta objects with the same classname.<KAIGYO>// This is required because extended objects seem not to share<KAIGYO>// a single meta object instance.': 1},1.0,{'// Also eliminate meta objects with the same classname.<KAIGYO>// This is required because extended objects seem not to share<KAIGYO>// a single meta object instance.': 1},1.0,{}
154,140628.0,1.0,1.0,0.0,ABANDONED,False,https://codereview.qt-project.org/#/c/140628,*** QMutex Test improvement,1.0,"{'// In this part, we will try to increment the waiters count.<KAIGYO>// We just need to take care of the case in which the old_waiters<KAIGYO>// is set to the BigNumber magic value set in unlockInternal()': 1}",1.0,"{'// In this part, we will try to increment the waiters count.<KAIGYO>// We just need to take care of the case in which the old_waiters<KAIGYO>// is set to the BigNumber magic value set in unlockInternal()': 1}",1.0,{}
173,140714.0,1.0,1.0,0.0,ABANDONED,False,https://codereview.qt-project.org/#/c/140714,WIP: QmlJs: Use regexp for matching expected result in tests.,1.0,{},0.0,"{'// TODO: check if it is possible to parse the output instead of checking for contained strings.<KAIGYO>// It may needs classes from QtCreator, in which case it is probably matter for another test suite<KAIGYO>// for QtCreator.': 1}",1.0,{}
178,140716.0,1.0,2.0,0.0,ABANDONED,False,https://codereview.qt-project.org/#/c/140716,"WIP: qmlplugindumper test, refactoring and cleanups.",1.0,"{'// Functor for matching a list of regular expression on a buffer.<KAIGYO>//<KAIGYO>// TODO: replace with a lambda (they should be allowed in Qt-5.6, iiuc)<KAIGYO>//': 1, ""// Read a test definition from a file.<KAIGYO>//<KAIGYO>// The file must define a json document that `createTest' can understand.<KAIGYO>//<KAIGYO>//<KAIGYO>// Returns a list of tests sorted lexicographically."": 1}",1.0,"{""// They must be json files that `createTest' can understand."": 1}",1.0,{}
102,141535.0,1.0,3.0,0.0,ABANDONED,False,https://codereview.qt-project.org/#/c/141535,qcocoamenu: send shortcut override events through QPA,1.0,{'// FIXME: Template handleWindowSystemEvent to support both sync and async delivery': 1},1.0,{'// FIXME: Template handleWindowSystemEvent to support both sync and async delivery': 1},1.0,{}
190,141780.0,4.0,11.0,0.0,ABANDONED,False,https://codereview.qt-project.org/#/c/141780,Rewrote qmake's #include-detection to be more faithful to CPP.,1.0,"{""        /*<KAIGYO>          States of C preprocessing (for TYPE_C only), after backslash-newline<KAIGYO>          elimination and skipping comments and spaces (i.e. in ANSI X3.159-1989<KAIGYO>          section 2.1.1.2's phase 4).  We're about to study buffer[x] to decide<KAIGYO>          on which transition to do.<KAIGYO>         */"": 1, '                        /* Drop out of phases 1, 2, 3, into phase 4 */<KAIGYO>                // Phase 4 study of buffer[x]:<KAIGYO>                switch (cpp_state) {<KAIGYO>                case AtStart:<KAIGYO>                    // Preprocessor directive ?<KAIGYO>                    cpp_state = (buffer[x] == \'#\') ? HadHash : InCode;<KAIGYO>                    break;<KAIGYO>                case HadHash:<KAIGYO>                {<KAIGYO>                    // Read keyword; buffer[x] starts first preprocessing token after #<KAIGYO>                    const char *const keyword = buffer + x;<KAIGYO>                    int clean = x;<KAIGYO>                    while (x < buffer_len && buffer[x] >= \'a\' && buffer[x] <= \'z\') {<KAIGYO>                        // skip over keyword, consolidating it if it contains BSNLs<KAIGYO>                        if (clean < x)<KAIGYO>                            buffer[clean++] = buffer[x];<KAIGYO>                        else<KAIGYO>                            clean++;<KAIGYO><KAIGYO>                        x = SKIP_BSNL(x + 1);<KAIGYO>                    const int keyword_len = buffer + clean - keyword;<KAIGYO>                    if (buffer + x > keyword)<KAIGYO>                        x--; // Still need to study buffer[x] next time round for loop.<KAIGYO><KAIGYO>                    cpp_state =<KAIGYO>                        ((keyword_len == 7 && !strncmp(keyword, """", 7)) // C & Obj-C<KAIGYO>                      || (keyword_len == 6 && !strncmp(keyword, """", 6))) // Obj-C<KAIGYO>                        ? WantName : InCode;<KAIGYO>                case WantName:<KAIGYO>                {<KAIGYO>                    char term = buffer[x];<KAIGYO>                    if (term == \'<\') {<KAIGYO>                        try_local = false;<KAIGYO>                        term = \'>\';<KAIGYO>                    } else if (term != \'""\') {<KAIGYO>                        /*<KAIGYO>                          Possibly malformed, but this may be something like:<KAIGYO>                          #include IDENTIFIER<KAIGYO>                          which does work, as long as #define IDENTIFIER<KAIGYO>                          """" is in effect.  This is beyond this noddy<KAIGYO>                          preprocessor\'s powers of tracking.  So give up and<KAIGYO>                          resume searching for a directive.  We haven\'t made<KAIGYO>                          sense of buffer[x], so back up to ensure we do study<KAIGYO>                          it (now as code) next time round the loop.<KAIGYO>                        */': 1, '                        /* Drop out of phases 1, 2, 3, into phase 4 */<KAIGYO>                // Phase 4 study of buffer[x]:<KAIGYO>                switch (cpp_state) {<KAIGYO>                case AtStart:<KAIGYO>                    // Preprocessor directive ?<KAIGYO>                    cpp_state = (buffer[x] == \'#\') ? HadHash : InCode;<KAIGYO>                    break;<KAIGYO>                case HadHash:<KAIGYO>                {<KAIGYO>                    // Read keyword; buffer[x] starts first preprocessing token after #<KAIGYO>                    const char *const keyword = buffer + x;<KAIGYO>                    int clean = x;<KAIGYO>                    while (x < buffer_len && buffer[x] >= \'a\' && buffer[x] <= \'z\') {<KAIGYO>                        // skip over keyword, consolidating it if it contains BSNLs<KAIGYO>                        // (see WantName\'s similar code consolidating inc, below)<KAIGYO>                        if (clean < x)<KAIGYO>                            buffer[clean++] = buffer[x];<KAIGYO>                        else<KAIGYO>                            clean++;<KAIGYO><KAIGYO>                        x = SKIP_BSNL(x + 1);<KAIGYO>                    const int keyword_len = buffer + clean - keyword;<KAIGYO>                    if (buffer + x > keyword)<KAIGYO>                        x--; // Still need to study buffer[x] next time round for loop.<KAIGYO><KAIGYO>                    cpp_state =<KAIGYO>                        ((keyword_len == 7 && !strncmp(keyword, """", 7)) // C & Obj-C<KAIGYO>                      || (keyword_len == 6 && !strncmp(keyword, """", 6))) // Obj-C<KAIGYO>                        ? WantName : InCode;<KAIGYO>                case WantName:<KAIGYO>                {<KAIGYO>                    char term = buffer[x];<KAIGYO>                    if (term == \'<\') {<KAIGYO>                        try_local = false;<KAIGYO>                        term = \'>\';<KAIGYO>                    } else if (term != \'""\') {<KAIGYO>                        /*<KAIGYO>                          Possibly malformed, but this may be something like:<KAIGYO>                          #include IDENTIFIER<KAIGYO>                          which does work, as long as #define IDENTIFIER<KAIGYO>                          """" is in effect.  This is beyond this noddy<KAIGYO>                          preprocessor\'s powers of tracking.  So give up and<KAIGYO>                          resume searching for a directive.  We haven\'t made<KAIGYO>                          sense of buffer[x], so back up to ensure we do study<KAIGYO>                          it (now as code) next time round the loop.<KAIGYO>                        */': 4}",1.0,"{'                    /*<KAIGYO>                      Possibly malformed, but this may be something like:<KAIGYO>                      #include IDENTIFIER<KAIGYO>                      which does work, as long as #define IDENTIFIER """"<KAIGYO>                      is in effect.  This is beyond this noddy preprocessor\'s<KAIGYO>                      powers of tracking.  So give up and resume searching for a<KAIGYO>                      directive.  We haven\'t made sense of buffer[x], so back up<KAIGYO>                      to ensure we do study it next time round the loop.<KAIGYO>                     */': 1}",1.0,{}
222,141833.0,13.0,17.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/141833,Bluetooth LE scan - move to its own dispatch queue (iOS/OS X),1.0,"{""// TODO: fix 'classOfDevice' (0 for now)."": 3}",1.0,"{""// We probably had 'PoweredOff' before,<KAIGYO>// cancel the previous handlePoweredOffAfterDelay."": 3, ""// TODO: fix 'classOfDevice' (0 for now)."": 3}",1.0,{}
48,142213.0,6.0,15.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/142213,handle TabletMove events during stylus hover,1.0,{},0.0,{'// Report TabletMove only when the stylus is touching the tablet or any button is pressed.<KAIGYO>// TODO: report proximity (hover) motion (no suitable Qt event exists yet).': 1},1.0,{}
84,142343.0,4.0,7.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/142343,Testlib: Move documentation from qtestcase.cpp to qtestcase.qdoc.,1.0,{},0.0,"{""/*! \\macro QCOMPARE(actual, expected)<KAIGYO><KAIGYO>   \\relates QTest<KAIGYO><KAIGYO>   The QCOMPARE macro compares an \\a actual value to an \\a expected value using<KAIGYO>   the equals operator. If \\a actual and \\a expected are identical, execution<KAIGYO>   continues. If not, a failure is recorded in the test log and the test<KAIGYO>   won't be executed further.<KAIGYO><KAIGYO>   In the case of comparing floats and doubles, qFuzzyCompare() is used for<KAIGYO>   comparing. This means that comparing to 0 will likely fail. One solution<KAIGYO>   to this is to compare to 1, and add 1 to the produced output.<KAIGYO><KAIGYO>   QCOMPARE tries to output the contents of the values if the comparison fails,<KAIGYO>   so it is visible from the test log why the comparison failed.<KAIGYO><KAIGYO>   QCOMPARE is very strict on the data types. Both \\a actual and \\a expected<KAIGYO>   have to be of the same type, otherwise the test won't compile. This prohibits<KAIGYO>   unspecified behavior from being introduced; that is behavior that usually<KAIGYO>   occurs when the compiler implicitly casts the argument.<KAIGYO><KAIGYO>   For your own classes, you can use \\l QTest::toString() to format values for<KAIGYO>   outputting into the test log.<KAIGYO><KAIGYO>   \\note This macro can only be used in a test function that is invoked<KAIGYO>   by the test framework.<KAIGYO><KAIGYO>   Example:<KAIGYO>   \\snippet code/src_qtestlib_qtestcase.cpp 2<KAIGYO><KAIGYO>   \\sa QVERIFY(), QTRY_COMPARE(), QTest::toString()<KAIGYO>*/"": 1, ""/*! \\macro QTEST_APPLESS_MAIN(TestClass)<KAIGYO><KAIGYO>    \\relates QTest<KAIGYO><KAIGYO>    Implements a main() function that executes all tests in \\a TestClass.<KAIGYO><KAIGYO>    Behaves like \\l QTEST_MAIN(), but doesn't instantiate a QApplication<KAIGYO>    object. Use this macro for really simple stand-alone non-GUI tests.<KAIGYO><KAIGYO>    \\sa QTEST_MAIN()<KAIGYO>*/"": 1, '/*!<KAIGYO>    \\fn QTouchEventSequence &QTest::QTouchEventSequence::move(int touchId, const QPoint &pt, QWindow *window)<KAIGYO>    \\since 5.0<KAIGYO><KAIGYO>    Adds a move event for touchpoint \\a touchId at position \\a pt to this sequence and returns<KAIGYO>    a reference to this QTouchEventSequence.<KAIGYO><KAIGYO>    The position \\a pt is interpreted as relative to \\a window. If \\a window is the null pointer, then<KAIGYO>    \\a pt is interpreted as relative to the window provided when instantiating this QTouchEventSequence.<KAIGYO><KAIGYO>    Simulates that the user moved the finger identified by \\a touchId.<KAIGYO>*/': 1}",1.0,{}
122,142532.0,8.0,34.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/142532,Fix containsMouse with touch and hoverEnabled,1.0,"{'// ------------------------- Mouse move to mouseArea1': 2, '// After the release, the item should have received a mouse press, move, and release,<KAIGYO>// plus another move back to where the real mouse cursor is.': 5}",1.0,"{'// The item should have received a mouse press, move, and release.': 5}",1.0,{}
213,142746.0,3.0,18.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/142746,Merge remote-tracking branch 'origin/5.6' into dev,1.0,{},0.0,"{'// Update the timeout<KAIGYO>// Clock source is monotonic, so we can recalculate how much timeout is left': 1, ""// in order to immediately drain the event queue of native events<KAIGYO>// (especially touch move events) we don't break out here"": 1, '// The exact bearer type is determined in QNetworkConfiguration<KAIGYO>// at the time this info is queried, because opposed to the<KAIGYO>// information here the type might change quickly.': 1}",1.0,{}
211,142975.0,4.0,13.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/142975,QEventDispatcherUNIX: Clean up thread_pipe logic,1.0,"{'// hopefully, this is dead code': 1}",1.0,"{'// hopefully, this is dead code': 1}",1.0,{}
48,143191.0,3.0,6.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/143191,QPlatformWindow::initialGeometry(): Pass screen when scaling.,1.0,{'// Center the window on the screen.  (Only applicable on platforms<KAIGYO>// which do not provide a better way.)': 1},1.0,{'// Center the window on the screen.  (Only applicable on platforms<KAIGYO>// which do not provide a better way.)': 1},1.0,{}
95,143355.0,1.0,2.0,0.0,ABANDONED,False,https://codereview.qt-project.org/#/c/143355,WIP try to add Image.physicalSize property,1.0,"{'// TODO check QImageIOHandler::IsVectorFormat or similar imageoption enum, or maybe just PhysicalSize': 1}",1.0,{'// TODO check QImageIOHandler::IsVectorFormat or similar imageoption enum': 1},1.0,{}
162,143621.0,3.0,9.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/143621,QFileSystemModel autotest: fix a broken sort() test,1.0,{},0.0,"{'//File dialog Mode means sub trees are not sorted, only the current root<KAIGYO>// FIXME: we were only able to disableRecursiveSort in developer builds, so we can only<KAIGYO>// stably perform this test for developer builds': 1}",1.0,{}
220,143761.0,4.0,10.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/143761,QChar: add missing relational operators against QLatin1String/QStringRef,1.0,{},0.0,"{'// FIXME: these are missing at the time of writing, add them, then remove the dummies here:': 1, '// END FIXME': 1}",1.0,{}
229,143796.0,3.0,7.0,0.0,ABANDONED,False,https://codereview.qt-project.org/#/c/143796,winrt: Do not early return if a rDNS lookup is started,1.0,{},0.0,{'// Reverse lookup<KAIGYO>// TODO: is there a replacement for getnameinfo for winrt?': 1},1.0,{}
45,144070.0,4.0,9.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/144070,winrt: Use winsock2 API for hostname resolution on WinRT/WinPhone,1.0,{},0.0,{'// Reverse lookup<KAIGYO>// TODO: is there a replacement for getnameinfo for winrt?': 1},1.0,{}
32,144111.0,1.0,2.0,0.0,DEFERRED,False,https://codereview.qt-project.org/#/c/144111,Use live qml help by default,1.0,{},0.0,{'// TODO: remove when we have QmlTextObjects in the browser': 1},1.0,{}
110,144147.0,7.0,11.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/144147,cleanups in the VNC plugin,1.0,{},0.0,{'// XXX: do a simple for-loop instead?<KAIGYO>// ###<KAIGYO>//    if (!qvnc_screen->screen() && !qvnc_screen->noDisablePainting && QWSServer::instance())<KAIGYO>//        QWSServer::instance()->enablePainting(false);': 1},1.0,{}
85,144206.0,2.0,3.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/144206,be more strict about bogus operators,1.0,{},0.0,"{""// '|' could actually work reasonably, but qmake does nonsense here."": 1}",1.0,{}
112,144231.0,2.0,3.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/144231,QMakeGlobals::expandEnvVars: Make sane,1.0,{},0.0,"{'// MSVC doesn\'t seem to know the semantics of """" ...': 1}",1.0,{}
182,144460.0,7.0,32.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/144460,bringToFront: support item view items,1.0,"{'// This may seem redundant, as QTabWidget is internally implemented<KAIGYO>// via a QStackedWidget, but the tab bar still needs to be updated.': 3}",1.0,"{'// This may seem redundant, as QTabWidget is internally implemented<KAIGYO>// via a QStackedWidget, but the tab bar still needs to be updated.': 3}",1.0,{}
62,145272.0,2.0,4.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/145272,Fix UB in tst_QDialog::showExtension(),1.0,{'// work around function being protected': 1},1.0,{'// work around function being protected': 1},1.0,{}
129,145510.0,4.0,10.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/145510,bringToFront: fix handling of QTabWidgets,1.0,{},0.0,"{'// This may seem redundant, as QTabWidget is internally implemented<KAIGYO>// via a QStackedWidget, but the tab bar still needs to be updated.': 1}",1.0,{}
78,146377.0,3.0,5.0,0.0,ABANDONED,False,https://codereview.qt-project.org/#/c/146377,QQuickStyleItem: wrap const char * in QStringLiteral,1.0,{},0.0,{'// Qt draws an ugly line here so I ignore it': 1},1.0,{}
82,146412.0,1.0,2.0,0.0,ABANDONED,False,https://codereview.qt-project.org/#/c/146412,Bluetooth LE: Register some meta types.,1.0,{},0.0,{'// TODO: Why on earth is this not in the library???': 1},1.0,{}
107,146445.0,2.0,2.0,0.0,ABANDONED,False,https://codereview.qt-project.org/#/c/146445,Qml: replace QStringLiteral with QLatin1String,1.0,"{""// TODO: `this' should be a builtin."": 1}",1.0,"{""// TODO: `this' should be a builtin."": 1}",1.0,{}
122,146596.0,2.0,2.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/146596,QQuickStyleItem: wrap const char * in QStringLiteral,1.0,{'// Qt draws an ugly line here so I ignore it': 1},1.0,{'// Qt draws an ugly line here so I ignore it': 1},1.0,{}
132,146628.0,3.0,5.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/146628,QQuickTextNode: Nuke some dead code.,1.0,{},0.0,{'// ### Should be made faster by implementing outline material': 1},1.0,{}
204,146933.0,3.0,3.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/146933,Bluetooth: Add more thorough checks for the Signed Write Command.,1.0,"{""// const QByteArray signature = packet.right(12);<KAIGYO>// TODO: Check signature and continue if it's valid. Check and update sign counter."": 1}",1.0,"{""// const QByteArray signature = packet.right(12);<KAIGYO>// TODO: Check signature and continue if it's valid. Store sign counter."": 1}",1.0,{}
212,146944.0,6.0,29.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/146944,dbusmenu: Add support for shortcuts,1.0,{},0.0,"{'        /* TODO support shortcuts<KAIGYO>            QDBusMenuShortcut shortcut(scut);<KAIGYO>            properties.insert(QLatin1String(""""), QVariant::fromValue(shortcut));<KAIGYO>        */': 1}",1.0,{}
65,147118.0,2.0,2.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/147118,Qml: replace QStringLiteral with QLatin1String,1.0,"{""// TODO: `this' should be a builtin."": 1}",1.0,"{""// TODO: `this' should be a builtin."": 1}",1.0,{}
60,147151.0,2.0,6.0,0.0,ABANDONED,False,https://codereview.qt-project.org/#/c/147151,QFontDatabase: Get rid of the check for OpenType tables,1.0,{},0.0,"{""// ### TODO: This only works for scripts that require OpenType. More generally<KAIGYO>// for scripts that do not require OpenType we should just look at the list of<KAIGYO>// supported writing systems in the font's OS/2 table."": 1}",1.0,{}
126,147422.0,3.0,3.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/147422,FileDialog: move shortcuts properties up to QQuickAbstractFileDialog,1.0,{'// TODO maybe some day QJSValue could directly store a QUrl': 1},1.0,{'// TODO maybe some day QJSValue could directly store a QUrl': 1},1.0,{}
225,147830.0,5.0,17.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/147830,Simplify QAbstractSocket::readData(),1.0,{},0.0,{'// no socket engine is probably EOF': 1},1.0,{}
242,147886.0,2.0,21.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/147886,"Revert ""QWindow::destroy(): only reset QGuiApp::focus_window and friends as a last resort""",1.0,{},0.0,{'// FIXME: Handle these two though QPA like the others. Unfortunately both<KAIGYO>// processMouseEvent and processTabletEvent in QGuiApplication have conditions<KAIGYO>// that make sending the event though QPA not feasable right now.': 1},1.0,{}
40,148226.0,3.0,9.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/148226,qmake: require a drive in a DOS path for it to be absolute,1.0,{},0.0,"{""// Unlike QFileInfo, this won't accept a relative path with a drive letter.<KAIGYO>// Such paths result in a royal mess anyway ..."": 1}",1.0,{}
61,148288.0,5.0,7.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/148288,Remove qt_safe_select and qt_select_msecs,1.0,"{""// clock source is (hopefully) monotonic, so we can recalculate how much timeout is left;<KAIGYO>// if it isn't monotonic, we'll simply hope that it hasn't jumped, because we have no alternative"": 1}",1.0,"{""// clock source is (hopefully) monotonic, so we can recalculate how much timeout is left;<KAIGYO>// if it isn't monotonic, we'll simply hope that it hasn't jumped, because we have no alternative"": 1}",1.0,{}
129,148309.0,28.0,94.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/148309,qmake: require a drive in a DOS path for it to be absolute,1.0,"{'// FIXME: for UNC, we might want to use \\\\server\\share as """".': 4}",1.0,"{""// Unlike QFileInfo, this won't accept a relative path with a drive letter.<KAIGYO>// Such paths result in a royal mess anyway ..."": 1}",1.0,{}
84,148403.0,2.0,8.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/148403,Get rid of the QRegExp dependency in qxmlutils.,1.0,{},0.0,"{'    /* Right, we here have a dependency on QRegExp. Writing a manual parser to<KAIGYO>     * replace that regexp is probably a 70 lines so I prioritize this to when<KAIGYO>     * the dependency is considered alarming, or when the rest of the bugs<KAIGYO>     * are fixed. */': 1}",1.0,{}
255,148551.0,46.0,60.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/148551,Add peripheral role (iOS/OS X).,1.0,"{'        /*<KAIGYO>        ""Therefore, if you need the value of a characteristic to be writeable,<KAIGYO>        or if you expect the value to change during the lifetime of the published<KAIGYO>        service to which the characteristic belongs, you must specify the value to be nil.""<KAIGYO>        */': 1, '// See comment above, TODO': 1, '    /*<KAIGYO>    This method is invoked when your app calls the startAdvertising: method to begin advertising<KAIGYO>    the local peripheral device’s data. If successful, the error parameter is nil. If there is a<KAIGYO>    problem advertising the data, the error parameter returns the cause of the failure.<KAIGYO>    */': 1, '    /*<KAIGYO>    This method is invoked when your app calls the addService: method to publish a service to<KAIGYO>    the local peripheral’s GATT database. If the service is successfully published to the<KAIGYO>    local database, the error parameter is nil. If unsuccessful, the error parameter<KAIGYO>    returns the cause of the failure.<KAIGYO>    */': 1, ""// TODO: I'll probably need a map between CB object and QLowEnergyCharacteristic<KAIGYO>// so that in delegate's methods I can find value, for example."": 5, ""// TODO: check if this value becomes cached/read-only (as it's done with a characteristic)"": 10, ""// TODO: with have to add 'included' bit on a d_ptr (can not be done<KAIGYO>// here - it's private)."": 10, ""// TODO: descriptor's value also!!!"": 10, ""// TODO: we have to add 'included' bit on a d_ptr (can not be done<KAIGYO>// here - it's private)."": 11, ""// TODO: we have to add 'included' bit on a d_ptr (cannot be done<KAIGYO>// here - it's a private data-member)."": 12, '// TODO: we can probably also use some of ADV parameters.': 14, ""// TODO: Controller's state!"": 16, ""// TODO: obviously, check the controller's state here."": 16, '        /*<KAIGYO>        """"<KAIGYO>        // TODO: let our controller know.<KAIGYO>        */': 20, '// TODO: Some cleanup probably ...': 21, '// TODO: additional cleanup if needed.': 21, '// TODO: notifier->error': 24, '// TODO: permissions etc.': 24, '                                                      value:value], false /*do not retain*/);<KAIGYO>    return d;<KAIGYO>}<KAIGYO><KAIGYO>quint32 qt_countGATTEntries(const QLowEnergyServiceData &data)<KAIGYO>{<KAIGYO>    const auto maxu32 = std::numeric_limits<quint32>::max();<KAIGYO>    // + 1 for a service itself.<KAIGYO>    quint32 nEntries = 1 + quint32(data.includedServices().count());<KAIGYO>    for (const auto &ch : data.characteristics()) {<KAIGYO>        if (maxu32 - 2 < nEntries)<KAIGYO>            return {};<KAIGYO>        nEntries += 2;<KAIGYO>        if (maxu32 - ch.descriptors().count() < nEntries)<KAIGYO>            return {};<KAIGYO>        nEntries += ch.descriptors().count();<KAIGYO>    }<KAIGYO><KAIGYO>    return nEntries;<KAIGYO>}<KAIGYO><KAIGYO>}<KAIGYO><KAIGYO>@interface QT_MANGLE_NAMESPACE(OSXBTPeripheralManager) (PrivateAPI)<KAIGYO><KAIGYO>- (void)addConnectedCentral:(CBCentral *)central;<KAIGYO>- (void)removeConnectedCentral:(CBCentral *)central;<KAIGYO>- (CBService *)findIncludedService:(CBUUID *)cbUUID;<KAIGYO><KAIGYO>- (void)addIncludedServices:(const QLowEnergyServiceData &)data<KAIGYO>        to:(CBMutableService *)cbService<KAIGYO>        qtService:(QLowEnergyServicePrivate *)qtService;<KAIGYO><KAIGYO>- (void)addCharacteristicsAndDescriptors:(const QLowEnergyServiceData &)data<KAIGYO>        to:(CBMutableService *)cbService<KAIGYO>        qtService:(QLowEnergyServicePrivate *)qtService;<KAIGYO><KAIGYO><KAIGYO>@end<KAIGYO><KAIGYO>@implementation QT_MANGLE_NAMESPACE(OSXBTPeripheralManager)<KAIGYO><KAIGYO>- (id)initWith:(LECBManagerNotifier *)aNotifier<KAIGYO>{<KAIGYO>    if (self = [super init]) {<KAIGYO>        Q_ASSERT(notifier);<KAIGYO><KAIGYO>        notifier = aNotifier;<KAIGYO>        state = PeripheralState::idle;<KAIGYO>        nextServiceToAdd = {};<KAIGYO>        connectedCentrals.reset([[NSMutableSet alloc] init]);<KAIGYO>    }<KAIGYO><KAIGYO>    return self;<KAIGYO>}<KAIGYO><KAIGYO>- (void)dealloc<KAIGYO>{<KAIGYO>    [self detach];<KAIGYO>    [super dealloc];<KAIGYO>}<KAIGYO><KAIGYO>- (QSharedPointer<QLowEnergyServicePrivate>)addService:(const QLowEnergyServiceData &)data<KAIGYO>{<KAIGYO>    Q_ASSERT(!data.uuid().isNull());<KAIGYO><KAIGYO>    using QLES = QLowEnergyService;<KAIGYO><KAIGYO>    const auto nEntries = qt_countGATTEntries(data);<KAIGYO>    if (!nEntries || nEntries > std::numeric_limits<QLowEnergyHandle>::max() - lastHandle) {<KAIGYO>        qCCritical(QT_BT_OSX) << """";<KAIGYO>        return {};<KAIGYO>    }<KAIGYO><KAIGYO>    QT_BT_MAC_AUTORELEASEPOOL<KAIGYO><KAIGYO>    const BOOL primary = data.type() == QLowEnergyServiceData::ServiceTypePrimary;<KAIGYO>    const auto cbUUID = cb_uuid(data.uuid());<KAIGYO><KAIGYO>    const ObjCStrongReference<CBMutableService><KAIGYO>        newCBService([[CBMutableService alloc] initWithType:cbUUID primary:primary],<KAIGYO>                     false /*do not retain*/': 28, '    /*<KAIGYO>    ""A state with a value lower than CBPeripheralManagerStatePoweredOn implies that<KAIGYO>    advertising has stopped and that any connected centrals have been disconnected.""<KAIGYO>    */': 28, '                                                      value:value], false /*do not retain*/);<KAIGYO>    return d;<KAIGYO>}<KAIGYO><KAIGYO>quint32 qt_countGATTEntries(const QLowEnergyServiceData &data)<KAIGYO>{<KAIGYO>    const auto maxu32 = std::numeric_limits<quint32>::max();<KAIGYO>    // + 1 for a service itself.<KAIGYO>    quint32 nEntries = 1 + quint32(data.includedServices().count());<KAIGYO>    for (const auto &ch : data.characteristics()) {<KAIGYO>        if (maxu32 - 2 < nEntries)<KAIGYO>            return {};<KAIGYO>        nEntries += 2;<KAIGYO>        if (maxu32 - ch.descriptors().count() < nEntries)<KAIGYO>            return {};<KAIGYO>        nEntries += ch.descriptors().count();<KAIGYO>    }<KAIGYO><KAIGYO>    return nEntries;<KAIGYO>}<KAIGYO><KAIGYO>}<KAIGYO><KAIGYO>@interface QT_MANGLE_NAMESPACE(OSXBTPeripheralManager) (PrivateAPI)<KAIGYO><KAIGYO>- (void)addConnectedCentral:(CBCentral *)central;<KAIGYO>- (void)removeConnectedCentral:(CBCentral *)central;<KAIGYO>- (CBService *)findIncludedService:(CBUUID *)cbUUID;<KAIGYO><KAIGYO>- (void)addIncludedServices:(const QLowEnergyServiceData &)data<KAIGYO>        to:(CBMutableService *)cbService<KAIGYO>        qtService:(QLowEnergyServicePrivate *)qtService;<KAIGYO><KAIGYO>- (void)addCharacteristicsAndDescriptors:(const QLowEnergyServiceData &)data<KAIGYO>        to:(CBMutableService *)cbService<KAIGYO>        qtService:(QLowEnergyServicePrivate *)qtService;<KAIGYO><KAIGYO><KAIGYO>@end<KAIGYO><KAIGYO>@implementation QT_MANGLE_NAMESPACE(OSXBTPeripheralManager)<KAIGYO><KAIGYO>- (id)initWith:(LECBManagerNotifier *)aNotifier<KAIGYO>{<KAIGYO>    if (self = [super init]) {<KAIGYO>        Q_ASSERT(aNotifier);<KAIGYO><KAIGYO>        notifier = aNotifier;<KAIGYO>        state = PeripheralState::idle;<KAIGYO>        nextServiceToAdd = {};<KAIGYO>        connectedCentrals.reset([[NSMutableSet alloc] init]);<KAIGYO>    }<KAIGYO><KAIGYO>    return self;<KAIGYO>}<KAIGYO><KAIGYO>- (void)dealloc<KAIGYO>{<KAIGYO>    [self detach];<KAIGYO>    [super dealloc];<KAIGYO>}<KAIGYO><KAIGYO>- (QSharedPointer<QLowEnergyServicePrivate>)addService:(const QLowEnergyServiceData &)data<KAIGYO>{<KAIGYO>    Q_ASSERT(!data.uuid().isNull());<KAIGYO><KAIGYO>    using QLES = QLowEnergyService;<KAIGYO><KAIGYO>    const auto nEntries = qt_countGATTEntries(data);<KAIGYO>    if (!nEntries || nEntries > std::numeric_limits<QLowEnergyHandle>::max() - lastHandle) {<KAIGYO>        qCCritical(QT_BT_OSX) << """";<KAIGYO>        return {};<KAIGYO>    }<KAIGYO><KAIGYO>    QT_BT_MAC_AUTORELEASEPOOL<KAIGYO><KAIGYO>    const BOOL primary = data.type() == QLowEnergyServiceData::ServiceTypePrimary;<KAIGYO>    const auto cbUUID = cb_uuid(data.uuid());<KAIGYO><KAIGYO>    const ObjCStrongReference<CBMutableService><KAIGYO>        newCBService([[CBMutableService alloc] initWithType:cbUUID primary:primary],<KAIGYO>                     false /*do not retain*/': 29, '                                                      value:value], false /*do not retain*/);<KAIGYO>    return d;<KAIGYO>}<KAIGYO><KAIGYO>quint32 qt_countGATTEntries(const QLowEnergyServiceData &data)<KAIGYO>{<KAIGYO>    const auto maxu32 = std::numeric_limits<quint32>::max();<KAIGYO>    // + 1 for a service itself.<KAIGYO>    quint32 nEntries = 1 + quint32(data.includedServices().count());<KAIGYO>    for (const auto &ch : data.characteristics()) {<KAIGYO>        if (maxu32 - 2 < nEntries)<KAIGYO>            return {};<KAIGYO>        nEntries += 2;<KAIGYO>        if (maxu32 - ch.descriptors().count() < nEntries)<KAIGYO>            return {};<KAIGYO>        nEntries += ch.descriptors().count();<KAIGYO>    }<KAIGYO><KAIGYO>    return nEntries;<KAIGYO>}<KAIGYO><KAIGYO>}<KAIGYO><KAIGYO>@interface QT_MANGLE_NAMESPACE(OSXBTPeripheralManager) (PrivateAPI)<KAIGYO><KAIGYO>- (void)addConnectedCentral:(CBCentral *)central;<KAIGYO>- (void)removeConnectedCentral:(CBCentral *)central;<KAIGYO>- (CBService *)findIncludedService:(CBUUID *)cbUUID;<KAIGYO><KAIGYO>- (void)addIncludedServices:(const QLowEnergyServiceData &)data<KAIGYO>        to:(CBMutableService *)cbService<KAIGYO>        qtService:(QLowEnergyServicePrivate *)qtService;<KAIGYO><KAIGYO>- (void)addCharacteristicsAndDescriptors:(const QLowEnergyServiceData &)data<KAIGYO>        to:(CBMutableService *)cbService<KAIGYO>        qtService:(QLowEnergyServicePrivate *)qtService;<KAIGYO><KAIGYO>@end<KAIGYO><KAIGYO>@implementation QT_MANGLE_NAMESPACE(OSXBTPeripheralManager)<KAIGYO><KAIGYO>- (id)initWith:(LECBManagerNotifier *)aNotifier<KAIGYO>{<KAIGYO>    if (self = [super init]) {<KAIGYO>        Q_ASSERT(aNotifier);<KAIGYO><KAIGYO>        notifier = aNotifier;<KAIGYO>        state = PeripheralState::idle;<KAIGYO>        nextServiceToAdd = {};<KAIGYO>        connectedCentrals.reset([[NSMutableSet alloc] init]);<KAIGYO>    }<KAIGYO><KAIGYO>    return self;<KAIGYO>}<KAIGYO><KAIGYO>- (void)dealloc<KAIGYO>{<KAIGYO>    [self detach];<KAIGYO>    [super dealloc];<KAIGYO>}<KAIGYO><KAIGYO>- (QSharedPointer<QLowEnergyServicePrivate>)addService:(const QLowEnergyServiceData &)data<KAIGYO>{<KAIGYO>    Q_ASSERT(!data.uuid().isNull());<KAIGYO><KAIGYO>    using QLES = QLowEnergyService;<KAIGYO><KAIGYO>    const auto nEntries = qt_countGATTEntries(data);<KAIGYO>    if (!nEntries || nEntries > std::numeric_limits<QLowEnergyHandle>::max() - lastHandle) {<KAIGYO>        qCCritical(QT_BT_OSX) << """";<KAIGYO>        return {};<KAIGYO>    }<KAIGYO><KAIGYO>    QT_BT_MAC_AUTORELEASEPOOL<KAIGYO><KAIGYO>    const BOOL primary = data.type() == QLowEnergyServiceData::ServiceTypePrimary;<KAIGYO>    const auto cbUUID = cb_uuid(data.uuid());<KAIGYO><KAIGYO>    const ObjCStrongReference<CBMutableService><KAIGYO>        newCBService([[CBMutableService alloc] initWithType:cbUUID primary:primary],<KAIGYO>                     false /*do not retain*/': 33, '                                                      value:value], false /*do not retain*/);<KAIGYO>    return d;<KAIGYO>}<KAIGYO><KAIGYO>quint32 qt_countGATTEntries(const QLowEnergyServiceData &data)<KAIGYO>{<KAIGYO>    const auto maxu32 = std::numeric_limits<quint32>::max();<KAIGYO>    // + 1 for a service itself.<KAIGYO>    quint32 nEntries = 1 + quint32(data.includedServices().count());<KAIGYO>    for (const auto &ch : data.characteristics()) {<KAIGYO>        if (maxu32 - 2 < nEntries)<KAIGYO>            return {};<KAIGYO>        nEntries += 2;<KAIGYO>        if (maxu32 - ch.descriptors().count() < nEntries)<KAIGYO>            return {};<KAIGYO>        nEntries += ch.descriptors().count();<KAIGYO>    }<KAIGYO><KAIGYO>    return nEntries;<KAIGYO>}<KAIGYO><KAIGYO>}<KAIGYO><KAIGYO>@interface QT_MANGLE_NAMESPACE(OSXBTPeripheralManager) (PrivateAPI)<KAIGYO><KAIGYO>- (void)addConnectedCentral:(CBCentral *)central;<KAIGYO>- (void)removeConnectedCentral:(CBCentral *)central;<KAIGYO>- (CBService *)findIncludedService:(CBUUID *)cbUUID;<KAIGYO><KAIGYO>- (void)addIncludedServices:(const QLowEnergyServiceData &)data<KAIGYO>        to:(CBMutableService *)cbService<KAIGYO>        qtService:(QLowEnergyServicePrivate *)qtService;<KAIGYO><KAIGYO>- (void)addCharacteristicsAndDescriptors:(const QLowEnergyServiceData &)data<KAIGYO>        to:(CBMutableService *)cbService<KAIGYO>        qtService:(QLowEnergyServicePrivate *)qtService;<KAIGYO><KAIGYO>- (CBATTError)validateWriteRequest:(CBATTRequest *)request;<KAIGYO><KAIGYO>@end<KAIGYO><KAIGYO>@implementation QT_MANGLE_NAMESPACE(OSXBTPeripheralManager)<KAIGYO><KAIGYO>- (id)initWith:(LECBManagerNotifier *)aNotifier<KAIGYO>{<KAIGYO>    if (self = [super init]) {<KAIGYO>        Q_ASSERT(aNotifier);<KAIGYO>        notifier = aNotifier;<KAIGYO>        state = PeripheralState::idle;<KAIGYO>        nextServiceToAdd = {};<KAIGYO>        connectedCentrals.reset([[NSMutableSet alloc] init]);<KAIGYO>    }<KAIGYO><KAIGYO>    return self;<KAIGYO>}<KAIGYO><KAIGYO>- (void)dealloc<KAIGYO>{<KAIGYO>    [self detach];<KAIGYO>    [super dealloc];<KAIGYO>}<KAIGYO><KAIGYO>- (QSharedPointer<QLowEnergyServicePrivate>)addService:(const QLowEnergyServiceData &)data<KAIGYO>{<KAIGYO>    using QLES = QLowEnergyService;<KAIGYO><KAIGYO>    const auto nEntries = qt_countGATTEntries(data);<KAIGYO>    if (!nEntries || nEntries > std::numeric_limits<QLowEnergyHandle>::max() - lastHandle) {<KAIGYO>        qCCritical(QT_BT_OSX) << """";<KAIGYO>        return {};<KAIGYO>    }<KAIGYO><KAIGYO>    QT_BT_MAC_AUTORELEASEPOOL<KAIGYO><KAIGYO>    const BOOL primary = data.type() == QLowEnergyServiceData::ServiceTypePrimary;<KAIGYO>    const auto cbUUID = cb_uuid(data.uuid());<KAIGYO><KAIGYO>    const ObjCStrongReference<CBMutableService><KAIGYO>        newCBService([[CBMutableService alloc] initWithType:cbUUID primary:primary],<KAIGYO>                     false /*do not retain*/': 37, '                                                      value:value], false /*do not retain*/);<KAIGYO>    return d;<KAIGYO>}<KAIGYO><KAIGYO>quint32 qt_countGATTEntries(const QLowEnergyServiceData &data)<KAIGYO>{<KAIGYO>    const auto maxu32 = std::numeric_limits<quint32>::max();<KAIGYO>    // + 1 for a service itself.<KAIGYO>    quint32 nEntries = 1 + quint32(data.includedServices().count());<KAIGYO>    for (const auto &ch : data.characteristics()) {<KAIGYO>        if (maxu32 - 2 < nEntries)<KAIGYO>            return {};<KAIGYO>        nEntries += 2;<KAIGYO>        if (maxu32 - ch.descriptors().count() < nEntries)<KAIGYO>            return {};<KAIGYO>        nEntries += ch.descriptors().count();<KAIGYO>    }<KAIGYO><KAIGYO>    return nEntries;<KAIGYO>}<KAIGYO><KAIGYO>}<KAIGYO><KAIGYO>@interface QT_MANGLE_NAMESPACE(OSXBTPeripheralManager) (PrivateAPI)<KAIGYO><KAIGYO>- (void)addConnectedCentral:(CBCentral *)central;<KAIGYO>- (void)removeConnectedCentral:(CBCentral *)central;<KAIGYO>- (CBService *)findIncludedService:(const QBluetoothUuid &)qtUUID;<KAIGYO><KAIGYO>- (void)addIncludedServices:(const QLowEnergyServiceData &)data<KAIGYO>        to:(CBMutableService *)cbService<KAIGYO>        qtService:(QLowEnergyServicePrivate *)qtService;<KAIGYO><KAIGYO>- (void)addCharacteristicsAndDescriptors:(const QLowEnergyServiceData &)data<KAIGYO>        to:(CBMutableService *)cbService<KAIGYO>        qtService:(QLowEnergyServicePrivate *)qtService;<KAIGYO><KAIGYO>- (CBATTError)validateWriteRequest:(CBATTRequest *)request;<KAIGYO><KAIGYO>@end<KAIGYO><KAIGYO>@implementation QT_MANGLE_NAMESPACE(OSXBTPeripheralManager)<KAIGYO><KAIGYO>- (id)initWith:(LECBManagerNotifier *)aNotifier<KAIGYO>{<KAIGYO>    if (self = [super init]) {<KAIGYO>        Q_ASSERT(aNotifier);<KAIGYO>        notifier = aNotifier;<KAIGYO>        state = PeripheralState::idle;<KAIGYO>        nextServiceToAdd = {};<KAIGYO>        connectedCentrals.reset([[NSMutableSet alloc] init]);<KAIGYO>    }<KAIGYO><KAIGYO>    return self;<KAIGYO>}<KAIGYO><KAIGYO>- (void)dealloc<KAIGYO>{<KAIGYO>    [self detach];<KAIGYO>    [super dealloc];<KAIGYO>}<KAIGYO><KAIGYO>- (QSharedPointer<QLowEnergyServicePrivate>)addService:(const QLowEnergyServiceData &)data<KAIGYO>{<KAIGYO>    using QLES = QLowEnergyService;<KAIGYO><KAIGYO>    const auto nEntries = qt_countGATTEntries(data);<KAIGYO>    if (!nEntries || nEntries > std::numeric_limits<QLowEnergyHandle>::max() - lastHandle) {<KAIGYO>        qCCritical(QT_BT_OSX) << """";<KAIGYO>        return {};<KAIGYO>    }<KAIGYO><KAIGYO>    QT_BT_MAC_AUTORELEASEPOOL<KAIGYO><KAIGYO>    const BOOL primary = data.type() == QLowEnergyServiceData::ServiceTypePrimary;<KAIGYO>    const auto cbUUID = cb_uuid(data.uuid());<KAIGYO><KAIGYO>    const ObjCStrongReference<CBMutableService><KAIGYO>        newCBService([[CBMutableService alloc] initWithType:cbUUID primary:primary],<KAIGYO>                     false /*do not retain*/': 43}",1.0,"{""// TODO: dispatch_sync 'setDelegate:Q_NULLPRT' to our CBCentralManager's delegate."": 21}",1.0,{}
228,148825.0,14.0,35.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/148825,QDateTimeParser: partial break-up of long method to eliminate goto,1.0,"{'// Fix by choice of year': 8, '// TODO (fiddly): handle using Qt::TimeZone instead': 9, '// no way to tell if this is am or pm so I assume am': 9}",1.0,"{'// Fix by choice of year': 8, '// TODO (fiddly): handle using Qt::TimeZone instead': 9, '// no way to tell if this is am or pm so I assume am': 9}",1.0,{}
110,149426.0,2.0,4.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/149426,Merge remote-tracking branch 'origin/5.6' into 5.7,1.0,{},0.0,{'// TODO maybe some day QJSValue could directly store a QUrl': 1},1.0,{}
256,149852.0,8.0,23.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/149852,Win: Prevent crash in qt_message_fatal(),1.0,"{""// we probably should let the compiler do this for us, by declaring QMessageLogContext::file to<KAIGYO>// be const wchar_t * in the first place, but the #ifdefery above is very complex  and we<KAIGYO>// wouldn't be able to change it later on..."": 1}",1.0,"{""// we probably should let the compiler do this for us, by declaring QMessageLogContext::file to<KAIGYO>// be const wchar_t * in the first place, but the #ifdefery above is very complex  and we<KAIGYO>// wouldn't be able to change it later on..."": 1}",1.0,{}
265,149908.0,1.0,3.0,0.0,ABANDONED,False,https://codereview.qt-project.org/#/c/149908,"Revert ""qdoc: Remove creation of redundant function & variable nodes""",1.0,"{""            /*<KAIGYO>              If the node was not found, then search for it in the<KAIGYO>              open C++ namespaces. We don't expect this search to<KAIGYO>              be necessary often. Nor do we expect it to succeed<KAIGYO>              very often.<KAIGYO>            */"": 1}",1.0,"{""        /*<KAIGYO>          If the node was not found, then search for it in the<KAIGYO>          open C++ namespaces. We don't expect this search to<KAIGYO>          be necessary often. Nor do we expect it to succeed<KAIGYO>          very often.<KAIGYO>        */"": 1}",1.0,{}
276,149913.0,1.0,3.0,0.0,ABANDONED,False,https://codereview.qt-project.org/#/c/149913,This change is not needed.,1.0,"{""            /*<KAIGYO>              If the node was not found, then search for it in the<KAIGYO>              open C++ namespaces. We don't expect this search to<KAIGYO>              be necessary often. Nor do we expect it to succeed<KAIGYO>              very often.<KAIGYO>            */"": 1}",1.0,"{""        /*<KAIGYO>          If the node was not found, then search for it in the<KAIGYO>          open C++ namespaces. We don't expect this search to<KAIGYO>          be necessary often. Nor do we expect it to succeed<KAIGYO>          very often.<KAIGYO>        */"": 1}",1.0,{}
286,149916.0,3.0,5.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/149916,"Revert ""qdoc: Remove creation of redundant function & variable nodes""",1.0,"{""            /*<KAIGYO>              If the node was not found, then search for it in the<KAIGYO>              open C++ namespaces. We don't expect this search to<KAIGYO>              be necessary often. Nor do we expect it to succeed<KAIGYO>              very often.<KAIGYO>            */"": 1}",1.0,"{""        /*<KAIGYO>          If the node was not found, then search for it in the<KAIGYO>          open C++ namespaces. We don't expect this search to<KAIGYO>          be necessary often. Nor do we expect it to succeed<KAIGYO>          very often.<KAIGYO>        */"": 1}",1.0,{}
274,149924.0,6.0,18.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/149924,Remove support for the obsolete -no-zlib configure arg,1.0,{},0.0,"{'// No longer supported since Qt 4.4.0<KAIGYO>// But save the information for later so that we can print a warning<KAIGYO>//<KAIGYO>// If you REALLY really need no zlib support, you can still disable<KAIGYO>// it by doing the following:<KAIGYO>//   add """" to mkspecs/qconfig.pri<KAIGYO>//   #define QT_NO_COMPRESS (probably by adding to src/corelib/global/qconfig.h)<KAIGYO>//<KAIGYO>// There\'s no guarantee that Qt will build under those conditions': 1}",1.0,{}
120,150397.0,2.0,2.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/150397,V4: tweak Phi node data destruction.,1.0,{},0.0,"{'// FIXME: this gets quite inefficient for large basic-blocks, so this function/case should be re-worked.': 1}",1.0,{}
187,150629.0,3.0,10.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/150629,SSSE3 optimized store of 24-bit formats,1.0,{},0.0,{'// we need the volatile and the following to make sure the compiler does not do<KAIGYO>// anything stupid :)': 1},1.0,{}
272,150967.0,3.0,3.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/150967,"D3D12: add opacity support, fix buffer handling and dirty tracking",1.0,{},0.0,"{'// ### this is wrong': 1, '// ### move format mapping to engine': 1}",1.0,{}
70,151203.0,2.0,2.0,0.0,ABANDONED,False,https://codereview.qt-project.org/#/c/151203,Particles: Shrink QQuickParticleData by 2 pointers.,1.0,{'//TODO: adjust for system?': 1},1.0,{'//TODO: adjust for system?': 1},1.0,{}
39,151215.0,1.0,1.0,0.0,ABANDONED,False,https://codereview.qt-project.org/#/c/151215,"V4: Move BitVector to the util header, so it can be re-used.",1.0,{},0.0,"{""// The ++operator of std::vector<bool>::iterator in libc++ has a bug when using it on an<KAIGYO>// iterator pointing to the last element. It will not be set to ::end(), but beyond<KAIGYO>// that. (It will be set to the first multiple of the native word size that is bigger<KAIGYO>// than size().)<KAIGYO>//<KAIGYO>// See httpllvm.org/bugs/show_bug.cgi?id=19663<KAIGYO>//<KAIGYO>// The work-around is to calculate the distance, and compare it to the size() to see if it's<KAIGYO>// beyond the end, or take the minimum of the distance and the size."": 1}",1.0,{}
104,151289.0,3.0,7.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/151289,Particles: Shrink QQuickParticleData by 2 pointers.,1.0,{'//TODO: adjust for system?': 1},1.0,{'//TODO: adjust for system?': 1},1.0,{}
63,151290.0,2.0,4.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/151290,"V4: Move BitVector to the util header, so it can be re-used.",1.0,{},0.0,"{""// The ++operator of std::vector<bool>::iterator in libc++ has a bug when using it on an<KAIGYO>// iterator pointing to the last element. It will not be set to ::end(), but beyond<KAIGYO>// that. (It will be set to the first multiple of the native word size that is bigger<KAIGYO>// than size().)<KAIGYO>//<KAIGYO>// See httpllvm.org/bugs/show_bug.cgi?id=19663<KAIGYO>//<KAIGYO>// The work-around is to calculate the distance, and compare it to the size() to see if it's<KAIGYO>// beyond the end, or take the minimum of the distance and the size."": 1}",1.0,{}
215,151320.0,11.0,11.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/151320,D3D12: Basic image support,1.0,"{'// ### will need a way to release unused descriptors, cannot just keep all SRVs or RTVs around for ever': 3, '// ### this has to be a lot smarter': 3, '// ### ==================== temp test, move to a dedicated upload func': 7, '// maybe move this to QSGD3D12Texture::bind()?': 7, ""// just to avoid problems with commandAllocator being Reset(), won't be needed once moved"": 7}",1.0,{'// One single root signature for now. This will obviously need some improvements later on...': 3},1.0,{}
101,151379.0,3.0,6.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/151379,Fix application fonts with DirectWrite font engine,1.0,{},0.0,"{'// Dynamically resolve GetUserDefaultLocaleName, which is available from Windows<KAIGYO>// Vista onwards. ### fixme 5.7: Consider reverting to direct linking.': 2}",1.0,{}
148,151553.0,2.0,4.0,0.0,ABANDONED,False,https://codereview.qt-project.org/#/c/151553,Fix application fonts with DirectWrite font engine,1.0,{},0.0,"{'// Dynamically resolve GetUserDefaultLocaleName, which is available from Windows<KAIGYO>// Vista onwards. ### fixme 5.7: Consider reverting to direct linking.': 1}",1.0,{}
154,151566.0,2.0,2.0,0.0,ABANDONED,False,https://codereview.qt-project.org/#/c/151566,D3D12: Proper descriptor handle management,1.0,{},0.0,"{'// ### will need a way to release unused descriptors, cannot just keep all SRVs or RTVs around for ever': 1, '// ### this has to be a lot smarter': 2}",1.0,{}
203,151695.0,2.0,4.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/151695,Deduplicate a condition to make clear that several cases ask it.,1.0,"{'// FIXME Implement a QNetworkReplyCacheImpl instead, see QTBUG-15106': 1}",1.0,"{'// FIXME Implement a QNetworkReplyCacheImpl instead, see QTBUG-15106': 1}",1.0,{}
232,151748.0,4.0,9.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/151748,QWheelEvent: Make NoScrollPhase public,1.0,{},0.0,{'// enable the fix for QTBUG-50199; TODO remove this check in 5.7': 1},1.0,{}
291,151861.0,8.0,30.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/151861,QHeaderView: fixing selection of reordered rows and columns,1.0,{},0.0,"{""// we only know about toplevel items and we don't want invalid ranges<KAIGYO>// FIXME an item inside the range may be the leftmost or rightmost"": 1, '// we only know about toplevel items<KAIGYO>// FIXME an item inside the range may be the leftmost or rightmost': 1}",1.0,{}
302,151963.0,2.0,3.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/151963,Remove Windows CE.,1.0,{},0.0,{'# take care of dependency': 1},1.0,{}
38,152140.0,3.0,15.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/152140,"tst_QSqlQuery: fix UBs (invalid downcasts, member calls)",1.0,{},0.0,"{""// don't call, it's only for stupid compilers"": 1}",1.0,{}
107,152371.0,11.0,12.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/152371,Enable building Qt Quick module with QT_NO_OPENGL defined,1.0,"{'    /* The cleanup of the atlas textures is a bit intriguing.<KAIGYO>       As part of the cleanup in the threaded render loop, we<KAIGYO>       do:<KAIGYO>       1. call this function<KAIGYO>       2. call QCoreApp::sendPostedEvents() to immediately process<KAIGYO>          any pending deferred deletes.<KAIGYO>       3. delete the GL context.<KAIGYO><KAIGYO>       As textures need the atlas manager while cleaning up, the<KAIGYO>       manager needs to be cleaned up after the textures, so<KAIGYO>       we post a deleteLater here at the very bottom so it gets<KAIGYO>       deferred deleted last.<KAIGYO><KAIGYO>       Another alternative would be to use a QPointer in<KAIGYO>       QSGAtlasTexture::Texture, but this seemed simpler.<KAIGYO>     */': 1}",1.0,"{'    /* The cleanup of the atlas textures is a bit intriguing.<KAIGYO>       As part of the cleanup in the threaded render loop, we<KAIGYO>       do:<KAIGYO>       1. call this function<KAIGYO>       2. call QCoreApp::sendPostedEvents() to immediately process<KAIGYO>          any pending deferred deletes.<KAIGYO>       3. delete the GL context.<KAIGYO><KAIGYO>       As textures need the atlas manager while cleaning up, the<KAIGYO>       manager needs to be cleaned up after the textures, so<KAIGYO>       we post a deleteLater here at the very bottom so it gets<KAIGYO>       deferred deleted last.<KAIGYO><KAIGYO>       Another alternative would be to use a QPointer in<KAIGYO>       QSGAtlasTexture::Texture, but this seemed simpler.<KAIGYO>     */': 1}",1.0,{}
101,152456.0,2.0,2.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/152456,tst_QNetworkReply: Commentary fixes on test server workarounds.,1.0,{'// Work round known quirk in the old test server (danted -v < v1.1.19):<KAIGYO>// QTBUG-23136 workaround (needed even with danted v1.1.19):': 1},1.0,{'// Work round known quirk in the old test server:<KAIGYO>//QTBUG-23136 workaround<KAIGYO>//XFAIL result above': 1},1.0,{}
64,153409.0,3.0,18.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/153409,Remove QPROCESS_USE_SPAWN and all that it surrounds,1.0,{},0.0,"{""// Workaround: QNX's spawn implementation will actually dup all FD values<KAIGYO>// LESS than fdmax - regardless of the FD_CLOEEXEC flag. So we need to add<KAIGYO>// those to the list of files to close, otherwise dup will fail when some<KAIGYO>// other thread closes the FD."": 1}",1.0,{}
67,153442.0,3.0,6.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/153442,Rework toggling the state of read notifier on buffered socket,1.0,{},0.0,"{""// ensure that the read notification is enabled if we've now got<KAIGYO>// room in the read buffer<KAIGYO>// but only if we're not inside canReadNotification -- that will take care on its own<KAIGYO>// Do not change the notifier unless we are connected."": 1}",1.0,{}
87,153498.0,2.0,6.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/153498,Merge remote-tracking branch 'origin/5.6' into 5.7,1.0,{},0.0,"{'// This file is responsible for resolving all GTK functions we use<KAIGYO>// dynamically. This is done to avoid link-time dependancy on GTK<KAIGYO>// as well as crashes occurring due to usage of the GTK_QT engines<KAIGYO>//<KAIGYO>// Additionally we create a map of common GTK widgets that we can pass<KAIGYO>// to the GTK theme engine as many engines resort to querying the<KAIGYO>// actual widget pointers for details that are not covered by the<KAIGYO>// state flags': 1, ""// the following is necessary to work around breakage in many versions<KAIGYO>// of XFree86's Xlib.h still in use<KAIGYO>// ### which versions?<KAIGYO>// crude hack, but..."": 1, '// TODO: choose between gtk2 and gtk3': 1}",1.0,{}
148,153715.0,2.0,5.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/153715,Merge remote-tracking branch 'origin/5.6' into 5.7,1.0,{},0.0,"{""// Workaround: QNX's spawn implementation will actually dup all FD values<KAIGYO>// LESS than fdmax - regardless of the FD_CLOEEXEC flag. So we need to add<KAIGYO>// those to the list of files to close, otherwise dup will fail when some<KAIGYO>// other thread closes the FD."": 1}",1.0,{}
215,153903.0,12.0,41.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/153903,Multi-screen handling for the eglfs_kms_egldevice backend,1.0,"{'// Maybe detecting the DPMS mode could help here, but there are no properties<KAIGYO>// exposed on the connector apparently. So rely on an env var for now.': 2}",1.0,"{'// Maybe detecting the DPMS mode could help here, but there are no properties<KAIGYO>// exposed on the connector apparently. So rely on an env var for now.': 1}",1.0,"{'// Maybe detecting the DPMS mode could help here, but there are no properties<KAIGYO>// exposed on the connector apparently. So rely on an env var for now.': '2-1'}"
44,154141.0,2.0,3.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/154141,windeployqt: Fix build.,1.0,{'// Deprecated by improved debug detection.': 1},1.0,{'// Deprecated by improved debug detection.': 1},1.0,{}
210,154265.0,12.0,65.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/154265,CoreLib: use QStringRef to optimize memory allocation,1.0,"{'// ### TODO write proper code: do not allocate memory, so we can go nothrow': 3}",1.0,"{'//#### TODO write proper code, do not use QStringList': 3}",1.0,{}
84,154328.0,2.0,15.0,0.0,ABANDONED,False,https://codereview.qt-project.org/#/c/154328,Update scroll resolution if it changes,1.0,{},0.0,"{'// ### If a slave device changes (XIDeviceChange), we should probably run setup on it again.': 1}",1.0,{}
112,154390.0,1.0,1.0,0.0,ABANDONED,False,https://codereview.qt-project.org/#/c/154390,AtSpiAdaptor: refactor some code,1.0,{},0.0,{'// FIXME all attribute methods below should share code': 1},1.0,{}
123,154417.0,1.0,6.0,0.0,ABANDONED,False,https://codereview.qt-project.org/#/c/154417,[Android] Support emojis character rendering,1.0,"{'// The scanlines in image are 32-bit aligned, even for mono or 8-bit formats. This<KAIGYO>// is good because it matches the default of 4 bytes for GL_UNPACK_ALIGNMENT.': 1}",1.0,"{'// The scanlines in mask are 32-bit aligned, even for mono or 8-bit formats. This<KAIGYO>// is good because it matches the default of 4 bytes for GL_UNPACK_ALIGNMENT.': 1}",1.0,{}
138,154459.0,6.0,21.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/154459,dbustray: Implement better detection of indicator-application,1.0,"{""// Hack for indicator-application, which doesn't handle icons sent across D-Bus:"": 1}",1.0,"{""// Hack for Unity, which doesn't handle icons sent across D-Bus:"": 1}",1.0,{}
228,154469.0,18.0,149.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/154469,Support color font rendering for freetype engine,1.0,"{'// The scanlines in image are 32-bit aligned, even for mono or 8-bit formats. This<KAIGYO>// is good because it matches the default of 4 bytes for GL_UNPACK_ALIGNMENT.': 1}",1.0,"{'// The scanlines in mask are 32-bit aligned, even for mono or 8-bit formats. This<KAIGYO>// is good because it matches the default of 4 bytes for GL_UNPACK_ALIGNMENT.': 1, '//even more of a workaround...': 5}",1.0,{}
221,154536.0,8.0,10.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/154536,D3D12: Add support for layers,1.0,"{'// Round it up and overallocate a little bit so that a subsequent<KAIGYO>// buffer contents rebuild with a slightly larger total size does<KAIGYO>// not lead to creating a new buffer.': 2, '// Bail out when the dirty list already spans the entire buffer.': 2}",1.0,"{'// Bail out when there was a resetV/I/CBuffer and the dirty list already spans the entire buffer data.': 2, '// Round it up and overallocate a little bit so that a subsequent<KAIGYO>// buffer contents rebuild with a slightly larger total size does<KAIGYO>// not lead to creating a new buffer.': 2}",1.0,{}
294,154880.0,14.0,34.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/154880,Use QStringRef to optimize memory allocation,1.0,"{""// Don't use QStringLiteral here. QRegExp has a global cache and will save an implicitly<KAIGYO>// shared copy of the passed string. That copy isn't properly detached when the library<KAIGYO>// is unloaded if the original string lives in the library's .rodata"": 6}",1.0,"{""// Don't use QStringLiteral here. QRegExp has a global cache and will save an implicitly<KAIGYO>// shared copy of the passed string. That copy isn't properly detached when the library<KAIGYO>// is unloaded if the original string lives in the library's .rodata"": 6}",1.0,{}
132,155444.0,5.0,17.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/155444,Merge remote-tracking branch 'origin/5.6' into 5.7,1.0,{},0.0,"{""/*! \\macro QCOMPARE(actual, expected)<KAIGYO><KAIGYO>   \\relates QTest<KAIGYO><KAIGYO>   The QCOMPARE macro compares an \\a actual value to an \\a expected value using<KAIGYO>   the equals operator. If \\a actual and \\a expected are identical, execution<KAIGYO>   continues. If not, a failure is recorded in the test log and the test<KAIGYO>   won't be executed further.<KAIGYO><KAIGYO>   In the case of comparing floats and doubles, qFuzzyCompare() is used for<KAIGYO>   comparing. This means that comparing to 0 will likely fail. One solution<KAIGYO>   to this is to compare to 1, and add 1 to the produced output.<KAIGYO><KAIGYO>   QCOMPARE tries to output the contents of the values if the comparison fails,<KAIGYO>   so it is visible from the test log why the comparison failed.<KAIGYO><KAIGYO>   QCOMPARE is very strict on the data types. Both \\a actual and \\a expected<KAIGYO>   have to be of the same type, otherwise the test won't compile. This prohibits<KAIGYO>   unspecified behavior from being introduced; that is behavior that usually<KAIGYO>   occurs when the compiler implicitly casts the argument.<KAIGYO><KAIGYO>   For your own classes, you can use \\l QTest::toString() to format values for<KAIGYO>   outputting into the test log.<KAIGYO><KAIGYO>   \\note This macro can only be used in a test function that is invoked<KAIGYO>   by the test framework.<KAIGYO><KAIGYO>   Example:<KAIGYO>   \\snippet code/src_qtestlib_qtestcase.cpp 2<KAIGYO><KAIGYO>   \\sa QVERIFY(), QTRY_COMPARE(), QTest::toString()<KAIGYO>*/"": 1, ""/*! \\macro QTEST_APPLESS_MAIN(TestClass)<KAIGYO><KAIGYO>    \\relates QTest<KAIGYO><KAIGYO>    Implements a main() function that executes all tests in \\a TestClass.<KAIGYO><KAIGYO>    Behaves like \\l QTEST_MAIN(), but doesn't instantiate a QApplication<KAIGYO>    object. Use this macro for really simple stand-alone non-GUI tests.<KAIGYO><KAIGYO>    \\sa QTEST_MAIN()<KAIGYO>*/"": 1, '/*!<KAIGYO>    \\fn QTouchEventSequence &QTest::QTouchEventSequence::move(int touchId, const QPoint &pt, QWindow *window)<KAIGYO>    \\since 5.0<KAIGYO><KAIGYO>    Adds a move event for touchpoint \\a touchId at position \\a pt to this sequence and returns<KAIGYO>    a reference to this QTouchEventSequence.<KAIGYO><KAIGYO>    The position \\a pt is interpreted as relative to \\a window. If \\a window is the null pointer, then<KAIGYO>    \\a pt is interpreted as relative to the window provided when instantiating this QTouchEventSequence.<KAIGYO><KAIGYO>    Simulates that the user moved the finger identified by \\a touchId.<KAIGYO>*/': 1}",1.0,{}
76,156295.0,4.0,13.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/156295,QQuickWidget: Enable use with software renderer backend,1.0,{'// Bail out when receiving a resize after scenegraph invalidation. This can happen<KAIGYO>// during hide - resize - show sequences and also during application exit.': 1},1.0,{'// Bail out when receiving a resize after scenegraph invalidation. This can happen<KAIGYO>// during hide - resize - show sequences and also during application exit.': 1},1.0,{}
120,156523.0,2.0,7.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/156523,tst_qwidget: Remove test widget member.,1.0,{},0.0,{'// TODO: Add initialization code here.<KAIGYO>// This will be executed immediately before each test is run.': 1},1.0,{}
291,156817.0,9.0,31.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/156817,Remove all code paths related to unsupported Apple platforms.,1.0,{},0.0,"{""// work around what seems to be a bug in CFPreferences:<KAIGYO>// don't report an error if there are no preferences for the application"": 1, '// On Mac OS X 10.5 and earlier, canonicalPath depends on cleanPath which<KAIGYO>// is itself very broken and fundamentally wrong on """" which, this would<KAIGYO>// exercise': 1, '// On Mac OS X 10.5 and earlier, canonicalPath depends on cleanPath which<KAIGYO>// is itself very broken and fundamentally wrong on """", which this would<KAIGYO>// exercise': 1}",1.0,{}
284,156966.0,4.0,11.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/156966,"V4: Limit call depth by count, not by checking the native stack.",1.0,{},0.0,"{'// On some architectures the stack grows upwards. All of these are rather exotic, so simply assume<KAIGYO>// everything is fine there.<KAIGYO>// Known examples:<KAIGYO>// -HP PA-RISC': 1, '// This is wrong. StackLimit is the currently committed stack size, not the real end.<KAIGYO>// only way to get that limit is apparently by using VirtualQuery (Yuck)<KAIGYO>//#elif OS(WINDOWS)<KAIGYO>//    PNT_TIB tib = (PNT_TIB)NtCurrentTeb();<KAIGYO>//    stackLimit = static_cast<quintptr>(tib->StackLimit);': 1}",1.0,{}
288,156998.0,19.0,37.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/156998,tst_QWidget: make it stable on OS X,1.0,{},0.0,"{'// Cocoa has no Z-Order for views, we hack it, but it results in paint events.': 9}",1.0,{}
36,157172.0,2.0,3.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/157172,Merge remote-tracking branch 'origin/5.6' into 5.7,1.0,{},0.0,"{""// we only know about toplevel items and we don't want invalid ranges<KAIGYO>// FIXME an item inside the range may be the leftmost or rightmost"": 1, '// we only know about toplevel items<KAIGYO>// FIXME an item inside the range may be the leftmost or rightmost': 1}",1.0,{}
108,157495.0,4.0,23.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/157495,Remove use of QMutexPool in Windows code resolving libraries,1.0,{},0.0,"{""// another thread did initialize the security function pointers,<KAIGYO>// so we shouldn't do it again."": 1}",1.0,{}
164,157659.0,2.0,4.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/157659,Drop the Win CE support,1.0,{},0.0,{'// FIXME: Here the situation is not properly handled with zero timeout:<KAIGYO>// breaker can work out before you call a method WaitCommEvent()<KAIGYO>// and so it will loop forever!': 1},1.0,{}
200,157817.0,12.0,88.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/157817,Determine the compiler's default include and lib directories at qmake time,1.0,{},0.0,{'// FIXME: add detection': 1},1.0,{}
38,158134.0,1.0,7.0,0.0,ABANDONED,False,https://codereview.qt-project.org/#/c/158134,"Revert ""Support color font rendering for freetype engine"" because this broke qt5.git integration in '5.7'",1.0,"{'// The scanlines in mask are 32-bit aligned, even for mono or 8-bit formats. This<KAIGYO>// is good because it matches the default of 4 bytes for GL_UNPACK_ALIGNMENT.': 1, '//even more of a workaround...': 1}",1.0,"{'// The scanlines in image are 32-bit aligned, even for mono or 8-bit formats. This<KAIGYO>// is good because it matches the default of 4 bytes for GL_UNPACK_ALIGNMENT.': 1}",1.0,{}
257,158628.0,11.0,65.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/158628,Merge remote-tracking branch 'origin/5.6' into 5.7,1.0,{},0.0,"{""// We only currently support share handles with BGRA surfaces, because<KAIGYO>// chrome needs BGRA. Once chrome fixes this, we should always support them.<KAIGYO>// PIX doesn't seem to support using share handles, so disable them.<KAIGYO>// Also disable share handles on Feature Level 9_3, since it doesn't support share handles on RGBA8 textures/swapchains.<KAIGYO>// && !(mFeatureLevel <= D3D_FEATURE_LEVEL_9_3); Qt: we don't care about the 9_3 limitation"": 8}",1.0,{}
207,158796.0,4.0,6.0,0.0,ABANDONED,False,https://codereview.qt-project.org/#/c/158796,Determine the compiler's default include and lib directories at qmake time,1.0,{},0.0,{'// FIXME: add detection': 1},1.0,{}
255,158890.0,9.0,23.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/158890,move license check to qmake-based configure system,1.0,{},0.0,"{'// Get console line height, to fill the screen properly<KAIGYO>// default': 4}",1.0,{}
10,159012.0,2.0,9.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/159012,QTest: do not generate stack traces when a debugger is attached.,1.0,{'// TODO': 1},1.0,{'// TODO': 1},1.0,{}
53,159087.0,6.0,20.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/159087,Move the QDateTime file static functions to their right place,1.0,"{'// same as, but producing better code<KAIGYO>//return d.data.msecs;': 1, '// same as, but producing better code<KAIGYO>//return StatusFlag(d.data.status);': 1}",1.0,"{'// same as, but producing better code<KAIGYO>//return d.data.msecs;': 1, '// same as, but producing better code<KAIGYO>//return StatusFlag(d.data.status);': 1}",1.0,{}
59,159153.0,4.0,4.0,0.0,DEFERRED,False,https://codereview.qt-project.org/#/c/159153,Add debug mode for XKeyboard,1.0,{'// TODO': 1},1.0,"{""// ### TODO some X servers don't set _XKB_RULES_NAMES at all, in these cases it is filled"": 2}",1.0,{}
66,159187.0,5.0,11.0,0.0,DEFERRED,False,https://codereview.qt-project.org/#/c/159187,Add debug mode for XKeyboard,1.0,{},0.0,"{""// ### TODO some X servers don't set _XKB_RULES_NAMES at all, in these cases it is filled"": 1, ""// ### TODO some X servers don't set _XKB_RULES_NAMES at all, in these cases it is filled<KAIGYO>// with gibberish, we would need to do some kind of sanity check"": 4}",1.0,{}
166,159375.0,3.0,4.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/159375,Windows QPA: Remove qtwindows_additional.h.,1.0,{},0.0,"{'#ifdef Q_CC_MINGW  /* Add missing declarations for MinGW */<KAIGYO><KAIGYO>#ifndef __IShellLibrary_FWD_DEFINED__<KAIGYO><KAIGYO>/* Constants obtained by running the below stream operator for<KAIGYO> * CLSID, IID on the constants in the Windows SDK libraries. */': 1}",1.0,{}
200,159507.0,3.0,3.0,0.0,ABANDONED,False,https://codereview.qt-project.org/#/c/159507,WIP: QmlProfiler: Don't send redundant RangeData and RangeLocation,1.0,{'// TODO: We might want to extract the pixmap URLs as type data.': 1},1.0,"{""// This unrefs all the objects. We have to make sure we do this in the GUI thread. Also, it's<KAIGYO>// a good idea to release the memory before creating the packets to be sent."": 2}",1.0,{}
175,159623.0,3.0,4.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/159623,Minor optimization for VME meta objects,1.0,{},0.0,{'// Need JS wrapper to ensure properties are marked.<KAIGYO>// ### FIXME: I hope that this can be removed once we have the proper scope chain<KAIGYO>// set up and the JS wrappers always exist.': 2},1.0,{}
210,159726.0,2.0,12.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/159726,Always use ::copysign instead of std::copysign where available,1.0,{},0.0,"{""// C++11's std::copysign is missing in the std namespace, so get it from the root namespace (math.h)<KAIGYO>// Ok, we have a proper C++11 standard library"": 1}",1.0,{}
247,159854.0,8.0,11.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/159854,Migrate to the new QSGNinePatchNode,1.0,{},0.0,{'// The texture material has mipmap filtering set to Nearest by default. This is not ideal.': 1},1.0,{}
264,159937.0,5.0,25.0,0.0,NEW,False,https://codereview.qt-project.org/#/c/159937,Use QDeadlineTimer in the qt_safe_poll code,1.0,{},0.0,"{""// clock source is (hopefully) monotonic, so we can recalculate how much timeout is left;<KAIGYO>// if it isn't monotonic, we'll simply hope that it hasn't jumped, because we have no alternative"": 1}",1.0,{}
250,159938.0,3.0,15.0,0.0,NEW,False,https://codereview.qt-project.org/#/c/159938,Remove the code that repairs timers in the event of a system clock jump,1.0,{},0.0,"{'/*<KAIGYO>  Returns \\c true if the real time clock has changed by more than 10%<KAIGYO>  relative to the processor time since the last time this function was<KAIGYO>  called. This presumably means that the system time has been changed.<KAIGYO><KAIGYO>  If /a delta is nonzero, delta is set to our best guess at how much the system clock was changed.<KAIGYO>*/': 1}",1.0,{}
140,160172.0,5.0,6.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/160172,QmlProfiler: Send RangeData and RangeLocation only once per type,1.0,{},0.0,"{""// This unrefs all the objects. We have to make sure we do this in the GUI thread. Also, it's<KAIGYO>// a good idea to release the memory before creating the packets to be sent."": 1}",1.0,{}
147,160443.0,6.0,14.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/160443,winrt: enable drag support,1.0,"{'// ### TODO: Missing: weblink, image': 1}",1.0,{'// ### TODO: Add dragging from Window': 1},1.0,{}
90,161247.0,3.0,4.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/161247,QtBluetooth: remove outdate code (OS X/iOS),1.0,{'// Our guess included/not was probably wrong.': 1},1.0,"{'// Ugly cast to deal with id being a pointer ...': 1, '// Our guess included/not was probably wrong.': 1}",1.0,{}
110,161353.0,2.0,2.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/161353,Enhance rendernode example with opacity support,1.0,{},0.0,"{""// we won't implement changedStates() since no viewport/scissor/stencil/blend related commands were added"": 1}",1.0,{}
207,161800.0,2.0,2.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/161800,Remove QWidgetBackingStore::fullUpdatePending,1.0,{},0.0,{'//### FIXME fullUpdatePending seems to be always false????': 1},1.0,{}
25,162056.0,4.0,12.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/162056,Merge remote-tracking branch 'origin/5.6' into 5.7,1.0,{},0.0,"{'// Drawing the entire itemview frame is very expensive, especially on the native X11 engine<KAIGYO>// Instead we cheat a bit and draw a border image without the center part, hence only scaling<KAIGYO>// thin rectangular images': 1, '// ### this mess should move to subcontrolrect': 1, '// See httpsbugzilla.mozilla.org/show_bug.cgi?id=405421 for info about this hack': 1, '// Since Qt does not currently allow filling the entire background<KAIGYO>// we use a hack for this by making a complete menubar each time and<KAIGYO>// paint with the correct offset inside it. Pixmap caching should resolve<KAIGYO>// most of the performance penalty.': 1, '// """" is actually hardcoded and fails on hardy (see gtk+-2.12/gtkmenuitem.c)<KAIGYO>// though the current documentation states otherwise': 1, '// Workaround for bug in QProgressBar': 1, '// adjust the font and add the difference in size.<KAIGYO>// it would be better if the font could be adjusted in the initStyleOption qmenu func!!': 1}",1.0,{}
27,162085.0,5.0,9.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/162085,Allow adjustment of device search timeout on BlueZ,1.0,{},0.0,{'//TODO change when implemented<KAIGYO>// wait 20s and sum up what was found<KAIGYO>// 20s': 1},1.0,{}
21,162127.0,2.0,3.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/162127,Android: Allow to set BTLE device search timeout,1.0,{},0.0,{'//TODO change when implemented': 1},1.0,{}
230,162142.0,22.0,28.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/162142,QtBluetooth - add LE device discovery timeout (OS X/iOS),1.0,"{'// TODO: emit a signal': 1, ""// timeChunk is in ms, that's why we have '/ 1000.' below."": 1, '// TODO: emit notifier->error instead<KAIGYO>// TODO: emit notifier->error instead.<KAIGYO>// TODO: emit notifier->error instead.<KAIGYO>// TODO: emit notifier->error instead.': 1, '// TODO: careful with this logic though!!!': 1, ""// TODO: my understanding of the same peripheral reported many times seems<KAIGYO>// to be outdated or even wrong - nowadays it's reported twice and the<KAIGYO>// second time (AFAIK) more info can be extracted ...<KAIGYO>//devices.append(newDeviceInfo);<KAIGYO>// TODO: instead - emit notifier's signal."": 1, '// TODO: this completely changes ...': 1, '// TODO: No more timer ...<KAIGYO>//timer->stop();': 1, '// Not sure how this is possible at all,<KAIGYO>// probably, can never happen.<KAIGYO>// TODO: emit notifier->error instead<KAIGYO>// TODO: emit notifier->error instead.<KAIGYO>// On iOS a user can see at this point an alert asking to<KAIGYO>// enable Bluetooth in the """" app. If a user does,<KAIGYO>// No change in internalState. Wait for 30 seconds<KAIGYO>// (we split it into smaller steps not to retain \'self\' for<KAIGYO>// too long ) ...<KAIGYO>// TODO: emit notifier->error instead.<KAIGYO>// TODO: emit notifier->error instead.': 3, ""// TODO: my understanding of the same peripheral reported many times seems<KAIGYO>// to be outdated or even wrong - nowadays it's reported twice and the<KAIGYO>// second time (AFAIK) more info can be extracted ..."": 4}",1.0,"{'// Not sure how this is possible at all, probably, can never happen.<KAIGYO>// On iOS a user can see at this point an alert asking to enable<KAIGYO>// Bluetooth in the """" app. If a user does,<KAIGYO>// No change in state. Wait for 30 seconds (we split it into \'chunks\' not<KAIGYO>// to retain \'self\' for too long ) ...': 3}",1.0,{}
45,162144.0,1.0,1.0,0.0,ABANDONED,False,https://codereview.qt-project.org/#/c/162144,WIP: REVIEW ONLY: Squashed commit of the remaining wip/scenegraphng merge,1.0,{},0.0,"{""// we won't implement changedStates() since no viewport/scissor/stencil/blend related commands were added"": 1}",1.0,{}
50,162228.0,2.0,2.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/162228,Cleanup: generalize type reference collection code,1.0,{},0.0,"{""// ### FIXME: We could report the more accurate location here by using prop->location, but the old<KAIGYO>// compiler can't and the tests expect it to be the object location right now."": 1}",1.0,{}
69,162278.0,5.0,13.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/162278,D3D12: Reintroduce the single threaded render loop,1.0,"{""// NOTE: The threaded renderloop is not currently safe to use in practice as it<KAIGYO>// is prone to deadlocks, in particular when multiple windows are active. This<KAIGYO>// is because DXGI's limitation of relying on the gui message pump in certain<KAIGYO>// cases. See<KAIGYO>// httpsmsdn.microsoft.com/en-us/library/windows/desktop/ee417025(v=vs.85).aspx#multithreading_and_dxgi<KAIGYO>//<KAIGYO>// This means that if swap chain functions like create, release, and<KAIGYO>// potentially even Present, are called outside the gui thread, then the<KAIGYO>// application must ensure the gui thread does not ever block and wait for the<KAIGYO>// render thread - since on the render thread a DXGI call may be in turn<KAIGYO>// waiting for the gui thread to deliver a window message...<KAIGYO>//<KAIGYO>// Ensuring this is impossible with the current design where the gui thread<KAIGYO>// must block at certain points, waiting for the render thread. Qt moves out<KAIGYO>// rendering from the main thread, in order to make application's life easier,<KAIGYO>// whereas the typical DXGI-compatible model would require moving work, but not<KAIGYO>// windowing and presenting, out to additional threads."": 1, '// Passed by the RL to the RT to maybe release resource if no windows are<KAIGYO>// rendering.': 2}",1.0,{'// Passed by the RL to the RT to maybe release resource if no windows are<KAIGYO>// rendering.': 2},1.0,{}
80,162287.0,6.0,23.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/162287,qmake: Fix missing newlines in generated vcxproj files,1.0,{},0.0,"{""// FIXME: Qt's line end conversion on sequential files should really be fixed"": 4}",1.0,{}
126,162570.0,3.0,4.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/162570,Move QQmlPropertyCacheCreator implementation into the header file,1.0,{},0.0,{'// XXX TODO: find a better way to get signal name from the property data :-/': 1},1.0,{}
188,162746.0,4.0,11.0,0.0,ABANDONED,False,https://codereview.qt-project.org/#/c/162746,QDesktopWidget: Find the closest screen for the point as documented,1.0,{},0.0,{'//even better would be closest screen': 1},1.0,{}
269,162809.0,7.0,9.0,0.0,ABANDONED,False,https://codereview.qt-project.org/#/c/162809,WIP refactor the event hierarchy,1.0,"{'// else TODO calculate it': 1, '// TODO setVelocity()': 1, '// TODO globalPosF may be wrong': 1, '// TODO use STL search algo': 3, ""// TODO calculate velocity if the event doesn't have it... or do it in the accessor"": 4}",1.0,"{'// TODO each instance should only track one touchpoint': 4, '// TODO destroy the right one': 4}",1.0,{}
268,162969.0,5.0,20.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/162969,Merge remote-tracking branch 'origin/5.7' into dev,1.0,{},0.0,"{""    /* This is a hack to get MySQL's stored procedure support working.<KAIGYO>       Since a stored procedure _may_ return multiple result sets,<KAIGYO>       we have to enable CLIEN_MULTI_STATEMENTS here, otherwise _any_<KAIGYO>       stored procedure call will fail.<KAIGYO>    */"": 1}",1.0,{}
69,163308.0,4.0,5.0,0.0,DEFERRED,False,https://codereview.qt-project.org/#/c/163308,WIP use QQuickPointerHandler::postHandlePointerEvent for atomic signals,1.0,"{""// TODO calculate velocity if the event doesn't have it... or do it in the accessor.<KAIGYO>// Or just make sure the event DOES have it: synthesize it in QQuickWindow when creating the QPointerEvent."": 3}",1.0,"{""// TODO calculate velocity if the event doesn't have it... or do it in the accessor"": 3}",1.0,{}
87,163330.0,5.0,9.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/163330,Merge remote-tracking branch 'origin/5.6' into 5.7,1.0,"{'// Maybe detecting the DPMS mode could help here, but there are no properties<KAIGYO>// exposed on the connector apparently. So rely on an env var for now.': 1}",1.0,"{'// Use a name different from qLcEglfsEglKmsDebug to avoid duplicate symbols in<KAIGYO>// static builds. Starting from Qt 5.7 this will be solved by the common kms<KAIGYO>// support library, but in the meantime just work it around.': 2, '// Maybe detecting the DPMS mode could help here, but there are no properties<KAIGYO>// exposed on the connector apparently. So rely on an env var for now.': 3}",1.0,"{'// Maybe detecting the DPMS mode could help here, but there are no properties<KAIGYO>// exposed on the connector apparently. So rely on an env var for now.': '1-3'}"
106,163390.0,13.0,33.0,0.0,ABANDONED,False,https://codereview.qt-project.org/#/c/163390,Implement universalPointId,1.0,"{'// Move to QQuickWindow?': 1, '// TODO globalPosF may be wrong': 1}",1.0,{'// TODO globalPosF may be wrong': 1},1.0,{}
163,163587.0,1.0,1.0,0.0,ABANDONED,False,https://codereview.qt-project.org/#/c/163587,PointerHandlers: clarify the meaning of the active property,1.0,{},0.0,{'// TODO should this be easier?  could be the PointerHandler.active property': 1},1.0,{}
34,164096.0,1.0,1.0,0.0,ABANDONED,False,https://codereview.qt-project.org/#/c/164096,"WIP Deliver only touch, not mouse.",1.0,"{'//        QQuickWindowPrivate *windowPriv = QQuickWindowPrivate::get(window);<KAIGYO>//    QQuickWindowPrivate *windowPriv = QQuickWindowPrivate::get(d->window);<KAIGYO>// TODO grab pointer point<KAIGYO>//    windowPriv->setMouseGrabber(this);<KAIGYO>//    QQuickWindowPrivate *windowPriv = QQuickWindowPrivate::get(d->window);<KAIGYO>// TODO ungrab pointer point<KAIGYO>//    QEvent ev(QEvent::UngrabMouse);<KAIGYO>//    d->window->sendEvent(this, &ev);': 1, '//        if (i == 0)<KAIGYO>//            lastMousePosition = touchPoint.pos().toPoint();<KAIGYO>// TODO': 1, '// Once per frame, send a synthetic hover, in case items have changed position.<KAIGYO>// For instance, during animation (including the case of a ListView<KAIGYO>// whose delegates contain MouseAreas), a MouseArea needs to know<KAIGYO>// whether it has moved into a position where it is now under the cursor.<KAIGYO>//    if (!mouseGrabberItem && !lastMousePosition.isNull()) {<KAIGYO>//        bool accepted = false;<KAIGYO>//        bool delivered = deliverHoverEvent(contentItem, lastMousePosition, lastMousePosition, QGuiApplication::keyboardModifiers(), accepted);<KAIGYO>//        if (!delivered)<KAIGYO>//            clearHover(); // take care of any exits<KAIGYO>//    }': 1, '// TODO the item should grab touchpoints that it wants, not all of them': 1, '//    case QEvent::MouseButtonPress:<KAIGYO>//    case QEvent::MouseButtonRelease:<KAIGYO>//    case QEvent::MouseButtonDblClick:<KAIGYO>//    case QEvent::MouseMove:<KAIGYO>//        // XXX todo - should sendEvent be doing this?  how does it relate to forwarded events?<KAIGYO>//        if (!d->sendFilteredMouseEvent(item->parentItem(), item, e)) {<KAIGYO>//            // accept because qml items by default accept and have to explicitly opt out of accepting<KAIGYO>//            e->accept();<KAIGYO>//            QCoreApplication::sendEvent(item, e);<KAIGYO>//        }<KAIGYO>//        break;<KAIGYO>//    case QEvent::UngrabMouse:<KAIGYO>//        if (!d->sendFilteredMouseEvent(item->parentItem(), item, e)) {<KAIGYO>//            e->accept();<KAIGYO>//            item->mouseUngrabEvent();<KAIGYO>//        }<KAIGYO>//        break;': 1}",1.0,"{'// probably redundant, we check bounds in the calling function (matchingNewPoints)': 1, ""// no grabber, check if we care about mouse hover<KAIGYO>// FIXME: this should only happen once, not recursively... I'll ignore it just ignore hover now.<KAIGYO>// hover for touch???"": 1, '//take care of any exits': 1, '// possible match.. is it really the same?': 1, '// Once per frame, send a synthetic hover, in case items have changed position.<KAIGYO>// For instance, during animation (including the case of a ListView<KAIGYO>// whose delegates contain MouseAreas), a MouseArea needs to know<KAIGYO>// whether it has moved into a position where it is now under the cursor.': 1, '// take care of any exits': 1, ""// If users spin the eventloop as a result of touch delivery, we disable<KAIGYO>// touch compression and send events directly. This is because we consider<KAIGYO>// the usecase a bit evil, but we at least don't want to lose events."": 1, '// XXX todo - should sendEvent be doing this?  how does it relate to forwarded events?': 1}",1.0,{}
111,164294.0,7.0,14.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/164294,Merge mouse handling functions,1.0,{'//take care of any exits': 1},1.0,{'//take care of any exits': 1},1.0,{}
130,164388.0,5.0,13.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/164388,Move touch event compression into a function,1.0,{'// possible match.. is it really the same?': 1},1.0,{'// possible match.. is it really the same?': 1},1.0,{}
121,164390.0,2.0,2.0,0.0,ABANDONED,False,https://codereview.qt-project.org/#/c/164390,Merge mouse handling functions,1.0,{'//take care of any exits': 1},1.0,{'//take care of any exits': 1},1.0,{}
138,164447.0,1.0,1.0,0.0,ABANDONED,False,https://codereview.qt-project.org/#/c/164447,Merge touch delivery lists,1.0,"{'// FIXME: why do we use send event here?': 1, '// FIXME: do not leak all these items': 1}",1.0,{'// FIXME: proper merging': 1},1.0,{}
148,164527.0,1.0,2.0,0.0,ABANDONED,False,https://codereview.qt-project.org/#/c/164527,Move touch event compression into a function,1.0,{'// possible match.. is it really the same?': 1},1.0,{'// possible match.. is it really the same?': 1},1.0,{}
155,164548.0,2.0,2.0,0.0,ABANDONED,False,https://codereview.qt-project.org/#/c/164548,WIP: Add mouse grabber again,1.0,"{'// FIXME: IMPLEMENT loop to remove grabber': 1, ""// FIXME: what if it's a touch point?"": 2, '// FIXME': 2, '// maybe rather true??? FIXME<KAIGYO>// FIXME: if the item has any new style handlers, call them here': 2, '// FIXME: only grab points that were inside the item': 2}",1.0,"{'//    Q_D(const QQuickWindow);<KAIGYO>//    return d->mouseGrabberItem;<KAIGYO>// FIXME<KAIGYO>//    Q_Q(QQuickWindow);<KAIGYO>//    QSet<QQuickItem *> cancelDelivered;<KAIGYO>//    foreach (QQuickItem *item, itemForTouchPointId) {<KAIGYO>//        if (cancelDelivered.contains(item))<KAIGYO>//            continue;<KAIGYO>//        cancelDelivered.insert(item);<KAIGYO>//        q->sendEvent(item, event);<KAIGYO>//    }<KAIGYO>//    // The next touch event can only be a TouchBegin so clean up.<KAIGYO>//    itemForTouchPointId.clear();<KAIGYO>//    return true;<KAIGYO>// FIXME': 2, '// FIXME: if the item has any new style handlers, call them<KAIGYO>//            item->grabMouse();': 2}",1.0,{}
261,164601.0,13.0,28.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/164601,Use the qmake based configuration system also on Windows,1.0,{},0.0,"{'//TODO actually wrong.<KAIGYO>//TODO': 1, '// compilerAndArgs contains compiler because there is no way to query it': 1}",1.0,{}
203,164652.0,1.0,1.0,0.0,ABANDONED,False,https://codereview.qt-project.org/#/c/164652,synthetize mouse events again,1.0,"{'// FIXME: only grab points that were inside the item': 1, '// FIXME: check if it should be synthesized (qapp flag)': 1, '// FIXME: use the right point, not randomly 0': 1, '// FIXME: why do we use send event here?': 1, '// FIXME: if the item has any new style handlers, call them here': 1}",1.0,"{'// FIXME: if the item has any new style handlers, call them here': 1, '// FIXME: cast :(': 1, '// FIXME: only grab points that were inside the item': 1, '// FIXME: why do we use send event here?': 1}",1.0,{}
205,164654.0,1.0,1.0,0.0,ABANDONED,False,https://codereview.qt-project.org/#/c/164654,Wip: towards accepting points,1.0,"{'// FIXME<KAIGYO>//        if (m_device)<KAIGYO>//            QGuiApplicationPrivate::setMouseEventCapsAndVelocity(me, m_device->capabilities(), p->velocity());': 1, '// maybe rather true??? FIXME<KAIGYO>// DO THE PARTIAL ACCEPT': 1, '// FIXME: why do we use send event here?': 1}",1.0,"{'// FIXME: split into several events if only some points are accepted': 1, '// maybe rather true??? FIXME': 1, '// FIXME: use event->button() as soon as grabbers work<KAIGYO>// buttons is all buttons, but that should only affect new events': 1, '// FIXME: why do we use send event here?': 1}",1.0,{}
264,164777.0,4.0,6.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/164777,Generalize the touchRecursionGuard to pointer events,1.0,"{""// If users spin the eventloop as a result of event delivery, we disable<KAIGYO>// event compression and send events directly. This is because we consider<KAIGYO>// the usecase a bit evil, but we at least don't want to lose events."": 1}",1.0,"{""// If users spin the eventloop as a result of touch delivery, we disable<KAIGYO>// touch compression and send events directly. This is because we consider<KAIGYO>// the usecase a bit evil, but we at least don't want to lose events."": 1}",1.0,{}
283,164846.0,1.0,2.0,0.0,ABANDONED,False,https://codereview.qt-project.org/#/c/164846,Move mouse move handling to deliverMouseEvent,1.0,{'//take care of any exits': 1},1.0,{'//take care of any exits': 1},1.0,{}
330,164957.0,5.0,8.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/164957,D3D12: Sprite node,1.0,{},0.0,{'// XXX: Do it the correct way': 4},1.0,{}
21,165011.0,4.0,7.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/165011,Call disconnectNotify() when disconnecting a QMetaObject::Connection,1.0,{},0.0,"{'// disconnectNotify() is not called, but it probably should be.': 2}",1.0,{}
40,165060.0,7.0,10.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/165060,Add support for the separate Classic/LE scans (macOS),1.0,"{'// Obj-C\'s way of """":': 1}",1.0,"{'// Obj-C\'s way of """":': 1, '//TODO Implement discovery method handling (see input parameter)': 1}",1.0,{}
39,165150.0,2.0,3.0,0.0,ABANDONED,False,https://codereview.qt-project.org/#/c/165150,WIP manage tablet device instances,1.0,{'// TODO detect other capabilities like rotation and tilt': 1},1.0,{'// TODO tablet event types': 2},1.0,{}
204,165474.0,10.0,27.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/165474,Hierarchy for touch and mouse pointer events,1.0,"{'//    QVERIFY(!pe->asTabletEvent()); // TODO': 7, '//    QVERIFY(!pte->asTabletEvent()); // TODO': 7, '//    QVERIFY(!pte.asTabletEvent()); // TODO': 8}",1.0,"{'// TODO it could alternatively be a tablet point': 1, '//    QVERIFY(!pe.asTabletEvent()); // TODO': 7}",1.0,{}
234,165675.0,2.0,5.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/165675,winrtrunner: Add support for installing packages,1.0,{'// ### TODO: read detailed error from event log directly': 1},1.0,"{'// TODO: handle already-built package as well': 1, '// ### TODO: read detailed error from event log directly': 1}",1.0,{}
319,165905.0,14.0,22.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/165905,Estimate the velocity of a point,1.0,"{'// cleanup events older than 500 ms (how old should they be, 500ms is probably too long<KAIGYO>// in order for a touch point to qualify as having velocity': 1, '// VERY simple kalman filter: does a weighted average<KAIGYO>// where the older velocities gets less and less significant': 1, '// TODO optimize: stop this dynamic memory thrashing': 3, '// VERY simple kalman filter: does a weighted average<KAIGYO>// where the older velocities get less and less significant': 3}",1.0,{'// TODO if Q_LIKELY(velocity.isNull) calculate velocity': 3},1.0,{}
299,165935.0,2.0,3.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/165935,Work around ICC bug about C++11 noexcept inheritance,1.0,{'//### reverse should probably apply on a per-action basis': 1},1.0,{'//### reverse should probably apply on a per-action basis': 1},1.0,{}
31,166083.0,4.0,4.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/166083,Keep track of the device which was grabbed as mouse for touch,1.0,{},0.0,{'// FIXME: it is unclear which touch device the mouse grab is for': 1},1.0,{}
84,166201.0,5.0,14.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/166201,QtPlatformSupport: Add QAbstractFileIconEngine,1.0,{},0.0,{'// TODO Should return QCommonStyle pixmaps?': 2},1.0,{}
103,166368.0,1.0,1.0,0.0,ABANDONED,False,https://codereview.qt-project.org/#/c/166368,WIP: break flickable tests -- Move call to sendFilteredMouseEvent out of sendEvent,1.0,{},0.0,{'// XXX todo - should sendEvent be doing this?  how does it relate to forwarded events?': 1},1.0,{}
235,166706.0,2.0,3.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/166706,Reduce duplicated code in MultiPointTouchArea,1.0,{},0.0,"{'//TODO: move to window': 1, '//TODO: verify this behavior': 1}",1.0,{}
264,166740.0,6.0,10.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/166740,Pass pointer event into sendFilteredTouchEvent,1.0,{'// FIXME: remove asTouchEvent!!!': 1},1.0,"{""// copy a touch event's basic properties but give it new touch points<KAIGYO>// TODO remove this variant and use QQuickPointerEvent/QQuickEventPoint"": 4}",1.0,{}
300,166887.0,2.0,2.0,0.0,ABANDONED,False,https://codereview.qt-project.org/#/c/166887,WIP: Use QQuickPointerEvent::asMouseEvent,1.0,{},0.0,"{'// FIXME: this is a bit backwards, should just have the pointer event passed into the function': 1, '// FIXME: remove asTouchEvent!!!': 1}",1.0,{}
302,166912.0,3.0,5.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/166912,winrt: Implement LE device discovery timeout,1.0,{},0.0,{'// TODO': 1},1.0,{}
305,166916.0,5.0,18.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/166916,Merge branch 'dev' into wip/pointerhandler,1.0,"{'//    QVERIFY(!pe->asTabletEvent()); // TODO': 1, '//    QVERIFY(!pte.asTabletEvent()); // TODO': 1}",1.0,"{'//    QVERIFY(!pe->asTabletEvent()); // TODO': 1, '//    QVERIFY(!pte.asTabletEvent()); // TODO': 1}",1.0,{}
322,166997.0,2.0,2.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/166997,Pass pointerEvent into QQuickWindowPrivate::deliverTouchAsMouse,1.0,{'// FIXME: make this work for mouse events too and get rid of the asTouchEvent in here.': 1},1.0,"{'// FIXME: this is a bit backwards, should just have the pointer event passed into the function': 1}",1.0,{}
326,167000.0,2.0,4.0,0.0,DEFERRED,False,https://codereview.qt-project.org/#/c/167000,Remove dead code - move events only get delivered to previous grabbers,1.0,{},0.0,"{""// no grabber, check if we care about mouse hover<KAIGYO>// FIXME: this should only happen once, not recursively... I'll ignore it just ignore hover now.<KAIGYO>// hover for touch???"": 1, '//take care of any exits': 1}",1.0,{}
43,167070.0,1.0,11.0,0.0,ABANDONED,False,https://codereview.qt-project.org/#/c/167070,WIP: squashed version of wip/pointerhandler merge,1.0,"{'// ### Figure out how to populate the tablet devices': 1, '// TODO calculate velocity': 1, '// TODO maybe add QQuickItem::mapVector2DFromScene(QVector2D) to avoid needing QQuickItemPrivate here<KAIGYO>// Or else just document that velocity is always scene-relative and is not scaled and rotated with the item<KAIGYO>// but that would require changing tst_qquickwindow::touchEvent_velocity(): it expects transformed velocity': 1, '// FIXME: make this work for mouse events too and get rid of the asTouchEvent in here.': 1, '// FIXME: deprecate this function, we need a device': 1, '// FIXME send ungrab event only once': 1, '// TODO tablet event types': 1, ""// If users spin the eventloop as a result of event delivery, we disable<KAIGYO>// event compression and send events directly. This is because we consider<KAIGYO>// the usecase a bit evil, but we at least don't want to lose events."": 1, '// check if item or any of its child items contain the point<KAIGYO>// FIXME: should this be iterative instead of recursive?': 1, '// TODO: unite this mouse point delivery with the synthetic mouse event below': 1, '// FIXME: remove asTouchEvent!!!': 1, '// FIXME: do not leak all these items': 1, '//    QVERIFY(!pe->asTabletEvent()); // TODO': 1, '//    QVERIFY(!pte.asTabletEvent()); // TODO': 1}",1.0,"{'//TODO: move to window': 1, '//TODO: verify this behavior': 1, ""// If users spin the eventloop as a result of touch delivery, we disable<KAIGYO>// touch compression and send events directly. This is because we consider<KAIGYO>// the usecase a bit evil, but we at least don't want to lose events."": 1}",1.0,{}
38,167122.0,2.0,3.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/167122,tst_librarymetrics_performance: Use QBENCHMARK macro instead of rolling our own,1.0,{},0.0,{'// twice to workaround bug in QTestLib': 1},1.0,{}
57,167160.0,2.0,4.0,0.0,ABANDONED,False,https://codereview.qt-project.org/#/c/167160,clang-format qquickevents_p_p.h and .cpp,1.0,{'// TODO maybe add QQuickItem::mapVector2DFromScene(QVector2D) to avoid needing QQuickItemPrivate<KAIGYO>// here<KAIGYO>// Or else just document that velocity is always scene-relative and is not scaled and rotated<KAIGYO>// with the item<KAIGYO>// but that would require changing tst_qquickwindow::touchEvent_velocity(): it expects<KAIGYO>// transformed velocity': 1},1.0,{'// TODO maybe add QQuickItem::mapVector2DFromScene(QVector2D) to avoid needing QQuickItemPrivate here<KAIGYO>// Or else just document that velocity is always scene-relative and is not scaled and rotated with the item<KAIGYO>// but that would require changing tst_qquickwindow::touchEvent_velocity(): it expects transformed velocity': 1},1.0,{}
191,167362.0,13.0,16.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/167362,QQuickEventPoint::grabber: allow grabbing either an item or a handler,1.0,"{'// TODO else if the old grabber was a PointerHandler, notify it somehow?': 3}",1.0,"{'// TODO eventually the handler itself should be the grabber, instead of the target Item': 3}",1.0,{}
158,167411.0,2.0,4.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/167411,Remove unused tool qconfig,1.0,{},0.0,"{'// maybe convert to Map to get keys sorted': 1, '// TODO<KAIGYO>// TODO<KAIGYO>// TODO': 1}",1.0,{}
153,167427.0,2.0,2.0,0.0,ABANDONED,False,https://codereview.qt-project.org/#/c/167427,WIP add and use separate accessors for Item and PointerHandler grabbers,1.0,"{'// TODO else if the old grabber was a PointerHandler, notify it somehow?': 2}",1.0,"{'// TODO eventually the handler itself should be the grabber, instead of the target Item': 1}",1.0,{}
278,167476.0,6.0,22.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/167476,Quick: replace 'foreach' with 'range for',1.0,"{'//take care of any exits': 2, '// possible match.. is it really the same?': 2}",1.0,"{'// possible match.. is it really the same?': 2, '//take care of any exits': 2, '// Once per frame, send a synthetic hover, in case items have changed position.<KAIGYO>// For instance, during animation (including the case of a ListView<KAIGYO>// whose delegates contain MouseAreas), a MouseArea needs to know<KAIGYO>// whether it has moved into a position where it is now under the cursor.': 2, '// take care of any exits': 2, '// no context validity check - it is essential to be able to return a<KAIGYO>// renderer interface instance before scenegraphInitialized() is emitted<KAIGYO>// (depending on the backend, that can happen way too late for some of the<KAIGYO>// rif use cases, like examining the graphics api or shading language in<KAIGYO>// use)': 2}",1.0,{}
239,167486.0,3.0,8.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/167486,Quick: use const (and const APIs) more,1.0,"{'//TODO: Actually image state count, need to rename these things to make sense together': 1}",1.0,"{'//TODO: Actually image state count, need to rename these things to make sense together': 1}",1.0,{}
218,167658.0,9.0,22.0,0.0,ABANDONED,False,https://codereview.qt-project.org/#/c/167658,inotify: only create one inotify fd per thread,1.0,{},0.0,{'// perhaps a directory?': 1},1.0,{}
264,167703.0,5.0,26.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/167703,Merge remote-tracking branch 'origin/5.7' into dev,1.0,{},0.0,"{""/*!<KAIGYO>    \\class QElapsedTimer<KAIGYO>    \\inmodule QtCore<KAIGYO>    \\brief The QElapsedTimer class provides a fast way to calculate elapsed times.<KAIGYO>    \\since 4.7<KAIGYO><KAIGYO>    \\reentrant<KAIGYO>    \\ingroup tools<KAIGYO><KAIGYO>    The QElapsedTimer class is usually used to quickly calculate how much<KAIGYO>    time has elapsed between two events. Its API is similar to that of QTime,<KAIGYO>    so code that was using that can be ported quickly to the new class.<KAIGYO><KAIGYO>    However, unlike QTime, QElapsedTimer tries to use monotonic clocks if<KAIGYO>    possible. This means it's not possible to convert QElapsedTimer objects<KAIGYO>    to a human-readable time.<KAIGYO><KAIGYO>    The typical use-case for the class is to determine how much time was<KAIGYO>    spent in a slow operation. The simplest example of such a case is for<KAIGYO>    debugging purposes, as in the following example:<KAIGYO><KAIGYO>    \\snippet qelapsedtimer/main.cpp 0<KAIGYO><KAIGYO>    In this example, the timer is started by a call to start() and the<KAIGYO>    elapsed timer is calculated by the elapsed() function.<KAIGYO><KAIGYO>    The time elapsed can also be used to recalculate the time available for<KAIGYO>    another operation, after the first one is complete. This is useful when<KAIGYO>    the execution must complete within a certain time period, but several<KAIGYO>    steps are needed. The \\tt{waitFor}-type functions in QIODevice and its<KAIGYO>    subclasses are good examples of such need. In that case, the code could<KAIGYO>    be as follows:<KAIGYO><KAIGYO>    \\snippet qelapsedtimer/main.cpp 1<KAIGYO><KAIGYO>    Another use-case is to execute a certain operation for a specific<KAIGYO>    timeslice. For this, QElapsedTimer provides the hasExpired() convenience<KAIGYO>    function, which can be used to determine if a certain number of<KAIGYO>    milliseconds has already elapsed:<KAIGYO><KAIGYO>    \\snippet qelapsedtimer/main.cpp 2<KAIGYO><KAIGYO>    \\section1 Reference Clocks<KAIGYO><KAIGYO>    QElapsedTimer will use the platform's monotonic reference clock in all<KAIGYO>    platforms that support it (see QElapsedTimer::isMonotonic()). This has<KAIGYO>    the added benefit that QElapsedTimer is immune to time adjustments, such<KAIGYO>    as the user correcting the time. Also unlike QTime, QElapsedTimer is<KAIGYO>    immune to changes in the timezone settings, such as daylight-saving<KAIGYO>    periods.<KAIGYO><KAIGYO>    On the other hand, this means QElapsedTimer values can only be compared<KAIGYO>    with other values that use the same reference. This is especially true if<KAIGYO>    the time since the reference is extracted from the QElapsedTimer object<KAIGYO>    (QElapsedTimer::msecsSinceReference()) and serialised. These values<KAIGYO>    should never be exchanged across the network or saved to disk, since<KAIGYO>    there's no telling whether the computer node receiving the data is the<KAIGYO>    same as the one originating it or if it has rebooted since.<KAIGYO><KAIGYO>    It is, however, possible to exchange the value with other processes<KAIGYO>    running on the same machine, provided that they also use the same<KAIGYO>    reference clock. QElapsedTimer will always use the same clock, so it's<KAIGYO>    safe to compare with the value coming from another process in the same<KAIGYO>    machine. If comparing to values produced by other APIs, you should check<KAIGYO>    that the clock used is the same as QElapsedTimer (see<KAIGYO>    QElapsedTimer::clockType()).<KAIGYO><KAIGYO>    \\section2 32-bit overflows<KAIGYO><KAIGYO>    Some of the clocks used by QElapsedTimer have a limited range and may<KAIGYO>    overflow after hitting the upper limit (usually 32-bit). QElapsedTimer<KAIGYO>    deals with this overflow issue and presents a consistent timing. However,<KAIGYO>    when extracting the time since reference from QElapsedTimer, two<KAIGYO>    different processes in the same machine may have different understanding<KAIGYO>    of how much time has actually elapsed.<KAIGYO><KAIGYO>    The information on which clocks types may overflow and how to remedy that<KAIGYO>    issue is documented along with the clock types.<KAIGYO><KAIGYO>    \\sa QTime, QTimer<KAIGYO>*/"": 2}",1.0,{}
37,168037.0,7.0,8.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/168037,add QQuickEventPoint::velocity property,1.0,{'// TODO if Q_LIKELY(velocity.isNull) calculate velocity': 1},1.0,{'// TODO calculate velocity': 1},1.0,{}
216,168208.0,29.0,59.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/168208,Refactor Http2::FrameReader/Http2::FrameWriter,1.0,"{'// Casts and ugliness - to deal with MSVC. Values are guaranteed to fit into quint32.': 2, ""// QNonContiguousByteDevice and this 'send' is probably"": 17}",1.0,"{""// QNonContiguousByteDevice and this 'writeDATA' is probably"": 17}",1.0,{}
102,168283.0,2.0,6.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/168283,Qt Designer: Adapt warning about mismatched class names,1.0,"{'// Perform literal comparison first for QAxWidget, for which a meta object hack is in effect.': 1}",1.0,"{'// Perform literal comparison first for QAxWidget, for which a meta object hack is in effect.': 1}",1.0,{}
151,168440.0,2.0,2.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/168440,qdnd.cpp: Extract Method imageMimeFormats,1.0,{},0.0,{'//put png at the front because it is best': 1},1.0,{}
195,168571.0,3.0,8.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/168571,V4: Use QLocale::IncludeTrailingZeroesAfterDot for number conversion,1.0,{},0.0,"{""// TODO: Once we get a NumberOption to retain trailing zeroes, replace the code below with:<KAIGYO>// QString result = NumberLocale::instance()->toString(v->asDouble(), 'g', precision);"": 2}",1.0,{}
309,168858.0,2.0,4.0,0.0,ABANDONED,False,https://codereview.qt-project.org/#/c/168858,Redo animator internals,1.0,"{""// This is a bit superfluous, but it ends up being simpler than the<KAIGYO>// alternative.  When an item happens to land on the same address as a<KAIGYO>// previous item, that helper might not have been fully cleaned up by<KAIGYO>// the time it gets taken back into use. As an alternative to storing<KAIGYO>// connections to each and every item's QObject::destroyed() and<KAIGYO>// having to clean those up afterwards, we simply sync all helpers on<KAIGYO>// the first run. The sync is only done once for the run of an<KAIGYO>// animation and it is a fairly light function (compared to storing<KAIGYO>// potentially thousands of connections and managing their lifetime."": 1}",1.0,"{'// If we have a controller, we might have posted the job to be started<KAIGYO>// so delete it through the controller to clean up properly.': 1}",1.0,{}
315,168910.0,3.0,10.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/168910,Remove tests/auto/other/atwrapper,1.0,{},0.0,"{'//Hack to remove a populated directory. (caveat: containing only files and empty dirs, not recursive!)': 1, '//FIXME: Switch to QStringList or something, hash is not needed!': 1}",1.0,{}
336,168949.0,6.0,27.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/168949,Redo animator internals,1.0,"{""// This is a bit superfluous, but it ends up being simpler than the<KAIGYO>// alternative.  When an item happens to land on the same address as a<KAIGYO>// previous item, that helper might not have been fully cleaned up by<KAIGYO>// the time it gets taken back into use. As an alternative to storing<KAIGYO>// connections to each and every item's QObject::destroyed() and<KAIGYO>// having to clean those up afterwards, we simply sync all helpers on<KAIGYO>// the first run. The sync is only done once for the run of an<KAIGYO>// animation and it is a fairly light function (compared to storing<KAIGYO>// potentially thousands of connections and managing their lifetime."": 1, '// Clear animation roots and iterate over a temporary to avoid that job->stop()<KAIGYO>// modifies the m_animationRoots and messes with our iteration': 3}",1.0,"{'// If we have a controller, we might have posted the job to be started<KAIGYO>// so delete it through the controller to clean up properly.': 1}",1.0,{}
97,169240.0,5.0,21.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/169240,xcb: Move handling of RRScreenChangeNotify from QXcbScreen to QXcbVirtualDesktop,1.0,"{'/*!<KAIGYO>    \\brief handle the XCB screen change event and update properties<KAIGYO><KAIGYO>    On a mobile device, the ideal use case is that the accelerometer would<KAIGYO>    drive the orientation. This could be achieved by using QSensors to read the<KAIGYO>    accelerometer and adjusting the rotation in QML, or by reading the<KAIGYO>    orientation from the QScreen object and doing the same, or in many other<KAIGYO>    ways. However, on X we have the XRandR extension, which makes it possible<KAIGYO>    to have the whole screen rotated, so that individual apps DO NOT have to<KAIGYO>    rotate themselves. Apps could optionally use the<KAIGYO>    QScreen::primaryOrientation property to optimize layout though.<KAIGYO>    Furthermore, there is no support in X for accelerometer events anyway. So<KAIGYO>    it makes more sense on a Linux system running X to just run a daemon which<KAIGYO>    monitors the accelerometer and runs xrandr automatically to do the rotation,<KAIGYO>    then apps do not have to be aware of it (but probably the window manager<KAIGYO>    would resize them accordingly). updateGeometry() is written with this<KAIGYO>    design in mind. Therefore the physical geometry, available geometry,<KAIGYO>    virtual geometry, orientation and primaryOrientation should all change at<KAIGYO>    the same time.  On a system which cannot rotate the whole screen, it would<KAIGYO>    be correct for only the orientation (not the primary orientation) to<KAIGYO>    change.<KAIGYO>*/': 3}",1.0,"{'/*!<KAIGYO>    \\brief handle the XCB screen change event and update properties<KAIGYO><KAIGYO>    On a mobile device, the ideal use case is that the accelerometer would<KAIGYO>    drive the orientation. This could be achieved by using QSensors to read the<KAIGYO>    accelerometer and adjusting the rotation in QML, or by reading the<KAIGYO>    orientation from the QScreen object and doing the same, or in many other<KAIGYO>    ways. However, on X we have the XRandR extension, which makes it possible<KAIGYO>    to have the whole screen rotated, so that individual apps DO NOT have to<KAIGYO>    rotate themselves. Apps could optionally use the<KAIGYO>    QScreen::primaryOrientation property to optimize layout though.<KAIGYO>    Furthermore, there is no support in X for accelerometer events anyway. So<KAIGYO>    it makes more sense on a Linux system running X to just run a daemon which<KAIGYO>    monitors the accelerometer and runs xrandr automatically to do the rotation,<KAIGYO>    then apps do not have to be aware of it (but probably the window manager<KAIGYO>    would resize them accordingly). updateGeometry() is written with this<KAIGYO>    design in mind. Therefore the physical geometry, available geometry,<KAIGYO>    virtual geometry, orientation and primaryOrientation should all change at<KAIGYO>    the same time.  On a system which cannot rotate the whole screen, it would<KAIGYO>    be correct for only the orientation (not the primary orientation) to<KAIGYO>    change.<KAIGYO>*/': 3}",1.0,{}
137,169414.0,4.0,6.0,0.0,ABANDONED,False,https://codereview.qt-project.org/#/c/169414,TapHandler: use QVector2D::lengthSquared instead of manhattanLength,1.0,{'// TODO put that in theme hints or style hints': 1},1.0,{'// TODO put that in theme hints or style hints': 1},1.0,{}
228,169808.0,2.0,2.0,0.0,ABANDONED,False,https://codereview.qt-project.org/#/c/169808,example hacks for Contributors' Summit,1.0,{'// TODO event.button?': 1},1.0,"{""// TODO this switch doesn't work"": 1}",1.0,{}
263,169888.0,3.0,3.0,0.0,ABANDONED,False,https://codereview.qt-project.org/#/c/169888,WIP QQuickWindow: avoid re-delivering pointer events to grabbers,1.0,{},0.0,{'// TODO avoid re-delivering to grabbers': 1},1.0,{}
163,170676.0,6.0,7.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/170676,QML: Make Heap::RegExp and Heap::String trivial,1.0,{},0.0,{'// TODO: remove the dummy bool when String is trivial': 1},1.0,{}
119,171312.0,4.0,11.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/171312,Merge remote-tracking branch 'origin/5.6' into 5.7,1.0,{},0.0,"{'        /* This block is a bit hacky, but if we want to support using width/height<KAIGYO>           as preferred size hints in layouts, (which we think most people expect),<KAIGYO>           we only want to use the initial width.<KAIGYO>           This is because the width will change due to layout rearrangement, and the preferred<KAIGYO>           width should return the same value, regardless of the current width.<KAIGYO>           We therefore store the width in the implicitWidth attached property.<KAIGYO>           Since the layout listens to changes of implicitWidth, (it will<KAIGYO>           basically cause an invalidation of the layout), we have to disable that<KAIGYO>           notification while we set the implicit width (and height).<KAIGYO><KAIGYO>           Only use this fallback the first time the size hint is queried. Otherwise, we might<KAIGYO>           end up picking a width that is different than what was specified in the QML.<KAIGYO>        */': 1}",1.0,{}
225,171353.0,9.0,44.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/171353,Merge remote-tracking branch 'origin/5.7' into 5.8,1.0,{},0.0,"{""    /* This is a hack to get MySQL's stored procedure support working.<KAIGYO>       Since a stored procedure _may_ return multiple result sets,<KAIGYO>       we have to enable CLIEN_MULTI_STATEMENTS here, otherwise _any_<KAIGYO>       stored procedure call will fail.<KAIGYO>    */"": 1}",1.0,{}
178,171647.0,1.0,1.0,0.0,ABANDONED,False,https://codereview.qt-project.org/#/c/171647,Merge remote-tracking branch 'origin/5.7' into 5.8,1.0,{},0.0,"{""    /* This is a hack to get MySQL's stored procedure support working.<KAIGYO>       Since a stored procedure _may_ return multiple result sets,<KAIGYO>       we have to enable CLIEN_MULTI_STATEMENTS here, otherwise _any_<KAIGYO>       stored procedure call will fail.<KAIGYO>    */"": 1}",1.0,{}
53,172002.0,3.0,4.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/172002,Crash on shape-outside when using calc(),1.0,"{'// FIXME: (httpwebkit.org/b/122036) Create a CSSCalcExpressionNode equivalent of CalcExpressionBlendLength.': 1, '// FIXME: calc (httpwebkit.org/b/16662) Add parsing for min and max here': 1, '// FIXME: We have a bug right now where the zoom will be applied twice to EX units.<KAIGYO>// We really need to compute EX using fontMetrics for the original specifiedSize and not use<KAIGYO>// our actual constructed rendering font.': 1}",1.0,"{'// FIXME calc (httpwebkit.org/b/16662) Add parsing for min and max here': 1, '// FIXME: We have a bug right now where the zoom will be applied twice to EX units.<KAIGYO>// We really need to compute EX using fontMetrics for the original specifiedSize and not use<KAIGYO>// our actual constructed rendering font.': 1}",1.0,{}
79,172289.0,2.0,4.0,0.0,ABANDONED,False,https://codereview.qt-project.org/#/c/172289,"WIP: Revert ""Pass pointerEvent into QQuickWindowPrivate::deliverTouchAsMouse""",1.0,"{'// FIXME: this is a bit backwards, should just have the pointer event passed into the function': 1}",1.0,{'// FIXME: make this work for mouse events too and get rid of the asTouchEvent in here.': 1},1.0,{}
135,172354.0,5.0,14.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/172354,Cleanup memrotate functions,1.0,{},0.0,{'// TODO: packing algorithms should probably be modified on 64-bit architectures': 1},1.0,{}
106,172415.0,1.0,3.0,0.0,ABANDONED,False,https://codereview.qt-project.org/#/c/172415,QWindowSystemInterface: fix racy handleShortcutEvent workaround,1.0,{},0.0,{'// FIXME: Template handleWindowSystemEvent to support both sync and async delivery': 1},1.0,{}
182,173473.0,2.0,7.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/173473,Merge remote-tracking branch 'origin/5.7' into 5.8,1.0,{},0.0,"{""// Hack for indicator-application, which doesn't handle icons sent across D-Bus:<KAIGYO>// save the icon to a temp file and set the icon name to that filename."": 1, '// TODO connect(m_menu, , m_menuAdaptor, SIGNAL(ItemActivationRequested(int,uint)));': 1}",1.0,{}
159,173488.0,2.0,2.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/173488,"Revert ""Combine device and point id into 32 bit point id""",1.0,{},0.0,"{'/*!<KAIGYO>    This function maps potentially arbitrary point ids \\a pointId in the 32 bit<KAIGYO>    value space to start from 1 and increase incrementally for each touch point<KAIGYO>    held down. If all touch points are released it will reset the id back to 1<KAIGYO>    for the following touch point.<KAIGYO><KAIGYO>    We can then assume that the touch points ids will never become too large,<KAIGYO>    and it will then put the device identifier \\a deviceId in the upper 8 bits.<KAIGYO>    This leaves us with max 255 devices, and 16.7M taps without full release<KAIGYO>    before we run out of value space.<KAIGYO>*/': 1, '// moving the point should translate to TouchUpdate': 1}",1.0,{}
217,173784.0,1.0,1.0,0.0,ABANDONED,False,https://codereview.qt-project.org/#/c/173784,WIP - HTTP/2 - PUSH_PROMISE,1.0,"{'// Check what was promised/pushed, maybe, we do not have to send a request<KAIGYO>// and have a response already?': 1, '// TODO: the part with assignment is not especially cool<KAIGYO>// or beautiful, good that at least QByteArray is implicitly<KAIGYO>// sharing data. To be refactored (std::move).': 1, '// TODO: refactor this to use std::move.': 1, '// TODO: error message must be translated!!! (tr)': 1, ""// TODO: we can also test ':method', it must be 'GET' ?"": 1, '// TODO: let our server know WHAT to promise :)': 1, ""// TODO: make the second request and make sure it's already here<KAIGYO>// (PUSH_PROMISEd from/by server)."": 1}",1.0,{'// TODO: error message must be translated!!! (tr)': 1},1.0,{}
12,174045.0,2.0,5.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/174045,Merge remote-tracking branch 'origin/5.6' into 5.7,1.0,{},0.0,"{""/*! \\macro QCOMPARE(actual, expected)<KAIGYO><KAIGYO>   \\relates QTest<KAIGYO><KAIGYO>   The QCOMPARE macro compares an \\a actual value to an \\a expected value using<KAIGYO>   the equals operator. If \\a actual and \\a expected are identical, execution<KAIGYO>   continues. If not, a failure is recorded in the test log and the test<KAIGYO>   won't be executed further.<KAIGYO><KAIGYO>   In the case of comparing floats and doubles, qFuzzyCompare() is used for<KAIGYO>   comparing. This means that comparing to 0 will likely fail. One solution<KAIGYO>   to this is to compare to 1, and add 1 to the produced output.<KAIGYO><KAIGYO>   QCOMPARE tries to output the contents of the values if the comparison fails,<KAIGYO>   so it is visible from the test log why the comparison failed.<KAIGYO><KAIGYO>   QCOMPARE is very strict on the data types. Both \\a actual and \\a expected<KAIGYO>   have to be of the same type, otherwise the test won't compile. This prohibits<KAIGYO>   unspecified behavior from being introduced; that is behavior that usually<KAIGYO>   occurs when the compiler implicitly casts the argument.<KAIGYO><KAIGYO>   For your own classes, you can use \\l QTest::toString() to format values for<KAIGYO>   outputting into the test log.<KAIGYO><KAIGYO>   \\note This macro can only be used in a test function that is invoked<KAIGYO>   by the test framework.<KAIGYO><KAIGYO>   Example:<KAIGYO>   \\snippet code/src_qtestlib_qtestcase.cpp 2<KAIGYO><KAIGYO>   \\sa QVERIFY(), QTRY_COMPARE(), QTest::toString()<KAIGYO>*/"": 1, ""/*! \\macro QTEST_APPLESS_MAIN(TestClass)<KAIGYO><KAIGYO>    \\relates QTest<KAIGYO><KAIGYO>    Implements a main() function that executes all tests in \\a TestClass.<KAIGYO><KAIGYO>    Behaves like \\l QTEST_MAIN(), but doesn't instantiate a QApplication<KAIGYO>    object. Use this macro for really simple stand-alone non-GUI tests.<KAIGYO><KAIGYO>    \\sa QTEST_MAIN()<KAIGYO>*/"": 1, '/*!<KAIGYO>    \\fn QTouchEventSequence &QTest::QTouchEventSequence::move(int touchId, const QPoint &pt, QWindow *window)<KAIGYO>    \\since 5.0<KAIGYO><KAIGYO>    Adds a move event for touchpoint \\a touchId at position \\a pt to this sequence and returns<KAIGYO>    a reference to this QTouchEventSequence.<KAIGYO><KAIGYO>    The position \\a pt is interpreted as relative to \\a window. If \\a window is the null pointer, then<KAIGYO>    \\a pt is interpreted as relative to the window provided when instantiating this QTouchEventSequence.<KAIGYO><KAIGYO>    Simulates that the user moved the finger identified by \\a touchId.<KAIGYO>*/': 1}",1.0,{}
38,174070.0,3.0,12.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/174070,"Revert ""Redo animator internals""",1.0,"{'// If we have a controller, we might have posted the job to be started<KAIGYO>// so delete it through the controller to clean up properly.': 1}",1.0,"{'// Clear animation roots and iterate over a temporary to avoid that job->stop()<KAIGYO>// modifies the m_animationRoots and messes with our iteration': 1, ""// This is a bit superfluous, but it ends up being simpler than the<KAIGYO>// alternative.  When an item happens to land on the same address as a<KAIGYO>// previous item, that helper might not have been fully cleaned up by<KAIGYO>// the time it gets taken back into use. As an alternative to storing<KAIGYO>// connections to each and every item's QObject::destroyed() and<KAIGYO>// having to clean those up afterwards, we simply sync all helpers on<KAIGYO>// the first run. The sync is only done once for the run of an<KAIGYO>// animation and it is a fairly light function (compared to storing<KAIGYO>// potentially thousands of connections and managing their lifetime."": 1}",1.0,{}
67,174121.0,6.0,14.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/174121,Fixed some problems with the centroid in PinchHandler,1.0,{'// TODO some translation inadvertently happens; try to hold the chosen pinch origin in place': 3},1.0,{'// TODO some translation inadvertently happens; try to hold the chosen pinch origin in place': 3},1.0,{}
87,174269.0,4.0,5.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/174269,"Revert ""Revert ""Redo animator internals""""",1.0,"{'// Clear animation roots and iterate over a temporary to avoid that job->stop()<KAIGYO>// modifies the m_animationRoots and messes with our iteration': 1, ""// This is a bit superfluous, but it ends up being simpler than the<KAIGYO>// alternative.  When an item happens to land on the same address as a<KAIGYO>// previous item, that helper might not have been fully cleaned up by<KAIGYO>// the time it gets taken back into use. As an alternative to storing<KAIGYO>// connections to each and every item's QObject::destroyed() and<KAIGYO>// having to clean those up afterwards, we simply sync all helpers on<KAIGYO>// the first run. The sync is only done once for the run of an<KAIGYO>// animation and it is a fairly light function (compared to storing<KAIGYO>// potentially thousands of connections and managing their lifetime."": 1}",1.0,"{'// If we have a controller, we might have posted the job to be started<KAIGYO>// so delete it through the controller to clean up properly.': 1}",1.0,{}
232,174425.0,43.0,52.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/174425,TapHandler: add gesturePolicy,1.0,"{'// TODO rename using positive nomenclature: e.g. TapGestureRequirement, GestureDetectionMethod, GesturePolicy or something like that:<KAIGYO>// the condition under which a tap gesture IS recognized': 1}",1.0,"{'// TODO put that in theme hints or style hints': 4, '// TODO different?': 6}",1.0,{}
182,175721.0,3.0,9.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/175721,QPA: Group functions in qwindowsysteminterface.cpp by area of responsibility,1.0,{'/*!<KAIGYO>    Make Qt Gui process all events on the event queue immediately. Return the<KAIGYO>    accepted state for the last event on the queue.<KAIGYO>*/': 1},1.0,{'/*!<KAIGYO>    Make Qt Gui process all events on the event queue immediately. Return the<KAIGYO>    accepted state for the last event on the queue.<KAIGYO>*/': 1},1.0,{}
43,176119.0,9.0,47.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/176119,Rework qAppFileName() on MS-Win to handle problems gracefully,1.0,{},0.0,"{""// We do MAX_PATH + 2 here, and request with MAX_PATH + 1, so we can handle all paths<KAIGYO>// up to, and including MAX_PATH size perfectly fine with string termination, as well<KAIGYO>// as easily detect if the file path is indeed larger than MAX_PATH, in which case we<KAIGYO>// need to use the heap instead. This is a work-around, since contrary to what the<KAIGYO>// MSDN documentation states, GetModuleFileName sometimes doesn't set the<KAIGYO>// ERROR_INSUFFICIENT_BUFFER error number, and we thus cannot rely on this value if<KAIGYO>// GetModuleFileName(0, buffer, MAX_PATH) == MAX_PATH.<KAIGYO>// GetModuleFileName(0, buffer, MAX_PATH + 1) == MAX_PATH just means we hit the normal<KAIGYO>// file path limit, and we handle it normally, if the result is MAX_PATH + 1, we use<KAIGYO>// heap (even if the result _might_ be exactly MAX_PATH + 1, but that's ok)."": 1}",1.0,{}
9,176139.0,4.0,4.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/176139,LE device scan - use advertisement data (iOS/macOS),1.0,{'// TODO: other keys probably?': 1},1.0,"{""// TODO: my understanding of the same peripheral reported many times seems<KAIGYO>// to be outdated or even wrong - nowadays it's reported twice and the<KAIGYO>// second time (AFAIK) more info can be extracted ..."": 1}",1.0,{}
69,176321.0,3.0,15.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/176321,Remove wondrous VS version detection logic,1.0,{},0.0,{'// Only search for the version once': 1},1.0,{}
16,177110.0,1.0,1.0,0.0,ABANDONED,False,https://codereview.qt-project.org/#/c/177110,TapHandler: obey QPlatformTheme::TouchDoubleTapDistance,1.0,{},0.0,{'// TODO put that in theme hints or style hints': 1},1.0,{}
22,177118.0,4.0,6.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/177118,Remove QQuickMultiPointerHandler::startingCentroid,1.0,{},0.0,{'// TODO cache it in setActive()?': 1},1.0,{}
90,177293.0,6.0,24.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/177293,... and so configureapp.exe disappeareth,1.0,{},0.0,{'// add the prgram as the first arrg ... it works better': 1},1.0,{}
96,177378.0,3.0,19.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/177378,QQuickItemView: always honor the removeDisplaced animation,1.0,{},0.0,{'// longer-lasting bounce to trigger bug': 2},1.0,{}
131,177433.0,3.0,4.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/177433,Move rebuildGeometry() functions of nodes,1.0,{'// Maybe transform the texture coordinates': 1},1.0,{'// Maybe transform the texture coordinates': 1},1.0,{}
149,177540.0,1.0,1.0,0.0,ABANDONED,False,https://codereview.qt-project.org/#/c/177540,TapHandler: add gesturePolicy,1.0,{},0.0,"{'// TODO put that in theme hints or style hints': 1, '// TODO different?': 1}",1.0,{}
158,177549.0,2.0,2.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/177549,Fix support for QML declared default list properties,1.0,{'// ### TODO: AST for initializer': 1},1.0,{'// ### TODO: AST for initializer': 1},1.0,{}
177,177598.0,3.0,14.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/177598,Fix support for namespaced types in property/signal declarations,1.0,{'// ### TODO: AST for initializer': 1},1.0,{'// ### TODO: AST for initializer': 1},1.0,{}
280,177953.0,3.0,14.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/177953,Merge remote-tracking branch 'origin/5.7' into 5.8,1.0,{},0.0,"{""    /* This is a hack to get MySQL's stored procedure support working.<KAIGYO>       Since a stored procedure _may_ return multiple result sets,<KAIGYO>       we have to enable CLIEN_MULTI_STATEMENTS here, otherwise _any_<KAIGYO>       stored procedure call will fail.<KAIGYO>    */"": 1}",1.0,{}
53,179053.0,1.0,4.0,0.0,ABANDONED,False,https://codereview.qt-project.org/#/c/179053,***Bump minimum Windows SDK version to Windows 7,1.0,{'// ### fixme: Consider direct linking of dwrite.dll (QTBUG-49711)': 1},1.0,{'// ### fixme: Consider direct linking of dwrite.dll once Windows Vista pre SP2 is dropped (QTBUG-49711)': 1},1.0,{}
61,179234.0,3.0,4.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/179234,OpenVG: Fix Recursive Layers,1.0,{},0.0,{'// XXX': 2},1.0,{}
205,179553.0,8.0,30.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/179553,Merge remote-tracking branch 'origin/5.8' into dev,1.0,{},0.0,"{'// Encapsulate Breakpoint handling<KAIGYO>// Could be made per-NativeDebugger (i.e. per execution engine, if needed)': 2, '// TODO: pause debugger': 2, '// TODO: complete this!': 2}",1.0,{}
243,179917.0,11.0,73.0,0.0,ABANDONED,False,https://codereview.qt-project.org/#/c/179917,Replace Qt's hashing function with SipHash,1.0,"{'// the seed is always 0 in bootstrapped mode (no seed generation code),<KAIGYO>// so help the compiler do dead code elimination': 7}",1.0,"{'// The 64-bit instruction still calculates only 32-bit, but without this<KAIGYO>// variable GCC 4.9 still tries to clear the high bits on every loop': 1}",1.0,{}
227,179918.0,2.0,4.0,0.0,ABANDONED,False,https://codereview.qt-project.org/#/c/179918,Replace Qt's hashing function with SipHash,1.0,{},0.0,"{'// The 64-bit instruction still calculates only 32-bit, but without this<KAIGYO>// variable GCC 4.9 still tries to clear the high bits on every loop': 1}",1.0,{}
38,180233.0,5.0,31.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/180233,"Revert ""QUrl::resolved: keep treating file:name.txt as relative for now""",1.0,{},0.0,"{'// Compatibility hack (mostly for qtdeclarative) : treat """" as relative even though QUrl::isRelative() says false': 1}",1.0,{}
38,181195.0,1.0,1.0,0.0,ABANDONED,False,https://codereview.qt-project.org/#/c/181195,Fixup Block Alloc,1.0,{'// ### handle huge chunks properly': 1},1.0,{'// ### handle huge chunks properly': 1},1.0,{}
42,181200.0,5.0,8.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/181200,Setup characteristic permissions for Android peripheral,1.0,{},0.0,{'// TODO set all characteristic properties': 1},1.0,{}
43,181201.0,5.0,10.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/181201,Setup descriptor permissions for Android peripheral,1.0,{},0.0,"{'//TODO add chars and their descriptors': 4, '// TODO set all descriptors': 4}",1.0,{}
66,181214.0,5.0,15.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/181214,Widgets: report focus object change to QtGui before sending widget events,1.0,{},0.0,"{""// Since focus_child is the basis for the top level QWidgetWindow's focusObject()<KAIGYO>// we need to report this change to the rest of Qt, but we match setFocus() and<KAIGYO>// do it at the end of the function."": 1}",1.0,{}
167,181245.0,3.0,6.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/181245,update bundled sqlite to 3.16.1,1.0,"{'/* Special Comments:<KAIGYO>**<KAIGYO>** Some comments have special meaning to the tools that measure test<KAIGYO>** coverage:<KAIGYO>**<KAIGYO>**    NO_TEST                     - The branches on this line are not<KAIGYO>**                                  measured by branch coverage.  This is<KAIGYO>**                                  used on lines of code that actually<KAIGYO>**                                  implement parts of coverage testing.<KAIGYO>**<KAIGYO>**    OPTIMIZATION-IF-TRUE        - This branch is allowed to alway be false<KAIGYO>**                                  and the correct answer is still obtained,<KAIGYO>**                                  though perhaps more slowly.<KAIGYO>**<KAIGYO>**    OPTIMIZATION-IF-FALSE       - This branch is allowed to alway be true<KAIGYO>**                                  and the correct answer is still obtained,<KAIGYO>**                                  though perhaps more slowly.<KAIGYO>**<KAIGYO>**    PREVENTS-HARMLESS-OVERREAD  - This branch prevents a buffer overread<KAIGYO>**                                  that would be harmless and undetectable<KAIGYO>**                                  if it did occur.  <KAIGYO>**<KAIGYO>** In all cases, the special comment must be enclosed in the usual<KAIGYO>** slash-asterisk...asterisk-slash comment marks, with no spaces between the <KAIGYO>** asterisks and the comment text.<KAIGYO>*/': 1, '/*<KAIGYO>** CAPI3REF: SQL Trace Hook<KAIGYO>** METHOD: sqlite3<KAIGYO>**<KAIGYO>** ^The sqlite3_trace_v2(D,M,X,P) interface registers a trace callback<KAIGYO>** function X against [database connection] D, using property mask M<KAIGYO>** and context pointer P.  ^If the X callback is<KAIGYO>** NULL or if the M mask is zero, then tracing is disabled.  The<KAIGYO>** M argument should be the bitwise OR-ed combination of<KAIGYO>** zero or more [SQLITE_TRACE] constants.<KAIGYO>**<KAIGYO>** ^Each call to either sqlite3_trace() or sqlite3_trace_v2() overrides <KAIGYO>** (cancels) any prior calls to sqlite3_trace() or sqlite3_trace_v2().<KAIGYO>**<KAIGYO>** ^The X callback is invoked whenever any of the events identified by <KAIGYO>** mask M occur.  ^The integer return value from the callback is currently<KAIGYO>** ignored, though this may change in future releases.  Callback<KAIGYO>** implementations should return zero to ensure future compatibility.<KAIGYO>**<KAIGYO>** ^A trace callback is invoked with four arguments: callback(T,C,P,X).<KAIGYO>** ^The T argument is one of the [SQLITE_TRACE]<KAIGYO>** constants to indicate why the callback was invoked.<KAIGYO>** ^The C argument is a copy of the context pointer.<KAIGYO>** The P and X arguments are pointers whose meanings depend on T.<KAIGYO>**<KAIGYO>** The sqlite3_trace_v2() interface is intended to replace the legacy<KAIGYO>** interfaces [sqlite3_trace()] and [sqlite3_profile()], both of which<KAIGYO>** are deprecated.<KAIGYO>*/': 1, '/*<KAIGYO>** CAPI3REF: Generate A Changeset From A Session Object<KAIGYO>**<KAIGYO>** Obtain a changeset containing changes to the tables attached to the <KAIGYO>** session object passed as the first argument. If successful, <KAIGYO>** set *ppChangeset to point to a buffer containing the changeset <KAIGYO>** and *pnChangeset to the size of the changeset in bytes before returning<KAIGYO>** SQLITE_OK. If an error occurs, set both *ppChangeset and *pnChangeset to<KAIGYO>** zero and return an SQLite error code.<KAIGYO>**<KAIGYO>** A changeset consists of zero or more INSERT, UPDATE and/or DELETE changes,<KAIGYO>** each representing a change to a single row of an attached table. An INSERT<KAIGYO>** change contains the values of each field of a new database row. A DELETE<KAIGYO>** contains the original values of each field of a deleted database row. An<KAIGYO>** UPDATE change contains the original values of each field of an updated<KAIGYO>** database row along with the updated values for each updated non-primary-key<KAIGYO>** column. It is not possible for an UPDATE change to represent a change that<KAIGYO>** modifies the values of primary key columns. If such a change is made, it<KAIGYO>** is represented in a changeset as a DELETE followed by an INSERT.<KAIGYO>**<KAIGYO>** Changes are not recorded for rows that have NULL values stored in one or <KAIGYO>** more of their PRIMARY KEY columns. If such a row is inserted or deleted,<KAIGYO>** no corresponding change is present in the changesets returned by this<KAIGYO>** function. If an existing row with one or more NULL values stored in<KAIGYO>** PRIMARY KEY columns is updated so that all PRIMARY KEY columns are non-NULL,<KAIGYO>** only an INSERT is appears in the changeset. Similarly, if an existing row<KAIGYO>** with non-NULL PRIMARY KEY values is updated so that one or more of its<KAIGYO>** PRIMARY KEY columns are set to NULL, the resulting changeset contains a<KAIGYO>** DELETE change only.<KAIGYO>**<KAIGYO>** The contents of a changeset may be traversed using an iterator created<KAIGYO>** using the [sqlite3changeset_start()] API. A changeset may be applied to<KAIGYO>** a database with a compatible schema using the [sqlite3changeset_apply()]<KAIGYO>** API.<KAIGYO>**<KAIGYO>** Within a changeset generated by this function, all changes related to a<KAIGYO>** single table are grouped together. In other words, when iterating through<KAIGYO>** a changeset or when applying a changeset to a database, all changes related<KAIGYO>** to a single table are processed before moving on to the next table. Tables<KAIGYO>** are sorted in the same order in which they were attached (or auto-attached)<KAIGYO>** to the sqlite3_session object. The order in which the changes related to<KAIGYO>** a single table are stored is undefined.<KAIGYO>**<KAIGYO>** Following a successful call to this function, it is the responsibility of<KAIGYO>** the caller to eventually free the buffer that *ppChangeset points to using<KAIGYO>** [sqlite3_free()].<KAIGYO>**<KAIGYO>** <h3>Changeset Generation</h3><KAIGYO>**<KAIGYO>** Once a table has been attached to a session object, the session object<KAIGYO>** records the primary key values of all new rows inserted into the table.<KAIGYO>** It also records the original primary key and other column values of any<KAIGYO>** deleted or updated rows. For each unique primary key value, data is only<KAIGYO>** recorded once - the first time a row with said primary key is inserted,<KAIGYO>** updated or deleted in the lifetime of the session.<KAIGYO>**<KAIGYO>** There is one exception to the previous paragraph: when a row is inserted,<KAIGYO>** updated or deleted, if one or more of its primary key columns contain a<KAIGYO>** NULL value, no record of the change is made.<KAIGYO>**<KAIGYO>** The session object therefore accumulates two types of records - those<KAIGYO>** that consist of primary key values only (created when the user inserts<KAIGYO>** a new record) and those that consist of the primary key values and the<KAIGYO>** original values of other table columns (created when the users deletes<KAIGYO>** or updates a record).<KAIGYO>**<KAIGYO>** When this function is called, the requested changeset is created using<KAIGYO>** both the accumulated records and the current contents of the database<KAIGYO>** file. Specifically:<KAIGYO>**<KAIGYO>** <ul><KAIGYO>**   <li> For each record generated by an insert, the database is queried<KAIGYO>**        for a row with a matching primary key. If one is found, an INSERT<KAIGYO>**        change is added to the changeset. If no such row is found, no change <KAIGYO>**        is added to the changeset.<KAIGYO>**<KAIGYO>**   <li> For each record generated by an update or delete, the database is <KAIGYO>**        queried for a row with a matching primary key. If such a row is<KAIGYO>**        found and one or more of the non-primary key fields have been<KAIGYO>**        modified from their original values, an UPDATE change is added to <KAIGYO>**        the changeset. Or, if no such row is found in the table, a DELETE <KAIGYO>**        change is added to the changeset. If there is a row with a matching<KAIGYO>**        primary key in the database, but all fields contain their original<KAIGYO>**        values, no change is added to the changeset.<KAIGYO>** </ul><KAIGYO>**<KAIGYO>** This means, amongst other things, that if a row is inserted and then later<KAIGYO>** deleted while a session object is active, neither the insert nor the delete<KAIGYO>** will be present in the changeset. Or if a row is deleted and then later a <KAIGYO>** row with the same primary key values inserted while a session object is<KAIGYO>** active, the resulting changeset will contain an UPDATE change instead of<KAIGYO>** a DELETE and an INSERT.<KAIGYO>**<KAIGYO>** When a session object is disabled (see the [sqlite3session_enable()] API),<KAIGYO>** it does not accumulate records when rows are inserted, updated or deleted.<KAIGYO>** This may appear to have some counter-intuitive effects if a single row<KAIGYO>** is written to more than once during a session. For example, if a row<KAIGYO>** is inserted while a session object is enabled, then later deleted while <KAIGYO>** the same session object is disabled, no INSERT record will appear in the<KAIGYO>** changeset, even though the delete took place while the session was disabled.<KAIGYO>** Or, if one field of a row is updated while a session is disabled, and <KAIGYO>** another field of the same row is updated while the session is enabled, the<KAIGYO>** resulting changeset will contain an UPDATE change that updates both fields.<KAIGYO>*/': 1, '/*<KAIGYO>** CAPI3REF: Invert A Changeset<KAIGYO>**<KAIGYO>** This function is used to """" a changeset object. Applying an inverted<KAIGYO>** changeset to a database reverses the effects of applying the uninverted<KAIGYO>** changeset. Specifically:<KAIGYO>**<KAIGYO>** <ul><KAIGYO>**   <li> Each DELETE change is changed to an INSERT, and<KAIGYO>**   <li> Each INSERT change is changed to a DELETE, and<KAIGYO>**   <li> For each UPDATE change, the old.* and new.* values are exchanged.<KAIGYO>** </ul><KAIGYO>**<KAIGYO>** This function does not change the order in which changes appear within<KAIGYO>** the changeset. It merely reverses the sense of each individual change.<KAIGYO>**<KAIGYO>** If successful, a pointer to a buffer containing the inverted changeset<KAIGYO>** is stored in *ppOut, the size of the same buffer is stored in *pnOut, and<KAIGYO>** SQLITE_OK is returned. If an error occurs, both *pnOut and *ppOut are<KAIGYO>** zeroed and an SQLite error code returned.<KAIGYO>**<KAIGYO>** It is the responsibility of the caller to eventually call sqlite3_free()<KAIGYO>** on the *ppOut pointer to free the buffer allocation following a successful <KAIGYO>** call to this function.<KAIGYO>**<KAIGYO>** WARNING/TODO: This function currently assumes that the input is a valid<KAIGYO>** changeset. If it is not, the results are undefined.<KAIGYO>*/': 1, '#define P4_INT64    (-10) /* P4 is a 64-bit signed integer */<KAIGYO>#define P4_INT32    (-11) /* P4 is a 32-bit signed integer */': 1, '#define OP_IdxDelete     126 /* synopsis: key=r[P2@P3]                     */<KAIGYO>#define OP_Seek          127 /* synopsis: Move P3 to P1.rowid              */': 1, '#define WHERE_GROUPBY          0x0040 /* pOrderBy is really a GROUP BY */<KAIGYO>#define WHERE_DISTINCTBY       0x0080 /* pOrderby is really a DISTINCT clause */': 1, ""  /* These verifications occurs for the main database only */<KAIGYO>  if( pFile->ctrlFlags & UNIXFILE_NOLOCK ) return;<KAIGYO><KAIGYO>  if( buf.st_nlink==0 ){<KAIGYO>  ** slightly in order to be compatible with Windows95 systems simultaneously<KAIGYO>  ** byte'.  If this is successful, 'shared byte range' is read-locked<KAIGYO>  ** and the lock on the 'pending byte' released.  (Legacy note:  When<KAIGYO>  ** SQLite was first developed, Windows95 systems were still very common,<KAIGYO>  ** and Widnows95 lacks a shared-lock capability.  So on Windows95, a<KAIGYO>  ** single randomly selected by from the 'shared byte range' is locked.<KAIGYO>  ** Windows95 is now pretty much extinct, but this work-around for the<KAIGYO>  ** lack of shared-locks on Windows95 lives on, for backwards<KAIGYO>  ** compatibility.)<KAIGYO>  if( p==0 ) return SQLITE_NOMEM_BKPT;<KAIGYO>      rc = SQLITE_NOMEM_BKPT;<KAIGYO>    if( sqlite3GlobalConfig.bCoreMutex ){<KAIGYO>      pShmNode->mutex = sqlite3_mutex_alloc(SQLITE_MUTEX_FAST);<KAIGYO>      if( pShmNode->mutex==0 ){<KAIGYO>        rc = SQLITE_NOMEM_BKPT;<KAIGYO>        goto shm_open_err;<KAIGYO>      }<KAIGYO>    }<KAIGYO>      rc = SQLITE_IOERR_NOMEM_BKPT;<KAIGYO>          rc = SQLITE_NOMEM_BKPT;<KAIGYO>    rc = SQLITE_NOMEM_BKPT;<KAIGYO>      rc = SQLITE_NOMEM_BKPT;<KAIGYO>      rc = SQLITE_NOMEM_BKPT;<KAIGYO>        rc = SQLITE_NOMEM_BKPT;<KAIGYO>  unsigned int i = 0;<KAIGYO>  while(1){<KAIGYO>    if( zDir!=0<KAIGYO>     && osStat(zDir, &buf)==0<KAIGYO>     && S_ISDIR(buf.st_mode)<KAIGYO>     && osAccess(zDir, 03)==0<KAIGYO>    ){<KAIGYO>      return zDir;<KAIGYO>    }<KAIGYO>    if( i>=sizeof(azDirs)/sizeof(azDirs[0]) ) break;<KAIGYO>    zDir = azDirs[i++];<KAIGYO>  }<KAIGYO>  return 0;<KAIGYO>  zBuf[0] = 0;<KAIGYO>  if( zDir==0 ) return SQLITE_IOERR_GETTEMPPATH;<KAIGYO>                     || pInode->fileId.ino!=(u64)sStat.st_ino) ){<KAIGYO>** Find the mode, uid and gid of file zFile. <KAIGYO>*/"": 1, '/*<KAIGYO>  assert( sqlite3PcachePageSanity(p) );<KAIGYO>  pcacheTrace(("""",pCache,p->pgno,newPgno));<KAIGYO>    pcacheTrace(("""",pCache,pgno));<KAIGYO>      if( p->pgno>pgno ){<KAIGYO>  pcacheTrace(("""",pCache));<KAIGYO>** Do not bother fixing the pDirtyPrev pointers.<KAIGYO>  assert( pA!=0 && pB!=0 );<KAIGYO>  for(;;){<KAIGYO>      if( pA==0 ){<KAIGYO>        pTail->pDirty = pB;<KAIGYO>        break;<KAIGYO>      }<KAIGYO>      if( pB==0 ){<KAIGYO>        pTail->pDirty = pA;<KAIGYO>        break;<KAIGYO>      }<KAIGYO>    }<KAIGYO>    if( a[i]==0 ) continue;<KAIGYO>    p = p ? pcacheMergeDirtyList(p, a[i]) : a[i];<KAIGYO>/*<KAIGYO>** Return the number of dirty pages currently in the cache, as a percentage<KAIGYO>** of the configured cache size.<KAIGYO>*/': 1, '  if( p->nFresh==0 ){  /*OPTIMIZATION-IF-FALSE*/<KAIGYO>    /* We could allocate a fresh RowSetEntry each time one is needed, but it<KAIGYO>    ** is more efficient to pull a preallocated entry from the pool */': 1, '  DbPage **ppPage,    /* Write a pointer to the page here */<KAIGYO>  int flags           /* PAGER_GET_XXX flags */': 1, '#endif /* SQLITE_ENABLE_SNAPSHOT */<KAIGYO><KAIGYO>      ** before checking pInfo->nBackfillAttempted.  <KAIGYO>      **<KAIGYO>      ** TODO: Does the aReadMark[] lock prevent a checkpointer from doing<KAIGYO>      **       this already?<KAIGYO>      */': 1, '/* Opcode: Lt P1 P2 P3 P4 P5<KAIGYO>** Synopsis: IF r[P3]<r[P1]<KAIGYO>**<KAIGYO>** Compare the values in register P1 and P3.  If reg(P3)<reg(P1) then<KAIGYO>** jump to address P2.  Or if the SQLITE_STOREP2 flag is set in P5 store<KAIGYO>** the result of comparison (0 or 1 or NULL) into register P2.<KAIGYO>**<KAIGYO>** If the SQLITE_JUMPIFNULL bit of P5 is set and either reg(P1) or<KAIGYO>** reg(P3) is NULL then the take the jump.  If the SQLITE_JUMPIFNULL <KAIGYO>** bit is clear then fall through if either operand is NULL.<KAIGYO>**<KAIGYO>** The SQLITE_AFF_MASK portion of P5 must be an affinity character -<KAIGYO>** SQLITE_AFF_TEXT, SQLITE_AFF_INTEGER, and so forth. An attempt is made <KAIGYO>** to coerce both inputs according to this affinity before the<KAIGYO>** comparison is made. If the SQLITE_AFF_MASK is 0x00, then numeric<KAIGYO>** affinity is used. Note that the affinity conversions are stored<KAIGYO>** back into the input registers P1 and P3.  So this opcode can cause<KAIGYO>** persistent changes to registers P1 and P3.<KAIGYO>**<KAIGYO>** Once any conversions have taken place, and neither value is NULL, <KAIGYO>** the values are compared. If both values are blobs then memcmp() is<KAIGYO>** used to determine the results of the comparison.  If both values<KAIGYO>** are text, then the appropriate collating function specified in<KAIGYO>** P4 is  used to do the comparison.  If P4 is not specified then<KAIGYO>** memcmp() is used to compare text string.  If both values are<KAIGYO>** numeric, then a numeric comparison is used. If the two values<KAIGYO>** are of different types, then numbers are considered less than<KAIGYO>** strings and strings are considered less than blobs.<KAIGYO>** Synopsis: IF r[P3]<=r[P1]<KAIGYO>** Synopsis: IF r[P3]>r[P1]<KAIGYO>** Synopsis: IF r[P3]>=r[P1]<KAIGYO>  int res, res2;      /* Result of the comparison of pIn1 against pIn3 */': 1, '/* Opcode: IntegrityCk P1 P2 P3 P4 P5<KAIGYO>** The root page numbers of all tables in the database are integers<KAIGYO>** stored in P4_INTARRAY argument.<KAIGYO>  aRoot = pOp->p4.ai;<KAIGYO>  assert( aRoot[nRoot]==0 );<KAIGYO>  assert( pOp->p3>0 && pOp->p3<=(p->nMem+1 - p->nCursor) );<KAIGYO>** Synopsis: rowset(P1)=r[P2]<KAIGYO>** Synopsis: r[P3]=rowset(P1)<KAIGYO>    goto abort_due_to_error;<KAIGYO>    assert( nMem>0 );<KAIGYO>    if( pProgram->nCsr==0 ) nMem++;<KAIGYO>              + pProgram->nCsr * sizeof(VdbeCursor *);<KAIGYO>    assert( pProgram->nMem+pProgram->nCsr==pFrame->nChildMem <KAIGYO>        || (pProgram->nCsr==0 && pProgram->nMem+1==pFrame->nChildMem) );<KAIGYO>  assert( pFrame->pAuxData==0 );<KAIGYO>  pFrame->pAuxData = p->pAuxData;<KAIGYO>  p->pAuxData = 0;<KAIGYO>  p->aMem = aMem = VdbeFrameMem(pFrame);<KAIGYO>  p->apCsr = (VdbeCursor **)&aMem[p->nMem];<KAIGYO>  i64 x;<KAIGYO>  x = pIn1->u.i;<KAIGYO>  if( x<=0 || sqlite3AddInt64(&x, pIn3->u.i>0?pIn3->u.i:0) ){<KAIGYO>    /* If the LIMIT is less than or equal to zero, loop forever.  This<KAIGYO>    ** is documented.  But also, if the LIMIT+OFFSET exceeds 2^63 then<KAIGYO>    ** also loop forever.  This is undocumented.  In fact, one could argue<KAIGYO>    ** that the loop should terminate.  But assuming 1 billion iterations<KAIGYO>    ** per second (far exceeding the capabilities of any current hardware)<KAIGYO>    ** it would take nearly 300 years to actually reach the limit.  So<KAIGYO>    ** looping forever is a reasonable approximation. */': 1, '      /* If a pre-update hook is registered and this is a write cursor, <KAIGYO>      ** invoke it here. <KAIGYO>      ** <KAIGYO>      ** TODO: The preupdate-hook is passed SQLITE_DELETE, even though this<KAIGYO>      ** operation should really be an SQLITE_UPDATE. This is probably<KAIGYO>      ** incorrect, but is convenient because at this point the new.* values <KAIGYO>      ** are not easily obtainable. And for the sessions module, an <KAIGYO>      ** SQLITE_UPDATE where the PK columns do not change is handled in the <KAIGYO>      ** same way as an SQLITE_DELETE (the SQLITE_DELETE code is actually<KAIGYO>      ** slightly more efficient). Since you cannot write to a PK column<KAIGYO>      ** using the incremental-blob API, this works. For the sessions module<KAIGYO>      ** anyhow.<KAIGYO>      */': 1, '  u8 ePragTyp;             /* PragTyp_XXX value */<KAIGYO>  u8 mPragFlg;             /* Zero or more PragFlg_XXX values */': 1, '/* Figure out the best index to use to search a pragma virtual table.<KAIGYO>**<KAIGYO>** There are not really any index choices.  But we want to encourage the<KAIGYO>** query planner to give == constraints on as many hidden parameters as<KAIGYO>** possible, and especially on the first hidden parameter.  So return a<KAIGYO>** high cost if hidden parameters are unconstrained.<KAIGYO>*/': 1, '  LogEst truthProb;       /* Probability of truth for this expression */<KAIGYO>  u16 wtFlags;            /* TERM_xxx bit flags.  See below */': 1, '        /* Take care here not to generate a TK_VECTOR containing only a<KAIGYO>        ** single value. Since the parser never creates such a vector, some<KAIGYO>        ** of the subroutines do not handle this case.  */': 1, '    /* These registers need to be preserved in case there is an IN operator<KAIGYO>    ** loop.  So we could deallocate the registers here (and potentially<KAIGYO>    ** reuse them later) if (pLoop->wsFlags & WHERE_IN_ABLE)==0.  But it seems<KAIGYO>    ** simpler and safer to simply not reuse the registers.<KAIGYO>    **<KAIGYO>    **    sqlite3ReleaseTempRange(pParse, iReg, nConstraint+2);<KAIGYO>    */': 1, '  int op,                /* The specific comparison operator */<KAIGYO><KAIGYO>  /* If this expression is a vector to the left or right of a <KAIGYO>  ** inequality constraint (>, <, >= or <=), perform the processing <KAIGYO>  ** on the first element of the vector.  */': 1, '/*<KAIGYO>** Obtain an indication as to the current stage of an RBU update or vacuum.<KAIGYO>** This function always returns one of the SQLITE_RBU_STATE_XXX constants<KAIGYO>** defined in this file. Return values should be interpreted as follows:<KAIGYO>**<KAIGYO>** SQLITE_RBU_STATE_OAL:<KAIGYO>**   RBU is currently building a *-oal file. The next call to sqlite3rbu_step()<KAIGYO>**   may either add further data to the *-oal file, or compute data that will<KAIGYO>**   be added by a subsequent call.<KAIGYO>**<KAIGYO>** SQLITE_RBU_STATE_MOVE:<KAIGYO>**   RBU has finished building the *-oal file. The next call to sqlite3rbu_step()<KAIGYO>**   will move the *-oal file to the equivalent *-wal path. If the current<KAIGYO>**   operation is an RBU update, then the updated version of the database<KAIGYO>**   file will become visible to ordinary SQLite clients following the next<KAIGYO>**   call to sqlite3rbu_step().<KAIGYO>**<KAIGYO>** SQLITE_RBU_STATE_CHECKPOINT:<KAIGYO>**   RBU is currently performing an incremental checkpoint. The next call to<KAIGYO>**   sqlite3rbu_step() will copy a page of data from the *-wal file into<KAIGYO>**   the target database file.<KAIGYO>**<KAIGYO>** SQLITE_RBU_STATE_DONE:<KAIGYO>**   The RBU operation has finished. Any subsequent calls to sqlite3rbu_step()<KAIGYO>**   will immediately return SQLITE_DONE.<KAIGYO>**<KAIGYO>** SQLITE_RBU_STATE_ERROR:<KAIGYO>**   An error has occurred. Any subsequent calls to sqlite3rbu_step() will<KAIGYO>**   immediately return the SQLite error code associated with the error.<KAIGYO>*/': 1, '  /* TODO: Check that zTarget and zRbu are non-NULL */<KAIGYO>  return openRbuHandle(zTarget, zRbu, zState);<KAIGYO>}<KAIGYO><KAIGYO>/*<KAIGYO>** Open a handle to begin or resume an RBU VACUUM operation.<KAIGYO>*/': 1, '  /* TODO: Check that both arguments are non-NULL */<KAIGYO>  return openRbuHandle(0, zTarget, zState);<KAIGYO>}<KAIGYO>SQLITE_API sqlite3 *sqlite3rbu_db(sqlite3rbu *pRbu, int bRbu){<KAIGYO>    unsigned int i;<KAIGYO>SQLITE_API int sqlite3rbu_close(sqlite3rbu *p, char **pzErrmsg){<KAIGYO>    /* If this is an RBU vacuum handle and the vacuum has either finished<KAIGYO>    ** successfully or encountered an error, delete the contents of the <KAIGYO>    ** state table. This causes the next call to sqlite3rbu_vacuum() <KAIGYO>    ** specifying the current target and state databases to start a new<KAIGYO>    ** vacuum from scratch.  */': 1, '    int eType;                    /* Value type (SQLITE_NULL, TEXT etc.) */<KAIGYO>  <KAIGYO>    eType = sqlite3_value_type(pValue);<KAIGYO>    if( aBuf ) aBuf[0] = eType;<KAIGYO>  <KAIGYO>    switch( eType ){<KAIGYO>      case SQLITE_NULL: <KAIGYO>        nByte = 1;<KAIGYO>        break;<KAIGYO>  <KAIGYO>      case SQLITE_INTEGER: <KAIGYO>      case SQLITE_FLOAT:<KAIGYO>        if( aBuf ){<KAIGYO>          /* TODO: SQLite does something special to deal with mixed-endian<KAIGYO>          ** floating point values (e.g. ARM7). This code probably should<KAIGYO>          ** too.  */': 1, '    sqlite3_free((char*)pTab->azCol);  /* cast works around VC++ bug */<KAIGYO>    sqlite3_free(pTab->apChange);<KAIGYO>    sqlite3_free(pTab);<KAIGYO>  }<KAIGYO>}<KAIGYO><KAIGYO>/*<KAIGYO>** Delete a session object previously allocated using sqlite3session_create().<KAIGYO>*/': 1, '      sqlite3_free((char*)azCol);  /* cast works around VC++ bug */<KAIGYO>    }<KAIGYO>  }<KAIGYO><KAIGYO>  if( rc==SQLITE_OK ){<KAIGYO>    if( xOutput==0 ){<KAIGYO>      *pnChangeset = buf.nBuf;<KAIGYO>      *ppChangeset = buf.aBuf;<KAIGYO>      buf.aBuf = 0;<KAIGYO>    }else if( buf.nBuf>0 ){<KAIGYO>      rc = xOutput(pOut, (void*)buf.aBuf, buf.nBuf);<KAIGYO>    }<KAIGYO>  }<KAIGYO><KAIGYO>  sqlite3_free(buf.aBuf);<KAIGYO>  sqlite3_exec(db, """", 0, 0, 0);<KAIGYO>  sqlite3_mutex_leave(sqlite3_db_mutex(db));<KAIGYO>  return rc;<KAIGYO>}<KAIGYO><KAIGYO>/*<KAIGYO>** Obtain a changeset object containing all changes recorded by the <KAIGYO>** session object passed as the first argument.<KAIGYO>**<KAIGYO>** It is the responsibility of the caller to eventually free the buffer <KAIGYO>** using sqlite3_free().<KAIGYO>*/': 1, '/*<KAIGYO>** Obtain a patchset object containing all changes recorded by the <KAIGYO>** session object passed as the first argument.<KAIGYO>**<KAIGYO>** It is the responsibility of the caller to eventually free the buffer <KAIGYO>** using sqlite3_free().<KAIGYO>*/': 1, '    /* This condition occurs when an earlier OOM in a call to<KAIGYO>    ** sqlite3_value_text() or sqlite3_value_blob() (perhaps from within<KAIGYO>    ** a conflict-handler) has zeroed the pVal->z pointer. Return NOMEM. */': 1, '      sqlite3_free((char*)sApply.azCol);  /* cast works around VC++ bug */<KAIGYO>      sqlite3_finalize(sApply.pDelete);<KAIGYO>      sqlite3_finalize(sApply.pUpdate); <KAIGYO>      sqlite3_finalize(sApply.pInsert);<KAIGYO>      sqlite3_finalize(sApply.pSelect);<KAIGYO>      memset(&sApply, 0, sizeof(sApply));<KAIGYO>      sApply.db = db;<KAIGYO>      sApply.bDeferConstraints = 1;<KAIGYO><KAIGYO>      /* If an xFilter() callback was specified, invoke it now. If the <KAIGYO>      ** xFilter callback returns zero, skip this table. If it returns<KAIGYO>      ** non-zero, proceed. */': 1, '  sqlite3_free((char*)sApply.azCol);  /* cast works around VC++ bug */<KAIGYO>  sqlite3_free((char*)sApply.constraints.aBuf);<KAIGYO>  sqlite3_mutex_leave(sqlite3_db_mutex(db));<KAIGYO>  return rc;<KAIGYO>}<KAIGYO><KAIGYO>/*<KAIGYO>** Apply the changeset passed via pChangeset/nChangeset to the main database<KAIGYO>** attached to handle """". Invoke the supplied conflict handler callback<KAIGYO>** to resolve any conflicts encountered while applying the change.<KAIGYO>*/': 1, '/*<KAIGYO>        if( c==\'""\' || c==\'\\\\\' || c==\'/\' || c==\'b\' || c==\'f\'<KAIGYO>           || c==\'n\' || c==\'r\' || c==\'t\'<KAIGYO>           || (c==\'u\' && jsonIs4Hex(pParse->zJson+j+1)) ){<KAIGYO>          jnFlags = JNODE_ESCAPE;<KAIGYO>        }else{<KAIGYO>          return -1;<KAIGYO>        }<KAIGYO>** Implementation of the json_QUOTE(VALUE) function.  Return a JSON value<KAIGYO>** corresponding to the SQL value input.  Mostly this means putting <KAIGYO>** double-quotes around strings and returning the unquoted string """"<KAIGYO>** when given a NULL input.<KAIGYO>*/': 1, '    /* TODO: Do we need this if the leaf-index is appended? Probably... */<KAIGYO>    memset(&pData->p[pData->nn], 0, FTS5_DATA_PADDING);<KAIGYO>    p->rc = fts5StructureDecode(pData->p, pData->nn, &iCookie, &pRet);<KAIGYO>    if( p->rc==SQLITE_OK && pConfig->iCookie!=iCookie ){<KAIGYO>      p->rc = sqlite3Fts5ConfigLoad(pConfig, iCookie);<KAIGYO>    }<KAIGYO>    fts5DataRelease(pData);<KAIGYO>    if( p->rc!=SQLITE_OK ){<KAIGYO>      fts5StructureRelease(pRet);<KAIGYO>      pRet = 0;<KAIGYO>    }<KAIGYO>  }<KAIGYO><KAIGYO>  return pRet;<KAIGYO>}<KAIGYO><KAIGYO>static i64 fts5IndexDataVersion(Fts5Index *p){<KAIGYO>  i64 iVersion = 0;<KAIGYO><KAIGYO>  if( p->rc==SQLITE_OK ){<KAIGYO>    if( p->pDataVersion==0 ){<KAIGYO>      p->rc = fts5IndexPrepareStmt(p, &p->pDataVersion, <KAIGYO>          sqlite3_mprintf("""", p->pConfig->zDb)<KAIGYO>          );<KAIGYO>      if( p->rc ) return 0;<KAIGYO>    }<KAIGYO><KAIGYO>    if( SQLITE_ROW==sqlite3_step(p->pDataVersion) ){<KAIGYO>      iVersion = sqlite3_column_int64(p->pDataVersion, 0);<KAIGYO>    }<KAIGYO>    p->rc = sqlite3_reset(p->pDataVersion);<KAIGYO>  }<KAIGYO><KAIGYO>  return iVersion;<KAIGYO>}<KAIGYO><KAIGYO>  if( p->pStruct==0 ){<KAIGYO>    p->iStructVersion = fts5IndexDataVersion(p);<KAIGYO>    if( p->rc==SQLITE_OK ){<KAIGYO>      p->pStruct = fts5StructureReadUncached(p);<KAIGYO>    }<KAIGYO>#if 0<KAIGYO>  else{<KAIGYO>    Fts5Structure *pTest = fts5StructureReadUncached(p);<KAIGYO>    if( pTest ){<KAIGYO>      int i, j;<KAIGYO>      assert_nc( p->pStruct->nSegment==pTest->nSegment );<KAIGYO>      assert_nc( p->pStruct->nLevel==pTest->nLevel );<KAIGYO>      for(i=0; i<pTest->nLevel; i++){<KAIGYO>        assert_nc( p->pStruct->aLevel[i].nMerge==pTest->aLevel[i].nMerge );<KAIGYO>        assert_nc( p->pStruct->aLevel[i].nSeg==pTest->aLevel[i].nSeg );<KAIGYO>        for(j=0; j<pTest->aLevel[i].nSeg; j++){<KAIGYO>          Fts5StructureSegment *p1 = &pTest->aLevel[i].aSeg[j];<KAIGYO>          Fts5StructureSegment *p2 = &p->pStruct->aLevel[i].aSeg[j];<KAIGYO>          assert_nc( p1->iSegid==p2->iSegid );<KAIGYO>          assert_nc( p1->pgnoFirst==p2->pgnoFirst );<KAIGYO>          assert_nc( p1->pgnoLast==p2->pgnoLast );<KAIGYO>        }<KAIGYO>      }<KAIGYO>      fts5StructureRelease(pTest);<KAIGYO>    }<KAIGYO>  }<KAIGYO>#endif<KAIGYO><KAIGYO>  if( p->rc!=SQLITE_OK ) return 0;<KAIGYO>  assert( p->iStructVersion!=0 );<KAIGYO>  assert( p->pStruct!=0 );<KAIGYO>  fts5StructureRef(p->pStruct);<KAIGYO>  return p->pStruct;<KAIGYO>}<KAIGYO><KAIGYO>static void fts5StructureInvalidate(Fts5Index *p){<KAIGYO>  if( p->pStruct ){<KAIGYO>    fts5StructureRelease(p->pStruct);<KAIGYO>    p->pStruct = 0;<KAIGYO>  }<KAIGYO>    pIter->pLeaf = fts5LeafRead(p, <KAIGYO>          );<KAIGYO>    if( iOff>=n ){<KAIGYO>      p->rc = FTS5_CORRUPT;<KAIGYO>      return;<KAIGYO>    }<KAIGYO><KAIGYO>static sqlite3_stmt *fts5IdxSelectStmt(Fts5Index *p){<KAIGYO>  if( p->pIdxSelect==0 ){<KAIGYO>    Fts5Config *pConfig = p->pConfig;<KAIGYO>    fts5IndexPrepareStmt(p, &p->pIdxSelect, sqlite3_mprintf(<KAIGYO>          """"<KAIGYO>          """",<KAIGYO>          pConfig->zDb, pConfig->zName<KAIGYO>    ));<KAIGYO>  }<KAIGYO>  return p->pIdxSelect;<KAIGYO>}<KAIGYO><KAIGYO>  sqlite3_stmt *pIdxSelect = 0;<KAIGYO>  pIdxSelect = fts5IdxSelectStmt(p);<KAIGYO>  sqlite3_bind_int(pIdxSelect, 1, pSeg->iSegid);<KAIGYO>  sqlite3_bind_blob(pIdxSelect, 2, pTerm, nTerm, SQLITE_STATIC);<KAIGYO>  if( SQLITE_ROW==sqlite3_step(pIdxSelect) ){<KAIGYO>    i64 val = sqlite3_column_int(pIdxSelect, 0);<KAIGYO>  p->rc = sqlite3_reset(pIdxSelect);<KAIGYO>  assert( pIter->base.bEof==0 );<KAIGYO>** xSetOutputs callback used when the Fts5Colset object has nCol==0 (match<KAIGYO>** against no columns at all).<KAIGYO>*/': 1}",1.0,"{'#define P4_INT64    (-13) /* P4 is a 64-bit signed integer */<KAIGYO>#define P4_INT32    (-14) /* P4 is a 32-bit signed integer */': 1, '#define OP_IdxDelete     111 /* synopsis: key=r[P2@P3]                     */<KAIGYO>#define OP_Seek          112 /* synopsis: Move P3 to P1.rowid              */': 1, '#define WHERE_GROUPBY          0x0100 /* pOrderBy is really a GROUP BY */<KAIGYO>#define WHERE_DISTINCTBY       0x0200 /* pOrderby is really a DISTINCT clause */': 1, '      /* Move the page to the head of the dirty list. */<KAIGYO>  if( p->flags & (PGHDR_CLEAN|PGHDR_DONT_WRITE) ){<KAIGYO>  if( (p->flags & PGHDR_DIRTY) ){<KAIGYO>      if( ALWAYS(p->pgno>pgno) ){<KAIGYO>** Do not both fixing the pDirtyPrev pointers.<KAIGYO>  while( pA && pB ){<KAIGYO>    }<KAIGYO>  }<KAIGYO>  if( pA ){<KAIGYO>    pTail->pDirty = pA;<KAIGYO>  }else if( pB ){<KAIGYO>    pTail->pDirty = pB;<KAIGYO>  }else{<KAIGYO>    pTail->pDirty = 0;<KAIGYO>    p = pcacheMergeDirtyList(p, a[i]);<KAIGYO>    szBulk = pCache->szAlloc*pCache->nMax;<KAIGYO>  int nFreed = 0;<KAIGYO>    nFreed = sqlite3MallocSize(p);<KAIGYO>    sqlite3_mutex_enter(pcache1.mutex);<KAIGYO>    sqlite3StatusDown(SQLITE_STATUS_PAGECACHE_OVERFLOW, nFreed);<KAIGYO>    sqlite3_mutex_leave(pcache1.mutex);<KAIGYO>  TESTONLY( unsigned int nPage = 0; )  /* To assert pCache->nPage is correct */': 1, '  /* This routine is called only once */<KAIGYO>  assert( p!=0 && (p->rsFlags & ROWSET_NEXT)==0 );<KAIGYO><KAIGYO>  if( (p->rsFlags & ROWSET_SORTED)==0 ){<KAIGYO>    p->pEntry = rowSetEntrySort(p->pEntry);<KAIGYO>  }<KAIGYO><KAIGYO>  /* While this module could theoretically support it, sqlite3RowSetNext()<KAIGYO>  ** is never called after sqlite3RowSetText() for the same RowSet.  So<KAIGYO>  ** there is never a forest to deal with.  Should this change, simply<KAIGYO>  ** remove the assert() and the #if 0. */': 1, '  const char *const zName;  /* Name of pragma */<KAIGYO>  u8 ePragTyp;              /* PragTyp_XXX value */': 1, '  u8 mPragFlag;             /* Zero or more PragFlag_XXX values */<KAIGYO>  u32 iArg;                 /* Extra argument */': 1, '  /* Allocate the parsing context */<KAIGYO>  pParse = sqlite3StackAllocZero(db, sizeof(*pParse));<KAIGYO>  if( pParse==0 ){<KAIGYO>    rc = SQLITE_NOMEM;<KAIGYO>    goto end_prepare;<KAIGYO>  }<KAIGYO>  pParse->pReprepare = pReprepare;<KAIGYO>        const char *zDb = db->aDb[i].zName;<KAIGYO>  pParse->db = db;<KAIGYO>  pParse->nQueryLoop = 0;  /* Logarithmic, so 0 really means 1 */': 1, '  int iLikeRepCntr;     /* LIKE range processing counter register */<KAIGYO>  LogEst truthProb;       /* Probability of truth for this expression */': 1, ""  int iBestLast;                  /* Last token of best snippet */<KAIGYO>  iBestLast = nToken-1;<KAIGYO><KAIGYO>  for(i=0; rc==SQLITE_OK && i<nInst; i++){<KAIGYO>    int ip, iSnippetCol, iStart;<KAIGYO>    memset(aSeen, 0, nPhrase);<KAIGYO>    rc = pApi->xInst(pFts, i, &ip, &iSnippetCol, &iStart);<KAIGYO>    if( rc==SQLITE_OK && (iCol<0 || iSnippetCol==iCol) ){<KAIGYO>      int nScore = 1000;<KAIGYO>      int iLast = iStart - 1 + pApi->xPhraseSize(pFts, ip);<KAIGYO>      int j;<KAIGYO>      aSeen[ip] = 1;<KAIGYO><KAIGYO>      for(j=i+1; rc==SQLITE_OK && j<nInst; j++){<KAIGYO>        int ic; int io; int iFinal;<KAIGYO>        rc = pApi->xInst(pFts, j, &ip, &ic, &io);<KAIGYO>        iFinal = io + pApi->xPhraseSize(pFts, ip) - 1;<KAIGYO>        if( rc==SQLITE_OK && ic==iSnippetCol && iLast<iStart+nToken ){<KAIGYO>          nScore += aSeen[ip] ? 1000 : 1;<KAIGYO>          aSeen[ip] = 1;<KAIGYO>          if( iFinal>iLast ) iLast = iFinal;<KAIGYO>        }<KAIGYO>      }<KAIGYO><KAIGYO>      if( rc==SQLITE_OK && nScore>nBestScore ){<KAIGYO>        iBestCol = iSnippetCol;<KAIGYO>        iBestStart = iStart;<KAIGYO>        iBestLast = iLast;<KAIGYO>        nBestScore = nScore;<KAIGYO>    rc = pApi->xColumnSize(pFts, iBestCol, &nColSize);<KAIGYO>  }<KAIGYO>  if( rc==SQLITE_OK ){<KAIGYO>    if( (iBestStart+nToken-1)>iBestLast ){<KAIGYO>      iBestStart -= (iBestStart+nToken-1-iBestLast) / 2;<KAIGYO>    }<KAIGYO>    if( iBestStart+nToken>nColSize ){<KAIGYO>      iBestStart = nColSize - nToken;<KAIGYO>    }<KAIGYO>    if( iBestStart<0 ) iBestStart = 0;<KAIGYO><KAIGYO><KAIGYO>    if( rc==SQLITE_OK ){<KAIGYO>      sqlite3_result_text(pCtx, (const char*)ctx.zOut, -1, SQLITE_TRANSIENT);<KAIGYO>    }else{<KAIGYO>      sqlite3_result_error_code(pCtx, rc);<KAIGYO>    }<KAIGYO>    sqlite3_free(ctx.zOut);<KAIGYO>  }<KAIGYO>      zOut[zRet-zIn] = '\\0';<KAIGYO>    }<KAIGYO>  }<KAIGYO>  int i, j;<KAIGYO>  int rc = SQLITE_OK;<KAIGYO>  for(i=0; rc==SQLITE_OK && i<pNear->nPhrase; i++){<KAIGYO>    for(j=0; j<pPhrase->nTerm; j++){<KAIGYO>      Fts5ExprTerm *pTerm = &pPhrase->aTerm[j];<KAIGYO>      Fts5ExprTerm *p;<KAIGYO>      int bEof = 1;<KAIGYO>      for(p=pTerm; p && rc==SQLITE_OK; p=p->pSynonym){<KAIGYO>        if( p->pIter ){<KAIGYO>          sqlite3Fts5IterClose(p->pIter);<KAIGYO>          p->pIter = 0;<KAIGYO>        }<KAIGYO>        rc = sqlite3Fts5IndexQuery(<KAIGYO>            pExpr->pIndex, p->zTerm, (int)strlen(p->zTerm),<KAIGYO>            (pTerm->bPrefix ? FTS5INDEX_QUERY_PREFIX : 0) |<KAIGYO>            (pExpr->bDesc ? FTS5INDEX_QUERY_DESC : 0),<KAIGYO>            pNear->pColset,<KAIGYO>            &p->pIter<KAIGYO>        );<KAIGYO>        assert( rc==SQLITE_OK || p->pIter==0 );<KAIGYO>        if( p->pIter && 0==sqlite3Fts5IterEof(p->pIter) ){<KAIGYO>          bEof = 0;<KAIGYO>        }<KAIGYO>      }<KAIGYO>      if( bEof ){<KAIGYO>        pNode->bEof = 1;<KAIGYO>        return rc;<KAIGYO>  return rc;<KAIGYO>          if( pIter->iRowid==iLast ) continue;<KAIGYO>  int rc = SQLITE_OK;<KAIGYO>  if( pRoot->xNext ){<KAIGYO>    p->pIndex = pIdx;<KAIGYO>    p->bDesc = bDesc;<KAIGYO>    rc = fts5ExprNodeFirst(p, pRoot);<KAIGYO>    /* If not at EOF but the current rowid occurs earlier than iFirst in<KAIGYO>    ** the iteration order, move to document iFirst or later. */"": 1, '  /* TODO: Do we need this if the leaf-index is appended? Probably... */<KAIGYO>  memset(&pData->p[pData->nn], 0, FTS5_DATA_PADDING);<KAIGYO>  p->rc = fts5StructureDecode(pData->p, pData->nn, &iCookie, &pRet);<KAIGYO>  if( p->rc==SQLITE_OK && pConfig->iCookie!=iCookie ){<KAIGYO>    p->rc = sqlite3Fts5ConfigLoad(pConfig, iCookie);<KAIGYO>  fts5DataRelease(pData);<KAIGYO>  if( p->rc!=SQLITE_OK ){<KAIGYO>    fts5StructureRelease(pRet);<KAIGYO>    pRet = 0;<KAIGYO>  }<KAIGYO>  return pRet;<KAIGYO>    pIter->pLeaf = fts5DataRead(p, <KAIGYO>              );<KAIGYO><KAIGYO>  if( p->pIdxSelect==0 ){<KAIGYO>    Fts5Config *pConfig = p->pConfig;<KAIGYO>    fts5IndexPrepareStmt(p, &p->pIdxSelect, sqlite3_mprintf(<KAIGYO>          """"<KAIGYO>          """",<KAIGYO>          pConfig->zDb, pConfig->zName<KAIGYO>    ));<KAIGYO>  }<KAIGYO>  sqlite3_bind_int(p->pIdxSelect, 1, pSeg->iSegid);<KAIGYO>  sqlite3_bind_blob(p->pIdxSelect, 2, pTerm, nTerm, SQLITE_STATIC);<KAIGYO>  if( SQLITE_ROW==sqlite3_step(p->pIdxSelect) ){<KAIGYO>    i64 val = sqlite3_column_int(p->pIdxSelect, 0);<KAIGYO>  p->rc = sqlite3_reset(p->pIdxSelect);<KAIGYO>        *aOut++ = (iPrev - iPrevOut) + 2;<KAIGYO>      while( iSegid==0 ){<KAIGYO>        int iLvl, iSeg;<KAIGYO>        sqlite3_randomness(sizeof(u32), (void*)&iSegid);<KAIGYO>        iSegid = iSegid & ((1 << FTS5_DATA_ID_B)-1);<KAIGYO>        for(iLvl=0; iLvl<pStruct->nLevel; iLvl++){<KAIGYO>          for(iSeg=0; iSeg<pStruct->aLevel[iLvl].nSeg; iSeg++){<KAIGYO>            if( iSegid==pStruct->aLevel[iLvl].aSeg[iSeg].iSegid ){<KAIGYO>              iSegid = 0;<KAIGYO>            }<KAIGYO>          }<KAIGYO>        }<KAIGYO>      }<KAIGYO>    }<KAIGYO>    fts5WriteFlushBtree(p, pWriter);<KAIGYO>  }<KAIGYO>static void fts5IndexMerge(<KAIGYO>  int nPg                         /* Pages of work to do */': 1}",1.0,{}
72,181248.0,5.0,7.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/181248,tst_qquickwindow::mouseFiltering: verify that siblings don't filter,1.0,{},0.0,{'// TODO Is it a bug if a QTouchEvent comes here?': 2},1.0,{}
147,181493.0,2.0,5.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/181493,QFusionStyle: don't lose precision when drawing a progress bar,1.0,{'// workaround for bug in QProgressBar': 1},1.0,{'// workaround for bug in QProgressBar': 1},1.0,{}
173,181572.0,5.0,7.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/181572,Minor assembler cleanup,1.0,{'// make sure we clean up nicely': 1},1.0,{'// make sure we clean up nicely': 1},1.0,{}
168,181580.0,7.0,8.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/181580,JIT Assembler instruction selection cleanup,1.0,{'// FIXME: this saves all registers. We can probably do with a subset: those that are not used by the register allocator.': 2},1.0,{'// FIXME: this saves all registers. We can probably do with a subset: those that are not used by the register allocator.': 2},1.0,{}
213,181657.0,2.0,17.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/181657,Imported WebKit commit 30997fb33975697a4af9cc6eef69967313d0ec9a,1.0,{},0.0,{'// FIXME: check me': 1},1.0,{}
226,181759.0,2.0,7.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/181759,"When changing the printer used, try to preserve the original page settings",1.0,{},0.0,{'// TODO Do we need to check if the page size is valid on new printer?': 1},1.0,{}
239,181782.0,5.0,14.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/181782,Separate fill and stroke geometry updates in generic PathItem,1.0,"{""// Unlikely in practice but in theory m_vp could be<KAIGYO>// resized. Therefore, capture 'i' instead of 'd'."": 1}",1.0,"{""// Unlikely in practice but in theory m_vp could be<KAIGYO>// resized. Therefore, capture 'i' instead of 'd'."": 1}",1.0,{}
259,181824.0,3.0,6.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/181824,"qmlInfo: Switch message level to QtInfoMsg, matching the function name",1.0,{},0.0,"{'// XXX: temporary, switch to QtInfoMsg when callers are ported': 1}",1.0,{}
284,181831.0,5.0,6.0,0.0,ABANDONED,False,https://codereview.qt-project.org/#/c/181831,Support DynamicGL builds (take 2),1.0,"{""// FIXME: We don't have the robustness methods from Extensions3DOpenGLES."": 1, ""// Need to emulate MAX_FRAGMENT/VERTEX_UNIFORM_VECTORS and MAX_VARYING_VECTORS<KAIGYO>// because desktop GL's corresponding queries return the number of components<KAIGYO>// whereas GLES2 return the number of vectors (each vector has 4 components).<KAIGYO>// Therefore, the value returned by desktop GL needs to be divided by 4."": 1}",1.0,"{""// Need to emulate MAX_FRAGMENT/VERTEX_UNIFORM_VECTORS and MAX_VARYING_VECTORS<KAIGYO>// because desktop GL's corresponding queries return the number of components<KAIGYO>// whereas GLES2 return the number of vectors (each vector has 4 components).<KAIGYO>// Therefore, the value returned by desktop GL needs to be divided by 4."": 1}",1.0,{}
283,181987.0,3.0,3.0,0.0,ABANDONED,False,https://codereview.qt-project.org/#/c/181987,*** Made DynamicGL changes in generic WebKit code less intrusive,1.0,"{""// Need to emulate MAX_FRAGMENT/VERTEX_UNIFORM_VECTORS and MAX_VARYING_VECTORS<KAIGYO>// because desktop GL's corresponding queries return the number of components<KAIGYO>// whereas GLES2 return the number of vectors (each vector has 4 components).<KAIGYO>// Therefore, the value returned by desktop GL needs to be divided by 4."": 1}",1.0,"{""// Need to emulate MAX_FRAGMENT/VERTEX_UNIFORM_VECTORS and MAX_VARYING_VECTORS<KAIGYO>// because desktop GL's corresponding queries return the number of components<KAIGYO>// whereas GLES2 return the number of vectors (each vector has 4 components).<KAIGYO>// Therefore, the value returned by desktop GL needs to be divided by 4."": 1}",1.0,{}
15,182043.0,2.0,8.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/182043,qdoc: Implement C++11 'override' specifier support,1.0,"{""// Hack to make 'default', 'final' and 'override'  work again in Q_PROPERTY"": 1}",1.0,"{""// Hack to make 'default' and 'final' work again in Q_PROPERTY"": 1}",1.0,{}
49,182206.0,3.0,13.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/182206,Remove dead code in Xcode generator,1.0,{},0.0,"{'/* This function is such a hack it is almost pointless, but it<KAIGYO>   eliminates the warning message from ProjectBuilder that the project<KAIGYO>   file is for an older version. I guess this could be used someday if<KAIGYO>   the format of the output is dependant upon the version of<KAIGYO>   ProjectBuilder as well.<KAIGYO>*/': 1}",1.0,{}
67,182230.0,7.0,16.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/182230,XCB QPA: Fix QScreen::grabWindow(0) to return the current screen,1.0,{},0.0,{'// TODO: handle multiple screens': 6},1.0,{}
334,182341.0,96.0,314.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/182341,Add support for calendars beside Gregorian,1.0,"{'// TODO: Check how to add calendaring support': 1, '// TODO: Check if we need maximum number of months in a year': 1, '// TODO: Check for year validity': 3, '// TODO: Check if this is an overkill...': 3, '// TODO: Move to QLocale?': 3, '// TODO: Remove this version, and use offset everywhere': 6, '// TODO: Remove pointer, use index instead': 6, '// TODO: Check this logic.': 9, '// TODO: Check for 31': 9, ""    /*<KAIGYO>     * TODO: Can't get y,m,d at once from calendar. It's protected.<KAIGYO>     * This is the reason we do need year(), month() and day() in calendar<KAIGYO>     */"": 10, '// TODO: Check those special numbers, 32 and 28': 10, '// TODO: Check if we need to implement QDate::dayOfWeek(const QAbstractCalendar&)': 11, '// TODO: What to do with default values? Maybe QAbstarctCalendar::defaultYear?<KAIGYO>// Maybe 1360 for Jalali, 1420 for Islamic, etc.<KAIGYO>// TODO: Why? There is pow()...': 11, ""// TODO: Check this. Why we don't want negative years? Has this something to do with Year 0?"": 11, '// TODO: Check this': 11, '// TODO: fix this known bug of calendaring API:<KAIGYO>// Changing locale before calendar works, but reverse order causes<KAIGYO>// invalid month names (In C Locale appearantly)': 11, '// TODO: What to do with default values? Maybe QAbstarctCalendar::defaultYear?<KAIGYO>// Maybe 1360 for Jalali, 1420 for Islamic, etc.': 12, ""// TODO: Check this, doesn't already QLocale have this data? Why we don't ask QLocale instead?"": 12, '// TODO: calendar->minDaysInMonth in place of 28 ?': 18, '// TODO: Remove this, move to somewhere shared between similar calendars': 22, '// TODO: Remove this, move to somewhere shared between similar calendars,<KAIGYO>//       or maybe in code...': 22, '/*!<KAIGYO>    Returns a pointer to a calendar object specified by \\a name. In case the<KAIGYO>    \\a name is not in availableCalendars() list, retusn \\c Q_NULLPTR.<KAIGYO><KAIGYO>    Ownership of the allocated object is transfered to user code. (You should<KAIGYO>    take care of deleting returned pointer after you are done with it).<KAIGYO><KAIGYO>    \\sa availableCalendars() , registerCalendar()<KAIGYO>*/': 25, ""/*!<KAIGYO>    \\class QJalaliCalendar<KAIGYO>    \\inmodule QtCore<KAIGYO>    \\brief The QJalaliCalendar class provides Jalali (Hijri Shamsi) calendar<KAIGYO>    system implementation.<KAIGYO><KAIGYO>    \\section1<KAIGYO><KAIGYO>    \\section2 Solar Hijri Calendar System<KAIGYO><KAIGYO>    The Solar Hijri calendar, also called the Solar Hejri calendar, Shamsi<KAIGYO>    Hijri calendar or Jalali calendar, is the official calendar of Iran and<KAIGYO>    Afghanistan. It begins on the vernal equinox (Nowruz) as determined by<KAIGYO>    astronomical calculation for the Iran Standard Time meridian<KAIGYO>    (52.5°E or GMT+3.5h). This determination of starting moment is more accurate<KAIGYO>    than the Gregorian calendar for predicting the date of the vernal equinox,<KAIGYO>    because it uses astronomical observations rather than mathematical rules.<KAIGYO><KAIGYO>    \\section3 Calendar Organization<KAIGYO><KAIGYO>    Each of the twelve months corresponds with a zodiac sign. The first six<KAIGYO>    months have 31 days, the next five have 30 days, and the last month has 29<KAIGYO>    days in usual years but 30 days in leap years. The New Year's Day always<KAIGYO>    falls on the March equinox.<KAIGYO><KAIGYO>    \\section4 Leap Year Rules<KAIGYO><KAIGYO>    The Solar Hijri calendar produces a five-year leap year interval after about<KAIGYO>    every seven four-year leap year intervals. It usually follows a 33-year<KAIGYO>    cycle with occasional interruptions by single 29-year or 37-year subcycles.<KAIGYO>    The reason for this behaviour is that it tracks the observed vernal equinox.<KAIGYO>    By contrast, some less accurate predictive algorithms are suggestion based<KAIGYO>    on confusion between the average tropical year (365.2422 days, approximated<KAIGYO>    with near 128-year cycles or 2820-year great cycles) and the mean interval<KAIGYO>    between spring equinoxes (365.2424 days, approximated with a near 33-year<KAIGYO>    cycle).<KAIGYO><KAIGYO> */"": 25, ""/*!<KAIGYO>    \\class QJalaliCalendar<KAIGYO>    \\inmodule QtCore<KAIGYO>    \\brief The QJalaliCalendar class provides Jalali (Hijri Shamsi) calendar<KAIGYO>    system implementation.<KAIGYO><KAIGYO>    \\section1<KAIGYO><KAIGYO>    \\section2 Solar Hijri Calendar System<KAIGYO><KAIGYO>    The Solar Hijri calendar, also called the Solar Hejri calendar, Shamsi<KAIGYO>    Hijri calendar or Jalali calendar, is the official calendar of Iran and<KAIGYO>    Afghanistan. It begins on the vernal equinox (Nowruz) as determined by<KAIGYO>    astronomical calculation for the Iran Standard Time meridian<KAIGYO>    (52.5°E or GMT+3.5h). This determination of starting moment is more accurate<KAIGYO>    than the Gregorian calendar for predicting the date of the vernal equinox,<KAIGYO>    because it uses astronomical observations rather than mathematical rules.<KAIGYO><KAIGYO>    \\section3 Calendar Organization<KAIGYO><KAIGYO>    Each of the twelve months corresponds with a zodiac sign. The first six<KAIGYO>    months have 31 days, the next five have 30 days, and the last month has 29<KAIGYO>    days in usual years but 30 days in leap years. The New Year's Day always<KAIGYO>    falls on the March equinox.<KAIGYO><KAIGYO>    \\section4 Leap Year Rules<KAIGYO><KAIGYO>    The Solar Hijri calendar produces a five-year leap year interval after about<KAIGYO>    every seven four-year leap year intervals. It usually follows a 33-year<KAIGYO>    cycle with occasional interruptions by single 29-year or 37-year subcycles.<KAIGYO>    The reason for this behavior is that it tracks the observed vernal equinox.<KAIGYO>    By contrast, some less accurate predictive algorithms are in use based<KAIGYO>    on confusion between the average tropical year (365.2422 days, approximated<KAIGYO>    with near 128-year cycles or 2820-year great cycles) and the mean interval<KAIGYO>    between spring equinoxes (365.2424 days, approximated with a near 33-year<KAIGYO>    cycle).<KAIGYO><KAIGYO>    Source: [Wikipedia page on Solar Hijri Calendar](httpsen.wikipedia.org/wiki/Solar_Hijri_calendar)<KAIGYO> */"": 27, '/*!<KAIGYO>    \\fn bool QAbstractCalendar::isSolar() const<KAIGYO><KAIGYO>    Returns \\c true if this calendar is a solar calendar. Otherwise returns<KAIGYO>    \\c false.<KAIGYO><KAIGYO>    A solar calendar is a calendar whose dates indicate the season or almost<KAIGYO>    equivalently the apparent position of the sun relative to the fixed stars.<KAIGYO>    The Gregorian calendar, widely accepted as standard in the world,<KAIGYO>    is an example of solar calendar.<KAIGYO><KAIGYO>    \\sa isLuniSolar(), isSolar(), isProleptic()<KAIGYO>*/': 28, '/*!<KAIGYO>    \\fn bool QCalendarBackend::isSolar() const<KAIGYO><KAIGYO>    Returns \\c true if this calendar is a solar calendar. Otherwise returns<KAIGYO>    \\c false.<KAIGYO><KAIGYO>    A solar calendar is a calendar whose dates indicate the season or almost<KAIGYO>    equivalently the apparent position of the sun relative to the fixed stars.<KAIGYO>    The Gregorian calendar, widely accepted as standard in the world,<KAIGYO>    is an example of solar calendar.<KAIGYO><KAIGYO>    \\sa isLuniSolar(), isLunar(), isProleptic()<KAIGYO>*/': 33, '// TODO: calendar.minDaysInMonth in place of 28 ?': 33, ""/*!<KAIGYO>    \\class QJalaliCalendar<KAIGYO>    \\inmodule QtCore<KAIGYO>    \\brief The QJalaliCalendar class provides Jalali (Hijri Shamsi) calendar<KAIGYO>    system implementation.<KAIGYO><KAIGYO>    \\section1 Solar Hijri Calendar System<KAIGYO><KAIGYO>    The Solar Hijri calendar, also called the Solar Hejri calendar, Shamsi<KAIGYO>    Hijri calendar or Jalali calendar, is the official calendar of Iran and<KAIGYO>    Afghanistan. It begins on the vernal equinox (Nowruz) as determined by<KAIGYO>    astronomical calculation for the Iran Standard Time meridian<KAIGYO>    (52.5°E or GMT+3.5h). This determination of starting moment is more accurate<KAIGYO>    than the Gregorian calendar for predicting the date of the vernal equinox,<KAIGYO>    because it uses astronomical observations rather than mathematical rules.<KAIGYO><KAIGYO>    \\section2 Calendar Organization<KAIGYO><KAIGYO>    Each of the twelve months corresponds with a zodiac sign. The first six<KAIGYO>    months have 31 days, the next five have 30 days, and the last month has 29<KAIGYO>    days in usual years but 30 days in leap years. The New Year's Day always<KAIGYO>    falls on the March equinox.<KAIGYO><KAIGYO>    \\section2 Leap Year Rules<KAIGYO><KAIGYO>    The Solar Hijri calendar produces a five-year leap year interval after about<KAIGYO>    every seven four-year leap year intervals. It usually follows a 33-year<KAIGYO>    cycle with occasional interruptions by single 29-year or 37-year subcycles.<KAIGYO>    The reason for this behavior is that it tracks the observed vernal equinox.<KAIGYO>    By contrast, some less accurate predictive algorithms are in use based<KAIGYO>    on confusion between the average tropical year (365.2422 days, approximated<KAIGYO>    with near 128-year cycles or 2820-year great cycles) and the mean interval<KAIGYO>    between spring equinoxes (365.2424 days, approximated with a near 33-year<KAIGYO>    cycle).<KAIGYO><KAIGYO>    Source: \\l {httpsen.wikipedia.org/wiki/Solar_Hijri_calendar}{Wikipedia<KAIGYO>    page on Solar Hijri Calendar}<KAIGYO> */"": 33, '// TODO: Check if we need to implement QDate::dayOfWeek(const QCalendar&)': 33, '// TODO: confirm this is correct': 33, '// TODO: does the system-local special handling belong only in Gregorian ?': 39, '// TODO: move to calendar, so that calendars with intercallary days can tweak behaviour.': 41, '// TODO: does the system-locale special handling belong only in Gregorian ?': 42, '// TODO: move to calendar, so that calendars with intercallary days can tweak behavior.': 42, '// TODO: does the system-locale-special handling belong only in Gregorian ?': 45, ""/*!<KAIGYO>  Returns \\c true if this calendar is luni-solar.<KAIGYO><KAIGYO>  A luni-solar calendar expresses the phases of the moon but adapts itself to<KAIGYO>  also keep track of the Sun's varying position in the sky, relative to the<KAIGYO>  fixed stars.<KAIGYO>*/"": 46, ""/*!<KAIGYO>  Returns \\c true if this calendar is solar.<KAIGYO><KAIGYO>  A solar calendar is based primaril on the Sun's varying position in the sky,<KAIGYO>  relative to the fixed stars.<KAIGYO>*/"": 46, ""/*!<KAIGYO>    \\since 5.14<KAIGYO><KAIGYO>    \\class QJalaliCalendar<KAIGYO>    \\inmodule QtCore<KAIGYO>    \\brief The QJalaliCalendar class provides Jalali (Hijri Shamsi) calendar<KAIGYO>    system implementation.<KAIGYO><KAIGYO>    \\section1 Solar Hijri Calendar System<KAIGYO><KAIGYO>    The Solar Hijri calendar, also called the Solar Hejri calendar, Shamsi<KAIGYO>    Hijri calendar or Jalali calendar, is the official calendar of Iran and<KAIGYO>    Afghanistan. It begins on the vernal equinox (Nowruz) as determined by<KAIGYO>    astronomical calculation for the Iran Standard Time meridian<KAIGYO>    (52.5°E or GMT+3.5h). This determination of starting moment is more accurate<KAIGYO>    than the Gregorian calendar for predicting the date of the vernal equinox,<KAIGYO>    because it uses astronomical observations rather than mathematical rules.<KAIGYO><KAIGYO>    \\section2 Calendar Organization<KAIGYO><KAIGYO>    Each of the twelve months corresponds with a zodiac sign. The first six<KAIGYO>    months have 31 days, the next five have 30 days, and the last month has 29<KAIGYO>    days in usual years but 30 days in leap years. The New Year's Day always<KAIGYO>    falls on the March equinox.<KAIGYO><KAIGYO>    \\section2 Leap Year Rules<KAIGYO><KAIGYO>    The Solar Hijri calendar produces a five-year leap year interval after about<KAIGYO>    every seven four-year leap year intervals. It usually follows a 33-year<KAIGYO>    cycle with occasional interruptions by single 29-year or 37-year subcycles.<KAIGYO>    The reason for this behavior is that it tracks the observed vernal equinox.<KAIGYO>    By contrast, some less accurate predictive algorithms are in use based<KAIGYO>    on confusion between the average tropical year (365.2422 days, approximated<KAIGYO>    with near 128-year cycles or 2820-year great cycles) and the mean interval<KAIGYO>    between spring equinoxes (365.2424 days, approximated with a near 33-year<KAIGYO>    cycle).<KAIGYO><KAIGYO>    Source: \\l {httpsen.wikipedia.org/wiki/Solar_Hijri_calendar}{Wikipedia<KAIGYO>    page on Solar Hijri Calendar}<KAIGYO> */"": 46, '// TODO: fix this known bug of calendaring API:<KAIGYO>// Changing locale before calendar works, but reverse order causes<KAIGYO>// invalid month names (in C Locale apparently).': 48, '// TODO: can we adapt this to cope gracefully with intercallary days (day of<KAIGYO>// week > 7) without making it slower for more widely-used calendars ?': 52, '// TODO: What to use (for non-Gregorian calendars) as default year?': 60, '// This could be replaced by use of QIso8601Calendar, once we implement it.': 75, ""/*!<KAIGYO>    \\since 5.14<KAIGYO><KAIGYO>    \\class QCalendarBackend<KAIGYO>    \\inmodule QtCore<KAIGYO>    \\reentrant<KAIGYO>    \\brief The QCalendarBackend class provides basic calendaring functions.<KAIGYO><KAIGYO>    QCalendarBackend provides the base class on which all calendar types are<KAIGYO>    implemented. On construction, the backend is registered with its primary<KAIGYO>    name.<KAIGYO><KAIGYO>    A backend may also be registered with aliases, where the calendar is known<KAIGYO>    by several names. Registering with the name used by CLDR (the Unicode<KAIGYO>    consortium's Common Locale Data Repository) is recommended, particularly<KAIGYO>    when interacting with third-party software. Once a backend is registered for<KAIGYO>    a name, QCalendar can be constructed using that name to select the backend.<KAIGYO><KAIGYO>    Each calendar backend must inherit from QCalendarBackend and implement its<KAIGYO>    pure virtual methods. It may also override some other virtual methods, as<KAIGYO>    needed.<KAIGYO><KAIGYO>    Most backends are pure code, with no data elements. Such backends should<KAIGYO>    normally be implemented as singletons. For a backend to be added to the<KAIGYO>    QCalendar::System enum, it should be such a singleton, with a case in<KAIGYO>    QCalendar::fromEnum()'s switch statement to instantiate it.<KAIGYO><KAIGYO>    Non-singleton calendar backends should ensure that each instance is created<KAIGYO>    with a distinct primary name. Later instances attempting to register with a<KAIGYO>    name already in use shall fail to register and be unavailable to QCalendar,<KAIGYO>    hence unusable.<KAIGYO><KAIGYO>    \\sa registerAlias(), QDate, QDateTime, QDateEdit, QDateTimeEdit, QCalendarWidget<KAIGYO>*/"": 84}",1.0,{'// maybe first week of next year': 39},1.0,{}
217,182350.0,9.0,42.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/182350,Merge remote-tracking branch 'origin/5.8' into dev,1.0,{'// Only search for the version once': 1},1.0,{'// Only search for the version once': 5},1.0,{'// Only search for the version once': '1-5'}
142,182419.0,1.0,1.0,0.0,ABANDONED,False,https://codereview.qt-project.org/#/c/182419,Update dferry code to get aggregate info improvements.,1.0,"{'// proceed immediately to reading the next element in the array<KAIGYO>// TODO check that final data position is where it should be according to the<KAIGYO>// serialized array length (same in BeginDict!)': 1, ""// NB: Do not make non-idempotent changes to member variables before potentially going to<KAIGYO>//     out_needMoreData! We'll make the same change again after getting more data."": 1, '/*<KAIGYO>    TODO test peek / readPrimitiveArray inside a nil array, and inside a nil array inside another<KAIGYO>         nil array. I am pretty sure that something is wrong here.<KAIGYO>*/': 1, '// TODO as noted in readPrimitiveArray(), primitive nil arrays need testing!': 1}",1.0,"{""// Special case 1: in state BeginArray/Dict, when we've just entered the nil array according<KAIGYO>// to our internal state, the API user cannot know that yet -> return false;<KAIGYO>// Since this is easily done here, don't complicate the rest of the code with a hacky solution."": 1, '// we\'re done iterating over it once<KAIGYO>// TODO unit-test this<KAIGYO>// HACK: decreasing m_nilArrayNesting here would be much cleaner! But from the<KAIGYO>// user\'s POV, the nil array has not been left before the call to endArray().<KAIGYO>// We will set state EndArray / EndDict, so we know that the user """" call<KAIGYO>// endArray()/endDict(), so adjust d->m_nilArrayNesting in those methods.<KAIGYO>//d->m_nilArrayNesting--;': 1, '// TODO check that final data position is where it should be according to the<KAIGYO>// serialized array length': 1, ""// we're done iterating over it once<KAIGYO>// TODO: unit-test this"": 1}",1.0,{}
144,182423.0,1.0,1.0,0.0,ABANDONED,False,https://codereview.qt-project.org/#/c/182423,Fix the build (yay!) and add/backport some code that was accidentally completely removed.,1.0,"{'// static const int unixFdCount = 32;<KAIGYO>// int unixFds[unixFdCount]; // Unix FDs are completely TODO': 1, '// TODO I hope it works to change the type after the fact when exchanging all the serialized<KAIGYO>//      data?': 1, '// TODO !!! q_dbus_message_demarshal(reinterpret_cast<char *>(&serialized[0]));': 1, '// TODO !!! ~~= q_dbus_message_marshal()...': 1, '// TODO create from dmsg': 1}",1.0,{'// TODO create from dmsg<KAIGYO>// TODO sync enum types betwen Message and QDBusMessage': 1},1.0,{}
145,182424.0,1.0,1.0,0.0,ABANDONED,False,https://codereview.qt-project.org/#/c/182424,Make DBusMessage <> serialized bytes work.,1.0,"{'//static const int unixFdCount = 32;<KAIGYO>//int unixFds[unixFdCount]; // Unix FDs are completely TODO<KAIGYO>// TODO make this work from chunk (pointer + size), not only vector': 1, '// TODO check error?': 1, '// TODO make this work from chunk (pointer + size), not only vector': 1}",1.0,"{'// static const int unixFdCount = 32;<KAIGYO>// int unixFds[unixFdCount]; // Unix FDs are completely TODO<KAIGYO>// TODO I hope it works to change the type after the fact when exchanging all the serialized<KAIGYO>//      data?': 1, '// TODO !!! q_dbus_message_demarshal(reinterpret_cast<char *>(&serialized[0]));<KAIGYO>// TODO !!! ~~= q_dbus_message_marshal()...<KAIGYO>// TODO create from dmsg': 1}",1.0,{}
301,182883.0,10.0,11.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/182883,corrections: copy some values from QQuickEventPoint to properties,1.0,{},0.0,"{""// TODO don't call setGrab(true) here, only setGrab(false), because concrete subclasses may<KAIGYO>// wait for the drag threshold to be exceeded, for example"": 1}",1.0,{}
306,182920.0,2.0,5.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/182920,Promote keyNavigationWraps/Enabled to QQuickAbstractItemView,1.0,"{'// TODO: default binding to """" can be removed in Qt 6; it only exists for compatibility reasons.': 1}",1.0,"{'// TODO: default binding to """" can be removed in Qt 6; it only exists for compatibility reasons.': 1}",1.0,{}
132,183485.0,3.0,5.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/183485,QQmlImport: Clean up & rename getTypeForUrl to fetchOrCreateTypeForUrl,1.0,{},0.0,"{'//XXX: The constData of the string ref is pointing somewhere unsafe in qmlregister, so we need to create a temporary copy': 1}",1.0,{}
162,183545.0,2.0,4.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/183545,Update qtgrayraster.c,1.0,{'    /* Even 32-bit deviation would vanish after 16 bisections.      */<KAIGYO>    draw = 1;<KAIGYO>    while ( dx > ONE_PIXEL / 4 );<KAIGYO>    {<KAIGYO>      dx >>= 2;<KAIGYO>      draw <<= 1;<KAIGYO>    }<KAIGYO>    /* We use decrement counter to count the total number of segments */': 1},1.0,"{'#endif /* PIXEL_BITS >= 8 */<KAIGYO><KAIGYO>    int     max_cells;<KAIGYO>    int     num_cells;<KAIGYO>    TCoord  cx, cy;<KAIGYO>    TPos    last_ey;<KAIGYO><KAIGYO>    QT_FT_Vector   bez_stack[32 * 3 + 1];<KAIGYO>    int         lev_stack[32];<KAIGYO><KAIGYO>    int  conic_level;<KAIGYO>    int  cubic_level;<KAIGYO>    int        ycount;<KAIGYO>                   long            byte_size )<KAIGYO>  static void<KAIGYO>  gray_record_cell( RAS_ARG )<KAIGYO>    int     x = ras.ex;<KAIGYO>    if ( ras.invalid || !( ras.area | ras.cover ) )<KAIGYO>        return;<KAIGYO>    if ( x > ras.max_ex )<KAIGYO>      x = ras.max_ex;<KAIGYO><KAIGYO>      if ( cell->x == x ) {<KAIGYO>          cell->area  += ras.area;<KAIGYO>          cell->cover += ras.cover;<KAIGYO>          return;<KAIGYO>      }<KAIGYO>    cell->area  = ras.area;<KAIGYO>    cell->cover = ras.cover;<KAIGYO>    ras.invalid = ( (unsigned)ey >= (unsigned)ras.count_ey ||<KAIGYO>                              ex >= ras.count_ex           );<KAIGYO>    ras.last_ey = SUBPIXELS( ey );<KAIGYO>    TCoord  ex1, ex2, fx1, fx2, delta;<KAIGYO>    int     incr, lift, mod, rem;<KAIGYO>    delta = (TCoord)( p / dx );<KAIGYO>    mod   = (TCoord)( p % dx );<KAIGYO>    if ( mod < 0 )<KAIGYO>    {<KAIGYO>      delta--;<KAIGYO>      mod += (TCoord)dx;<KAIGYO>    }<KAIGYO>      p    = ONE_PIXEL * ( y2 - y1 + delta );<KAIGYO>      lift = (TCoord)( p / dx );<KAIGYO>      rem  = (TCoord)( p % dx );<KAIGYO>      if ( rem < 0 )<KAIGYO>      {<KAIGYO>        lift--;<KAIGYO>        rem += (TCoord)dx;<KAIGYO>      }<KAIGYO>    TCoord  ey1, ey2, fy1, fy2;<KAIGYO>    int     delta, rem, mod, lift, incr;<KAIGYO>    ey1 = TRUNC( ras.last_ey );<KAIGYO>    fy1 = (TCoord)( ras.y - ras.last_ey );<KAIGYO>    /* XXX: we should do something about the trivial case where dx == 0, */': 1}",1.0,{}
210,183783.0,2.0,2.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/183783,compiler: Rename _env to _variableEnvironment,1.0,"{'            _variableEnvironment->enter(name, Environment::FunctionDefinition, false /* readonly */, expr);<KAIGYO>            _variableEnvironment->usesArgumentsObject = Environment::ArgumentsObjectNotUsed;<KAIGYO>        wasStrict = _variableEnvironment->isStrict;<KAIGYO>    _variableEnvironment->isNamedFunctionExpression = isExpression && !name.isEmpty();<KAIGYO>    _variableEnvironment->formals = formals;<KAIGYO>    if (wasStrict || _variableEnvironment->isStrict) {<KAIGYO>    , _variableEnvironment(0)<KAIGYO>    _variableEnvironment = 0;<KAIGYO>    _variableEnvironment = 0;<KAIGYO>    _variableEnvironment = _envMap.value(node);<KAIGYO>    Q_ASSERT(_variableEnvironment);<KAIGYO>    Q_ASSERT(_variableEnvironment);<KAIGYO>    _variableEnvironment = _variableEnvironment->parent;<KAIGYO>    if (al && al->index < static_cast<unsigned>(_variableEnvironment->members.size())) {<KAIGYO>             expr->asArgLocal()->index >= static_cast<unsigned>(_variableEnvironment->members.size()))) {<KAIGYO>    Environment *e = _variableEnvironment;<KAIGYO>    if (!e->parent && (!f || !f->insideWithOrCatch) && _variableEnvironment->compilationMode != EvalCode && e->compilationMode != QmlBinding)<KAIGYO>    if (_variableEnvironment->compilationMode == QmlBinding)<KAIGYO>    function->hasDirectEval = _variableEnvironment->hasDirectEval || _variableEnvironment->compilationMode == EvalCode<KAIGYO>    function->usesArgumentsObject = _variableEnvironment->parent && (_variableEnvironment->usesArgumentsObject == Environment::ArgumentsObjectUsed);<KAIGYO>    function->usesThis = _variableEnvironment->usesThis;<KAIGYO>    function->maxNumberOfArguments = qMax(_variableEnvironment->maxNumberOfArguments, (int)QV4::Global::ReservedArgumentCount);<KAIGYO>    function->isStrict = _variableEnvironment->isStrict;<KAIGYO>    function->isNamedExpression = _variableEnvironment->isNamedFunctionExpression;<KAIGYO>    function->isQmlBinding = _variableEnvironment->compilationMode == QmlBinding;<KAIGYO>        _variableEnvironment->enter(QStringLiteral(""""), Environment::VariableDeclaration, false /* readonly */': 1}",1.0,"{'            _env->enter(name, Environment::FunctionDefinition, false /* readonly */, expr);<KAIGYO>            _env->usesArgumentsObject = Environment::ArgumentsObjectNotUsed;<KAIGYO>        wasStrict = _env->isStrict;<KAIGYO>    _env->isNamedFunctionExpression = isExpression && !name.isEmpty();<KAIGYO>    _env->formals = formals;<KAIGYO>    if (wasStrict || _env->isStrict) {<KAIGYO>    , _env(0)<KAIGYO>    _env = 0;<KAIGYO>    _env = 0;<KAIGYO>    _env = _envMap.value(node);<KAIGYO>    Q_ASSERT(_env);<KAIGYO>    Q_ASSERT(_env);<KAIGYO>    _env = _env->parent;<KAIGYO>    if (al && al->index < static_cast<unsigned>(_env->members.size())) {<KAIGYO>             expr->asArgLocal()->index >= static_cast<unsigned>(_env->members.size()))) {<KAIGYO>    Environment *e = _env;<KAIGYO>    if (!e->parent && (!f || !f->insideWithOrCatch) && _env->compilationMode != EvalCode && e->compilationMode != QmlBinding)<KAIGYO>    if (_env->compilationMode == QmlBinding)<KAIGYO>    function->hasDirectEval = _env->hasDirectEval || _env->compilationMode == EvalCode<KAIGYO>    function->usesArgumentsObject = _env->parent && (_env->usesArgumentsObject == Environment::ArgumentsObjectUsed);<KAIGYO>    function->usesThis = _env->usesThis;<KAIGYO>    function->maxNumberOfArguments = qMax(_env->maxNumberOfArguments, (int)QV4::Global::ReservedArgumentCount);<KAIGYO>    function->isStrict = _env->isStrict;<KAIGYO>    function->isNamedExpression = _env->isNamedFunctionExpression;<KAIGYO>    function->isQmlBinding = _env->compilationMode == QmlBinding;<KAIGYO>        _env->enter(QStringLiteral(""""), Environment::VariableDeclaration, false /* readonly */': 1}",1.0,{}
235,184791.0,4.0,11.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/184791,Avoid unnecessary creation of some Q_GLOBAL_STATIC,1.0,{},0.0,"{""// ignore - if we can't allocate a post routine list,<KAIGYO>// there's a high probability that there's no post<KAIGYO>// routine to be executed :)"": 1}",1.0,{}
287,184832.0,23.0,40.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/184832,QQuickWindow: remove sendFilteredTouchEvent,1.0,"{""// If any parent filters the event, we're done.<KAIGYO>// updateFilteringParentItems was already called (TODO verify)"": 1}",1.0,"{'// TODO assimilate this logic and remove this function': 1, '// FIXME: remove asTouchEvent!!!': 1}",1.0,{}
258,184874.0,2.0,2.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/184874,Remove remaining ARM #ifdef in qv4assembler.cpp,1.0,{},0.0,"{""// Work around bug in ARMv7Assembler.h where add32(imm, sp, sp) doesn't<KAIGYO>// work well for large immediates."": 1}",1.0,{}
26,185055.0,3.0,13.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/185055,Replace usage of QSignalMapper by lambda,1.0,{},0.0,{'//XXX': 2},1.0,{}
36,185103.0,6.0,9.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/185103,add categorized log message in QQuickEventPoint::cancelPassiveGrab,1.0,{},0.0,{'// TODO somehow avoid duplicating this code from setGrabberPointerHandler': 1},1.0,{}
54,185155.0,3.0,3.0,0.0,ABANDONED,False,https://codereview.qt-project.org/#/c/185155,WIP: working incremental GC,1.0,{'// ### find better condition!': 1},1.0,{'// ### find better condition!<KAIGYO>//!(count % 4);': 1},1.0,{}
131,185425.0,3.0,11.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/185425,Merge remote-tracking branch 'origin/5.8' into 5.9,1.0,{},0.0,"{'// convolute the bitmap with a triangle filter to get rid of color fringes<KAIGYO>// If we take account for a gamma value of 2, we end up with<KAIGYO>// weights of 1, 4, 9, 4, 1. We use an approximation of 1, 3, 8, 3, 1 here,<KAIGYO>// as this nicely sums up to 16 :)': 1, '// looks better with thicker line for small pointsizes': 1, ""// This is an error in the bytecode, probably a web font made by someone who<KAIGYO>// didn't test bytecode hinting at all so disable for it for all glyphs."": 1}",1.0,{}
191,185610.0,2.0,2.0,0.0,ABANDONED,False,https://codereview.qt-project.org/#/c/185610,Some more tuning,1.0,{},0.0,{'// ### find better condition!': 1},1.0,{}
220,185747.0,3.0,5.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/185747,Eliminate QT_NO_DYNAMIC_LIBRARY,1.0,{'// Workaround until fixed in QNX; fixes crash in': 1},1.0,{'// Workaround until fixed in QNX; fixes crash in': 1},1.0,{}
263,185843.0,15.0,42.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/185843,notify a PointerHandler when it loses grab due to Item::grabTouchPoints,1.0,{},0.0,"{'// FIXME: deprecate this function, we need a device': 1, '// TODO else if the old grabber was a PointerHandler, notify it somehow?': 1, '// FIXME send ungrab event only once': 7, '// TODO else if the old grabber was a PointerHandler, notify it somehow?<KAIGYO>// FIXME send ungrab event only once': 12}",1.0,{}
268,186281.0,15.0,34.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/186281,Add feature.label and feature.formlayout,1.0,{'// moving': 1},1.0,{'// moving': 1},1.0,{}
143,186404.0,6.0,11.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/186404,tst_QGuiApplication: Split the quitOnLastWindowClosed() tests,1.0,{'// Should be around 10 if closing caused the quit': 1},1.0,{'// Should be around 10 if closing caused the quit': 1},1.0,{}
142,186423.0,1.0,1.0,0.0,DEFERRED,False,https://codereview.qt-project.org/#/c/186423,xcb: move XI2 in its own class,1.0,"{'// TODO: handled = m_xinput->xi2HandleEvent(event);': 1, ""// FIXME: Don't use XInput2 mouse events when Xinerama extension<KAIGYO>// is enabled, because it causes problems with multi-monitor setup."": 1}",1.0,"{""// FIXME: Don't use XInput2 mouse events when Xinerama extension<KAIGYO>// is enabled, because it causes problems with multi-monitor setup."": 1}",1.0,{}
37,187047.0,7.0,9.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/187047,QMainWindow: move the separator handling in another class,1.0,{},0.0,"{""// We're moving a separator, eat this event"": 1, ""//let's move the separators"": 1}",1.0,{}
76,187179.0,5.0,5.0,0.0,ABANDONED,False,https://codereview.qt-project.org/#/c/187179,WIP: Experiment with grab() in QVulkanWindow,1.0,"{'// move on to next swapchain image': 2, '// block and then bail out when grabbing': 2}",1.0,{'// move on to next swapchain image': 2},1.0,{}
205,187848.0,5.0,8.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/187848,PinchHandler: Do not grab immediately,1.0,{},0.0,"{'// TODO wait for the drag threshold before setting active<KAIGYO>// but the old behavior was that whenever we """" all the points, we\'re active<KAIGYO>// so that behavior is retained here temporarily': 1}",1.0,{}
70,188372.0,1.0,5.0,0.0,DEFERRED,False,https://codereview.qt-project.org/#/c/188372,Improve visual quality of downscaled jpeg image reading,1.0,"{'// libjpeg supports M/8 scaling with M=[1,16]. All downscaling factors<KAIGYO>// are a speed improvement, but upscaling during decode is slower.': 1}",1.0,"{'// libjpeg supports M/8 scaling with M=[1,16]. All downscaling factors<KAIGYO>// are a speed improvement, but upscaling during decode is slower.': 1}",1.0,{}
98,188613.0,4.0,6.0,0.0,ABANDONED,False,https://codereview.qt-project.org/#/c/188613,Send drag move event whenever a modifier is pressed or released,1.0,"{'// Send drag move event whenever a modifier is pressed or released': 1, '// ### fixme: no mouse pos registered. Get pos from touch...': 3}",1.0,{'// ### fixme: no mouse pos registered. Get pos from touch...': 3},1.0,{}
148,188974.0,6.0,17.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/188974,QDataWidgetMapper: replace an inefficient QList with std::vector,1.0,{},0.0,{'// a C++98 move': 1},1.0,{}
35,189146.0,4.0,7.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/189146,QTzTimeZonePrivate: resolve a misguided TODO,1.0,{},0.0,{'// TODO convert to UTC if not in UTC': 1},1.0,{}
116,189506.0,4.0,8.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/189506,Register additional meta types,1.0,{},0.0,{'// TODO: Why on earth is this not in the library???': 2},1.0,{}
167,190424.0,9.0,44.0,0.0,ABANDONED,False,https://codereview.qt-project.org/#/c/190424,Introduce openglshadercache feature,1.0,"{'// NB! It could be tempting to defer reading the file contents and just<KAIGYO>// hash the filename as the cache key, perhaps combined with last-modified<KAIGYO>// timestamp checks. However, this would raise a number of issues (no<KAIGYO>// timestamps for files in the resource system; preference for global, not<KAIGYO>// per-application cache items (where filenames may clash); resource-based<KAIGYO>// shaders from libraries like Qt Quick; etc.), so just avoid it.': 4}",1.0,"{'// NB! It could be tempting to defer reading the file contents and just<KAIGYO>// hash the filename as the cache key, perhaps combined with last-modified<KAIGYO>// timestamp checks. However, this would raise a number of issues (no<KAIGYO>// timestamps for files in the resource system; preference for global, not<KAIGYO>// per-application cache items (where filenames may clash); resource-based<KAIGYO>// shaders from libraries like Qt Quick; etc.), so just avoid it.': 4}",1.0,{}
180,190499.0,3.0,19.0,0.0,ABANDONED,False,https://codereview.qt-project.org/#/c/190499,Merge remote-tracking branch 'origin/dev' into wip/pointerhandler,1.0,{},0.0,{'// FIXME: remove asTouchEvent!!!': 1},1.0,{}
270,190730.0,12.0,29.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/190730,Make tst_qquickflickable::nestedSliderUsingTouch pass,1.0,"{""// it's done in QQuickEventPoint::setGrabberItem; TODO really always?<KAIGYO>//                oldGrabber->touchUngrabEvent();<KAIGYO>//        QQuickItemPrivate *itemPriv = QQuickItemPrivate::get(item);<KAIGYO>//        // If the item neither handles events nor has handlers which do, then it will never be a receiver, so filtering is irrelevant<KAIGYO>//        if (!item->acceptedMouseButtons() && !(itemPriv->extra.isAllocated() && !itemPriv->extra->pointerHandlers.isEmpty()))<KAIGYO>//            continue; // TODO there's no acceptTouchEvents, so it's hard to avoid skipping any items which handle only touch"": 1}",1.0,"{""// TODO there's no acceptTouchEvents, so it's hard to avoid skipping any items which handle only touch"": 1}",1.0,{}
281,190757.0,5.0,12.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/190757,Add QQuickItem acceptTouchEvents/setAcceptTouchEvents; require for touch,1.0,{},0.0,"{""//        QQuickItemPrivate *itemPriv = QQuickItemPrivate::get(item);<KAIGYO>//        // If the item neither handles events nor has handlers which do, then it will never be a receiver, so filtering is irrelevant<KAIGYO>//        if (!item->acceptedMouseButtons() && !(itemPriv->extra.isAllocated() && !itemPriv->extra->pointerHandlers.isEmpty()))<KAIGYO>//            continue; // TODO there's no acceptTouchEvents, so it's hard to avoid skipping any items which handle only touch"": 1, ""// TODO there's no acceptTouchEvents, so it's hard to avoid skipping any items which handle only touch"": 2}",1.0,{}
310,190920.0,2.0,3.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/190920,Remove heartlistener example,1.0,{},0.0,"{'// workaround for Core Bluetooth:': 1, ""// ignore any other characteristic change -> shouldn't really happen though"": 1}",1.0,{}
123,191497.0,4.0,7.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/191497,qsystemtrayicon_win.cpp: Clean obsolete code,1.0,{},0.0,{'// Call the deprecated ChangeWindowMessageFilter API otherwise (Vista onwards)<KAIGYO>// May 2016: Still resolved at runtime since the definition is not present in MinGW 4.9.<KAIGYO>// TODO: Replace by direct invocation when upgrading MinGW.': 1},1.0,{}
121,191540.0,2.0,7.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/191540,qgrayraster: use a cast to void to mark a variable as unused,1.0,{},0.0,{'  /* This macro is used to indicate that a function parameter is unused. */<KAIGYO>  /* Its purpose is simply to reduce compiler warnings.  Note also that  */': 1},1.0,{}
155,191685.0,2.0,4.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/191685,Merge remote-tracking branch 'origin/dev' into wip/pointerhandler,1.0,{},0.0,{'// FIXME: remove asTouchEvent!!!': 1},1.0,{}
147,191698.0,2.0,6.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/191698,QAccessibleQuickItem: Remove dead code,1.0,{},0.0,{'// FIXME can this happen?': 1},1.0,{}
149,191702.0,2.0,2.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/191702,QQuickFlickable: Remove an obviously stale comment,1.0,{},0.0,"{'/*<KAIGYO>XXXTODO add docs describing moving, dragging, flicking properties, e.g.<KAIGYO><KAIGYO>When the user starts dragging the Flickable, the dragging and moving properties<KAIGYO>will be true.<KAIGYO><KAIGYO>If the velocity is sufficient when the drag is ended, flicking may begin.<KAIGYO><KAIGYO>The moving properties will remain true until all dragging and flicking<KAIGYO>is finished.<KAIGYO>*/': 1}",1.0,{}
160,191703.0,1.0,7.0,0.0,DEFERRED,False,https://codereview.qt-project.org/#/c/191703,quick: Remove some old TODO,1.0,{},0.0,"{'// XXX todo - do we want this?': 1, '// XXX todo - i think this needs work and a bit of a re-think': 1, '// XXX todo Check that elements that create items handle memory correctly after visual ownership change': 1, '// XXX todo - optimize<KAIGYO>// XXX todo - optimize<KAIGYO>// XXX todo<KAIGYO>// XXX todo - we need to be able to handle common parents better and detect<KAIGYO>// invalid cases': 1, '// XXX todo - should we change rectangle to draw entirely within its width/height?': 1, '// XXX todo - should sendEvent be doing this?  how does it relate to forwarded events?': 1}",1.0,{}
183,191733.0,8.0,20.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/191733,Move qrand() & qsrand() to qrandom.cpp,1.0,"{'/*!<KAIGYO>    \\relates <QtGlobal><KAIGYO>    \\since 4.2<KAIGYO><KAIGYO>    Thread-safe version of the standard C++ \\c rand() function.<KAIGYO><KAIGYO>    Returns a value between 0 and \\c RAND_MAX (defined in \\c <cstdlib> and<KAIGYO>    \\c <stdlib.h>), the next number in the current sequence of pseudo-random<KAIGYO>    integers.<KAIGYO><KAIGYO>    Use \\c qsrand() to initialize the pseudo-random number generator with a<KAIGYO>    seed value. Seeding must be performed on once on each thread. If that step<KAIGYO>    is skipped, then the sequence will be pre-seeded with a constant value.<KAIGYO><KAIGYO>    \\sa qsrand(), QRandomDevice<KAIGYO>*/': 1, '/*!<KAIGYO>    \\relates <QtGlobal><KAIGYO>    \\since 4.2<KAIGYO><KAIGYO>    Thread-safe version of the standard C++ \\c rand() function.<KAIGYO><KAIGYO>    Returns a value between 0 and \\c RAND_MAX (defined in \\c <cstdlib> and<KAIGYO>    \\c <stdlib.h>), the next number in the current sequence of pseudo-random<KAIGYO>    integers.<KAIGYO><KAIGYO>    Use \\c qsrand() to initialize the pseudo-random number generator with a<KAIGYO>    seed value. Seeding must be performed at least once on each thread. If that<KAIGYO>    step is skipped, then the sequence will be pre-seeded with a constant<KAIGYO>    value.<KAIGYO><KAIGYO>    \\sa qsrand(), QRandomDevice<KAIGYO>*/': 6, '/*!<KAIGYO>    \\relates <QtGlobal><KAIGYO>    \\since 4.2<KAIGYO><KAIGYO>    Thread-safe version of the standard C++ \\c rand() function.<KAIGYO><KAIGYO>    Returns a value between 0 and \\c RAND_MAX (defined in \\c <cstdlib> and<KAIGYO>    \\c <stdlib.h>), the next number in the current sequence of pseudo-random<KAIGYO>    integers.<KAIGYO><KAIGYO>    Use \\c qsrand() to initialize the pseudo-random number generator with a<KAIGYO>    seed value. Seeding must be performed at least once on each thread. If that<KAIGYO>    step is skipped, then the sequence will be pre-seeded with a constant<KAIGYO>    value.<KAIGYO><KAIGYO>    \\sa qsrand(), QRandomGenerator<KAIGYO>*/': 7}",1.0,"{'/*!<KAIGYO>    \\relates <QtGlobal><KAIGYO>    \\since 4.2<KAIGYO><KAIGYO>    Thread-safe version of the standard C++ \\c rand() function.<KAIGYO><KAIGYO>    Returns a value between 0 and \\c RAND_MAX (defined in \\c <cstdlib> and<KAIGYO>    \\c <stdlib.h>), the next number in the current sequence of pseudo-random<KAIGYO>    integers.<KAIGYO><KAIGYO>    Use \\c qsrand() to initialize the pseudo-random number generator with a<KAIGYO>    seed value. Seeding must be performed on once on each thread. If that step<KAIGYO>    is skipped, then the sequence will be pre-seeded with a constant value.<KAIGYO><KAIGYO>    \\sa qsrand(), QRandomDevice<KAIGYO>*/': 1, '/*!<KAIGYO>    \\relates <QtGlobal><KAIGYO>    \\since 4.2<KAIGYO><KAIGYO>    Thread-safe version of the standard C++ \\c rand() function.<KAIGYO><KAIGYO>    Returns a value between 0 and \\c RAND_MAX (defined in \\c <cstdlib> and<KAIGYO>    \\c <stdlib.h>), the next number in the current sequence of pseudo-random<KAIGYO>    integers.<KAIGYO><KAIGYO>    Use \\c qsrand() to initialize the pseudo-random number generator with a<KAIGYO>    seed value. Seeding must be performed at least once on each thread. If that<KAIGYO>    step is skipped, then the sequence will be pre-seeded with a constant<KAIGYO>    value.<KAIGYO><KAIGYO>    \\sa qsrand(), QRandomDevice<KAIGYO>*/': 6, '/*!<KAIGYO>    \\relates <QtGlobal><KAIGYO>    \\since 4.2<KAIGYO><KAIGYO>    Thread-safe version of the standard C++ \\c rand() function.<KAIGYO><KAIGYO>    Returns a value between 0 and \\c RAND_MAX (defined in \\c <cstdlib> and<KAIGYO>    \\c <stdlib.h>), the next number in the current sequence of pseudo-random<KAIGYO>    integers.<KAIGYO><KAIGYO>    Use \\c qsrand() to initialize the pseudo-random number generator with a<KAIGYO>    seed value. Seeding must be performed at least once on each thread. If that<KAIGYO>    step is skipped, then the sequence will be pre-seeded with a constant<KAIGYO>    value.<KAIGYO><KAIGYO>    \\sa qsrand(), QRandomGenerator<KAIGYO>*/': 7}",1.0,{}
169,191734.0,4.0,14.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/191734,QTemporaryFile: fix the generation of names from templates,1.0,{},0.0,{'// Fix the random seed.': 1},1.0,{}
270,191738.0,12.0,41.0,0.0,ABANDONED,False,https://codereview.qt-project.org/#/c/191738,Change almost all other uses of qrand() to QRandomGenerator,1.0,{},0.0,"{""// Mac has 3 different ways of accomplishing this (same for moving to the back)<KAIGYO>// So I guess we should just randomly do this for now. Which may get people mad, but if<KAIGYO>// we fail at one point, it's just a matter of setting roll to the correct value<KAIGYO>// instead of random."": 6}",1.0,{}
282,192396.0,16.0,60.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/192396,Add support for enum declarations in QML,1.0,"{'// ### TODO: AST for initializer': 1, '// ### we probably want to avoid the create of the metaobject...': 1, '// ### FIXME: we probably want to avoid the creation of the metaobject...': 2}",1.0,{'// ### TODO: AST for initializer': 1},1.0,{}
64,193228.0,2.0,2.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/193228,Import WebKit commit a4582ff260c0683b310e8ebbd5c3e6d5ad9fccc2,1.0,{},0.0,{'//        return *privateSession(); // FIXME: Implement and call ensurePrivateBrowsingSession()': 1},1.0,{}
148,193528.0,3.0,4.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/193528,Fix the build with qtwebkit,1.0,{},0.0,{'# FIXME: currently broken': 1},1.0,{}
221,193559.0,4.0,34.0,0.0,ABANDONED,False,https://codereview.qt-project.org/#/c/193559,Long live QTest::testMoveSemantics()!,1.0,{},0.0,"{'// move ctor': 1, '// move assignment op': 1, '// move assignment<KAIGYO>// isCopyOf() works on moved-from palettes, too': 1, '// move construction': 1}",1.0,{}
153,193561.0,2.0,7.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/193561,Revert gamma-corrected handling of transparent destination buffer,1.0,"{'// Give up and do a naive gray alphablend. Needed to deal with ARGB32 and invalid ARGB32_premultiplied, see QTBUG-60571': 1}",1.0,"{'// Give up and do a gray alphablend.': 1, '// Give up and do a gray blend.': 1}",1.0,{}
243,193959.0,5.0,44.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/193959,QSslSocketBackendPrivate::transmit(): improve writing to OpenSSL,1.0,{'// ### Better error handling.': 1},1.0,"{'// ### TODO: make this cheaper by not making it memcpy. E.g. make it work with data=0x0 or make it work with seek': 1, '// ### Better error handling.': 1, '// do the actual read() here and throw away the results.<KAIGYO>// ### TODO: make this cheaper by not making it memcpy. E.g. make it work with data=0x0 or make it work with seek': 4}",1.0,{}
172,194996.0,30.0,50.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/194996,Let passive-grabbing PointerHandlers see all point updates,1.0,"{'// TODO MPTA is not notified<KAIGYO>//        QCOMPARE(tp.at(0)->property("""").toBool(), !pinchStoleGrab);<KAIGYO>//        QCOMPARE(tp.at(1)->property("""").toBool(), !pinchStoleGrab);<KAIGYO>//        QCOMPARE(tp.at(2)->property("""").toBool(), !pinchStoleGrab);': 5, '// Move some more... MPTA keeps reacting': 5, '// Move some more... MPTA keeps reacting<KAIGYO>//        QCOMPARE(pointerEvent->point(3)->exclusiveGrabber(), mpta);': 24, '// Move some more: PinchHander isn\'t interested in a mere 2 points.<KAIGYO>// MPTA could maybe react; but QQuickWindowPrivate::deliverTouchEvent() calls<KAIGYO>// deliverPressOrReleaseEvent() in a way which """" with event delivery<KAIGYO>// only for handlers, not for Items; therefore MPTA is not visited at this time.': 25}",1.0,"{""// ATM it's required that when PinchHandler sees the third touchpoint,<KAIGYO>// the pre-existing points must have moved far enough to exceed the drag threshold.<KAIGYO>// If MPTA is allowed to grab that third point, then PinchHandler won't steal.<KAIGYO>// TODO should we change that?  make sure that if PH has a passive grab, it always gets updated even though MPTA has the grab?"": 5, '// Move some more: PinchHandler reacts': 5, '//        QTRY_COMPARE(tp.at(0)->property("""").toBool(), false); // TODO fails; MPTA doesn\'t know it lost its grabs<KAIGYO>//        QCOMPARE(tp.at(1)->property("""").toBool(), false);<KAIGYO>//        QCOMPARE(tp.at(2)->property("""").toBool(), false);': 5, '//    QTRY_VERIFY(tp.at(0)->property("""").toBool());<KAIGYO>// Move some more: PinchHandler reacts': 25, '// MPTA grabs p4 (which is at index 3)<KAIGYO>//    QTRY_COMPARE(pointerEvent->point(3)->exclusiveGrabber(), mpta);<KAIGYO>// PinchHandler wantsPointerEvent declines, because it wants exactly 3 touchpoints, and there are now 4.<KAIGYO>// Move some more... MPTA reacts, in spite of not grabbing all the points<KAIGYO>//        QTRY_COMPARE(pointerEvent->point(0)->exclusiveGrabber(), nullptr);<KAIGYO>//        QCOMPARE(pointerEvent->point(1)->exclusiveGrabber(), nullptr);<KAIGYO>//        QCOMPARE(pointerEvent->point(2)->exclusiveGrabber(), nullptr);<KAIGYO>//        QCOMPARE(pointerEvent->point(3)->exclusiveGrabber(), mpta);<KAIGYO>//        QCOMPARE(tp.at(0)->property("""").toBool(), true);<KAIGYO>//        QCOMPARE(tp.at(1)->property("""").toBool(), true);<KAIGYO>//        QCOMPARE(tp.at(2)->property("""").toBool(), true);<KAIGYO>//        QCOMPARE(tp.at(3)->property("""").toBool(), true);<KAIGYO>// Release the pinkie': 25, ""// Move some more: PinchHander isn't interested in a mere 2 points, and MPTA should react... but it doesn't (TODO?)"": 25}",1.0,{}
76,195044.0,17.0,17.0,0.0,ABANDONED,False,https://codereview.qt-project.org/#/c/195044,Call QQI::touchUngrabEvent() regardless of stealing/ungrab scenario,1.0,{},0.0,"{""// TODO: MPTA doesn't deactivate a point when it loses its grab"": 1, '//        QTRY_COMPARE(tp.at(0)->property("""").toBool(), false); // TODO fails; MPTA doesn\'t know it lost its grabs?<KAIGYO>//        QCOMPARE(tp.at(1)->property("""").toBool(), false);<KAIGYO>//        QCOMPARE(tp.at(2)->property("""").toBool(), false);': 1, '//        QTRY_COMPARE(tp.at(0)->property("""").toBool(), false); // TODO fails; MPTA doesn\'t know it lost its grabs<KAIGYO>//        QCOMPARE(tp.at(1)->property("""").toBool(), false);<KAIGYO>//        QCOMPARE(tp.at(2)->property("""").toBool(), false);': 2, '// TODO MPTA doesn\'t deactivate a point when it loses its grab<KAIGYO>//        QCOMPARE(tp.at(0)->property("""").toBool(), !dragStoleGrab);<KAIGYO>// TODO MPTA is not notified<KAIGYO>//        QCOMPARE(tp.at(0)->property("""").toBool(), !pinchStoleGrab);<KAIGYO>//        QCOMPARE(tp.at(1)->property("""").toBool(), !pinchStoleGrab);<KAIGYO>//        QCOMPARE(tp.at(2)->property("""").toBool(), !pinchStoleGrab);': 3}",1.0,{}
90,195159.0,3.0,10.0,0.0,ABANDONED,False,https://codereview.qt-project.org/#/c/195159,Use (new) erase()/erase_if() algorithms,1.0,{},0.0,{'// work-around for (at least) MSVC 2012 emitting<KAIGYO>// warning C4100 for its own header <algorithm><KAIGYO>// when passing nullptr directly to std::remove': 3},1.0,{}
143,195164.0,9.0,46.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/195164,QSqlField: Add a means to see what the tablename is for a given field,1.0,{},0.0,{'// TODO: case-insensitive comparison': 1},1.0,{}
51,195266.0,2.0,2.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/195266,QWizard: move 'initialized' bit into QWizardPage,1.0,{},0.0,{'// ### remove and move bit to QWizardPage?': 1},1.0,{}
132,195413.0,3.0,6.0,0.0,ABANDONED,False,https://codereview.qt-project.org/#/c/195413,"WIP header diff for PointerHandler classes, with manual tests",1.0,"{""// If one or more points are newly pressed or released, all non-released points are candidates for this handler.<KAIGYO>// In other cases however, do not steal the grab: that is, if a point has a grabber,<KAIGYO>// it's not a candidate for this handler."": 1, '// TODO optimize: either ensure the points are sorted,<KAIGYO>// or use std::equal with a predicate': 1, '// TODO make templates for these functions somehow?': 1, '// TODO cache it in setActive()?': 1, '// TODO incompatible with independent x/y scaling': 1, ""// TODO check m_pinchOrigin: right now it acts like it's set to PinchCenter"": 1, '// TODO some translation inadvertently happens; try to hold the chosen pinch origin in place': 1, ""/*!<KAIGYO>    Notification that the grab has changed in some way which is relevant to this handler.<KAIGYO>    The \\a grabber (subject) will be the PointerHandler whose state is changing,<KAIGYO>    or null if the state change regards an Item. (TODO do we have any such cases?)<KAIGYO>    The \\a stateChange (verb) tells what happened.<KAIGYO>    The \\a point (object) is the point that was grabbed or ungrabbed.<KAIGYO>    EventPoint has the sole responsibility to call this function.<KAIGYO>    The PointerHandler must react in whatever way is appropriate, and must<KAIGYO>    emit the relevant signals (for the benefit of QML code).<KAIGYO>    A subclass is allowed to override this virtual function, but must always<KAIGYO>    call its parent class's implementation in addition to (usually after)<KAIGYO>    whatever custom behavior it implements.<KAIGYO>*/"": 1, '// TODO m_hadKeepMouseGrab m_hadKeepTouchGrab': 1, '/*!<KAIGYO>     \\qmlproperty QQuickPointerHandler::enabled<KAIGYO><KAIGYO>     If a PointerHandler is disabled, it will reject all events<KAIGYO>     and no signals will be emitted.<KAIGYO><KAIGYO>     TODO is it too extreme not even to emit pressed/updated/released?<KAIGYO>     or should we disable only the higher-level interpretation, in subclasses?<KAIGYO>*/': 1, '// TODO': 1, ""// If the user has not violated any constraint, it could be a tap.<KAIGYO>// Otherwise we want to give up the grab so that a competing handler<KAIGYO>// (e.g. DragHandler) gets a chance to take over.<KAIGYO>// Don't forget to emit released in case of a cancel."": 1, ""// Never react in any way when the point hasn't moved.<KAIGYO>// In autotests, the point's position may not even be correct, because<KAIGYO>// QTest::touchEvent(window, touchDevice).stationary(1)<KAIGYO>// provides no opportunity to give a position, so it ends up being random."": 1, '/*!<KAIGYO>    Set this point as \\a accepted (true) or rejected (false).<KAIGYO>    Accepting a point is intended to stop event propagation.<KAIGYO>    It does not imply any kind of grab, passive or exclusive.<KAIGYO>    TODO explain further under what conditions propagation really does stop...<KAIGYO>*/': 1, '// TODO optimize: stop this dynamic memory thrashing': 1, '// VERY simple kalman filter: does a weighted average<KAIGYO>// where the older velocities get less and less significant': 1, ""// RectangularGlow is better, but that's a different module"": 3}",1.0,"{'// TODO calculate velocity': 1, '// FIXME: deprecate this function, we need a device': 1, '// FIXME send ungrab event only once': 1, '// FIXME: remove asTouchEvent!!!': 1}",1.0,{}
106,195485.0,3.0,7.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/195485,"Qt Designer: Fix crash in ""Go to slot"" dialog when no signal is selected",1.0,{'// TODO: Check whether signal is connected to slot': 1},1.0,{'// TODO: Check whether signal is connected to slot': 1},1.0,{}
123,195539.0,7.0,23.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/195539,Qt Designer: Refactor signal dialog,1.0,{'// TODO: Check whether signal is connected to slot': 1},1.0,{'// TODO: Check whether signal is connected to slot': 1},1.0,{}
141,195787.0,2.0,3.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/195787,"Qt Designer: Fix crash in ""Go to slot"" dialog when no signal is selected",1.0,{'// TODO: Check whether signal is connected to slot': 1},1.0,{'// TODO: Check whether signal is connected to slot': 1},1.0,{}
175,195938.0,2.0,6.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/195938,winrt: Get rid of one deferral when handling socket data,1.0,{},0.0,"{'// Defer putting the datagrams into the list until the next event loop iteration<KAIGYO>// (where the readyRead signal is emitted as well)': 1, '// Defer putting the data into the list until the next event loop iteration<KAIGYO>// (where the readyRead signal is emitted as well)': 1}",1.0,{}
65,196061.0,3.0,14.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/196061,Remove ancient embedded pixmaps and scripts from uic,1.0,{},0.0,{'// be nice with MSVC & Co.': 1},1.0,{}
167,196396.0,15.0,20.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/196396,xcb: cleanup updating of scrolling device valuators,1.0,{},0.0,"{'// ### If a slave device changes (XIDeviceChange), we should probably run setup on it again.': 1}",1.0,{}
144,196621.0,4.0,20.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/196621,Refactor tst_QStyleSheetStyle::focus/hoverColors(),1.0,"{'// Move the mouse cursor out of the way to suppress spontaneous QEvent::Enter<KAIGYO>// events interfering with QApplicationPrivate::dispatchEnterLeave().<KAIGYO>// Mouse events can then be sent directly to the QWindow instead of the<KAIGYO>// QWidget, triggering the enter/leave handling within the dialog window,<KAIGYO>// speeding up the test.': 3}",1.0,{'//without Qt::X11BypassWindowManagerHint the window manager may move the window after we moved the cursor': 1},1.0,{}
109,197177.0,17.0,56.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/197177,QWidget: Call appropriate QWindow method from setGeometry_sys(),1.0,{'// Pre-check whether the WM is going to play nice with this test.': 14},1.0,{'//### why do we have isMove as a parameter?': 1},1.0,{}
67,197213.0,8.0,8.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/197213,Add Reference to codegen's result and start using it,1.0,"{'// ?!<KAIGYO>//        if (f->insideWithOrCatch || (f->isNamedExpression && QStringRef(f->name) == name))<KAIGYO>//            return Codegen::Result::fromName(cg, XXXXX));<KAIGYO>//            return _block->NAME(name, line, col);<KAIGYO>//            if (name == QLatin1String(""""))<KAIGYO>//                al->isArgumentsOrEval = true;': 1, '//### TODO: try constant folding': 2, '//### TODO': 2, '//### TODO<KAIGYO>//        move(identifier(QStringLiteral(""""), ast->firstSourceLocation().startLine, ast->firstSourceLocation().startColumn),<KAIGYO>//             _block->CALL(_block->NAME(IR::Name::builtin_setup_argument_object,<KAIGYO>//                     ast->firstSourceLocation().startLine, ast->firstSourceLocation().startColumn), 0));<KAIGYO>//    if (hasError)<KAIGYO>//        return true;<KAIGYO>//    TempScope scope(_function);<KAIGYO>//    IR::BasicBlock *foreachin = _function->newBasicBlock(exceptionHandler());<KAIGYO>//    IR::BasicBlock *foreachbody = _function->newBasicBlock(exceptionHandler());<KAIGYO>//    IR::BasicBlock *foreachend = _function->newBasicBlock(exceptionHandler());<KAIGYO>//    variableDeclaration(ast->declaration);<KAIGYO>//    int iterator = _block->newTemp();<KAIGYO>//    move(_block->TEMP(iterator), *expression(ast->expression));<KAIGYO>//    IR::ExprList *args = _function->New<IR::ExprList>();<KAIGYO>//    args->init(_block->TEMP(iterator));<KAIGYO>//    move(_block->TEMP(iterator), _block->CALL(_block->NAME(IR::Name::builtin_foreach_iterator_object, 0, 0), args));<KAIGYO>//    _block->JUMP(foreachin);<KAIGYO>//    enterLoop(ast, foreachend, foreachin);<KAIGYO>//    _block = foreachbody;<KAIGYO>//    int temp = _block->newTemp();<KAIGYO>//    move(identifier(ast->declaration->name.toString()), _block->TEMP(temp));<KAIGYO>//    statement(ast->statement);<KAIGYO>//    setJumpOutLocation(_block->JUMP(foreachin), ast->statement, ast->forToken);<KAIGYO>//    _block = foreachin;<KAIGYO>//    args = _function->New<IR::ExprList>();<KAIGYO>//    args->init(_block->TEMP(iterator));<KAIGYO>//    move(_block->TEMP(temp), _block->CALL(_block->NAME(IR::Name::builtin_foreach_next_property_name, 0, 0), args));<KAIGYO>//    int null = _block->newTemp();<KAIGYO>//    move(_block->TEMP(null), _block->CONST(IR::NullType, 0));<KAIGYO>//    setLocation(cjump(_block->BINOP(IR::OpStrictNotEqual, _block->TEMP(temp), _block->TEMP(null)), foreachbody, foreachend), ast->forToken);<KAIGYO>//    _block = foreachend;<KAIGYO>//    leaveLoop();<KAIGYO>//    if (hasError)<KAIGYO>//        return true;<KAIGYO>//    TempScope scope(_function);<KAIGYO>//    IR::BasicBlock *switchend = _function->newBasicBlock(exceptionHandler());<KAIGYO>//    if (ast->block) {<KAIGYO>//        int lhs = _block->newTemp();<KAIGYO>//        move(_block->TEMP(lhs), *expression(ast->expression));<KAIGYO>//        IR::BasicBlock *switchcond = _function->newBasicBlock(exceptionHandler());<KAIGYO>//        _block->JUMP(switchcond);<KAIGYO>//        IR::BasicBlock *previousBlock = 0;<KAIGYO>//        QHash<Node *, IR::BasicBlock *> blockMap;<KAIGYO>//        enterLoop(ast, switchend, 0);<KAIGYO>//        for (CaseClauses *it = ast->block->clauses; it; it = it->next) {<KAIGYO>//            CaseClause *clause = it->clause;<KAIGYO>//            _block = _function->newBasicBlock(exceptionHandler());<KAIGYO>//            blockMap[clause] = _block;<KAIGYO>//            if (previousBlock && !previousBlock->isTerminated())<KAIGYO>//                previousBlock->JUMP(_block);<KAIGYO>//            for (StatementList *it2 = clause->statements; it2; it2 = it2->next)<KAIGYO>//                statement(it2->statement);<KAIGYO>//            previousBlock = _block;<KAIGYO>//        }<KAIGYO>//        if (ast->block->defaultClause) {<KAIGYO>//            _block = _function->newBasicBlock(exceptionHandler());<KAIGYO>//            blockMap[ast->block->defaultClause] = _block;<KAIGYO>//            if (previousBlock && !previousBlock->isTerminated())<KAIGYO>//                previousBlock->JUMP(_block);<KAIGYO>//            for (StatementList *it2 = ast->block->defaultClause->statements; it2; it2 = it2->next)<KAIGYO>//                statement(it2->statement);<KAIGYO>//            previousBlock = _block;<KAIGYO>//        }<KAIGYO>//        for (CaseClauses *it = ast->block->moreClauses; it; it = it->next) {<KAIGYO>//            CaseClause *clause = it->clause;<KAIGYO>//            _block = _function->newBasicBlock(exceptionHandler());<KAIGYO>//            blockMap[clause] = _block;<KAIGYO>//            if (previousBlock && !previousBlock->isTerminated())<KAIGYO>//                previousBlock->JUMP(_block);<KAIGYO>//            for (StatementList *it2 = clause->statements; it2; it2 = it2->next)<KAIGYO>//                statement(it2->statement);<KAIGYO>//            previousBlock = _block;<KAIGYO>//        }<KAIGYO>//        leaveLoop();<KAIGYO>//        _block->JUMP(switchend);<KAIGYO>//        _block = switchcond;<KAIGYO>//        for (CaseClauses *it = ast->block->clauses; it; it = it->next) {<KAIGYO>//            CaseClause *clause = it->clause;<KAIGYO>//            Result rhs = expression(clause->expression);<KAIGYO>//            IR::BasicBlock *iftrue = blockMap[clause];<KAIGYO>//            IR::BasicBlock *iffalse = _function->newBasicBlock(exceptionHandler());<KAIGYO>//            setLocation(cjump(binop(IR::OpStrictEqual, _block->TEMP(lhs), *rhs), iftrue, iffalse), clause->caseToken);<KAIGYO>//            _block = iffalse;<KAIGYO>//        }<KAIGYO>//        for (CaseClauses *it = ast->block->moreClauses; it; it = it->next) {<KAIGYO>//            CaseClause *clause = it->clause;<KAIGYO>//            Result rhs = expression(clause->expression);<KAIGYO>//            IR::BasicBlock *iftrue = blockMap[clause];<KAIGYO>//            IR::BasicBlock *iffalse = _function->newBasicBlock(exceptionHandler());<KAIGYO>//            setLocation(cjump(binop(IR::OpStrictEqual, _block->TEMP(lhs), *rhs), iftrue, iffalse), clause->caseToken);<KAIGYO>//            _block = iffalse;<KAIGYO>//        }<KAIGYO>//        if (DefaultClause *defaultClause = ast->block->defaultClause) {<KAIGYO>//            setLocation(_block->JUMP(blockMap[ast->block->defaultClause]), defaultClause->defaultToken);<KAIGYO>//        }<KAIGYO>//    }<KAIGYO>//    _block->JUMP(switchend);<KAIGYO>//    _block = switchend;': 2, '//### TODO<KAIGYO>//        move(identifier(QStringLiteral(""""), ast->firstSourceLocation().startLine, ast->firstSourceLocation().startColumn),<KAIGYO>//             _block->CALL(_block->NAME(IR::Name::builtin_setup_argument_object,<KAIGYO>//                     ast->firstSourceLocation().startLine, ast->firstSourceLocation().startColumn), 0));': 3, '//### TODO: try constant folding?': 6}",1.0,{'// This hook allows implementing QML lookup semantics': 2},1.0,{}
64,197231.0,8.0,20.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/197231,Fix classic and LE devices discovery,1.0,{},0.0,{'// FIXME: Add required discovery method!': 1},1.0,{}
63,197263.0,3.0,21.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/197263,winrt: Fix tst_QDialog::showFullScreen,1.0,{},0.0,"{'// FIXME: Why not showNormal(), like QWindow::show()?': 1}",1.0,{}
73,197299.0,4.0,5.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/197299,Add array member access,1.0,{'//    _function->newString(ast->name.toString());<KAIGYO>//### TODO': 1},1.0,{'//### TODO': 1},1.0,{}
86,197300.0,5.0,7.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/197300,Support for some more binary and unary operations,1.0,"{'//### TODO: try constant folding?<KAIGYO>//        if (left.isConstant())<KAIGYO>//            std::swap(left, right);<KAIGYO>//        if (right.isConstant()) {<KAIGYO>//            bitAnd.rhs = Primitive::fromReturnedValue(jsUnitGenerator->constant(right.index)).toInteger();<KAIGYO>//        if (left.isConstant())<KAIGYO>//            std::swap(left, right);<KAIGYO>//        if (right.isConstant()) {<KAIGYO>//            bitOr.rhs = Primitive::fromReturnedValue(jsUnitGenerator->constant(right.index)).toInteger();': 1}",1.0,"{'//                return Result(Reference::fromConst(this,<KAIGYO>//                                                   Primitive::fromDouble(!c->value).asReturnedValue()));<KAIGYO>//            case IR::OpUPlus:<KAIGYO>//                return expr;<KAIGYO>//            case IR::OpCompl:<KAIGYO>//                return _block->CONST(IR::NumberType, ~QV4::Primitive::toInt32(c->value));<KAIGYO>//            case IR::OpIncrement:<KAIGYO>//                return _block->CONST(IR::NumberType, c->value + 1);<KAIGYO>//            case IR::OpDecrement:<KAIGYO>//                return _block->CONST(IR::NumberType, c->value - 1);<KAIGYO>//### TODO: try constant folding<KAIGYO>//        if (leftSource->asConst())<KAIGYO>//            qSwap(leftSource, rightSource);<KAIGYO>//        if (IR::Const *c = rightSource->asConst()) {<KAIGYO>//            bitAnd.rhs = convertToValue(c).Value::toInt32();<KAIGYO>//        if (leftSource->asConst())<KAIGYO>//            qSwap(leftSource, rightSource);<KAIGYO>//        if (IR::Const *c = rightSource->asConst()) {<KAIGYO>//            bitOr.rhs = convertToValue(c).Value::toInt32();<KAIGYO>//    if (oper == IR::OpBitXor) {<KAIGYO>//        QV4::Moth::Instruction::BitXor bitXor;<KAIGYO>//        bitXor.lhs = left;<KAIGYO>//        bitXor.rhs = right;<KAIGYO>//        bitXor.result = dest;<KAIGYO>//        bytecodeGenerator->addInstruction(bitXor);<KAIGYO>//        return bitXor.result;<KAIGYO>//    }<KAIGYO>//    if (hasError)<KAIGYO>//        return false;<KAIGYO>//    const unsigned r = _block->newTemp();<KAIGYO>//    TempScope scope(_function);': 1}",1.0,{}
70,197307.0,4.0,4.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/197307,Properly implement Reference::fromMember/fromName,1.0,{},0.0,{'//    _function->newString(ast->name.toString());<KAIGYO>//### TODO': 1},1.0,{}
144,197471.0,5.0,6.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/197471,Simplify function call and new handling,1.0,{},0.0,{'//### TODO: support more calls': 1},1.0,{}
299,197557.0,5.0,12.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/197557,Import WebKit commit 6d0ad27b6bc4209fb8d8cee2692dc0c6a5462051,1.0,"{'// FIXME: Do not even try to reshuffle first letter renderers when we are not in layout<KAIGYO>// until after webkit.org/b/163848 is fixed.': 1, ""// We won't normally run this code. Only when the repaintContainer is null (i.e., we're trying<KAIGYO>// to get the rect in view coordinates) will we come in here, since normally repaintContainer<KAIGYO>// will be set and we'll stop at the flow thread. This case is mainly hit by the check for whether<KAIGYO>// or not images should animate.<KAIGYO>// FIXME: Just as with offsetFromContainer, we aren't really handling objects that span<KAIGYO>// multiple columns properly."": 1, '// FIXME: Do not even try to reposition the marker when we are not in layout': 1}",1.0,"{'// FIXME: Eliminate legacy editing positions<KAIGYO>// FIXME: Eliminate legacy editing positions<KAIGYO>// FIXME: Eliminate legacy editing positions<KAIGYO>// FIXME: Eliminate legacy editing positions': 1, '// FIXME: Do not even try reposition the marker when we are not in layout': 1}",1.0,{}
195,197687.0,7.0,9.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/197687,Cleanup control flow handling,1.0,{},0.0,"{""        enterLoop(ast->statement, &breakLabel, /*continueBlock*/ 0);<KAIGYO>        leaveLoop();<KAIGYO>    enterLoop(ast, &end, &in);<KAIGYO>    enterLoop(ast, &end, &step);<KAIGYO>    leaveLoop();<KAIGYO><KAIGYO>    // Since we're leaving, don't let any finally statements we emit as part of the unwinding<KAIGYO>    // jump to exception handlers at run-time if they throw.<KAIGYO>    //### TODO:<KAIGYO>    IR::BasicBlock *unwindBlock = _function->newBasicBlock(/*no exception handler*/"": 1}",1.0,{}
194,197705.0,2.0,2.0,0.0,ABANDONED,False,https://codereview.qt-project.org/#/c/197705,"xcb: fix builds with XCB_USE_XINPUT2{1,2} and QT_NO_TABLETEVENT",1.0,"{""// FIXME: Don't use XInput2 mouse events when Xinerama extension<KAIGYO>// is enabled, because it causes problems with multi-monitor setup."": 1}",1.0,"{""// FIXME: Don't use XInput2 mouse events when Xinerama extension<KAIGYO>// is enabled, because it causes problems with multi-monitor setup."": 1}",1.0,{}
208,197719.0,9.0,15.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/197719,xcb: fix build failure when XCB_USE_XINPUT22 is not defined,1.0,"{""// FIXME: Don't use XInput2 mouse events when Xinerama extension<KAIGYO>// is enabled, because it causes problems with multi-monitor setup."": 1}",1.0,"{""// FIXME: Don't use XInput2 mouse events when Xinerama extension<KAIGYO>// is enabled, because it causes problems with multi-monitor setup."": 1}",1.0,{}
214,197745.0,6.0,7.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/197745,Fix throwSyntaxErrorOnEvalOrArgumentsInStrictMode,1.0,{},0.0,"{'//        if (throwSyntaxErrorOnEvalOrArgumentsInStrictMode(left, ast->left->lastSourceLocation()))<KAIGYO>//            return false;<KAIGYO>//        if (throwSyntaxErrorOnEvalOrArgumentsInStrictMode(left, ast->left->lastSourceLocation()))<KAIGYO>//            return false;<KAIGYO>// ### check that this converts correctly<KAIGYO>// throwSyntaxError(loc, QStringLiteral(""""));<KAIGYO>//    if (throwSyntaxErrorOnEvalOrArgumentsInStrictMode(*expr, ast->decrementToken))<KAIGYO>//        return false;<KAIGYO>//    if (throwSyntaxErrorOnEvalOrArgumentsInStrictMode(*expr, ast->decrementToken))<KAIGYO>//        return false;<KAIGYO>//### TODO<KAIGYO>//    if (throwSyntaxErrorOnEvalOrArgumentsInStrictMode(*expr, ast->incrementToken))<KAIGYO>//        return false;<KAIGYO>//### TODO<KAIGYO>//    if (throwSyntaxErrorOnEvalOrArgumentsInStrictMode(*expr, ast->incrementToken))<KAIGYO>//        return false;': 1}",1.0,{}
220,197749.0,6.0,7.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/197749,Properly implement the function prologue,1.0,{},0.0,"{'//### TODO<KAIGYO>//        move(identifier(QStringLiteral(""""), ast->firstSourceLocation().startLine, ast->firstSourceLocation().startColumn),<KAIGYO>//             _block->CALL(_block->NAME(IR::Name::builtin_setup_argument_object,<KAIGYO>//                     ast->firstSourceLocation().startLine, ast->firstSourceLocation().startColumn), 0));': 1}",1.0,{}
244,197751.0,6.0,7.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/197751,Get back some line number information,1.0,{},0.0,"{'//### TODO:<KAIGYO>//            setLocation(cjump(*r, r.iftrue, r.iffalse), ast->firstSourceLocation());<KAIGYO>//### TODO:<KAIGYO>//            setLocation(cjump(_block->TEMP(r), iftrue, endif), ast->operatorToken);<KAIGYO>//### TODO:<KAIGYO>//            setLocation(cjump(_block->TEMP(r), endif, iffalse), ast->operatorToken);<KAIGYO>//        setLocation(move(*expr, op), ast->incrementToken);<KAIGYO>//        setLocation(move(*expr, op), ast->incrementToken);<KAIGYO>//###    setLocation(exitBlock->RET(exitBlock->TEMP(returnAddress)), ast->lastSourceLocation());': 1}",1.0,{}
296,197925.0,7.0,18.0,0.0,DEFERRED,False,https://codereview.qt-project.org/#/c/197925,QWindow: Generate synthetic expose events when shrinking window,1.0,"{""// Go through event queue twice, because expose event is sent after resize event.<KAIGYO>// We must be sure that we don't duplicate event in case when QPA sends it anyway."": 5}",1.0,"{'// Exclude plain move<KAIGYO>// One dimension grew -> Windows will send expose, no need to synthesize.': 1}",1.0,{}
295,197963.0,5.0,5.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/197963,Port JSCodeGen in qqmlirbuilder over to new parser,1.0,{'// This hook allows implementing QML lookup semantics': 1},1.0,{'// Make sure the run-time loads this through the more efficient singleton getter.': 1},1.0,{}
285,198514.0,15.0,15.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/198514,Remove unused types on engine destruction,1.0,{},0.0,{'// ### FIXME: sweep unused QQmlType instances': 1},1.0,{}
222,198544.0,5.0,13.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/198544,Merge remote-tracking branch 'origin/dev' into wip/pointerhandler,1.0,{},0.0,{'// TODO after merge of e0c30279ec1fad88346ed3fb483bc3c672fdd01b<KAIGYO>//    auto pointerEvent = QQuickWindowPrivate::pointerEventInstance(touchPointerDevice);': 1},1.0,{}
223,198717.0,2.0,3.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/198717,Merge remote-tracking branch 'origin/dev' into wip/itemviews,1.0,{},0.0,"{'// TODO: default binding to """" can be removed in Qt 6; it only exists for compatibility reasons.': 1}",1.0,{}
311,198719.0,10.0,25.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/198719,Ensure all platforms send geometry events if request was not fulfilled,1.0,"{'// Take care of WM behavior, constrain/modify geometry': 1}",1.0,"{'// FIXME: In the case of the requestedGeometry not matching the actualGeometry due<KAIGYO>// to e.g. the window manager applying restrictions to the geometry, the application<KAIGYO>// will never see a move/resize event if the actualGeometry is the same as the current<KAIGYO>// geometry, and may think the requested geometry was fulfilled.': 1}",1.0,{}
257,198813.0,2.0,4.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/198813,"QLineEdit: Fix length calculation for input mask ""\\\\""",1.0,{},0.0,{'// Really a test for #30447': 1},1.0,{}
297,198847.0,2.0,1.0,0.0,NEW,False,https://codereview.qt-project.org/#/c/198847,WIP: qmlplugindump refactoring,1.0,"{'// Workaround for avoiding conflicting types when no dependency has been found.<KAIGYO>//<KAIGYO>// qmlplugindump used to import QtQuick, so all types defined in QtQuick used to be skipped when dumping.<KAIGYO>// Now that it imports only Qt, it is no longer the case: if no dependency is found all the types defined<KAIGYO>// in QtQuick will be dumped, causing conflicts.': 1, '// TODO: remove any dependency from iostream': 1, '// --<KAIGYO>// TODO: move this definitions  in a better place (it is used also by main.cpp)': 1, '// TODO': 1, ""/* Takes a C++ type name, such as Qt::LayoutDirection or QString and<KAIGYO>   maps it to how it should appear in the description file.<KAIGYO><KAIGYO>   These names need to be unique globally, so we don't change the C++ symbol's<KAIGYO>   name much. It is mostly used to for explicit translations such as<KAIGYO>   QString->string and translations for extended QML objects.<KAIGYO>*/"": 1, '// FIXME: it seems to be always true': 1, ""/* We want to add the MetaObject for 'Qt' to the list, this is a<KAIGYO>   simple way to access it.<KAIGYO>*/"": 1, '// FIXME: creatable seems to be always true': 1}",1.0,"{""/* We want to add the MetaObject for 'Qt' to the list, this is a<KAIGYO>   simple way to access it.<KAIGYO>*/"": 1, ""/* Takes a C++ type name, such as Qt::LayoutDirection or QString and<KAIGYO>   maps it to how it should appear in the description file.<KAIGYO><KAIGYO>   These names need to be unique globally, so we don't change the C++ symbol's<KAIGYO>   name much. It is mostly used to for explicit translations such as<KAIGYO>   QString->string and translations for extended QML objects.<KAIGYO>*/"": 1, '// Workaround for avoiding conflicting types when no dependency has been found.<KAIGYO>//<KAIGYO>// qmlplugindump used to import QtQuick, so all types defined in QtQuick used to be skipped when dumping.<KAIGYO>// Now that it imports only Qt, it is no longer the case: if no dependency is found all the types defined<KAIGYO>// in QtQuick will be dumped, causing conflicts.': 1}",1.0,{}
20,199007.0,3.0,12.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/199007,QFile::rename: use QTemporaryFileName instead of QTemporaryFile,1.0,{},0.0,"{'// This #ifndef disables the workaround it encloses. Therefore, this configuration is not recommended.': 1}",1.0,{}
27,199046.0,2.0,2.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/199046,Move Codegen::ScanFunctions into it's own file,1.0,{'// TODO: give a warning.': 1},1.0,{'// TODO: give a warning.': 1},1.0,{}
124,199228.0,4.0,15.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/199228,Merge remote-tracking branch 'origin/5.9' into dev,1.0,{},0.0,"{'// workaround for bug in QProgressBar': 1, '// Not needed for QtQuick Controls<KAIGYO>//The rect adjustment is a workaround for the menu not really filling its background.': 1, '// Note that setting a saturated color here results in ugly XOR colors in the focus rect': 1, ""/*! \\internal<KAIGYO>    Returns the pointer to a tab widgets body pixmap, scaled to the<KAIGYO>    height of the screen. This way the theme engine doesn't need to<KAIGYO>    scale the body for every time we ask for it. (Speed optimization)<KAIGYO>*/"": 1, ""/*! \\internal<KAIGYO>    Returns \\c true if the part contains any transparency at all. This does<KAIGYO>    not indicate what kind of transparency we're dealing with. It can be<KAIGYO>        - Alpha transparency<KAIGYO>        - Masked transparency<KAIGYO>*/"": 1, '// OLD PSDK Workaround ------------------------------------------------------------------------<KAIGYO>// See if we need extra clipping for the older PSDK, which does<KAIGYO>// not have a DrawThemeBackgroundEx function for DTGB_OMITBORDER<KAIGYO>// and DTGB_OMITCONTENT': 1}",1.0,{}
114,199349.0,9.0,14.0,0.0,DEFERRED,False,https://codereview.qt-project.org/#/c/199349,WIP - prototype HSTS persistent store,1.0,"{'// ???<KAIGYO>// This is a synchronous read, probably will change in future ...': 4}",1.0,"{""// We'd like to avoid constant copying ... but this looks ugly!"": 4}",1.0,{}
250,199408.0,20.0,100.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/199408,configure: Add a feature to write tests in the .json file,1.0,{},0.0,{'// FIXME This workaround can be removed for xcb-icccm > 3.8': 13},1.0,{}
198,199740.0,3.0,29.0,0.0,ABANDONED,False,https://codereview.qt-project.org/#/c/199740,Merge remote-tracking branch 'origin/5.9' into dev,1.0,{},0.0,"{""/*! \\internal<KAIGYO>    Returns the pointer to a tab widgets body pixmap, scaled to the<KAIGYO>    height of the screen. This way the theme engine doesn't need to<KAIGYO>    scale the body for every time we ask for it. (Speed optimization)<KAIGYO>*/"": 2, ""/*! \\internal<KAIGYO>    Returns \\c true if the part contains any transparency at all. This does<KAIGYO>    not indicate what kind of transparency we're dealing with. It can be<KAIGYO>        - Alpha transparency<KAIGYO>        - Masked transparency<KAIGYO>*/"": 2, '// OLD PSDK Workaround ------------------------------------------------------------------------<KAIGYO>// See if we need extra clipping for the older PSDK, which does<KAIGYO>// not have a DrawThemeBackgroundEx function for DTGB_OMITBORDER<KAIGYO>// and DTGB_OMITCONTENT': 2}",1.0,{}
74,200032.0,7.0,8.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/200032,"Introduce an accumulator in the interpreter, and change instructions",1.0,"{'//### temp-to-temp move?': 1, '//### Maybe add a MoveConst instruction for this?': 1, '//### Maybe add a MoveTemp instruction for this?': 1, '//### Maybe create a CreateValueA that takes an accumulator?': 1, '//### is this giving too much overhead?': 1, '// temp-to-temp move': 2}",1.0,"{'//### TODO: try constant folding?': 1, '//### we probably need a write-barrier for instr.source, because it will be written to': 1}",1.0,{}
12,200059.0,2.0,3.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/200059,Merge remote-tracking branch 'origin/5.9' into dev,1.0,{},0.0,"{""/*! \\internal<KAIGYO>    Returns the pointer to a tab widgets body pixmap, scaled to the<KAIGYO>    height of the screen. This way the theme engine doesn't need to<KAIGYO>    scale the body for every time we ask for it. (Speed optimization)<KAIGYO>*/"": 1, ""/*! \\internal<KAIGYO>    Returns \\c true if the part contains any transparency at all. This does<KAIGYO>    not indicate what kind of transparency we're dealing with. It can be<KAIGYO>        - Alpha transparency<KAIGYO>        - Masked transparency<KAIGYO>*/"": 1, '// OLD PSDK Workaround ------------------------------------------------------------------------<KAIGYO>// See if we need extra clipping for the older PSDK, which does<KAIGYO>// not have a DrawThemeBackgroundEx function for DTGB_OMITBORDER<KAIGYO>// and DTGB_OMITCONTENT': 1}",1.0,{}
10,200069.0,4.0,13.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/200069,QFileSystemEngine::fillMetaData: simplify and comment the code,1.0,{},0.0,{'//  FIXME:  Would other queries being performed provide this bit?': 1},1.0,{}
106,200454.0,5.0,11.0,0.0,DEFERRED,False,https://codereview.qt-project.org/#/c/200454,QWindow: Send QShowEvent before creating platform window,1.0,{'// FIXME: Skip this if we create. The create should pick up the<KAIGYO>// visible-property from QWindow on creation.': 1},1.0,"{""// FIXME: At this point we've already updated the visible state of<KAIGYO>// the QWindow, so any platform pulling out the visible state during<KAIGYO>// creation to set on the native window will create a visible window,<KAIGYO>// which may result in resize and expose events before the show event<KAIGYO>// sent below. This code assumes that the platform will set the window<KAIGYO>// to be hidden, until receiving a setVisible call below."": 1}",1.0,{}
219,200999.0,8.0,30.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/200999,Merge remote-tracking branch 'origin/5.9' into dev,1.0,{},0.0,"{'// workaround for bug in QProgressBar': 1, '// Not needed for QtQuick Controls<KAIGYO>//The rect adjustment is a workaround for the menu not really filling its background.': 1, '// Note that setting a saturated color here results in ugly XOR colors in the focus rect': 1, ""/*! \\internal<KAIGYO>    Returns the pointer to a tab widgets body pixmap, scaled to the<KAIGYO>    height of the screen. This way the theme engine doesn't need to<KAIGYO>    scale the body for every time we ask for it. (Speed optimization)<KAIGYO>*/"": 1, ""/*! \\internal<KAIGYO>    Returns \\c true if the part contains any transparency at all. This does<KAIGYO>    not indicate what kind of transparency we're dealing with. It can be<KAIGYO>        - Alpha transparency<KAIGYO>        - Masked transparency<KAIGYO>*/"": 1, '// OLD PSDK Workaround ------------------------------------------------------------------------<KAIGYO>// See if we need extra clipping for the older PSDK, which does<KAIGYO>// not have a DrawThemeBackgroundEx function for DTGB_OMITBORDER<KAIGYO>// and DTGB_OMITCONTENT': 1, ""// We're moving a separator, eat this event"": 1, ""//let's move the separators"": 1}",1.0,{}
73,201372.0,1.0,10.0,0.0,ABANDONED,False,https://codereview.qt-project.org/#/c/201372,configure: remove xcb_icccm.h c++ workaround,1.0,{},0.0,{'// FIXME This workaround can be removed for xcb-icccm > 3.8': 1},1.0,{}
117,201489.0,3.0,5.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/201489,Fix Q(Quick)Window on eglfs,1.0,{},0.0,"{'// Take care of WM behavior, constrain/modify geometry<KAIGYO>// React to the setGeometry, as if from a WM callback': 1}",1.0,{}
145,201549.0,1.0,1.0,0.0,ABANDONED,False,https://codereview.qt-project.org/#/c/201549,Merge remote-tracking branch 'origin/5.9' into dev,1.0,{},0.0,"{'// workaround for bug in QProgressBar': 1, '// Not needed for QtQuick Controls<KAIGYO>//The rect adjustment is a workaround for the menu not really filling its background.': 1, '// Note that setting a saturated color here results in ugly XOR colors in the focus rect': 1, ""/*! \\internal<KAIGYO>    Returns the pointer to a tab widgets body pixmap, scaled to the<KAIGYO>    height of the screen. This way the theme engine doesn't need to<KAIGYO>    scale the body for every time we ask for it. (Speed optimization)<KAIGYO>*/"": 1, ""/*! \\internal<KAIGYO>    Returns \\c true if the part contains any transparency at all. This does<KAIGYO>    not indicate what kind of transparency we're dealing with. It can be<KAIGYO>        - Alpha transparency<KAIGYO>        - Masked transparency<KAIGYO>*/"": 1, '// OLD PSDK Workaround ------------------------------------------------------------------------<KAIGYO>// See if we need extra clipping for the older PSDK, which does<KAIGYO>// not have a DrawThemeBackgroundEx function for DTGB_OMITBORDER<KAIGYO>// and DTGB_OMITCONTENT': 1, ""// We're moving a separator, eat this event"": 1, ""//let's move the separators"": 1}",1.0,{}
43,202044.0,5.0,5.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/202044,Get rid of simpleCall,1.0,{},0.0,{'// ### why copy those on the stack again?': 1},1.0,{}
64,202372.0,3.0,22.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/202372,qmake: make yet more use of ProString::toQStringRef(),1.0,{},0.0,{'// XXX optimize ... somehow': 1},1.0,{}
75,202433.0,2.0,12.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/202433,Remove unnecesary if and dead code,1.0,{'// VERY simple kalman filter: does a weighted average<KAIGYO>// where the older velocities get less and less significant': 1},1.0,{'// VERY simple kalman filter: does a weighted average<KAIGYO>// where the older velocities get less and less significant': 1},1.0,{}
134,202512.0,8.0,36.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/202512,qmake: make argument validation of built-ins data driven,1.0,"{'// FIXME: this is inconsistent with the """" dogma.': 7}",1.0,"{'// FIXME: this is inconsistent with the """" dogma.': 7}",1.0,{}
120,202519.0,2.0,2.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/202519,Cleanup argument handling in contexts,1.0,{},0.0,"{'// iterate backwards, so we get the right ordering for duplicate names': 1}",1.0,{}
135,202559.0,4.0,10.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/202559,Merge remote-tracking branch 'origin/5.9' into dev,1.0,{},0.0,"{""/*! \\internal<KAIGYO>    Returns the pointer to a tab widgets body pixmap, scaled to the<KAIGYO>    height of the screen. This way the theme engine doesn't need to<KAIGYO>    scale the body for every time we ask for it. (Speed optimization)<KAIGYO>*/"": 1, ""/*! \\internal<KAIGYO>    Returns \\c true if the part contains any transparency at all. This does<KAIGYO>    not indicate what kind of transparency we're dealing with. It can be<KAIGYO>        - Alpha transparency<KAIGYO>        - Masked transparency<KAIGYO>*/"": 1, '// OLD PSDK Workaround ------------------------------------------------------------------------<KAIGYO>// See if we need extra clipping for the older PSDK, which does<KAIGYO>// not have a DrawThemeBackgroundEx function for DTGB_OMITBORDER<KAIGYO>// and DTGB_OMITCONTENT': 1}",1.0,{}
119,202590.0,2.0,3.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/202590,Cleanup obsolete TODO in source code,1.0,{},0.0,{'// XXX TODO<KAIGYO>//   - check that the Component.onCompleted behavior is the same as 4.8 in the synchronous and<KAIGYO>//     async if nested cases': 1},1.0,{}
210,202750.0,8.0,8.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/202750,Cleanup object construction instructions,1.0,{'//### Maybe create a ConstructA that takes an accumulator?': 1},1.0,{'//### Maybe create a CreateValueA that takes an accumulator?': 1},1.0,{}
170,202797.0,2.0,14.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/202797,"Revert ""macOS: Create NSView as initially hidden, to match QWindow behavior""",1.0,{},0.0,"{""// FIXME: At this point we've already updated the visible state of<KAIGYO>// the QWindow, so any platform pulling out the visible state during<KAIGYO>// creation to set on the native window will create a visible window,<KAIGYO>// which may result in resize and expose events before the show event<KAIGYO>// sent below. This code assumes that the platform will set the window<KAIGYO>// to be hidden, until receiving a setVisible call below."": 1}",1.0,{}
215,202876.0,4.0,13.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/202876,Support explicit enum value declaration in QML,1.0,{'// ### TODO: AST for initializer': 1},1.0,{'// ### TODO: AST for initializer': 1},1.0,{}
34,203212.0,1.0,2.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/203212,Merge remote-tracking branch 'origin/dev' into wip/new-backend,1.0,{},0.0,"{'// Make sure the run-time loads this through the more efficient singleton getter.': 1, '// iterate backwards, so we get the right ordering for duplicate names': 1}",1.0,{}
43,203245.0,1.0,1.0,0.0,ABANDONED,False,https://codereview.qt-project.org/#/c/203245,more crap,1.0,"{'//    moveAndPress(window.data(), QPoint(150, 150));<KAIGYO>//    // The press should not occur immediately<KAIGYO>//    QVERIFY(!mouseArea->property("""").toBool());<KAIGYO>//    // But, it should occur eventually<KAIGYO>//    QTRY_VERIFY(mouseArea->property("""").toBool());<KAIGYO>//    QCOMPARE(clickedSpy.count(),0);<KAIGYO>//    // On release the clicked signal should be emitted<KAIGYO>//    QTest::mouseRelease(window.data(), Qt::LeftButton, 0, QPoint(150, 150));<KAIGYO>//    QCOMPARE(clickedSpy.count(),1);<KAIGYO>//    // Press and release position should match<KAIGYO>//    QCOMPARE(flickable->property("""").toReal());<KAIGYO>//    QCOMPARE(flickable->property("""").toReal());': 1}",1.0,"{'// But, it should occur eventually': 1}",1.0,{}
105,203360.0,11.0,22.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/203360,Detect doc version number and fix jumping to the proper doc,1.0,"{'// TODO: still, we may like to return the ns for the highest available version': 7}",1.0,{'// TODO: version match heuristics': 7},1.0,{}
132,203632.0,7.0,7.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/203632,Remove the distinction between wide and xwide instructions,1.0,{},0.0,"{'//    // compress all jumps<KAIGYO>//    position = 0;<KAIGYO>//    for (auto &i : instructions) {<KAIGYO>//        i.position = position;<KAIGYO>//        if (i.offsetForJump != -1)<KAIGYO>//            packInstruction(i);<KAIGYO>//        position += i.size;<KAIGYO>//    }<KAIGYO>//    // adjust once again, as the packing above could have changed offsets<KAIGYO>//    adjustJumpOffsets();': 1}",1.0,{}
199,203866.0,2.0,5.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/203866,Split up classes in standalone example,1.0,{},0.0,"{'/*!<KAIGYO>    An instance of this class gets published over the WebChannel and is then accessible to HTML clients.<KAIGYO>*/': 1, '    /*!<KAIGYO>        Note that this slot is private and thus not accessible to HTML clients.<KAIGYO>    */': 1}",1.0,{}
69,204330.0,2.0,5.0,0.0,ABANDONED,False,https://codereview.qt-project.org/#/c/204330,Fix crash in test by actually doing the right thing,1.0,{},0.0,"{'// Clicking on menu should close, we workaround the current<KAIGYO>// implementation event routing of the TestCase suite.<KAIGYO>// We send the event to an item that is child of the menupopupwindow<KAIGYO>// to a a negative coordinate': 1}",1.0,{}
76,204348.0,2.0,7.0,0.0,ABANDONED,False,https://codereview.qt-project.org/#/c/204348,test_clickMenuBar: directly click the menubar by clicking the window,1.0,{},0.0,"{'// Clicking on menu should close, we workaround the current<KAIGYO>// implementation event routing of the TestCase suite.<KAIGYO>// We send the event to an item that is child of the menupopupwindow<KAIGYO>// to a a negative coordinate': 1}",1.0,{}
90,204380.0,4.0,7.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/204380,ModelTest: cleanups,1.0,{},0.0,"{'// While you can technically return a QVariant usually this is a sign<KAIGYO>// of a bug in data().  Disable if this really is ok in your model.<KAIGYO>//            QVERIFY( model->data ( index, Qt::DisplayRole ).isValid() );': 1}",1.0,{}
149,204608.0,1.0,1.0,0.0,ABANDONED,False,https://codereview.qt-project.org/#/c/204608,"DefaultFileDialog: back to single-column ListView, with more details",1.0,{},0.0,"{'// TODO should not need to create a whole new component just to customize the text value<KAIGYO>// something like textFormat: function(text) { return view.model.get(styleData.row, """" : text }': 1}",1.0,{}
184,204744.0,4.0,22.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/204744,QAbstractSocket: remove disconnect timer,1.0,{},0.0,"{'// hack: when we are waiting for the socket engine to write bytes (only<KAIGYO>// possible when using Socks5 or HTTP socket engine), then close<KAIGYO>// anyway after 2 seconds. This is to prevent a timeout on Mac, where we<KAIGYO>// sometimes just did not get the write notifier from the underlying<KAIGYO>// CFSocket and no progress was made.': 1}",1.0,{}
197,204810.0,3.0,13.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/204810,Fix crashes in QML apps when upgrading Qt snapshots,1.0,{'// This is a bit of a hack to make development easier. When hacking on the code generator<KAIGYO>// the cache files may end up being re-used. To avoid that we also add the checksum of<KAIGYO>// the QtQml library.': 1},1.0,{'// This is a bit of a hack to make development easier. When hacking on the code generator<KAIGYO>// the cache files may end up being re-used. To avoid that we also add the checksum of<KAIGYO>// the QtQml library.': 1},1.0,{}
208,204836.0,6.0,6.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/204836,tests: fix and un-blacklist tst_qgraphicsview::hoverLeave,1.0,{},0.0,{'// move the cursor out of the way': 1},1.0,{}
227,204925.0,1.0,2.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/204925,Merge remote-tracking branch 'origin/dev' into wip/new-backend,1.0,{},0.0,"{'    opt.run(qmlEngine, useTypeInference, /*peelLoops =*/ false);<KAIGYO>    if (opt.isInSSA()) {<KAIGYO>        static const bool doStackSlotAllocation =<KAIGYO>                qEnvironmentVariableIsEmpty("""");<KAIGYO><KAIGYO>        if (doStackSlotAllocation) {<KAIGYO>            IR::AllocateStackSlots(opt.lifeTimeIntervals()).forFunction(_function);<KAIGYO>        } else {<KAIGYO>            opt.convertOutOfSSA();<KAIGYO>            ConvertTemps().toStackSlots(_function);<KAIGYO>        }<KAIGYO>        opt.showMeTheCode(_function, """");<KAIGYO>    } else {<KAIGYO>        ConvertTemps().toStackSlots(_function);<KAIGYO>    }<KAIGYO><KAIGYO>    BitVector removableJumps = opt.calculateOptionalJumps();<KAIGYO>    qSwap(_removableJumps, removableJumps);<KAIGYO><KAIGYO>    IR::Stmt *cs = 0;<KAIGYO>    qSwap(_currentStatement, cs);<KAIGYO><KAIGYO>    int locals = frameSize();<KAIGYO>    Q_ASSERT(locals >= 0);<KAIGYO><KAIGYO>    IR::BasicBlock *exceptionHandler = 0;<KAIGYO><KAIGYO>    Instruction::Push push;<KAIGYO>    push.value = quint32(locals);<KAIGYO>    addInstruction(push);<KAIGYO><KAIGYO>    currentLine = 0;<KAIGYO>    const QVector<IR::BasicBlock *> &basicBlocks = _function->basicBlocks();<KAIGYO>    for (int i = 0, ei = basicBlocks.size(); i != ei; ++i) {<KAIGYO>        blockNeedsDebugInstruction = irModule->debugMode;<KAIGYO>        _block = basicBlocks[i];<KAIGYO>        _nextBlock = (i < ei - 1) ? basicBlocks[i + 1] : 0;<KAIGYO>        _addrs.insert(_block, _codeNext - _codeStart);<KAIGYO><KAIGYO>        if (_block->catchBlock != exceptionHandler) {<KAIGYO>            Instruction::SetExceptionHandler set;<KAIGYO>            set.offset = 0;<KAIGYO>            if (_block->catchBlock) {<KAIGYO>                ptrdiff_t loc = addInstruction(set) + (((const char *)&set.offset) - ((const char *)&set));<KAIGYO>                _patches[_block->catchBlock].append(loc);<KAIGYO>            } else {<KAIGYO>                addInstruction(set);<KAIGYO>            }<KAIGYO>            exceptionHandler = _block->catchBlock;<KAIGYO>        } else if (_block->catchBlock == nullptr && _block->index() != 0 && _block->in.isEmpty()) {<KAIGYO>            exceptionHandler = nullptr;<KAIGYO>            Instruction::SetExceptionHandler set;<KAIGYO>            set.offset = 0;<KAIGYO>            addInstruction(set);<KAIGYO>        }<KAIGYO><KAIGYO>        for (IR::Stmt *s : _block->statements()) {<KAIGYO>            _currentStatement = s;<KAIGYO><KAIGYO>            if (s->location.isValid()) {<KAIGYO>                if (s->location.startLine != currentLine) {<KAIGYO>                    blockNeedsDebugInstruction = false;<KAIGYO>                    currentLine = s->location.startLine;<KAIGYO>#ifndef QT_NO_QML_DEBUGGER<KAIGYO>                    if (irModule->debugMode) {<KAIGYO>                        Instruction::Debug debug;<KAIGYO>                        debug.lineNumber = currentLine;<KAIGYO>                        addInstruction(debug);<KAIGYO>                    } else {<KAIGYO>                        Instruction::Line line;<KAIGYO>                        line.lineNumber = currentLine;<KAIGYO>                        addInstruction(line);<KAIGYO>                    }<KAIGYO>#endif<KAIGYO>                }<KAIGYO>            }<KAIGYO><KAIGYO>            visit(s);<KAIGYO>        }<KAIGYO>    }<KAIGYO><KAIGYO>    // TODO: patch stack size (the push instruction)<KAIGYO>    patchJumpAddresses();<KAIGYO><KAIGYO>    codeRefs.insert(_function, squeezeCode());<KAIGYO><KAIGYO>    qSwap(_currentStatement, cs);<KAIGYO>    qSwap(_removableJumps, removableJumps);<KAIGYO>    qSwap(_function, function);<KAIGYO>    qSwap(block, _block);<KAIGYO>    qSwap(nextBlock, _nextBlock);<KAIGYO>    qSwap(patches, _patches);<KAIGYO>    qSwap(addrs, _addrs);<KAIGYO>    qSwap(codeStart, _codeStart);<KAIGYO>    qSwap(codeNext, _codeNext);<KAIGYO>    qSwap(codeEnd, _codeEnd);<KAIGYO><KAIGYO>    delete[] codeStart;<KAIGYO>}<KAIGYO><KAIGYO>QQmlRefPointer<QV4::CompiledData::CompilationUnit> InstructionSelection::backendCompileStep()<KAIGYO>{<KAIGYO>    compilationUnit->codeRefs.resize(irModule->functions.size());<KAIGYO>    int i = 0;<KAIGYO>    for (IR::Function *irFunction : qAsConst(irModule->functions))<KAIGYO>        compilationUnit->codeRefs[i++] = codeRefs[irFunction];<KAIGYO>    QQmlRefPointer<QV4::CompiledData::CompilationUnit> result;<KAIGYO>    result.adopt(compilationUnit.take());<KAIGYO>    return result;<KAIGYO>}<KAIGYO><KAIGYO>void InstructionSelection::callValue(IR::Expr *value, IR::ExprList *args, IR::Expr *result)<KAIGYO>{<KAIGYO>    Instruction::CallValue call;<KAIGYO>    prepareCallArgs(args, call.argc);<KAIGYO>    call.callData = callDataStart();<KAIGYO>    call.dest = getParam(value);<KAIGYO>    call.result = getResultParam(result);<KAIGYO>    addInstruction(call);<KAIGYO>}<KAIGYO><KAIGYO>void InstructionSelection::callQmlContextProperty(IR::Expr *base, IR::Member::MemberKind kind, int propertyIndex, IR::ExprList *args, IR::Expr *result)<KAIGYO>{<KAIGYO>    if (kind == IR::Member::MemberOfQmlScopeObject) {<KAIGYO>        Instruction::CallScopeObjectProperty call;<KAIGYO>        call.base = getParam(base);<KAIGYO>        call.index = propertyIndex;<KAIGYO>        prepareCallArgs(args, call.argc);<KAIGYO>        call.callData = callDataStart();<KAIGYO>        call.result = getResultParam(result);<KAIGYO>        addInstruction(call);<KAIGYO>    } else if (kind == IR::Member::MemberOfQmlContextObject) {<KAIGYO>        Instruction::CallContextObjectProperty call;<KAIGYO>        call.base = getParam(base);<KAIGYO>        call.index = propertyIndex;<KAIGYO>        prepareCallArgs(args, call.argc);<KAIGYO>        call.callData = callDataStart();<KAIGYO>        call.result = getResultParam(result);<KAIGYO>        addInstruction(call);<KAIGYO>    } else {<KAIGYO>        Q_ASSERT(false);<KAIGYO>    }<KAIGYO>}<KAIGYO><KAIGYO>void InstructionSelection::callProperty(IR::Expr *base, const QString &name, IR::ExprList *args,<KAIGYO>                                        IR::Expr *result)<KAIGYO>{<KAIGYO>    if (useFastLookups) {<KAIGYO>        Instruction::CallPropertyLookup call;<KAIGYO>        call.base = getParam(base);<KAIGYO>        call.lookupIndex = registerGetterLookup(name);<KAIGYO>        prepareCallArgs(args, call.argc);<KAIGYO>        call.callData = callDataStart();<KAIGYO>        call.result = getResultParam(result);<KAIGYO>        addInstruction(call);<KAIGYO>    } else {<KAIGYO>        // call the property on the loaded base<KAIGYO>        Instruction::CallProperty call;<KAIGYO>        call.base = getParam(base);<KAIGYO>        call.name = registerString(name);<KAIGYO>        prepareCallArgs(args, call.argc);<KAIGYO>        call.callData = callDataStart();<KAIGYO>        call.result = getResultParam(result);<KAIGYO>        addInstruction(call);<KAIGYO>    }<KAIGYO>}<KAIGYO><KAIGYO>void InstructionSelection::callSubscript(IR::Expr *base, IR::Expr *index, IR::ExprList *args,<KAIGYO>                                         IR::Expr *result)<KAIGYO>{<KAIGYO>    // call the property on the loaded base<KAIGYO>    Instruction::CallElement call;<KAIGYO>    call.base = getParam(base);<KAIGYO>    call.index = getParam(index);<KAIGYO>    prepareCallArgs(args, call.argc);<KAIGYO>    call.callData = callDataStart();<KAIGYO>    call.result = getResultParam(result);<KAIGYO>    addInstruction(call);<KAIGYO>}<KAIGYO><KAIGYO>void InstructionSelection::convertType(IR::Expr *source, IR::Expr *target)<KAIGYO>{<KAIGYO>    // FIXME: do something more useful with this info<KAIGYO>    if (target->type & IR::NumberType && !(source->type & IR::NumberType))<KAIGYO>        unop(IR::OpUPlus, source, target);<KAIGYO>    else<KAIGYO>        copyValue(source, target);<KAIGYO>}<KAIGYO><KAIGYO>void InstructionSelection::constructActivationProperty(IR::Name *func,<KAIGYO>                                                       IR::ExprList *args,<KAIGYO>                                                       IR::Expr *target)<KAIGYO>{<KAIGYO>    if (useFastLookups && func->global) {<KAIGYO>        Instruction::ConstructGlobalLookup call;<KAIGYO>        call.index = registerGlobalGetterLookup(*func->id);<KAIGYO>        prepareCallArgs(args, call.argc);<KAIGYO>        call.callData = callDataStart();<KAIGYO>        call.result = getResultParam(target);<KAIGYO>        addInstruction(call);<KAIGYO>        return;<KAIGYO>    }<KAIGYO>    Instruction::CreateActivationProperty create;<KAIGYO>    create.name = registerString(*func->id);<KAIGYO>    prepareCallArgs(args, create.argc);<KAIGYO>    create.callData = callDataStart();<KAIGYO>    create.result = getResultParam(target);<KAIGYO>    addInstruction(create);<KAIGYO>}<KAIGYO><KAIGYO>void InstructionSelection::constructProperty(IR::Expr *base, const QString &name, IR::ExprList *args, IR::Expr *target)<KAIGYO>{<KAIGYO>    if (useFastLookups) {<KAIGYO>        Instruction::ConstructPropertyLookup call;<KAIGYO>        call.base = getParam(base);<KAIGYO>        call.index = registerGetterLookup(name);<KAIGYO>        prepareCallArgs(args, call.argc);<KAIGYO>        call.callData = callDataStart();<KAIGYO>        call.result = getResultParam(target);<KAIGYO>        addInstruction(call);<KAIGYO>        return;<KAIGYO>    }<KAIGYO>    Instruction::CreateProperty create;<KAIGYO>    create.base = getParam(base);<KAIGYO>    create.name = registerString(name);<KAIGYO>    prepareCallArgs(args, create.argc);<KAIGYO>    create.callData = callDataStart();<KAIGYO>    create.result = getResultParam(target);<KAIGYO>    addInstruction(create);<KAIGYO>}<KAIGYO><KAIGYO>void InstructionSelection::constructValue(IR::Expr *value, IR::ExprList *args, IR::Expr *target)<KAIGYO>{<KAIGYO>    Instruction::CreateValue create;<KAIGYO>    create.func = getParam(value);<KAIGYO>    prepareCallArgs(args, create.argc);<KAIGYO>    create.callData = callDataStart();<KAIGYO>    create.result = getResultParam(target);<KAIGYO>    addInstruction(create);<KAIGYO>}<KAIGYO><KAIGYO>void InstructionSelection::loadThisObject(IR::Expr *e)<KAIGYO>{<KAIGYO>    Instruction::LoadThis load;<KAIGYO>    load.result = getResultParam(e);<KAIGYO>    addInstruction(load);<KAIGYO>}<KAIGYO><KAIGYO>void InstructionSelection::loadQmlContext(IR::Expr *e)<KAIGYO>{<KAIGYO>    Instruction::LoadQmlContext load;<KAIGYO>    load.result = getResultParam(e);<KAIGYO>    addInstruction(load);<KAIGYO>}<KAIGYO><KAIGYO>void InstructionSelection::loadQmlImportedScripts(IR::Expr *e)<KAIGYO>{<KAIGYO>    Instruction::LoadQmlImportedScripts load;<KAIGYO>    load.result = getResultParam(e);<KAIGYO>    addInstruction(load);<KAIGYO>}<KAIGYO><KAIGYO>void InstructionSelection::loadQmlSingleton(const QString &name, IR::Expr *e)<KAIGYO>{<KAIGYO>    Instruction::LoadQmlSingleton load;<KAIGYO>    load.result = getResultParam(e);<KAIGYO>    load.name = registerString(name);<KAIGYO>    addInstruction(load);<KAIGYO>}<KAIGYO><KAIGYO>void InstructionSelection::loadConst(IR::Const *sourceConst, IR::Expr *e)<KAIGYO>{<KAIGYO>    Q_ASSERT(sourceConst);<KAIGYO><KAIGYO>    Instruction::MoveConst move;<KAIGYO>    move.source = convertToValue(sourceConst).asReturnedValue();<KAIGYO>    move.result = getResultParam(e);<KAIGYO>    addInstruction(move);<KAIGYO>}<KAIGYO><KAIGYO>void InstructionSelection::loadString(const QString &str, IR::Expr *target)<KAIGYO>{<KAIGYO>    Instruction::LoadRuntimeString load;<KAIGYO>    load.stringId = registerString(str);<KAIGYO>    load.result = getResultParam(target);<KAIGYO>    addInstruction(load);<KAIGYO>}<KAIGYO><KAIGYO>void InstructionSelection::loadRegexp(IR::RegExp *sourceRegexp, IR::Expr *target)<KAIGYO>{<KAIGYO>    Instruction::LoadRegExp load;<KAIGYO>    load.regExpId = registerRegExp(sourceRegexp);<KAIGYO>    load.result = getResultParam(target);<KAIGYO>    addInstruction(load);<KAIGYO>}<KAIGYO><KAIGYO>void InstructionSelection::getActivationProperty(const IR::Name *name, IR::Expr *target)<KAIGYO>{<KAIGYO>    if (useFastLookups && name->global) {<KAIGYO>        Instruction::GetGlobalLookup load;<KAIGYO>        load.index = registerGlobalGetterLookup(*name->id);<KAIGYO>        load.result = getResultParam(target);<KAIGYO>        addInstruction(load);<KAIGYO>        return;<KAIGYO>    }<KAIGYO>    Instruction::LoadName load;<KAIGYO>    load.name = registerString(*name->id);<KAIGYO>    load.result = getResultParam(target);<KAIGYO>    addInstruction(load);<KAIGYO>}<KAIGYO><KAIGYO>void InstructionSelection::setActivationProperty(IR::Expr *source, const QString &targetName)<KAIGYO>{<KAIGYO>    Instruction::StoreName store;<KAIGYO>    store.source = getParam(source);<KAIGYO>    store.name = registerString(targetName);<KAIGYO>    addInstruction(store);<KAIGYO>}<KAIGYO><KAIGYO>void InstructionSelection::initClosure(IR::Closure *closure, IR::Expr *target)<KAIGYO>{<KAIGYO>    int id = closure->value;<KAIGYO>    Instruction::LoadClosure load;<KAIGYO>    load.value = id;<KAIGYO>    load.result = getResultParam(target);<KAIGYO>    addInstruction(load);<KAIGYO>}<KAIGYO><KAIGYO>void InstructionSelection::getProperty(IR::Expr *base, const QString &name, IR::Expr *target)<KAIGYO>{<KAIGYO>    if (useFastLookups) {<KAIGYO>        Instruction::GetLookup load;<KAIGYO>        load.base = getParam(base);<KAIGYO>        load.index = registerGetterLookup(name);<KAIGYO>        load.result = getResultParam(target);<KAIGYO>        addInstruction(load);<KAIGYO>        return;<KAIGYO>    }<KAIGYO>    Instruction::LoadProperty load;<KAIGYO>    load.base = getParam(base);<KAIGYO>    load.name = registerString(name);<KAIGYO>    load.result = getResultParam(target);<KAIGYO>    addInstruction(load);<KAIGYO>}<KAIGYO><KAIGYO>void InstructionSelection::setProperty(IR::Expr *source, IR::Expr *targetBase,<KAIGYO>                                       const QString &targetName)<KAIGYO>{<KAIGYO>    if (useFastLookups) {<KAIGYO>        Instruction::SetLookup store;<KAIGYO>        store.base = getParam(targetBase);<KAIGYO>        store.index = registerSetterLookup(targetName);<KAIGYO>        store.source = getParam(source);<KAIGYO>        addInstruction(store);<KAIGYO>        return;<KAIGYO>    }<KAIGYO>    Instruction::StoreProperty store;<KAIGYO>    store.base = getParam(targetBase);<KAIGYO>    store.name = registerString(targetName);<KAIGYO>    store.source = getParam(source);<KAIGYO>    addInstruction(store);<KAIGYO>}<KAIGYO><KAIGYO>void InstructionSelection::setQmlContextProperty(IR::Expr *source, IR::Expr *targetBase, IR::Member::MemberKind kind, int propertyIndex)<KAIGYO>{<KAIGYO>    if (kind == IR::Member::MemberOfQmlScopeObject) {<KAIGYO>        Instruction::StoreScopeObjectProperty store;<KAIGYO>        store.base = getParam(targetBase);<KAIGYO>        store.propertyIndex = propertyIndex;<KAIGYO>        store.source = getParam(source);<KAIGYO>        addInstruction(store);<KAIGYO>    } else if (kind == IR::Member::MemberOfQmlContextObject) {<KAIGYO>        Instruction::StoreContextObjectProperty store;<KAIGYO>        store.base = getParam(targetBase);<KAIGYO>        store.propertyIndex = propertyIndex;<KAIGYO>        store.source = getParam(source);<KAIGYO>        addInstruction(store);<KAIGYO>    } else {<KAIGYO>        Q_ASSERT(false);<KAIGYO>    }<KAIGYO>}<KAIGYO><KAIGYO>void InstructionSelection::setQObjectProperty(IR::Expr *source, IR::Expr *targetBase, int propertyIndex)<KAIGYO>{<KAIGYO>    Instruction::StoreQObjectProperty store;<KAIGYO>    store.base = getParam(targetBase);<KAIGYO>    store.propertyIndex = propertyIndex;<KAIGYO>    store.source = getParam(source);<KAIGYO>    addInstruction(store);<KAIGYO>}<KAIGYO><KAIGYO>void InstructionSelection::getQmlContextProperty(IR::Expr *source, IR::Member::MemberKind kind, int index, bool captureRequired, IR::Expr *target)<KAIGYO>{<KAIGYO>    if (kind == IR::Member::MemberOfQmlScopeObject) {<KAIGYO>        Instruction::LoadScopeObjectProperty load;<KAIGYO>        load.base = getParam(source);<KAIGYO>        load.propertyIndex = index;<KAIGYO>        load.captureRequired = captureRequired;<KAIGYO>        load.result = getResultParam(target);<KAIGYO>        addInstruction(load);<KAIGYO>    } else if (kind == IR::Member::MemberOfQmlContextObject) {<KAIGYO>        Instruction::LoadContextObjectProperty load;<KAIGYO>        load.base = getParam(source);<KAIGYO>        load.propertyIndex = index;<KAIGYO>        load.captureRequired = captureRequired;<KAIGYO>        load.result = getResultParam(target);<KAIGYO>        addInstruction(load);<KAIGYO>    } else if (kind == IR::Member::MemberOfIdObjectsArray) {<KAIGYO>        Instruction::LoadIdObject load;<KAIGYO>        load.base = getParam(source);<KAIGYO>        load.index = index;<KAIGYO>        load.result = getResultParam(target);<KAIGYO>        addInstruction(load);<KAIGYO>    } else {<KAIGYO>        Q_ASSERT(false);<KAIGYO>    }<KAIGYO>}<KAIGYO><KAIGYO>void InstructionSelection::getQObjectProperty(IR::Expr *base, int propertyIndex, bool captureRequired, bool isSingletonProperty, int attachedPropertiesId, IR::Expr *target)<KAIGYO>{<KAIGYO>    if (attachedPropertiesId != 0) {<KAIGYO>        Instruction::LoadAttachedQObjectProperty load;<KAIGYO>        load.propertyIndex = propertyIndex;<KAIGYO>        load.result = getResultParam(target);<KAIGYO>        load.attachedPropertiesId = attachedPropertiesId;<KAIGYO>        addInstruction(load);<KAIGYO>    } else if (isSingletonProperty) {<KAIGYO>        Instruction::LoadSingletonQObjectProperty load;<KAIGYO>        load.base = getParam(base);<KAIGYO>        load.propertyIndex = propertyIndex;<KAIGYO>        load.result = getResultParam(target);<KAIGYO>        load.captureRequired = captureRequired;<KAIGYO>        addInstruction(load);<KAIGYO>    } else {<KAIGYO>        Instruction::LoadQObjectProperty load;<KAIGYO>        load.base = getParam(base);<KAIGYO>        load.propertyIndex = propertyIndex;<KAIGYO>        load.result = getResultParam(target);<KAIGYO>        load.captureRequired = captureRequired;<KAIGYO>        addInstruction(load);<KAIGYO>    }<KAIGYO>}<KAIGYO><KAIGYO>void InstructionSelection::getElement(IR::Expr *base, IR::Expr *index, IR::Expr *target)<KAIGYO>{<KAIGYO>    if (0 && useFastLookups) {<KAIGYO>        Instruction::LoadElementLookup load;<KAIGYO>        load.lookup = registerIndexedGetterLookup();<KAIGYO>        load.base = getParam(base);<KAIGYO>        load.index = getParam(index);<KAIGYO>        load.result = getResultParam(target);<KAIGYO>        addInstruction(load);<KAIGYO>        return;<KAIGYO>    }<KAIGYO>    Instruction::LoadElement load;<KAIGYO>    load.base = getParam(base);<KAIGYO>    load.index = getParam(index);<KAIGYO>    load.result = getResultParam(target);<KAIGYO>    addInstruction(load);<KAIGYO>}<KAIGYO><KAIGYO>void InstructionSelection::setElement(IR::Expr *source, IR::Expr *targetBase,<KAIGYO>                                      IR::Expr *targetIndex)<KAIGYO>{<KAIGYO>    if (0 && useFastLookups) {<KAIGYO>        Instruction::StoreElementLookup store;<KAIGYO>        store.lookup = registerIndexedSetterLookup();<KAIGYO>        store.base = getParam(targetBase);<KAIGYO>        store.index = getParam(targetIndex);<KAIGYO>        store.source = getParam(source);<KAIGYO>        addInstruction(store);<KAIGYO>        return;<KAIGYO>    }<KAIGYO>    Instruction::StoreElement store;<KAIGYO>    store.base = getParam(targetBase);<KAIGYO>    store.index = getParam(targetIndex);<KAIGYO>    store.source = getParam(source);<KAIGYO>    addInstruction(store);<KAIGYO>}<KAIGYO><KAIGYO>void InstructionSelection::copyValue(IR::Expr *source, IR::Expr *target)<KAIGYO>{<KAIGYO>    Instruction::Move move;<KAIGYO>    move.source = getParam(source);<KAIGYO>    move.result = getResultParam(target);<KAIGYO>    if (move.source != move.result)<KAIGYO>        addInstruction(move);<KAIGYO>}<KAIGYO><KAIGYO>void InstructionSelection::swapValues(IR::Expr *source, IR::Expr *target)<KAIGYO>{<KAIGYO>    Instruction::SwapTemps swap;<KAIGYO>    swap.left = getParam(source);<KAIGYO>    swap.right = getParam(target);<KAIGYO>    addInstruction(swap);<KAIGYO>}<KAIGYO><KAIGYO>void InstructionSelection::unop(IR::AluOp oper, IR::Expr *source, IR::Expr *target)<KAIGYO>{<KAIGYO>    switch (oper) {<KAIGYO>    case IR::OpIfTrue:<KAIGYO>        Q_ASSERT(!""""); break;<KAIGYO>    case IR::OpNot: {<KAIGYO>        // ### enabling this fails in some cases, where apparently the value is not a bool at runtime<KAIGYO>        if (0 && isBoolType(source)) {<KAIGYO>            Instruction::UNotBool unot;<KAIGYO>            unot.source = getParam(source);<KAIGYO>            unot.result = getResultParam(target);<KAIGYO>            addInstruction(unot);<KAIGYO>            return;<KAIGYO>        }<KAIGYO>        Instruction::UNot unot;<KAIGYO>        unot.source = getParam(source);<KAIGYO>        unot.result = getResultParam(target);<KAIGYO>        addInstruction(unot);<KAIGYO>        return;<KAIGYO>    }<KAIGYO>    case IR::OpUMinus: {<KAIGYO>        Instruction::UMinus uminus;<KAIGYO>        uminus.source = getParam(source);<KAIGYO>        uminus.result = getResultParam(target);<KAIGYO>        addInstruction(uminus);<KAIGYO>        return;<KAIGYO>    }<KAIGYO>    case IR::OpUPlus: {<KAIGYO>        if (isNumberType(source)) {<KAIGYO>            // use a move<KAIGYO>            Instruction::Move move;<KAIGYO>            move.source = getParam(source);<KAIGYO>            move.result = getResultParam(target);<KAIGYO>            if (move.source != move.result)<KAIGYO>                addInstruction(move);<KAIGYO>            return;<KAIGYO>        }<KAIGYO>        Instruction::UPlus uplus;<KAIGYO>        uplus.source = getParam(source);<KAIGYO>        uplus.result = getResultParam(target);<KAIGYO>        addInstruction(uplus);<KAIGYO>        return;<KAIGYO>    }<KAIGYO>    case IR::OpCompl: {<KAIGYO>        // ### enabling this fails in some cases, where apparently the value is not a int at runtime<KAIGYO>        if (0 && isIntegerType(source)) {<KAIGYO>            Instruction::UComplInt unot;<KAIGYO>            unot.source = getParam(source);<KAIGYO>            unot.result = getResultParam(target);<KAIGYO>            addInstruction(unot);<KAIGYO>            return;<KAIGYO>        }<KAIGYO>        Instruction::UCompl ucompl;<KAIGYO>        ucompl.source = getParam(source);<KAIGYO>        ucompl.result = getResultParam(target);<KAIGYO>        addInstruction(ucompl);<KAIGYO>        return;<KAIGYO>    }<KAIGYO>    case IR::OpIncrement: {<KAIGYO>        Instruction::Increment inc;<KAIGYO>        inc.source = getParam(source);<KAIGYO>        inc.result = getResultParam(target);<KAIGYO>        addInstruction(inc);<KAIGYO>        return;<KAIGYO>    }<KAIGYO>    case IR::OpDecrement: {<KAIGYO>        Instruction::Decrement dec;<KAIGYO>        dec.source = getParam(source);<KAIGYO>        dec.result = getResultParam(target);<KAIGYO>        addInstruction(dec);<KAIGYO>        return;<KAIGYO>    }<KAIGYO>    default:  break;<KAIGYO>    } // switch<KAIGYO><KAIGYO>    Q_ASSERT(!"""");<KAIGYO>}<KAIGYO><KAIGYO>void InstructionSelection::binop(IR::AluOp oper, IR::Expr *leftSource, IR::Expr *rightSource, IR::Expr *target)<KAIGYO>{<KAIGYO>    binopHelper(oper, leftSource, rightSource, target);<KAIGYO>}<KAIGYO><KAIGYO>Param InstructionSelection::binopHelper(IR::AluOp oper, IR::Expr *leftSource, IR::Expr *rightSource, IR::Expr *target)<KAIGYO>{<KAIGYO>    if (oper == IR::OpAdd) {<KAIGYO>        Instruction::Add add;<KAIGYO>        add.lhs = getParam(leftSource);<KAIGYO>        add.rhs = getParam(rightSource);<KAIGYO>        add.result = getResultParam(target);<KAIGYO>        addInstruction(add);<KAIGYO>        return add.result;<KAIGYO>    }<KAIGYO>    if (oper == IR::OpSub) {<KAIGYO>        Instruction::Sub sub;<KAIGYO>        sub.lhs = getParam(leftSource);<KAIGYO>        sub.rhs = getParam(rightSource);<KAIGYO>        sub.result = getResultParam(target);<KAIGYO>        addInstruction(sub);<KAIGYO>        return sub.result;<KAIGYO>    }<KAIGYO>    if (oper == IR::OpMul) {<KAIGYO>        Instruction::Mul mul;<KAIGYO>        mul.lhs = getParam(leftSource);<KAIGYO>        mul.rhs = getParam(rightSource);<KAIGYO>        mul.result = getResultParam(target);<KAIGYO>        addInstruction(mul);<KAIGYO>        return mul.result;<KAIGYO>    }<KAIGYO>    if (oper == IR::OpBitAnd) {<KAIGYO>        if (leftSource->asConst())<KAIGYO>            qSwap(leftSource, rightSource);<KAIGYO>        if (IR::Const *c = rightSource->asConst()) {<KAIGYO>            Instruction::BitAndConst bitAnd;<KAIGYO>            bitAnd.lhs = getParam(leftSource);<KAIGYO>            bitAnd.rhs = convertToValue(c).Value::toInt32();<KAIGYO>            bitAnd.result = getResultParam(target);<KAIGYO>            addInstruction(bitAnd);<KAIGYO>            return bitAnd.result;<KAIGYO>        }<KAIGYO>        Instruction::BitAnd bitAnd;<KAIGYO>        bitAnd.lhs = getParam(leftSource);<KAIGYO>        bitAnd.rhs = getParam(rightSource);<KAIGYO>        bitAnd.result = getResultParam(target);<KAIGYO>        addInstruction(bitAnd);<KAIGYO>        return bitAnd.result;<KAIGYO>    }<KAIGYO>    if (oper == IR::OpBitOr) {<KAIGYO>        if (leftSource->asConst())<KAIGYO>            qSwap(leftSource, rightSource);<KAIGYO>        if (IR::Const *c = rightSource->asConst()) {<KAIGYO>            Instruction::BitOrConst bitOr;<KAIGYO>            bitOr.lhs = getParam(leftSource);<KAIGYO>            bitOr.rhs = convertToValue(c).Value::toInt32();<KAIGYO>            bitOr.result = getResultParam(target);<KAIGYO>            addInstruction(bitOr);<KAIGYO>            return bitOr.result;<KAIGYO>        }<KAIGYO>        Instruction::BitOr bitOr;<KAIGYO>        bitOr.lhs = getParam(leftSource);<KAIGYO>        bitOr.rhs = getParam(rightSource);<KAIGYO>        bitOr.result = getResultParam(target);<KAIGYO>        addInstruction(bitOr);<KAIGYO>        return bitOr.result;<KAIGYO>    }<KAIGYO>    if (oper == IR::OpBitXor) {<KAIGYO>        if (leftSource->asConst())<KAIGYO>            qSwap(leftSource, rightSource);<KAIGYO>        if (IR::Const *c = rightSource->asConst()) {<KAIGYO>            Instruction::BitXorConst bitXor;<KAIGYO>            bitXor.lhs = getParam(leftSource);<KAIGYO>            bitXor.rhs = convertToValue(c).Value::toInt32();<KAIGYO>            bitXor.result = getResultParam(target);<KAIGYO>            addInstruction(bitXor);<KAIGYO>            return bitXor.result;<KAIGYO>        }<KAIGYO>        Instruction::BitXor bitXor;<KAIGYO>        bitXor.lhs = getParam(leftSource);<KAIGYO>        bitXor.rhs = getParam(rightSource);<KAIGYO>        bitXor.result = getResultParam(target);<KAIGYO>        addInstruction(bitXor);<KAIGYO>        return bitXor.result;<KAIGYO>    }<KAIGYO>    if (oper == IR::OpRShift) {<KAIGYO>        if (IR::Const *c = rightSource->asConst()) {<KAIGYO>            Instruction::ShrConst shr;<KAIGYO>            shr.lhs = getParam(leftSource);<KAIGYO>            shr.rhs = convertToValue(c).Value::toInt32() & 0x1f;<KAIGYO>            shr.result = getResultParam(target);<KAIGYO>            addInstruction(shr);<KAIGYO>            return shr.result;<KAIGYO>        }<KAIGYO>        Instruction::Shr shr;<KAIGYO>        shr.lhs = getParam(leftSource);<KAIGYO>        shr.rhs = getParam(rightSource);<KAIGYO>        shr.result = getResultParam(target);<KAIGYO>        addInstruction(shr);<KAIGYO>        return shr.result;<KAIGYO>    }<KAIGYO>    if (oper == IR::OpLShift) {<KAIGYO>        if (IR::Const *c = rightSource->asConst()) {<KAIGYO>            Instruction::ShlConst shl;<KAIGYO>            shl.lhs = getParam(leftSource);<KAIGYO>            shl.rhs = convertToValue(c).Value::toInt32() & 0x1f;<KAIGYO>            shl.result = getResultParam(target);<KAIGYO>            addInstruction(shl);<KAIGYO>            return shl.result;<KAIGYO>        }<KAIGYO>        Instruction::Shl shl;<KAIGYO>        shl.lhs = getParam(leftSource);<KAIGYO>        shl.rhs = getParam(rightSource);<KAIGYO>        shl.result = getResultParam(target);<KAIGYO>        addInstruction(shl);<KAIGYO>        return shl.result;<KAIGYO>    }<KAIGYO><KAIGYO>    if (oper == IR::OpInstanceof || oper == IR::OpIn || oper == IR::OpAdd) {<KAIGYO>        Instruction::BinopContext binop;<KAIGYO>        if (oper == IR::OpInstanceof)<KAIGYO>            binop.alu = QV4::Runtime::instanceof;<KAIGYO>        else if (oper == IR::OpIn)<KAIGYO>            binop.alu = QV4::Runtime::in;<KAIGYO>        else<KAIGYO>            binop.alu = QV4::Runtime::add;<KAIGYO>        binop.lhs = getParam(leftSource);<KAIGYO>        binop.rhs = getParam(rightSource);<KAIGYO>        binop.result = getResultParam(target);<KAIGYO>        Q_ASSERT(binop.alu != QV4::Runtime::InvalidRuntimeMethod);<KAIGYO>        addInstruction(binop);<KAIGYO>        return binop.result;<KAIGYO>    } else {<KAIGYO>        auto binopFunc = aluOpFunction(oper);<KAIGYO>        Q_ASSERT(binopFunc != QV4::Runtime::InvalidRuntimeMethod);<KAIGYO>        Instruction::Binop binop;<KAIGYO>        binop.alu = binopFunc;<KAIGYO>        binop.lhs = getParam(leftSource);<KAIGYO>        binop.rhs = getParam(rightSource);<KAIGYO>        binop.result = getResultParam(target);<KAIGYO>        addInstruction(binop);<KAIGYO>        return binop.result;<KAIGYO>    }<KAIGYO>}<KAIGYO><KAIGYO>void InstructionSelection::prepareCallArgs(IR::ExprList *e, quint32 &argc, quint32 *args)<KAIGYO>{<KAIGYO>    int argLocation = outgoingArgumentTempStart();<KAIGYO>    argc = 0;<KAIGYO>    if (args)<KAIGYO>        *args = argLocation;<KAIGYO>    if (e) {<KAIGYO>        // We need to move all the temps into the function arg array<KAIGYO>        Q_ASSERT(argLocation >= 0);<KAIGYO>        while (e) {<KAIGYO>            if (IR::Const *c = e->expr->asConst()) {<KAIGYO>                Instruction::MoveConst move;<KAIGYO>                move.source = convertToValue(c).asReturnedValue();<KAIGYO>                move.result = Param::createTemp(argLocation);<KAIGYO>                addInstruction(move);<KAIGYO>            } else {<KAIGYO>                Instruction::Move move;<KAIGYO>                move.source = getParam(e->expr);<KAIGYO>                move.result = Param::createTemp(argLocation);<KAIGYO>                addInstruction(move);<KAIGYO>            }<KAIGYO>            ++argLocation;<KAIGYO>            ++argc;<KAIGYO>            e = e->next;<KAIGYO>        }<KAIGYO>    }<KAIGYO>}<KAIGYO><KAIGYO>void InstructionSelection::addDebugInstruction()<KAIGYO>{<KAIGYO>#ifndef QT_NO_QML_DEBUGGER<KAIGYO>    if (blockNeedsDebugInstruction) {<KAIGYO>        Instruction::Debug debug;<KAIGYO>        debug.lineNumber = -int(currentLine);<KAIGYO>        addInstruction(debug);<KAIGYO>    }<KAIGYO>#endif<KAIGYO>}<KAIGYO><KAIGYO>void InstructionSelection::visitJump(IR::Jump *s)<KAIGYO>{<KAIGYO>    if (s->target == _nextBlock)<KAIGYO>        return;<KAIGYO>    if (_removableJumps.at(_block->index()))<KAIGYO>        return;<KAIGYO><KAIGYO>    addDebugInstruction();<KAIGYO><KAIGYO>    Instruction::Jump jump;<KAIGYO>    jump.offset = 0;<KAIGYO>    ptrdiff_t loc = addInstruction(jump) + (((const char *)&jump.offset) - ((const char *)&jump));<KAIGYO><KAIGYO>    _patches[s->target].append(loc);<KAIGYO>}<KAIGYO><KAIGYO>void InstructionSelection::visitCJump(IR::CJump *s)<KAIGYO>{<KAIGYO>    addDebugInstruction();<KAIGYO><KAIGYO>    Param condition;<KAIGYO>    if (IR::Temp *t = s->cond->asTemp()) {<KAIGYO>        condition = getResultParam(t);<KAIGYO>    } else if (IR::Binop *b = s->cond->asBinop()) {<KAIGYO>        condition = binopHelper(b->op, b->left, b->right, /*target*/': 1}",1.0,{}
13,205024.0,7.0,13.0,0.0,ABANDONED,False,https://codereview.qt-project.org/#/c/205024,Use the 'FcGetDefaultLangs' instead of workarounds,1.0,{},0.0,{'// Hack to get system default language until FcGetDefaultLangs()<KAIGYO>// is exported (httpsbugs.freedesktop.org/show_bug.cgi?id=32853)<KAIGYO>// or httpsbugs.freedesktop.org/show_bug.cgi?id=35482 is fixed': 1},1.0,{}
30,205189.0,2.0,4.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/205189,PinchHandler: make the properties useful when target is null,1.0,{'// TODO incompatible with independent x/y scaling': 1},1.0,{'// TODO incompatible with independent x/y scaling': 1},1.0,{}
36,205195.0,3.0,4.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/205195,Fix argument order for bound signal expressions,1.0,{'// Resolve duplicate parameter names:': 2},1.0,"{'// iterate backwards, so we get the right ordering for duplicate names': 2}",1.0,{}
56,205286.0,3.0,5.0,0.0,ABANDONED,False,https://codereview.qt-project.org/#/c/205286,Native gestures: use actual QTouchDevice rather than synthetic,1.0,{},0.0,{'// TODO identify specific touchpads instead': 2},1.0,{}
148,205732.0,3.0,6.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/205732,Handle coordinates related to component window,1.0,{},0.0,{'// FIXME': 1},1.0,{}
159,205770.0,4.0,45.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/205770,QTreeWidgetItem::insertChildren: ignore out of bounds indexes,1.0,{},0.0,{'// ### fixme': 1},1.0,{}
47,206059.0,3.0,8.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/206059,Merge remote-tracking branch 'origin/5.9' into 5.10,1.0,"{""//let's move the separators"": 1}",1.0,"{'// workaround for bug in QProgressBar': 1, '// Not needed for QtQuick Controls<KAIGYO>//The rect adjustment is a workaround for the menu not really filling its background.': 1, '// Note that setting a saturated color here results in ugly XOR colors in the focus rect': 1, ""/*! \\internal<KAIGYO>    Returns the pointer to a tab widgets body pixmap, scaled to the<KAIGYO>    height of the screen. This way the theme engine doesn't need to<KAIGYO>    scale the body for every time we ask for it. (Speed optimization)<KAIGYO>*/"": 1, ""/*! \\internal<KAIGYO>    Returns \\c true if the part contains any transparency at all. This does<KAIGYO>    not indicate what kind of transparency we're dealing with. It can be<KAIGYO>        - Alpha transparency<KAIGYO>        - Masked transparency<KAIGYO>*/"": 1, '// OLD PSDK Workaround ------------------------------------------------------------------------<KAIGYO>// See if we need extra clipping for the older PSDK, which does<KAIGYO>// not have a DrawThemeBackgroundEx function for DTGB_OMITBORDER<KAIGYO>// and DTGB_OMITCONTENT': 1, ""//let's move the separators"": 2}",1.0,"{""//let's move the separators"": '1-2'}"
191,206179.0,8.0,35.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/206179,Change almost all other uses of qrand() to QRandomGenerator,1.0,{},0.0,"{""// Mac has 3 different ways of accomplishing this (same for moving to the back)<KAIGYO>// So I guess we should just randomly do this for now. Which may get people mad, but if<KAIGYO>// we fail at one point, it's just a matter of setting roll to the correct value<KAIGYO>// instead of random."": 1}",1.0,{}
163,206807.0,3.0,39.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/206807,Tidy up QDateTimeParser code to make it easier to reason about,1.0,{},0.0,"{'// typing 2 in a zzz field should be .200, not .002<KAIGYO>// reversed test to dodge QDTPDEBUG ugliness !': 1}",1.0,{}
166,206832.0,1.0,2.0,0.0,ABANDONED,False,https://codereview.qt-project.org/#/c/206832,Windows: #ifdef SM_DIGITIZER and related macros,1.0,{},0.0,{'// FIXME: Do we still need this enum? MSDN documentation states min. req. is Windows 2000': 1},1.0,{}
38,207094.0,5.0,19.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/207094,xcb: Unify visual to QImage::Format logic,1.0,{},0.0,"{'// TODO: Merge with imageFormatForVisual in qxcbwindow.cpp': 1, '// TODO: Merge with qt_xcb_imageFormatForVisual in qxcbimage.cpp': 1}",1.0,{}
48,207236.0,2.0,8.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/207236,"Revert ""HTTP/2 protocol handler: set the redirect URL on reply""",1.0,{},0.0,"{'// TODO: part of this code copies what SPDY does when processing<KAIGYO>// headers. It would be nice to re-factor HTTP/2 protocol handler<KAIGYO>// to make it more strict in extracting things. For example, the<KAIGYO>// status code below ... yeah, should be an integer, right?': 1}",1.0,{}
15,208017.0,6.0,14.0,0.0,ABANDONED,False,https://codereview.qt-project.org/#/c/208017,tests: cleanup tst_QComboBox::keyBoardNavigationWithMouse,1.0,{},0.0,{'//since we moved the mouse is in the middle it should even be around 5;': 2},1.0,{}
0,208037.0,1.0,2.0,0.0,NEW,False,https://codereview.qt-project.org/#/c/208037,Windows: #ifdef SM_DIGITIZER and related macros,1.0,{},0.0,{'// FIXME: Do we still need this enum? MSDN documentation states min. req. is Windows 2000': 1},1.0,{}
121,208441.0,7.0,39.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/208441,QRandomGenerator: remove the per-thread buffer,1.0,{'// Verify that the pointers are properly aligned for 32-bit': 1},1.0,{'// Verify that the pointers are properly aligned for 32-bit': 1},1.0,{}
116,208474.0,6.0,22.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/208474,Merge remote-tracking branch 'origin/5.9' into 5.10,1.0,{},0.0,{'// Call the deprecated ChangeWindowMessageFilter API otherwise (Vista onwards)<KAIGYO>// May 2016: Still resolved at runtime since the definition is not present in MinGW 4.9.<KAIGYO>// TODO: Replace by direct invocation when upgrading MinGW.': 3},1.0,{}
119,208599.0,2.0,6.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/208599,tests: fix and un-blacklist tst_qgraphicsview::hoverLeave,1.0,{},0.0,{'// move the cursor out of the way': 1},1.0,{}
75,209260.0,5.0,13.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/209260,Allow more paths for lookup of lock-file directories,1.0,{},0.0,{'// This is the workaround to specify a temporary directory<KAIGYO>// on OSX when running the App Sandbox feature.': 1},1.0,{}
96,209356.0,5.0,23.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/209356,QQuickEventPoint: make ungrab/cancel notifications more consistent,1.0,{},0.0,"{'//        QTRY_COMPARE(tp.at(0)->property("""").toBool(), false); // TODO fails; MPTA doesn\'t know it lost its grabs<KAIGYO>//        QCOMPARE(tp.at(1)->property("""").toBool(), false);<KAIGYO>//        QCOMPARE(tp.at(2)->property("""").toBool(), false);': 1}",1.0,{}
204,209846.0,1.0,1.0,0.0,ABANDONED,False,https://codereview.qt-project.org/#/c/209846,tests: cleanup tst_QComboBox::keyBoardNavigationWithMouse,1.0,{},0.0,{'//since we moved the mouse is in the middle it should even be around 5;': 1},1.0,{}
233,209917.0,5.0,48.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/209917,Clean up in TZP-Win's calculateTransitionLocalDate(),1.0,{'// TODO Consider caching the calculated values - i.e. replace SYSTEMTIME in<KAIGYO>// WinTransitionRule; do this in init() once and store the results.': 2},1.0,{'// TODO Consider caching the calculated values': 2},1.0,{}
86,210065.0,19.0,36.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/210065,Implement bluetoothd version test,1.0,"{""// suitably large value that won't consume too much memory"": 12}",1.0,{'//TODO implement': 1},1.0,{}
56,210172.0,14.0,17.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/210172,Get rid of the last usage of the V4_OBJECT macro,1.0,{'//TODO: Guard needed?': 1},1.0,{'//TODO: Guard needed?': 1},1.0,{}
96,210284.0,10.0,33.0,0.0,ABANDONED,False,https://codereview.qt-project.org/#/c/210284,QSslSocket (SecureTransport) - add QSslContextSecureTransport,1.0,"{""// We'd like to verify peer ourselves, otherwise handshake will<KAIGYO>// most probably fail before we can do anything."": 1}",1.0,"{""// We'd like to verify peer ourselves, otherwise handshake will<KAIGYO>// most probably fail before we can do anything."": 1}",1.0,{}
57,210289.0,4.0,14.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/210289,Never create pointer events from mouseGrabberItem(),1.0,{'// FIXME send ungrab event only once': 3},1.0,{'// FIXME send ungrab event only once': 3},1.0,{}
82,210392.0,3.0,9.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/210392,QWinEventNotifier: Fix exit crash,1.0,{'// perhaps application is shutting down': 1},1.0,{'// perhaps application is shutting down': 1},1.0,{}
108,210422.0,8.0,12.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/210422,Don't copy unnamed arguments onto the JS stack,1.0,{},0.0,{'// ### Fixme: only copy nFormals': 1},1.0,{}
206,210604.0,15.0,30.0,0.0,DEFERRED,False,https://codereview.qt-project.org/#/c/210604,qtestlib: add plugin support,1.0,"{'// Physical button state as seen by platform is not relevant. At least with the current<KAIGYO>// implementation of qtestlib that sends mocked events instead of generating real mouse<KAIGYO>// press/release/move events. If this changes in the future, we might need to check in<KAIGYO>// what """" is qtestlib running in - mocked vs real system events.': 4, '// TEMP FIX FOR OTHER ISSUE ............': 5, ""// This value is used to emulate timestamps to avoid creating double clicks by mistake.<KAIGYO>// Use this constant instead of QStyleHints::mouseDoubleClickInterval property to avoid tests<KAIGYO>// to depend on platform themes. ### FIXME: We don't have this restriction anymore when<KAIGYO>// this qtest functionality has been moved into a plugin."": 6, '// ### FIXME: TEMP FIX FOR OTHER ISSUE': 6, ""// This value is used to emulate timestamps to avoid creating double clicks by mistake.<KAIGYO>// Use this constant instead of QStyleHints::mouseDoubleClickInterval property to avoid tests<KAIGYO>// to depend on platform themes. ### FIXME: We don't have this restriction anymore when<KAIGYO>// this functionality has been moved into a plugin."": 8, '// ### FIXME: QTBUG-63542': 13}",1.0,"{'// FIXME: It seems unnecessary to export these wrapper functions, when qtestlib could access<KAIGYO>// QWindowSystemInterface directly (by adding dependency to gui-private), see QTBUG-63146.<KAIGYO>// Wrapper for compatibility with Qt < 5.11<KAIGYO>// ### Qt6: Remove<KAIGYO>// Wrapper for compatibility with Qt < 5.6<KAIGYO>// ### Qt6: Remove': 6, '// FIXME: It seems unnecessary to export these wrapper functions, when qtestlib could access<KAIGYO>// QWindowSystemInterface directly (by adding dependency to gui-private), see QTBUG-63146.': 10}",1.0,{}
188,210838.0,8.0,19.0,0.0,DEFERRED,False,https://codereview.qt-project.org/#/c/210838,QSslSocket (SecureTransport) - add QSslContextSecureTransport,1.0,"{""// We'd like to verify peer ourselves, otherwise handshake will<KAIGYO>// most probably fail before we can do anything."": 1}",1.0,"{""// We'd like to verify peer ourselves, otherwise handshake will<KAIGYO>// most probably fail before we can do anything."": 2}",1.0,"{""// We'd like to verify peer ourselves, otherwise handshake will<KAIGYO>// most probably fail before we can do anything."": '1-2'}"
196,210846.0,9.0,22.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/210846,"PointerHandler: add grabPermissions, enforce in setExclusiveGrab",1.0,"{""/*!<KAIGYO>    \\internal<KAIGYO>    Acquire or give up the exlusive grab of the given \\a point, according to<KAIGYO>    the \\a grab state, and subject to the rules: grabStealPermissions, and the<KAIGYO>    rule not to relinquish another handler's grab.<KAIGYO>*/"": 1, ""/*!<KAIGYO>    \\internal<KAIGYO>    Acquire or give up the exlusive grab of the given \\a point, according to<KAIGYO>    the \\a grab state, and subject to the rules: canGrab(), and the<KAIGYO>    rule not to relinquish another handler's grab.  Returns true if permission<KAIGYO>    is granted, false if it's denied.  (Note: returning true may not mean<KAIGYO>    the grab or ungrab actually occurred, if it turned out not to be a change<KAIGYO>    in state.)<KAIGYO>*/"": 2, ""/*!<KAIGYO>    \\internal<KAIGYO>    Acquire or give up the exclusive grab of the given \\a point, according to<KAIGYO>    the \\a grab state, and subject to the rules: canGrab(), and the rule not to<KAIGYO>    relinquish another handler's grab. Returns true if permission is granted,<KAIGYO>    or if the exclusive grab has already been acquired or relinquished as<KAIGYO>    specified. Returns false if permission is denied either by this handler or<KAIGYO>    by the handler or item from which this handler would take over<KAIGYO>*/"": 3, '// TODO m_hadKeepMouseGrab m_hadKeepTouchGrab': 3}",1.0,{'// TODO m_hadKeepMouseGrab m_hadKeepTouchGrab': 3},1.0,{}
180,210889.0,2.0,10.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/210889,Fix positioning and placement of initially invisible items in layouts,1.0,"{'        /* If we want to support using width/height as preferred size hints in<KAIGYO>           layouts, (which we think most people expect), we only want to use the<KAIGYO>           initial width.<KAIGYO>           This is because the width will change due to layout rearrangement,<KAIGYO>           and the preferred width should return the same value, regardless of<KAIGYO>           the current width.<KAIGYO>           We therefore store this initial width in the attached layout object<KAIGYO>           and reuse it if needed rather than querying the width another time.<KAIGYO>           That means we need to ensure that an Layout attached object is available<KAIGYO>           by creating one if necessary.<KAIGYO>        */': 1}",1.0,"{'        /* This block is a bit hacky, but if we want to support using width/height<KAIGYO>           as preferred size hints in layouts, (which we think most people expect),<KAIGYO>           we only want to use the initial width.<KAIGYO>           This is because the width will change due to layout rearrangement, and the preferred<KAIGYO>           width should return the same value, regardless of the current width.<KAIGYO>           We therefore store the width in the implicitWidth attached property.<KAIGYO>           Since the layout listens to changes of implicitWidth, (it will<KAIGYO>           basically cause an invalidation of the layout), we have to disable that<KAIGYO>           notification while we set the implicit width (and height).<KAIGYO>           Only use this fallback the first time the size hint is queried. Otherwise, we might<KAIGYO>           end up picking a width that is different than what was specified in the QML.<KAIGYO>        */': 1}",1.0,{}
33,211185.0,7.0,13.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/211185,Merge remote-tracking branch 'origin/5.9' into 5.10,1.0,{'// FIXME send ungrab event only once': 1},1.0,{'// FIXME send ungrab event only once': 3},1.0,{'// FIXME send ungrab event only once': '1-3'}
61,211217.0,8.0,25.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/211217,Refactor getter lookups,1.0,{},0.0,{'// sort the better getter first': 1},1.0,{}
135,211739.0,2.0,10.0,0.0,ABANDONED,False,https://codereview.qt-project.org/#/c/211739,Optimize drawing of antialiased glyphs,1.0,"{'// Give up and do a naive gray alphablend. Needed to deal with ARGB32 and invalid ARGB32_premultiplied, see QTBUG-60571': 2}",1.0,"{'// Give up and do a naive gray alphablend. Needed to deal with ARGB32 and invalid ARGB32_premultiplied, see QTBUG-60571': 2}",1.0,{}
146,211797.0,2.0,4.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/211797,qsimd.cpp: Remove workaround for GCC 4.2,1.0,{},0.0,"{""// GCC 4.2 (at least the one that comes with Apple's XCode, on Mac) is<KAIGYO>// known to be broken beyond repair in dealing with the inline assembly<KAIGYO>// above. It will generate bad code that could corrupt important registers<KAIGYO>// like the PIC register. The behaviour of code after this function would<KAIGYO>// be totally unpredictable.<KAIGYO>//<KAIGYO>// For that reason, simply forego the CPUID check at all and return the set<KAIGYO>// of features that we found at compile time, through the #defines from the<KAIGYO>// compiler. This should at least allow code to execute, even if none of<KAIGYO>// the specialized code found in Qt GUI and elsewhere will ever be enabled<KAIGYO>// (it's the user's fault for using a broken compiler).<KAIGYO>//<KAIGYO>// This also disables the runtime checking that the processor actually<KAIGYO>// contains all the features that the code required. Qt 4 ran for years<KAIGYO>// like that, so it shouldn't be a problem."": 1}",1.0,{}
25,212054.0,2.0,4.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/212054,Merge remote-tracking branch 'origin/wip/new-backend' into dev,1.0,{},0.0,"{'    opt.run(qmlEngine, useTypeInference, /*peelLoops =*/ false);<KAIGYO>    if (opt.isInSSA()) {<KAIGYO>        static const bool doStackSlotAllocation =<KAIGYO>                qEnvironmentVariableIsEmpty("""");<KAIGYO><KAIGYO>        if (doStackSlotAllocation) {<KAIGYO>            IR::AllocateStackSlots(opt.lifeTimeIntervals()).forFunction(_function);<KAIGYO>        } else {<KAIGYO>            opt.convertOutOfSSA();<KAIGYO>            ConvertTemps().toStackSlots(_function);<KAIGYO>        }<KAIGYO>        opt.showMeTheCode(_function, """");<KAIGYO>    } else {<KAIGYO>        ConvertTemps().toStackSlots(_function);<KAIGYO>    }<KAIGYO><KAIGYO>    BitVector removableJumps = opt.calculateOptionalJumps();<KAIGYO>    qSwap(_removableJumps, removableJumps);<KAIGYO><KAIGYO>    IR::Stmt *cs = 0;<KAIGYO>    qSwap(_currentStatement, cs);<KAIGYO><KAIGYO>    int locals = frameSize();<KAIGYO>    Q_ASSERT(locals >= 0);<KAIGYO><KAIGYO>    IR::BasicBlock *exceptionHandler = 0;<KAIGYO><KAIGYO>    Instruction::Push push;<KAIGYO>    push.value = quint32(locals);<KAIGYO>    addInstruction(push);<KAIGYO><KAIGYO>    currentLine = 0;<KAIGYO>    const QVector<IR::BasicBlock *> &basicBlocks = _function->basicBlocks();<KAIGYO>    for (int i = 0, ei = basicBlocks.size(); i != ei; ++i) {<KAIGYO>        blockNeedsDebugInstruction = irModule->debugMode;<KAIGYO>        _block = basicBlocks[i];<KAIGYO>        _nextBlock = (i < ei - 1) ? basicBlocks[i + 1] : 0;<KAIGYO>        _addrs.insert(_block, _codeNext - _codeStart);<KAIGYO><KAIGYO>        if (_block->catchBlock != exceptionHandler) {<KAIGYO>            Instruction::SetExceptionHandler set;<KAIGYO>            set.offset = 0;<KAIGYO>            if (_block->catchBlock) {<KAIGYO>                ptrdiff_t loc = addInstruction(set) + (((const char *)&set.offset) - ((const char *)&set));<KAIGYO>                _patches[_block->catchBlock].append(loc);<KAIGYO>            } else {<KAIGYO>                addInstruction(set);<KAIGYO>            }<KAIGYO>            exceptionHandler = _block->catchBlock;<KAIGYO>        } else if (_block->catchBlock == nullptr && _block->index() != 0 && _block->in.isEmpty()) {<KAIGYO>            exceptionHandler = nullptr;<KAIGYO>            Instruction::SetExceptionHandler set;<KAIGYO>            set.offset = 0;<KAIGYO>            addInstruction(set);<KAIGYO>        }<KAIGYO><KAIGYO>        for (IR::Stmt *s : _block->statements()) {<KAIGYO>            _currentStatement = s;<KAIGYO><KAIGYO>            if (s->location.isValid()) {<KAIGYO>                if (s->location.startLine != currentLine) {<KAIGYO>                    blockNeedsDebugInstruction = false;<KAIGYO>                    currentLine = s->location.startLine;<KAIGYO>#if QT_CONFIG(qml_debug)<KAIGYO>                    if (irModule->debugMode) {<KAIGYO>                        Instruction::Debug debug;<KAIGYO>                        debug.lineNumber = currentLine;<KAIGYO>                        addInstruction(debug);<KAIGYO>                    } else {<KAIGYO>                        Instruction::Line line;<KAIGYO>                        line.lineNumber = currentLine;<KAIGYO>                        addInstruction(line);<KAIGYO>                    }<KAIGYO>#endif<KAIGYO>                }<KAIGYO>            }<KAIGYO><KAIGYO>            visit(s);<KAIGYO>        }<KAIGYO>    }<KAIGYO><KAIGYO>    // TODO: patch stack size (the push instruction)<KAIGYO>    patchJumpAddresses();<KAIGYO><KAIGYO>    codeRefs.insert(_function, squeezeCode());<KAIGYO><KAIGYO>    qSwap(_currentStatement, cs);<KAIGYO>    qSwap(_removableJumps, removableJumps);<KAIGYO>    qSwap(_function, function);<KAIGYO>    qSwap(block, _block);<KAIGYO>    qSwap(nextBlock, _nextBlock);<KAIGYO>    qSwap(patches, _patches);<KAIGYO>    qSwap(addrs, _addrs);<KAIGYO>    qSwap(codeStart, _codeStart);<KAIGYO>    qSwap(codeNext, _codeNext);<KAIGYO>    qSwap(codeEnd, _codeEnd);<KAIGYO><KAIGYO>    delete[] codeStart;<KAIGYO>}<KAIGYO><KAIGYO>QQmlRefPointer<QV4::CompiledData::CompilationUnit> InstructionSelection::backendCompileStep()<KAIGYO>{<KAIGYO>    compilationUnit->codeRefs.resize(irModule->functions.size());<KAIGYO>    int i = 0;<KAIGYO>    for (IR::Function *irFunction : qAsConst(irModule->functions))<KAIGYO>        compilationUnit->codeRefs[i++] = codeRefs[irFunction];<KAIGYO>    QQmlRefPointer<QV4::CompiledData::CompilationUnit> result;<KAIGYO>    result.adopt(compilationUnit.take());<KAIGYO>    return result;<KAIGYO>}<KAIGYO><KAIGYO>void InstructionSelection::callValue(IR::Expr *value, IR::ExprList *args, IR::Expr *result)<KAIGYO>{<KAIGYO>    Instruction::CallValue call;<KAIGYO>    prepareCallArgs(args, call.argc);<KAIGYO>    call.callData = callDataStart();<KAIGYO>    call.dest = getParam(value);<KAIGYO>    call.result = getResultParam(result);<KAIGYO>    addInstruction(call);<KAIGYO>}<KAIGYO><KAIGYO>void InstructionSelection::callQmlContextProperty(IR::Expr *base, IR::Member::MemberKind kind, int propertyIndex, IR::ExprList *args, IR::Expr *result)<KAIGYO>{<KAIGYO>    if (kind == IR::Member::MemberOfQmlScopeObject) {<KAIGYO>        Instruction::CallScopeObjectProperty call;<KAIGYO>        call.base = getParam(base);<KAIGYO>        call.index = propertyIndex;<KAIGYO>        prepareCallArgs(args, call.argc);<KAIGYO>        call.callData = callDataStart();<KAIGYO>        call.result = getResultParam(result);<KAIGYO>        addInstruction(call);<KAIGYO>    } else if (kind == IR::Member::MemberOfQmlContextObject) {<KAIGYO>        Instruction::CallContextObjectProperty call;<KAIGYO>        call.base = getParam(base);<KAIGYO>        call.index = propertyIndex;<KAIGYO>        prepareCallArgs(args, call.argc);<KAIGYO>        call.callData = callDataStart();<KAIGYO>        call.result = getResultParam(result);<KAIGYO>        addInstruction(call);<KAIGYO>    } else {<KAIGYO>        Q_ASSERT(false);<KAIGYO>    }<KAIGYO>}<KAIGYO><KAIGYO>void InstructionSelection::callProperty(IR::Expr *base, const QString &name, IR::ExprList *args,<KAIGYO>                                        IR::Expr *result)<KAIGYO>{<KAIGYO>    if (useFastLookups) {<KAIGYO>        Instruction::CallPropertyLookup call;<KAIGYO>        call.base = getParam(base);<KAIGYO>        call.lookupIndex = registerGetterLookup(name);<KAIGYO>        prepareCallArgs(args, call.argc);<KAIGYO>        call.callData = callDataStart();<KAIGYO>        call.result = getResultParam(result);<KAIGYO>        addInstruction(call);<KAIGYO>    } else {<KAIGYO>        // call the property on the loaded base<KAIGYO>        Instruction::CallProperty call;<KAIGYO>        call.base = getParam(base);<KAIGYO>        call.name = registerString(name);<KAIGYO>        prepareCallArgs(args, call.argc);<KAIGYO>        call.callData = callDataStart();<KAIGYO>        call.result = getResultParam(result);<KAIGYO>        addInstruction(call);<KAIGYO>    }<KAIGYO>}<KAIGYO><KAIGYO>void InstructionSelection::callSubscript(IR::Expr *base, IR::Expr *index, IR::ExprList *args,<KAIGYO>                                         IR::Expr *result)<KAIGYO>{<KAIGYO>    // call the property on the loaded base<KAIGYO>    Instruction::CallElement call;<KAIGYO>    call.base = getParam(base);<KAIGYO>    call.index = getParam(index);<KAIGYO>    prepareCallArgs(args, call.argc);<KAIGYO>    call.callData = callDataStart();<KAIGYO>    call.result = getResultParam(result);<KAIGYO>    addInstruction(call);<KAIGYO>}<KAIGYO><KAIGYO>void InstructionSelection::convertType(IR::Expr *source, IR::Expr *target)<KAIGYO>{<KAIGYO>    // FIXME: do something more useful with this info<KAIGYO>    if (target->type & IR::NumberType && !(source->type & IR::NumberType))<KAIGYO>        unop(IR::OpUPlus, source, target);<KAIGYO>    else<KAIGYO>        copyValue(source, target);<KAIGYO>}<KAIGYO><KAIGYO>void InstructionSelection::constructActivationProperty(IR::Name *func,<KAIGYO>                                                       IR::ExprList *args,<KAIGYO>                                                       IR::Expr *target)<KAIGYO>{<KAIGYO>    if (useFastLookups && func->global) {<KAIGYO>        Instruction::ConstructGlobalLookup call;<KAIGYO>        call.index = registerGlobalGetterLookup(*func->id);<KAIGYO>        prepareCallArgs(args, call.argc);<KAIGYO>        call.callData = callDataStart();<KAIGYO>        call.result = getResultParam(target);<KAIGYO>        addInstruction(call);<KAIGYO>        return;<KAIGYO>    }<KAIGYO>    Instruction::CreateActivationProperty create;<KAIGYO>    create.name = registerString(*func->id);<KAIGYO>    prepareCallArgs(args, create.argc);<KAIGYO>    create.callData = callDataStart();<KAIGYO>    create.result = getResultParam(target);<KAIGYO>    addInstruction(create);<KAIGYO>}<KAIGYO><KAIGYO>void InstructionSelection::constructProperty(IR::Expr *base, const QString &name, IR::ExprList *args, IR::Expr *target)<KAIGYO>{<KAIGYO>    if (useFastLookups) {<KAIGYO>        Instruction::ConstructPropertyLookup call;<KAIGYO>        call.base = getParam(base);<KAIGYO>        call.index = registerGetterLookup(name);<KAIGYO>        prepareCallArgs(args, call.argc);<KAIGYO>        call.callData = callDataStart();<KAIGYO>        call.result = getResultParam(target);<KAIGYO>        addInstruction(call);<KAIGYO>        return;<KAIGYO>    }<KAIGYO>    Instruction::CreateProperty create;<KAIGYO>    create.base = getParam(base);<KAIGYO>    create.name = registerString(name);<KAIGYO>    prepareCallArgs(args, create.argc);<KAIGYO>    create.callData = callDataStart();<KAIGYO>    create.result = getResultParam(target);<KAIGYO>    addInstruction(create);<KAIGYO>}<KAIGYO><KAIGYO>void InstructionSelection::constructValue(IR::Expr *value, IR::ExprList *args, IR::Expr *target)<KAIGYO>{<KAIGYO>    Instruction::CreateValue create;<KAIGYO>    create.func = getParam(value);<KAIGYO>    prepareCallArgs(args, create.argc);<KAIGYO>    create.callData = callDataStart();<KAIGYO>    create.result = getResultParam(target);<KAIGYO>    addInstruction(create);<KAIGYO>}<KAIGYO><KAIGYO>void InstructionSelection::loadThisObject(IR::Expr *e)<KAIGYO>{<KAIGYO>    Instruction::LoadThis load;<KAIGYO>    load.result = getResultParam(e);<KAIGYO>    addInstruction(load);<KAIGYO>}<KAIGYO><KAIGYO>void InstructionSelection::loadQmlContext(IR::Expr *e)<KAIGYO>{<KAIGYO>    Instruction::LoadQmlContext load;<KAIGYO>    load.result = getResultParam(e);<KAIGYO>    addInstruction(load);<KAIGYO>}<KAIGYO><KAIGYO>void InstructionSelection::loadQmlImportedScripts(IR::Expr *e)<KAIGYO>{<KAIGYO>    Instruction::LoadQmlImportedScripts load;<KAIGYO>    load.result = getResultParam(e);<KAIGYO>    addInstruction(load);<KAIGYO>}<KAIGYO><KAIGYO>void InstructionSelection::loadQmlSingleton(const QString &name, IR::Expr *e)<KAIGYO>{<KAIGYO>    Instruction::LoadQmlSingleton load;<KAIGYO>    load.result = getResultParam(e);<KAIGYO>    load.name = registerString(name);<KAIGYO>    addInstruction(load);<KAIGYO>}<KAIGYO><KAIGYO>void InstructionSelection::loadConst(IR::Const *sourceConst, IR::Expr *e)<KAIGYO>{<KAIGYO>    Q_ASSERT(sourceConst);<KAIGYO><KAIGYO>    Instruction::MoveConst move;<KAIGYO>    move.source = convertToValue(sourceConst).asReturnedValue();<KAIGYO>    move.result = getResultParam(e);<KAIGYO>    addInstruction(move);<KAIGYO>}<KAIGYO><KAIGYO>void InstructionSelection::loadString(const QString &str, IR::Expr *target)<KAIGYO>{<KAIGYO>    Instruction::LoadRuntimeString load;<KAIGYO>    load.stringId = registerString(str);<KAIGYO>    load.result = getResultParam(target);<KAIGYO>    addInstruction(load);<KAIGYO>}<KAIGYO><KAIGYO>void InstructionSelection::loadRegexp(IR::RegExp *sourceRegexp, IR::Expr *target)<KAIGYO>{<KAIGYO>    Instruction::LoadRegExp load;<KAIGYO>    load.regExpId = registerRegExp(sourceRegexp);<KAIGYO>    load.result = getResultParam(target);<KAIGYO>    addInstruction(load);<KAIGYO>}<KAIGYO><KAIGYO>void InstructionSelection::getActivationProperty(const IR::Name *name, IR::Expr *target)<KAIGYO>{<KAIGYO>    if (useFastLookups && name->global) {<KAIGYO>        Instruction::GetGlobalLookup load;<KAIGYO>        load.index = registerGlobalGetterLookup(*name->id);<KAIGYO>        load.result = getResultParam(target);<KAIGYO>        addInstruction(load);<KAIGYO>        return;<KAIGYO>    }<KAIGYO>    Instruction::LoadName load;<KAIGYO>    load.name = registerString(*name->id);<KAIGYO>    load.result = getResultParam(target);<KAIGYO>    addInstruction(load);<KAIGYO>}<KAIGYO><KAIGYO>void InstructionSelection::setActivationProperty(IR::Expr *source, const QString &targetName)<KAIGYO>{<KAIGYO>    Instruction::StoreName store;<KAIGYO>    store.source = getParam(source);<KAIGYO>    store.name = registerString(targetName);<KAIGYO>    addInstruction(store);<KAIGYO>}<KAIGYO><KAIGYO>void InstructionSelection::initClosure(IR::Closure *closure, IR::Expr *target)<KAIGYO>{<KAIGYO>    int id = closure->value;<KAIGYO>    Instruction::LoadClosure load;<KAIGYO>    load.value = id;<KAIGYO>    load.result = getResultParam(target);<KAIGYO>    addInstruction(load);<KAIGYO>}<KAIGYO><KAIGYO>void InstructionSelection::getProperty(IR::Expr *base, const QString &name, IR::Expr *target)<KAIGYO>{<KAIGYO>    if (useFastLookups) {<KAIGYO>        Instruction::GetLookup load;<KAIGYO>        load.base = getParam(base);<KAIGYO>        load.index = registerGetterLookup(name);<KAIGYO>        load.result = getResultParam(target);<KAIGYO>        addInstruction(load);<KAIGYO>        return;<KAIGYO>    }<KAIGYO>    Instruction::LoadProperty load;<KAIGYO>    load.base = getParam(base);<KAIGYO>    load.name = registerString(name);<KAIGYO>    load.result = getResultParam(target);<KAIGYO>    addInstruction(load);<KAIGYO>}<KAIGYO><KAIGYO>void InstructionSelection::setProperty(IR::Expr *source, IR::Expr *targetBase,<KAIGYO>                                       const QString &targetName)<KAIGYO>{<KAIGYO>    if (useFastLookups) {<KAIGYO>        Instruction::SetLookup store;<KAIGYO>        store.base = getParam(targetBase);<KAIGYO>        store.index = registerSetterLookup(targetName);<KAIGYO>        store.source = getParam(source);<KAIGYO>        addInstruction(store);<KAIGYO>        return;<KAIGYO>    }<KAIGYO>    Instruction::StoreProperty store;<KAIGYO>    store.base = getParam(targetBase);<KAIGYO>    store.name = registerString(targetName);<KAIGYO>    store.source = getParam(source);<KAIGYO>    addInstruction(store);<KAIGYO>}<KAIGYO><KAIGYO>void InstructionSelection::setQmlContextProperty(IR::Expr *source, IR::Expr *targetBase, IR::Member::MemberKind kind, int propertyIndex)<KAIGYO>{<KAIGYO>    if (kind == IR::Member::MemberOfQmlScopeObject) {<KAIGYO>        Instruction::StoreScopeObjectProperty store;<KAIGYO>        store.base = getParam(targetBase);<KAIGYO>        store.propertyIndex = propertyIndex;<KAIGYO>        store.source = getParam(source);<KAIGYO>        addInstruction(store);<KAIGYO>    } else if (kind == IR::Member::MemberOfQmlContextObject) {<KAIGYO>        Instruction::StoreContextObjectProperty store;<KAIGYO>        store.base = getParam(targetBase);<KAIGYO>        store.propertyIndex = propertyIndex;<KAIGYO>        store.source = getParam(source);<KAIGYO>        addInstruction(store);<KAIGYO>    } else {<KAIGYO>        Q_ASSERT(false);<KAIGYO>    }<KAIGYO>}<KAIGYO><KAIGYO>void InstructionSelection::setQObjectProperty(IR::Expr *source, IR::Expr *targetBase, int propertyIndex)<KAIGYO>{<KAIGYO>    Instruction::StoreQObjectProperty store;<KAIGYO>    store.base = getParam(targetBase);<KAIGYO>    store.propertyIndex = propertyIndex;<KAIGYO>    store.source = getParam(source);<KAIGYO>    addInstruction(store);<KAIGYO>}<KAIGYO><KAIGYO>void InstructionSelection::getQmlContextProperty(IR::Expr *source, IR::Member::MemberKind kind, int index, bool captureRequired, IR::Expr *target)<KAIGYO>{<KAIGYO>    if (kind == IR::Member::MemberOfQmlScopeObject) {<KAIGYO>        Instruction::LoadScopeObjectProperty load;<KAIGYO>        load.base = getParam(source);<KAIGYO>        load.propertyIndex = index;<KAIGYO>        load.captureRequired = captureRequired;<KAIGYO>        load.result = getResultParam(target);<KAIGYO>        addInstruction(load);<KAIGYO>    } else if (kind == IR::Member::MemberOfQmlContextObject) {<KAIGYO>        Instruction::LoadContextObjectProperty load;<KAIGYO>        load.base = getParam(source);<KAIGYO>        load.propertyIndex = index;<KAIGYO>        load.captureRequired = captureRequired;<KAIGYO>        load.result = getResultParam(target);<KAIGYO>        addInstruction(load);<KAIGYO>    } else if (kind == IR::Member::MemberOfIdObjectsArray) {<KAIGYO>        Instruction::LoadIdObject load;<KAIGYO>        load.base = getParam(source);<KAIGYO>        load.index = index;<KAIGYO>        load.result = getResultParam(target);<KAIGYO>        addInstruction(load);<KAIGYO>    } else {<KAIGYO>        Q_ASSERT(false);<KAIGYO>    }<KAIGYO>}<KAIGYO><KAIGYO>void InstructionSelection::getQObjectProperty(IR::Expr *base, int propertyIndex, bool captureRequired, bool isSingletonProperty, int attachedPropertiesId, IR::Expr *target)<KAIGYO>{<KAIGYO>    if (attachedPropertiesId != 0) {<KAIGYO>        Instruction::LoadAttachedQObjectProperty load;<KAIGYO>        load.propertyIndex = propertyIndex;<KAIGYO>        load.result = getResultParam(target);<KAIGYO>        load.attachedPropertiesId = attachedPropertiesId;<KAIGYO>        addInstruction(load);<KAIGYO>    } else if (isSingletonProperty) {<KAIGYO>        Instruction::LoadSingletonQObjectProperty load;<KAIGYO>        load.base = getParam(base);<KAIGYO>        load.propertyIndex = propertyIndex;<KAIGYO>        load.result = getResultParam(target);<KAIGYO>        load.captureRequired = captureRequired;<KAIGYO>        addInstruction(load);<KAIGYO>    } else {<KAIGYO>        Instruction::LoadQObjectProperty load;<KAIGYO>        load.base = getParam(base);<KAIGYO>        load.propertyIndex = propertyIndex;<KAIGYO>        load.result = getResultParam(target);<KAIGYO>        load.captureRequired = captureRequired;<KAIGYO>        addInstruction(load);<KAIGYO>    }<KAIGYO>}<KAIGYO><KAIGYO>void InstructionSelection::getElement(IR::Expr *base, IR::Expr *index, IR::Expr *target)<KAIGYO>{<KAIGYO>    if (0 && useFastLookups) {<KAIGYO>        Instruction::LoadElementLookup load;<KAIGYO>        load.lookup = registerIndexedGetterLookup();<KAIGYO>        load.base = getParam(base);<KAIGYO>        load.index = getParam(index);<KAIGYO>        load.result = getResultParam(target);<KAIGYO>        addInstruction(load);<KAIGYO>        return;<KAIGYO>    }<KAIGYO>    Instruction::LoadElement load;<KAIGYO>    load.base = getParam(base);<KAIGYO>    load.index = getParam(index);<KAIGYO>    load.result = getResultParam(target);<KAIGYO>    addInstruction(load);<KAIGYO>}<KAIGYO><KAIGYO>void InstructionSelection::setElement(IR::Expr *source, IR::Expr *targetBase,<KAIGYO>                                      IR::Expr *targetIndex)<KAIGYO>{<KAIGYO>    if (0 && useFastLookups) {<KAIGYO>        Instruction::StoreElementLookup store;<KAIGYO>        store.lookup = registerIndexedSetterLookup();<KAIGYO>        store.base = getParam(targetBase);<KAIGYO>        store.index = getParam(targetIndex);<KAIGYO>        store.source = getParam(source);<KAIGYO>        addInstruction(store);<KAIGYO>        return;<KAIGYO>    }<KAIGYO>    Instruction::StoreElement store;<KAIGYO>    store.base = getParam(targetBase);<KAIGYO>    store.index = getParam(targetIndex);<KAIGYO>    store.source = getParam(source);<KAIGYO>    addInstruction(store);<KAIGYO>}<KAIGYO><KAIGYO>void InstructionSelection::copyValue(IR::Expr *source, IR::Expr *target)<KAIGYO>{<KAIGYO>    Instruction::Move move;<KAIGYO>    move.source = getParam(source);<KAIGYO>    move.result = getResultParam(target);<KAIGYO>    if (move.source != move.result)<KAIGYO>        addInstruction(move);<KAIGYO>}<KAIGYO><KAIGYO>void InstructionSelection::swapValues(IR::Expr *source, IR::Expr *target)<KAIGYO>{<KAIGYO>    Instruction::SwapTemps swap;<KAIGYO>    swap.left = getParam(source);<KAIGYO>    swap.right = getParam(target);<KAIGYO>    addInstruction(swap);<KAIGYO>}<KAIGYO><KAIGYO>void InstructionSelection::unop(IR::AluOp oper, IR::Expr *source, IR::Expr *target)<KAIGYO>{<KAIGYO>    switch (oper) {<KAIGYO>    case IR::OpIfTrue:<KAIGYO>        Q_ASSERT(!""""); break;<KAIGYO>    case IR::OpNot: {<KAIGYO>        // ### enabling this fails in some cases, where apparently the value is not a bool at runtime<KAIGYO>        if (0 && isBoolType(source)) {<KAIGYO>            Instruction::UNotBool unot;<KAIGYO>            unot.source = getParam(source);<KAIGYO>            unot.result = getResultParam(target);<KAIGYO>            addInstruction(unot);<KAIGYO>            return;<KAIGYO>        }<KAIGYO>        Instruction::UNot unot;<KAIGYO>        unot.source = getParam(source);<KAIGYO>        unot.result = getResultParam(target);<KAIGYO>        addInstruction(unot);<KAIGYO>        return;<KAIGYO>    }<KAIGYO>    case IR::OpUMinus: {<KAIGYO>        Instruction::UMinus uminus;<KAIGYO>        uminus.source = getParam(source);<KAIGYO>        uminus.result = getResultParam(target);<KAIGYO>        addInstruction(uminus);<KAIGYO>        return;<KAIGYO>    }<KAIGYO>    case IR::OpUPlus: {<KAIGYO>        if (isNumberType(source)) {<KAIGYO>            // use a move<KAIGYO>            Instruction::Move move;<KAIGYO>            move.source = getParam(source);<KAIGYO>            move.result = getResultParam(target);<KAIGYO>            if (move.source != move.result)<KAIGYO>                addInstruction(move);<KAIGYO>            return;<KAIGYO>        }<KAIGYO>        Instruction::UPlus uplus;<KAIGYO>        uplus.source = getParam(source);<KAIGYO>        uplus.result = getResultParam(target);<KAIGYO>        addInstruction(uplus);<KAIGYO>        return;<KAIGYO>    }<KAIGYO>    case IR::OpCompl: {<KAIGYO>        // ### enabling this fails in some cases, where apparently the value is not a int at runtime<KAIGYO>        if (0 && isIntegerType(source)) {<KAIGYO>            Instruction::UComplInt unot;<KAIGYO>            unot.source = getParam(source);<KAIGYO>            unot.result = getResultParam(target);<KAIGYO>            addInstruction(unot);<KAIGYO>            return;<KAIGYO>        }<KAIGYO>        Instruction::UCompl ucompl;<KAIGYO>        ucompl.source = getParam(source);<KAIGYO>        ucompl.result = getResultParam(target);<KAIGYO>        addInstruction(ucompl);<KAIGYO>        return;<KAIGYO>    }<KAIGYO>    case IR::OpIncrement: {<KAIGYO>        Instruction::Increment inc;<KAIGYO>        inc.source = getParam(source);<KAIGYO>        inc.result = getResultParam(target);<KAIGYO>        addInstruction(inc);<KAIGYO>        return;<KAIGYO>    }<KAIGYO>    case IR::OpDecrement: {<KAIGYO>        Instruction::Decrement dec;<KAIGYO>        dec.source = getParam(source);<KAIGYO>        dec.result = getResultParam(target);<KAIGYO>        addInstruction(dec);<KAIGYO>        return;<KAIGYO>    }<KAIGYO>    default:  break;<KAIGYO>    } // switch<KAIGYO><KAIGYO>    Q_ASSERT(!"""");<KAIGYO>}<KAIGYO><KAIGYO>void InstructionSelection::binop(IR::AluOp oper, IR::Expr *leftSource, IR::Expr *rightSource, IR::Expr *target)<KAIGYO>{<KAIGYO>    binopHelper(oper, leftSource, rightSource, target);<KAIGYO>}<KAIGYO><KAIGYO>Param InstructionSelection::binopHelper(IR::AluOp oper, IR::Expr *leftSource, IR::Expr *rightSource, IR::Expr *target)<KAIGYO>{<KAIGYO>    if (oper == IR::OpAdd) {<KAIGYO>        Instruction::Add add;<KAIGYO>        add.lhs = getParam(leftSource);<KAIGYO>        add.rhs = getParam(rightSource);<KAIGYO>        add.result = getResultParam(target);<KAIGYO>        addInstruction(add);<KAIGYO>        return add.result;<KAIGYO>    }<KAIGYO>    if (oper == IR::OpSub) {<KAIGYO>        Instruction::Sub sub;<KAIGYO>        sub.lhs = getParam(leftSource);<KAIGYO>        sub.rhs = getParam(rightSource);<KAIGYO>        sub.result = getResultParam(target);<KAIGYO>        addInstruction(sub);<KAIGYO>        return sub.result;<KAIGYO>    }<KAIGYO>    if (oper == IR::OpMul) {<KAIGYO>        Instruction::Mul mul;<KAIGYO>        mul.lhs = getParam(leftSource);<KAIGYO>        mul.rhs = getParam(rightSource);<KAIGYO>        mul.result = getResultParam(target);<KAIGYO>        addInstruction(mul);<KAIGYO>        return mul.result;<KAIGYO>    }<KAIGYO>    if (oper == IR::OpBitAnd) {<KAIGYO>        if (leftSource->asConst())<KAIGYO>            qSwap(leftSource, rightSource);<KAIGYO>        if (IR::Const *c = rightSource->asConst()) {<KAIGYO>            Instruction::BitAndConst bitAnd;<KAIGYO>            bitAnd.lhs = getParam(leftSource);<KAIGYO>            bitAnd.rhs = convertToValue(c).Value::toInt32();<KAIGYO>            bitAnd.result = getResultParam(target);<KAIGYO>            addInstruction(bitAnd);<KAIGYO>            return bitAnd.result;<KAIGYO>        }<KAIGYO>        Instruction::BitAnd bitAnd;<KAIGYO>        bitAnd.lhs = getParam(leftSource);<KAIGYO>        bitAnd.rhs = getParam(rightSource);<KAIGYO>        bitAnd.result = getResultParam(target);<KAIGYO>        addInstruction(bitAnd);<KAIGYO>        return bitAnd.result;<KAIGYO>    }<KAIGYO>    if (oper == IR::OpBitOr) {<KAIGYO>        if (leftSource->asConst())<KAIGYO>            qSwap(leftSource, rightSource);<KAIGYO>        if (IR::Const *c = rightSource->asConst()) {<KAIGYO>            Instruction::BitOrConst bitOr;<KAIGYO>            bitOr.lhs = getParam(leftSource);<KAIGYO>            bitOr.rhs = convertToValue(c).Value::toInt32();<KAIGYO>            bitOr.result = getResultParam(target);<KAIGYO>            addInstruction(bitOr);<KAIGYO>            return bitOr.result;<KAIGYO>        }<KAIGYO>        Instruction::BitOr bitOr;<KAIGYO>        bitOr.lhs = getParam(leftSource);<KAIGYO>        bitOr.rhs = getParam(rightSource);<KAIGYO>        bitOr.result = getResultParam(target);<KAIGYO>        addInstruction(bitOr);<KAIGYO>        return bitOr.result;<KAIGYO>    }<KAIGYO>    if (oper == IR::OpBitXor) {<KAIGYO>        if (leftSource->asConst())<KAIGYO>            qSwap(leftSource, rightSource);<KAIGYO>        if (IR::Const *c = rightSource->asConst()) {<KAIGYO>            Instruction::BitXorConst bitXor;<KAIGYO>            bitXor.lhs = getParam(leftSource);<KAIGYO>            bitXor.rhs = convertToValue(c).Value::toInt32();<KAIGYO>            bitXor.result = getResultParam(target);<KAIGYO>            addInstruction(bitXor);<KAIGYO>            return bitXor.result;<KAIGYO>        }<KAIGYO>        Instruction::BitXor bitXor;<KAIGYO>        bitXor.lhs = getParam(leftSource);<KAIGYO>        bitXor.rhs = getParam(rightSource);<KAIGYO>        bitXor.result = getResultParam(target);<KAIGYO>        addInstruction(bitXor);<KAIGYO>        return bitXor.result;<KAIGYO>    }<KAIGYO>    if (oper == IR::OpRShift) {<KAIGYO>        if (IR::Const *c = rightSource->asConst()) {<KAIGYO>            Instruction::ShrConst shr;<KAIGYO>            shr.lhs = getParam(leftSource);<KAIGYO>            shr.rhs = convertToValue(c).Value::toInt32() & 0x1f;<KAIGYO>            shr.result = getResultParam(target);<KAIGYO>            addInstruction(shr);<KAIGYO>            return shr.result;<KAIGYO>        }<KAIGYO>        Instruction::Shr shr;<KAIGYO>        shr.lhs = getParam(leftSource);<KAIGYO>        shr.rhs = getParam(rightSource);<KAIGYO>        shr.result = getResultParam(target);<KAIGYO>        addInstruction(shr);<KAIGYO>        return shr.result;<KAIGYO>    }<KAIGYO>    if (oper == IR::OpLShift) {<KAIGYO>        if (IR::Const *c = rightSource->asConst()) {<KAIGYO>            Instruction::ShlConst shl;<KAIGYO>            shl.lhs = getParam(leftSource);<KAIGYO>            shl.rhs = convertToValue(c).Value::toInt32() & 0x1f;<KAIGYO>            shl.result = getResultParam(target);<KAIGYO>            addInstruction(shl);<KAIGYO>            return shl.result;<KAIGYO>        }<KAIGYO>        Instruction::Shl shl;<KAIGYO>        shl.lhs = getParam(leftSource);<KAIGYO>        shl.rhs = getParam(rightSource);<KAIGYO>        shl.result = getResultParam(target);<KAIGYO>        addInstruction(shl);<KAIGYO>        return shl.result;<KAIGYO>    }<KAIGYO><KAIGYO>    if (oper == IR::OpInstanceof || oper == IR::OpIn || oper == IR::OpAdd) {<KAIGYO>        Instruction::BinopContext binop;<KAIGYO>        if (oper == IR::OpInstanceof)<KAIGYO>            binop.alu = QV4::Runtime::instanceof;<KAIGYO>        else if (oper == IR::OpIn)<KAIGYO>            binop.alu = QV4::Runtime::in;<KAIGYO>        else<KAIGYO>            binop.alu = QV4::Runtime::add;<KAIGYO>        binop.lhs = getParam(leftSource);<KAIGYO>        binop.rhs = getParam(rightSource);<KAIGYO>        binop.result = getResultParam(target);<KAIGYO>        Q_ASSERT(binop.alu != QV4::Runtime::InvalidRuntimeMethod);<KAIGYO>        addInstruction(binop);<KAIGYO>        return binop.result;<KAIGYO>    } else {<KAIGYO>        auto binopFunc = aluOpFunction(oper);<KAIGYO>        Q_ASSERT(binopFunc != QV4::Runtime::InvalidRuntimeMethod);<KAIGYO>        Instruction::Binop binop;<KAIGYO>        binop.alu = binopFunc;<KAIGYO>        binop.lhs = getParam(leftSource);<KAIGYO>        binop.rhs = getParam(rightSource);<KAIGYO>        binop.result = getResultParam(target);<KAIGYO>        addInstruction(binop);<KAIGYO>        return binop.result;<KAIGYO>    }<KAIGYO>}<KAIGYO><KAIGYO>void InstructionSelection::prepareCallArgs(IR::ExprList *e, quint32 &argc, quint32 *args)<KAIGYO>{<KAIGYO>    int argLocation = outgoingArgumentTempStart();<KAIGYO>    argc = 0;<KAIGYO>    if (args)<KAIGYO>        *args = argLocation;<KAIGYO>    if (e) {<KAIGYO>        // We need to move all the temps into the function arg array<KAIGYO>        Q_ASSERT(argLocation >= 0);<KAIGYO>        while (e) {<KAIGYO>            if (IR::Const *c = e->expr->asConst()) {<KAIGYO>                Instruction::MoveConst move;<KAIGYO>                move.source = convertToValue(c).asReturnedValue();<KAIGYO>                move.result = Param::createTemp(argLocation);<KAIGYO>                addInstruction(move);<KAIGYO>            } else {<KAIGYO>                Instruction::Move move;<KAIGYO>                move.source = getParam(e->expr);<KAIGYO>                move.result = Param::createTemp(argLocation);<KAIGYO>                addInstruction(move);<KAIGYO>            }<KAIGYO>            ++argLocation;<KAIGYO>            ++argc;<KAIGYO>            e = e->next;<KAIGYO>        }<KAIGYO>    }<KAIGYO>}<KAIGYO><KAIGYO>void InstructionSelection::addDebugInstruction()<KAIGYO>{<KAIGYO>#if QT_CONFIG(qml_debug)<KAIGYO>    if (blockNeedsDebugInstruction) {<KAIGYO>        Instruction::Debug debug;<KAIGYO>        debug.lineNumber = -int(currentLine);<KAIGYO>        addInstruction(debug);<KAIGYO>    }<KAIGYO>#endif<KAIGYO>}<KAIGYO><KAIGYO>void InstructionSelection::visitJump(IR::Jump *s)<KAIGYO>{<KAIGYO>    if (s->target == _nextBlock)<KAIGYO>        return;<KAIGYO>    if (_removableJumps.at(_block->index()))<KAIGYO>        return;<KAIGYO><KAIGYO>    addDebugInstruction();<KAIGYO><KAIGYO>    Instruction::Jump jump;<KAIGYO>    jump.offset = 0;<KAIGYO>    ptrdiff_t loc = addInstruction(jump) + (((const char *)&jump.offset) - ((const char *)&jump));<KAIGYO><KAIGYO>    _patches[s->target].append(loc);<KAIGYO>}<KAIGYO><KAIGYO>void InstructionSelection::visitCJump(IR::CJump *s)<KAIGYO>{<KAIGYO>    addDebugInstruction();<KAIGYO><KAIGYO>    Param condition;<KAIGYO>    if (IR::Temp *t = s->cond->asTemp()) {<KAIGYO>        condition = getResultParam(t);<KAIGYO>    } else if (IR::Binop *b = s->cond->asBinop()) {<KAIGYO>        condition = binopHelper(b->op, b->left, b->right, /*target*/': 1}",1.0,{}
57,212244.0,1.0,1.0,0.0,DEFERRED,False,https://codereview.qt-project.org/#/c/212244,qtestmouse: tag mouse events that originated from qtestlib,1.0,{},0.0,"{'// FIXME: It seems unnecessary to export these wrapper functions, when qtestlib could access<KAIGYO>// QWindowSystemInterface directly (by adding dependency to gui-private), see QTBUG-63146.': 1}",1.0,{}
69,212262.0,1.0,1.0,0.0,NEW,False,https://codereview.qt-project.org/#/c/212262,Port QFileSystemEngine::createLink to QSystemResult,1.0,{'// TODO implement; - code needs to be moved from qfsfileengine_win.cpp': 1},1.0,{'// TODO implement; - code needs to be moved from qfsfileengine_win.cpp': 1},1.0,{}
158,212272.0,7.0,28.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/212272,Make use of our egl convenience code for QNX QPA,1.0,{'// Choose best match based on supported pixel formats': 4},1.0,{'// Choose best match based on supported pixel formats': 1},1.0,{'// Choose best match based on supported pixel formats': '4-1'}
89,213432.0,6.0,31.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/213432,Don't send a mouse move when we just need to do a synthetic enter/leave,1.0,{},0.0,{'// Send enter/leave events followed by a mouse move on the entered widget.': 4},1.0,{}
93,213493.0,2.0,8.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/213493,xcb: remove redundant QT_XCB_DEBUG_XINPUT* envvars,1.0,{},0.0,{'// TODO Qt 6 (or perhaps earlier): remove these redundant env variables': 1},1.0,{}
168,213661.0,9.0,19.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/213661,CUPS: Use printer job-hold-until as default instead of the nohold,1.0,{},0.0,{'//TODO restore last used values': 1},1.0,{}
167,213756.0,17.0,121.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/213756,Add a thread for QLowEnergyControllerPrivateWin32,1.0,{},0.0,"{'// TODO: If a device is not connected, this function will block<KAIGYO>// for some time. So, need to re-implement of writeCharacteristic()<KAIGYO>// with use QFutureWatcher.': 1}",1.0,{}
154,213798.0,2.0,23.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/213798,qlineedit: Use QIcon::Active for pressed action button,1.0,{},0.0,{'// Note isDown should really use the active state but in most styles<KAIGYO>// this has no proper feedback': 1},1.0,{}
127,214183.0,17.0,55.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/214183,Allow QQmlComponent::loadUrl() to load absolute URLs with relative paths,1.0,"{""// Shouldn't assert; we want QQmlComponent to assume that main.qml refers to<KAIGYO>// the main.qml in the current working directory."": 1, ""// Shouldn't assert; we want QQmlComponent to assume that data/QtObjectComponent.qml refers to<KAIGYO>// the data/QtObjectComponent.qml in the current working directory."": 3, '// TODO: and check if scheme is file, since local could mean it has a hostname?': 4, '// The new URL is a file on disk but it\'s a relative URL; e.g.:<KAIGYO>// QUrl::fromLocalFile("""").<KAIGYO>// We need to extract the path so that it becomes a relative URL with a relative path (i.e no scheme),<KAIGYO>// which we do with QUrl(newUrl.path()), and then turn it into an absolute URL<KAIGYO>// with an absolute path by resolving it against the engine\'s baseUrl().<KAIGYO>// This is a compatibility hack for QTBUG-58837.': 8, ""// Shouldn't assert in QQmlTypeLoader; we want QQmlComponent to assume that<KAIGYO>// data/QtObjectComponent.qml refers to the data/QtObjectComponent.qml in the current working directory."": 8, '// The new URL is either:<KAIGYO>// a) a file on disk but it\'s a relative URL; e.g.: QUrl::fromLocalFile("""")<KAIGYO>// b) a relative URL like QUrl("""")<KAIGYO>// We need to extract the path so that it becomes a relative URL with a relative path (i.e no scheme),<KAIGYO>// which we do with QUrl(newUrl.path()), and then turn it into an absolute URL<KAIGYO>// with an absolute path by resolving it against the engine\'s baseUrl().<KAIGYO>// This is a compatibility hack for QTBUG-58837.': 10, '// The new URL is a file on disk but it\'s a relative URL; e.g.:<KAIGYO>// QUrl::fromLocalFile("""")<KAIGYO>// We need to extract the path so that it becomes a relative URL with a relative path (i.e no scheme),<KAIGYO>// which we do with QUrl(newUrl.path()), and then turn it into an absolute URL<KAIGYO>// with an absolute path by resolving it against the engine\'s baseUrl().<KAIGYO>// This is a compatibility hack for QTBUG-58837.': 11, ""// Then, turn it into an absolute URL with an absolute path by resolving it against the engine's baseUrl().<KAIGYO>// This is a compatibility hack for QTBUG-58837."": 13}",1.0,{'// Workaround QTBUG-11929': 8},1.0,{}
192,214511.0,10.0,65.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/214511,Import WebKit commit 3b024218447b7838f08ccd8cf2c8515387ae41c2,1.0,"{'// Workaround for broken accesskey when QKeyEvent has modifier, see QTBUG-64891': 1}",1.0,{'// FIXME: not correct': 1},1.0,{}
168,214591.0,9.0,24.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/214591,Release left button before showing the popup context menu,1.0,{},0.0,{'//### TODO: add proper API for Qt 5.2': 1},1.0,{}
53,215289.0,1.0,1.0,0.0,ABANDONED,False,https://codereview.qt-project.org/#/c/215289,grabMouse() and QQWPriv::removeGrabber(): be clear whether mouse or touch,1.0,{},0.0,"{'// TODO fix in a separate patch after the 5.9->5.10 merge<KAIGYO>// QTest::newRow("""") << false << true;': 1}",1.0,{}
76,215290.0,8.0,19.0,0.0,NEW,False,https://codereview.qt-project.org/#/c/215290,QQuickWindow: make mouse press delivery independent of other grabs,1.0,{},0.0,"{'// TODO fix in a separate patch after the 5.9->5.10 merge<KAIGYO>// QTest::newRow("""") << false << true;': 2}",1.0,{}
73,215296.0,10.0,42.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/215296,ftp backend: Dynamically resolving resource path with URL prefix,1.0,"{""// even if we failed to set the authority properly, let's try to recover"": 1, '// no commands sent, move to the next state': 8}",1.0,"{""// even if we failed to set the authority properly, let's try to recover"": 1}",1.0,{}
222,215787.0,12.0,24.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/215787,xcb: re-factor QXcbKeyboard::updateKeymap() to remove various fallbacks,1.0,{},0.0,"{""// ### TODO some X servers don't set _XKB_RULES_NAMES at all, in these cases it is filled<KAIGYO>// with gibberish, we would need to do some kind of sanity check"": 1}",1.0,{}
274,215953.0,3.0,5.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/215953,Import WebKit commit 69d327017a8d700cbfc7e1120270db4d55416f41,1.0,{},0.0,{'// FIXME: HTML5 specifies that this should be a RadioNodeList.': 1},1.0,{}
103,216393.0,3.0,2.0,0.0,NEW,False,https://codereview.qt-project.org/#/c/216393,WIP (over)simplify QQuickWindowPrivate::deliverHoverEvent,1.0,{'// TODO get rid of accepted parameter?': 1},1.0,"{'//move': 1, ""//Not entering a new Item<KAIGYO>// ### Shouldn't we send moves for the parent items as well?"": 1}",1.0,{}
149,216605.0,6.0,15.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/216605,Unix: Fix page size margins when changing page size,1.0,{},0.0,"{'// TODO Set layout margin min/max to printer custom min/max': 1, '// TODO Set layout margin min/max to printer min/max for page size': 1}",1.0,{}
164,216696.0,2.0,25.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/216696,Fix opening of flatpak FileChooser portal,1.0,{'// TODO': 1},1.0,{'// TODO': 1},1.0,{}
176,216733.0,2.0,3.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/216733,Optimizations for Repeater::clear() and ~QQmlItem(),1.0,{},0.0,{'// XXX todo - optimize': 1},1.0,{}
206,216806.0,6.0,19.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/216806,Speed up PropertyChange state application,1.0,{'//### better way to check for signal property?': 1},1.0,{'//### better way to check for signal property?': 1},1.0,{}
16,217053.0,2.0,8.0,0.0,NEW,False,https://codereview.qt-project.org/#/c/217053,xcb: Improve AltGr handling for legacy X11 keyboard support,1.0,{},0.0,"{""        /* Level 3 symbols (e.g. AltGr+something) seem to come in two flavors:<KAIGYO>         * - as a proper level 3 in group 1, at least on recent X.org versions<KAIGYO>         * - 'disguised' as group 2, on 'legacy' X servers<KAIGYO>         * In the 2nd case, remap group 2 to level 3, that seems to work better<KAIGYO>         * in practice */"": 1}",1.0,{}
160,217661.0,2.0,14.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/217661,QQmlEngineDebugService: Output better diagnostics on test failure,1.0,{'// TODO test complex types': 1},1.0,{'// TODO test complex types': 1},1.0,{}
224,217898.0,3.0,7.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/217898,Match QQmlEngineDebugServiceTest to the service,1.0,{},0.0,{'// TODO test complex types': 1},1.0,{}
95,218233.0,11.0,33.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/218233,Fix dead lock / race in QML type loader when importing plugins,1.0,"{'// things on the engine (eg. adding new global objects) have to be done for every<KAIGYO>// engine.<KAIGYO>// XXX protect against double initialization': 5, ""// Engines in separate threads are tricky, but as long as we do not create a graphical object and<KAIGYO>// move objects created by the engines across thread boundaries, this is safe. At the same time<KAIGYO>// this allows us to place the engine's loader thread into the position where, without the fix<KAIGYO>// for this bug, the global lock is acquired."": 7, '// XXX protect against double initialization': 8, ""// The plugin's per-engine initialization does not need lock protection, as this function is<KAIGYO>// only called from the engine specific loader thread and importDynamicPlugin as well as<KAIGYO>// importStaticPlugin are the only places of access.<KAIGYO>// XXX protect against double initialization"": 8, ""// Engines in separate threads are tricky, but as long as we do not create a graphical<KAIGYO>// object and move objects created by the engines across thread boundaries, this is safe.<KAIGYO>// At the same time this allows us to place the engine's loader thread into the position<KAIGYO>// where, without the fix for this bug, the global lock is acquired."": 10}",1.0,{'// things on the engine (eg. adding new global objects) have to be done for every<KAIGYO>// engine.<KAIGYO>// XXX protect against double initialization': 5},1.0,{}
40,218284.0,2.0,11.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/218284,ANGLE: Remove workaround for files having the same name (Debug.h/.cpp),1.0,{},0.0,{'// TODO(geofflang) Check the synchronous flag and potentially flush messages from another<KAIGYO>// thread.': 1},1.0,{}
189,218573.0,8.0,18.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/218573,QQuickWindow: obey AA_SynthesizeMouseForUnhandledTouchEvents,1.0,"{'// targetEvent is already transformed wrt local position, velocity, etc.<KAIGYO>// FIXME: remove asTouchEvent!!!': 1}",1.0,"{'// targetEvent is already transformed wrt local position, velocity, etc.<KAIGYO>// FIXME: remove asTouchEvent!!!': 1}",1.0,{}
182,218790.0,4.0,12.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/218790,stylesheets cleanup to prepare for a bigger patch,1.0,"{'// Metal hack has been removed. Checkout 5.11 to look at it.': 1, '// Metal hack, WA_MacOpaqueSizeGrip and WA_Hover have been removed<KAIGYO>// Checkout 5.11 to look at them': 2}",1.0,"{""// Used to be included in Qt4 for Q_WS_MAC<KAIGYO>// the metalhack boolean allows Qt/Mac to do a proper re-polish depending<KAIGYO>// on how the Qt::WA_MacBrushedMetal attribute is set. It is only ever<KAIGYO>// set when changing that attribute and passes the widget's CURRENT style.<KAIGYO>// therefore no need to do a reassignment."": 1}",1.0,{}
177,218908.0,2.0,5.0,0.0,ABANDONED,False,https://codereview.qt-project.org/#/c/218908,WIP: qdoc: Fix Clang default arguments,1.0,{},0.0,{'// HEINOUS_SYSINC_HACK': 2},1.0,{}
179,218921.0,2.0,2.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/218921,LE/Android: replace activity()/service() with context(),1.0,{},0.0,{'// TODO: replace with QtAndroidPrivate::context() introduced by Qt 5.8': 1},1.0,{}
13,219003.0,2.0,3.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/219003,Remove QCupsPrintEnginePrivate::setupDefaultPrinter,1.0,{},0.0,"{'// Get default printer id, if no default then use the first available<KAIGYO>// TODO Find way to remove printerName from base class?': 1}",1.0,{}
26,219067.0,2.0,7.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/219067,eglfs_kms_vsp2: Try to recover when failing in the middle of a blend,1.0,{},0.0,"{""//TODO: perhaps it's better to try to continue with the other inputs?"": 1}",1.0,{}
65,219123.0,10.0,61.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/219123,Merge remote-tracking branch 'origin/5.10' into 5.11,1.0,{},0.0,"{'/*!<KAIGYO>    \\fn QJsonArray::QJsonArray(std::initializer_list<QJsonValue> args)<KAIGYO>    \\since 5.4<KAIGYO>    Creates an array initialized from \\a args initialization list.<KAIGYO><KAIGYO>    QJsonArray can be constructed in a way similar to JSON notation,<KAIGYO>    for example:<KAIGYO>    \\code<KAIGYO>    QJsonArray array = { 1, 2.2, QString() };<KAIGYO>    \\endcode<KAIGYO> */': 3, '/*! \\class QJsonArray::iterator<KAIGYO>    \\inmodule QtCore<KAIGYO>    \\brief The QJsonArray::iterator class provides an STL-style non-const iterator for QJsonArray.<KAIGYO><KAIGYO>    QJsonArray::iterator allows you to iterate over a QJsonArray<KAIGYO>    and to modify the array item associated with the<KAIGYO>    iterator. If you want to iterate over a const QJsonArray, use<KAIGYO>    QJsonArray::const_iterator instead. It is generally a good practice to<KAIGYO>    use QJsonArray::const_iterator on a non-const QJsonArray as well, unless<KAIGYO>    you need to change the QJsonArray through the iterator. Const<KAIGYO>    iterators are slightly faster and improves code readability.<KAIGYO><KAIGYO>    The default QJsonArray::iterator constructor creates an uninitialized<KAIGYO>    iterator. You must initialize it using a QJsonArray function like<KAIGYO>    QJsonArray::begin(), QJsonArray::end(), or QJsonArray::insert() before you can<KAIGYO>    start iterating.<KAIGYO><KAIGYO>    Most QJsonArray functions accept an integer index rather than an<KAIGYO>    iterator. For that reason, iterators are rarely useful in<KAIGYO>    connection with QJsonArray. One place where STL-style iterators do<KAIGYO>    make sense is as arguments to \\l{generic algorithms}.<KAIGYO><KAIGYO>    Multiple iterators can be used on the same array. However, be<KAIGYO>    aware that any non-const function call performed on the QJsonArray<KAIGYO>    will render all existing iterators undefined.<KAIGYO><KAIGYO>    \\sa QJsonArray::const_iterator<KAIGYO>*/': 3, '/*! \\class QJsonArray::const_iterator<KAIGYO>    \\inmodule QtCore<KAIGYO>    \\brief The QJsonArray::const_iterator class provides an STL-style const iterator for QJsonArray.<KAIGYO><KAIGYO>    QJsonArray::const_iterator allows you to iterate over a<KAIGYO>    QJsonArray. If you want to modify the QJsonArray as<KAIGYO>    you iterate over it, use QJsonArray::iterator instead. It is generally a<KAIGYO>    good practice to use QJsonArray::const_iterator on a non-const QJsonArray<KAIGYO>    as well, unless you need to change the QJsonArray through the<KAIGYO>    iterator. Const iterators are slightly faster and improves<KAIGYO>    code readability.<KAIGYO><KAIGYO>    The default QJsonArray::const_iterator constructor creates an<KAIGYO>    uninitialized iterator. You must initialize it using a QJsonArray<KAIGYO>    function like QJsonArray::constBegin(), QJsonArray::constEnd(), or<KAIGYO>    QJsonArray::insert() before you can start iterating.<KAIGYO><KAIGYO>    Most QJsonArray functions accept an integer index rather than an<KAIGYO>    iterator. For that reason, iterators are rarely useful in<KAIGYO>    connection with QJsonArray. One place where STL-style iterators do<KAIGYO>    make sense is as arguments to \\l{generic algorithms}.<KAIGYO><KAIGYO>    Multiple iterators can be used on the same array. However, be<KAIGYO>    aware that any non-const function call performed on the QJsonArray<KAIGYO>    will render all existing iterators undefined.<KAIGYO><KAIGYO>    \\sa QJsonArray::iterator<KAIGYO>*/': 3}",1.0,{}
102,219284.0,3.0,8.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/219284,QList/Table/TreeWidget: remove vc6 workaround,1.0,{},0.0,{'// workaround for VC++ 6.0 linker bug (?)': 1},1.0,{}
185,219563.0,9.0,50.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/219563,logging: Clarify and document how we look for the presence of a console,1.0,{},0.0,"{""// rules to determine if we'll log preferably to the console:<KAIGYO>//  1) if QT_LOGGING_TO_CONSOLE is set, it determines behavior:<KAIGYO>//    - if it's set to 0, we will not log to console<KAIGYO>//    - if it's set to 1, we will log to console<KAIGYO>//  2) otherwise, we will log to console if we have a console window (Windows)<KAIGYO>//     or a controlling TTY (Unix). This is done even if stderr was redirected<KAIGYO>//     to the blackhole device (NUL or /dev/null)."": 1}",1.0,{}
164,219623.0,3.0,3.0,0.0,ABANDONED,False,https://codereview.qt-project.org/#/c/219623,WIP: Start updating the parser to make it ES6 compatible,1.0,{'// ### TODO: AST for initializer': 1},1.0,{'// ### TODO: AST for initializer': 1},1.0,{}
254,219713.0,23.0,39.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/219713,Add support for ES6 template strings,1.0,{'// ### TODO: AST for initializer': 1},1.0,{'// ### TODO: AST for initializer': 1},1.0,{}
255,219811.0,27.0,46.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/219811,Partially support binding patterns,1.0,{'// ### TODO: AST for initializer': 1},1.0,{'// ### TODO: AST for initializer': 1},1.0,{}
251,219812.0,19.0,62.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/219812,Get rid of qlalr generated files,1.0,{},0.0,{'// ### TODO: AST for initializer': 1},1.0,{}
78,220079.0,4.0,16.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/220079,Use explicit QThreadData::hasEventDispatcher() where possible,1.0,{'// perhaps application/thread is shutting down': 1},1.0,{'// perhaps application/thread is shutting down': 1},1.0,{}
72,220352.0,1.0,1.0,0.0,ABANDONED,False,https://codereview.qt-project.org/#/c/220352,Avoid program without shaders when glProgramBinary fails,1.0,{},0.0,{'// glProgramBinary(). Check to see if the program is already linked and<KAIGYO>// bail out if so.': 1},1.0,{}
100,220446.0,1.0,4.0,0.0,ABANDONED,False,https://codereview.qt-project.org/#/c/220446,Change leading tabs to 4 spaces,1.0,"{'// Note: if the QCursorData::update() function is ever finished,<KAIGYO>// this should probably be changed to just use that': 1}",1.0,"{'//Note: if the QCursorData::update() function is ever finished,<KAIGYO>//\tthis should probably be changed to just use that': 1}",1.0,{}
170,220659.0,4.0,46.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/220659,White-list more recent Mesa version for multi-threading,1.0,"{""// The issue was fixed in Xcb 1.11, but we can't check for that<KAIGYO>// at runtime, so instead assume it fixed with recent Mesa versions<KAIGYO>// released several years after the Xcb fix."": 1}",1.0,"{'// This disables threaded rendering on anything using mesa, e.g.<KAIGYO>// - nvidia/nouveau<KAIGYO>// - amd/gallium<KAIGYO>// - intel<KAIGYO>// - some software opengl implementations<KAIGYO>//<KAIGYO>// The client glx vendor string is used to identify those setups as that seems to show the least<KAIGYO>// variance between the bad configurations. It\'s always """". There are some<KAIGYO>// configurations which don\'t use mesa and which can do threaded rendering (amd and nvidia chips<KAIGYO>// with their own proprietary drivers).<KAIGYO>//<KAIGYO>// This, of course, is very broad and disables threaded rendering on a lot of devices which would<KAIGYO>// be able to use it. However, the bugs listed below don\'t follow any easily recognizable pattern<KAIGYO>// and we should rather be safe.<KAIGYO>//<KAIGYO>// httpcgit.freedesktop.org/xcb/libxcb/commit/?id=be0fe56c3bcad5124dcc6c47a2fad01acd16f71a will<KAIGYO>// fix some of the issues. Basically, the proprietary drivers seem to have a way of working around<KAIGYO>// a fundamental flaw with multithreaded access to xcb, but mesa doesn\'t. The blacklist should be<KAIGYO>// reevaluated once that patch is released in some version of xcb.': 1}",1.0,{}
224,220951.0,3.0,4.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/220951,Remove left over json/qjsonarray.cpp,1.0,{},0.0,"{'/*!<KAIGYO>    \\fn QJsonArray::QJsonArray(std::initializer_list<QJsonValue> args)<KAIGYO>    \\since 5.4<KAIGYO>    Creates an array initialized from \\a args initialization list.<KAIGYO><KAIGYO>    QJsonArray can be constructed in a way similar to JSON notation,<KAIGYO>    for example:<KAIGYO>    \\code<KAIGYO>    QJsonArray array = { 1, 2.2, QString() };<KAIGYO>    \\endcode<KAIGYO> */': 1, '/*! \\class QJsonArray::iterator<KAIGYO>    \\inmodule QtCore<KAIGYO>    \\brief The QJsonArray::iterator class provides an STL-style non-const iterator for QJsonArray.<KAIGYO><KAIGYO>    QJsonArray::iterator allows you to iterate over a QJsonArray<KAIGYO>    and to modify the array item associated with the<KAIGYO>    iterator. If you want to iterate over a const QJsonArray, use<KAIGYO>    QJsonArray::const_iterator instead. It is generally a good practice to<KAIGYO>    use QJsonArray::const_iterator on a non-const QJsonArray as well, unless<KAIGYO>    you need to change the QJsonArray through the iterator. Const<KAIGYO>    iterators are slightly faster and improves code readability.<KAIGYO><KAIGYO>    The default QJsonArray::iterator constructor creates an uninitialized<KAIGYO>    iterator. You must initialize it using a QJsonArray function like<KAIGYO>    QJsonArray::begin(), QJsonArray::end(), or QJsonArray::insert() before you can<KAIGYO>    start iterating.<KAIGYO><KAIGYO>    Most QJsonArray functions accept an integer index rather than an<KAIGYO>    iterator. For that reason, iterators are rarely useful in<KAIGYO>    connection with QJsonArray. One place where STL-style iterators do<KAIGYO>    make sense is as arguments to \\l{generic algorithms}.<KAIGYO><KAIGYO>    Multiple iterators can be used on the same array. However, be<KAIGYO>    aware that any non-const function call performed on the QJsonArray<KAIGYO>    will render all existing iterators undefined.<KAIGYO><KAIGYO>    \\sa QJsonArray::const_iterator<KAIGYO>*/': 1, '/*! \\class QJsonArray::const_iterator<KAIGYO>    \\inmodule QtCore<KAIGYO>    \\brief The QJsonArray::const_iterator class provides an STL-style const iterator for QJsonArray.<KAIGYO><KAIGYO>    QJsonArray::const_iterator allows you to iterate over a<KAIGYO>    QJsonArray. If you want to modify the QJsonArray as<KAIGYO>    you iterate over it, use QJsonArray::iterator instead. It is generally a<KAIGYO>    good practice to use QJsonArray::const_iterator on a non-const QJsonArray<KAIGYO>    as well, unless you need to change the QJsonArray through the<KAIGYO>    iterator. Const iterators are slightly faster and improves<KAIGYO>    code readability.<KAIGYO><KAIGYO>    The default QJsonArray::const_iterator constructor creates an<KAIGYO>    uninitialized iterator. You must initialize it using a QJsonArray<KAIGYO>    function like QJsonArray::constBegin(), QJsonArray::constEnd(), or<KAIGYO>    QJsonArray::insert() before you can start iterating.<KAIGYO><KAIGYO>    Most QJsonArray functions accept an integer index rather than an<KAIGYO>    iterator. For that reason, iterators are rarely useful in<KAIGYO>    connection with QJsonArray. One place where STL-style iterators do<KAIGYO>    make sense is as arguments to \\l{generic algorithms}.<KAIGYO><KAIGYO>    Multiple iterators can be used on the same array. However, be<KAIGYO>    aware that any non-const function call performed on the QJsonArray<KAIGYO>    will render all existing iterators undefined.<KAIGYO><KAIGYO>    \\sa QJsonArray::iterator<KAIGYO>*/': 1}",1.0,{}
94,221208.0,7.0,50.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/221208,qsimd: add support for new x86 CPU features,1.0,{},0.0,"{'// the low 32-bits of features is cpuid01ECX<KAIGYO>// note: we need to check OS support for saving the AVX register state': 1, '// the high 32-bits of features is cpuid0700EBX': 1}",1.0,{}
95,221358.0,7.0,13.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/221358,AnimatedSprite: set implicit size based on implicit frame size,1.0,{},0.0,{'//TODO: Implicitly size element to size of sprite': 1},1.0,{}
117,221437.0,3.0,5.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/221437,Merge remote-tracking branch 'origin/5.11' into dev,1.0,{},0.0,{'//TODO: Implicitly size element to size of sprite': 2},1.0,{}
114,221531.0,2.0,3.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/221531,Move test for ignoreMessage to the top,1.0,"{'// although silly, it should not cause a warning from the Layouts POV': 1}",1.0,"{'// although silly, it should not cause a warning from the Layouts POV': 1}",1.0,{}
195,221769.0,4.0,26.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/221769,tests: cleanup tst_QComboBox::keyBoardNavigationWithMouse(),1.0,{},0.0,{'//since we moved the mouse is in the middle it should even be around 5;': 1},1.0,{}
245,222016.0,31.0,42.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/222016,Bring JS grammar in line with ES7 spec,1.0,{'// TODO: give a warning.': 2},1.0,{'// TODO: give a warning.': 2},1.0,{}
41,222037.0,3.0,5.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/222037,Revert the heinous sysinc hack qdoc needed for clang 3.9,1.0,{},0.0,{'// HEINOUS_SYSINC_HACK': 1},1.0,{}
84,222214.0,5.0,22.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/222214,QSemaphore: fix deadlock when the woken up thread wakes up another,1.0,"{""// If we're counting waiters, the number of waiters is stored in the low 31<KAIGYO>// bits of the high word (that is, bits 32-62). If we're not, then we use<KAIGYO>// bit 31 to indicate anyone is waiting. Either way, if any bit 31 or above<KAIGYO>// is set, there are waiters."": 1}",1.0,"{'// quintptr might be 32bit, in which case we want this to be 0, without implicitly casting.': 1}",1.0,{}
100,222310.0,4.0,4.0,0.0,ABANDONED,False,https://codereview.qt-project.org/#/c/222310,WIP: debug new parser,1.0,{'// TODO: give a warning.': 2},1.0,{'// TODO: give a warning.': 2},1.0,{}
119,222506.0,1.0,1.0,0.0,ABANDONED,False,https://codereview.qt-project.org/#/c/222506,WIP: debug new parser,1.0,{'// TODO: give a warning.': 1},1.0,{'// TODO: give a warning.': 1},1.0,{}
144,222541.0,1.0,1.0,0.0,ABANDONED,False,https://codereview.qt-project.org/#/c/222541,WIP: Bring JS grammar in line with ES7 spec,1.0,{'// TODO: give a warning.': 1},1.0,{'// TODO: give a warning.': 1},1.0,{}
202,222749.0,2.0,6.0,0.0,ABANDONED,False,https://codereview.qt-project.org/#/c/222749,Fix circular dependency handling for composite singletons,1.0,{},0.0,"{'// TODO: give an error message? If so, we should record and show the path of the cycle.': 1}",1.0,{}
199,222788.0,10.0,44.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/222788,macOS: Explicitly link to debug version of framework when needed,1.0,{},0.0,"{'// Loading both the debug and release version of the cocoa plugins causes the objective-c runtime<KAIGYO>// to print """" warnings. Detect if QFactoryLoader is about to load both,<KAIGYO>// skip one of them (below).<KAIGYO>//<KAIGYO>// ### FIXME find a proper solution<KAIGYO>//': 4}",1.0,{}
242,222915.0,14.0,17.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/222915,Deliver QNativeGestureEvent via deliverSinglePointEventUntilAccepted,1.0,"{""// TODO can't copy things I can't access"": 1}",1.0,"{""// TODO can't copy things I can't access"": 1}",1.0,{}
235,222916.0,4.0,11.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/222916,Tighten QML cache version checking,1.0,{},0.0,{'// This is a bit of a hack to make development easier. When hacking on the code generator<KAIGYO>// the cache files may end up being re-used. To avoid that we also add the checksum of<KAIGYO>// the QtQml library.': 1},1.0,{}
267,224594.0,27.0,31.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/224594,Add support for proper lexical scoping,1.0,{},0.0,"{'// temporary hack to work around some unknown issue in 1.7': 13, '// Hack to ensure an activation is created.': 15, ""/* The next three methods are a bit tricky. They can't open up a Scope, as that<KAIGYO> * would mess up the pushing of the context.<KAIGYO> *<KAIGYO> * Instead the push/pop pair acts as a non local scope.<KAIGYO> */"": 15, ""// Even though this is bad practice (and test262 covers it with best practices test cases),<KAIGYO>// we do allow for function declarations in if and while statements, as unfortunately that's<KAIGYO>// real world JavaScript. (QTBUG-33064 for example)"": 21}",1.0,{}
258,224950.0,5.0,19.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/224950,Fix bug preventing ungrabMouse() on TouchCancel,1.0,{},0.0,{'// TODO Is it a bug if a QTouchEvent comes here?': 4},1.0,{}
146,225343.0,17.0,20.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/225343,Rework catch context handling,1.0,{},0.0,"{""/* The next three methods are a bit tricky. They can't open up a Scope, as that<KAIGYO> * would mess up the pushing of the context.<KAIGYO> *<KAIGYO> * Instead the push/pop pair acts as a non local scope.<KAIGYO> */"": 1}",1.0,{}
109,225344.0,17.0,20.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/225344,Cleanup handling of with() statements,1.0,{},0.0,{'// Hack to ensure an activation is created.': 1},1.0,{}
104,225425.0,1.0,1.0,0.0,ABANDONED,False,https://codereview.qt-project.org/#/c/225425,Unify the Object::getValueOrSetter overloads,1.0,"{""// this is an evil hack, but it works, as the method is only ever called from putIndexed,<KAIGYO>// where we don't use the returned pointer there for non writable attributes"": 1}",1.0,"{""// this is an evil hack, but it works, as the method is only ever called from putIndexed,<KAIGYO>// where we don't use the returned pointer there for non writable attributes"": 1}",1.0,{}
278,225924.0,15.0,40.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/225924,"xcb: rely on WM_SIZE_HINTS gravity to handle x,y positioning",1.0,"{'    /* Gravity describes how to interpret x and y positions in subsequent<KAIGYO>       calls to xcb_configure_window()<KAIGYO>       XCB_GRAVITY_STATIC     : the left top corner of the client window<KAIGYO>       XCB_GRAVITY_NORTH_WEST : the left top corner of the frame window */': 1, '    /* Gravity describes how to interpret x and y values the next time<KAIGYO>       window needs to be positioned on a screen.<KAIGYO>       XCB_GRAVITY_STATIC     : the left top corner of the client window<KAIGYO>       XCB_GRAVITY_NORTH_WEST : the left top corner of the frame window */': 4, ""// ### Qt 6 - Perhaps it makes sense to dumb down the restoreGeometry() logic. This function<KAIGYO>// is full of undocumented tweaks. It should simply take the saved geometry, screen, and/or<KAIGYO>// placement in a virtual desktop and call the corresponding APIs to set the storred values,<KAIGYO>// without any sanity checking. Thats all. If a user has changed a desktop settings (e.g<KAIGYO>// screen size, window decoration size) then an application should have an option not to<KAIGYO>// restore from saved settings (or reset to defaults). A smarter restoreGeometry() version<KAIGYO>// could store screen serial numbers and return 'false' if things has changed. There are a<KAIGYO>// lot of ways to do this, perhaps the best is to have dump version and document it as such<KAIGYO>// and inform developers that they can write a smarter version if desired."": 10, '// ### Qt 6 - Perhaps it makes sense to dumb down the restoreGeometry() logic, see QTBUG-69104': 12}",1.0,{'// Parameters to XCreateWindow() are frame corner + inner size.<KAIGYO>// This fits in case position policy is frame inclusive. There is<KAIGYO>// currently no way to implement it for frame-exclusive geometries.': 5},1.0,{}
225,226449.0,26.0,107.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/226449,QRegularExpression: refactor wildcard translation,1.0,{},0.0,"{'// Valid case but pattern generated is wrong, will be fixed in next refactoring': 2}",1.0,{}
43,227017.0,6.0,13.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/227017,TableView: add support for table margins,1.0,"{'// ###todo: support starting with other top-left items than 0,0': 1}",1.0,"{'// Request loaded top-left item rather than an edge.<KAIGYO>// ###todo: support starting with other top-left items than 0,0': 1}",1.0,{}
121,227531.0,3.0,9.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/227531,Remove hack that violates ODR,1.0,{},0.0,{'// hack': 1},1.0,{}
20,228083.0,1.0,1.0,0.0,ABANDONED,False,https://codereview.qt-project.org/#/c/228083,WIP: dnd: random fixes,1.0,{},0.0,{'// #fixme enableEventFilter();': 1},1.0,{}
40,228186.0,3.0,4.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/228186,Fix crash in qsslsocket_openssl,1.0,{},0.0,"{'// TODO: verify ASAP, in the past we had sk_pop_free with q_OPENSSL_sk_free<KAIGYO>// which seems to be blatantly wrong and even crashes with 1.1.': 2}",1.0,{}
99,228354.0,3.0,10.0,0.0,ABANDONED,False,https://codereview.qt-project.org/#/c/228354,QSslSocket: add and set the TLSv1.3-specific PSK callback,1.0,{},0.0,"{'// FIXME. With OpenSSL 1.1.1 and TLS 1.3 PSK auto-test is broken.': 2, '// FIXME: with OpenSSL 1.1.1 (thus TLS 1.3) test is known to fail<KAIGYO>// due to the different PSK mechanism (?) - to be investigated ASAP.': 2}",1.0,{}
221,228381.0,6.0,16.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/228381,Ensure we have a lexical scope for global code,1.0,{},0.0,"{""// ### Shouldn't be required, we could probably rather change the ContextType to FunctionCode for strict eval"": 2}",1.0,{}
115,228382.0,2.0,2.0,0.0,ABANDONED,False,https://codereview.qt-project.org/#/c/228382,WIP: Introduce a scriptcontext,1.0,{},0.0,"{""// ### Shouldn't be required, we could probably rather change the ContextType to FunctionCode for strict eval"": 1}",1.0,{}
226,228418.0,19.0,40.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/228418,dnd: send DragEnter and DragMove on DnD start,1.0,"{'// ### FIXME - QTBUG-35117 ????': 1, '// ### FIXME - QTBUG-35117 ???': 9, '// Some dnd implementation rely on running internal event loops, so we have to use<KAIGYO>// the following queued signal hack to simulate mouse clicks in the widget.': 9, '// Note: This test is somewhat a hack as testing DnD with qtestlib is not<KAIGYO>// supported at the moment. The test verifies that we get an expected event<KAIGYO>// sequence on dnd operation that does not move a mouse. This logic is implemented<KAIGYO>// in QGuiApplication, so we have to go via QWindowSystemInterface API (QTest::mouse*).': 11}",1.0,{'// #fixme enableEventFilter();': 1},1.0,{}
109,228419.0,8.0,22.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/228419,xcb: qxcbdrag.cpp cleanups,1.0,"{'// ### FIXME ? - answerRect appears to be unused.<KAIGYO>// The target sends a ClientMessage of type XdndStatus. This tells the source whether or not<KAIGYO>// it will accept the drop, and, if so, what action will be taken. It also includes a rectangle<KAIGYO>// that means """".': 1, '// Target receives XdndDrop. Once it is finished processing the drop, it sends XdndFinished.': 1}",1.0,{'// #fixme enableEventFilter();': 7},1.0,{}
184,228720.0,1.0,2.0,0.0,ABANDONED,False,https://codereview.qt-project.org/#/c/228720,WIP: wasm: improve event dispatcher,1.0,{},0.0,{'// probably not the best way': 1},1.0,{}
199,228930.0,3.0,3.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/228930,Enable checks for tst_QHeaderView::sectionSizeHint(),1.0,{},0.0,{'// TODO how to test the return value?': 1},1.0,{}
225,229000.0,12.0,30.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/229000,widgetwindow: send DragMove for every DragEnter,1.0,{},0.0,"{""// Handling 'DragEnter' should suffice for the application."": 1}",1.0,{}
71,229211.0,6.0,8.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/229211,wasm: implement event dispatcher timers,1.0,{},0.0,{'// probably not the best way': 1},1.0,{}
189,229412.0,8.0,36.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/229412,Move qtimageformats over to the new config system,1.0,{},0.0,"{'// This version of Jasper is broken, according to the old Qt Solutions docs': 1}",1.0,{}
96,229427.0,2.0,2.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/229427,Move QQuickHandlerPoint into its own header and cpp files,1.0,"{'/*!<KAIGYO>    \\readonly<KAIGYO>    \\qmlproperty QVector2D QtQuick::HandlerPoint::velocity<KAIGYO>    \\brief A vector representing the average speed and direction of movement<KAIGYO><KAIGYO>    This is a velocity vector pointing in the direction of movement, in logical<KAIGYO>    pixels per second. It has x and y components, at least one of which will be<KAIGYO>    nonzero when this point is in motion. It holds the average recent velocity:<KAIGYO>    how fast and in which direction the event point has been moving recently.<KAIGYO><KAIGYO>    \\sa QtQuick::EventPoint::velocity, QtQuick::TouchPoint::velocity, QTouchEvent::TouchPoint::velocity<KAIGYO>*/': 1}",1.0,"{'/*!<KAIGYO>    \\readonly<KAIGYO>    \\qmlproperty QVector2D QtQuick::HandlerPoint::velocity<KAIGYO>    \\brief A vector representing the average speed and direction of movement<KAIGYO><KAIGYO>    This is a velocity vector pointing in the direction of movement, in logical<KAIGYO>    pixels per second. It has x and y components, at least one of which will be<KAIGYO>    nonzero when this point is in motion. It holds the average recent velocity:<KAIGYO>    how fast and in which direction the event point has been moving recently.<KAIGYO><KAIGYO>    \\sa QtQuick::EventPoint::velocity, QtQuick::TouchPoint::velocity, QTouchEvent::TouchPoint::velocity<KAIGYO>*/': 1}",1.0,{}
195,229430.0,26.0,45.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/229430,Make DragHandler a MultiPointHandler,1.0,"{'//        acceptedButtons: Qt.AllButtons // TODO: only SinglePointHandler has this so far': 12, '// TODO wrong I think': 18, '// TODO fails here': 18, '// Move some more... PinchHandler and MPTA both keep reacting': 19}",1.0,"{""// ATM it's required that when PinchHandler sees the third touchpoint,<KAIGYO>// the pre-existing points must have moved far enough to exceed the drag threshold.<KAIGYO>// If MPTA is allowed to grab that third point, then PinchHandler won't steal.<KAIGYO>// TODO should we change that?  make sure that if PH has a passive grab, it always gets updated even though MPTA has the grab?"": 19, '// Move some more... MPTA keeps reacting': 19}",1.0,{}
153,229503.0,10.0,19.0,0.0,DEFERRED,False,https://codereview.qt-project.org/#/c/229503,Fix AnimatedSprite showing the first frame briefly after being hidden,1.0,"{'//### hard-coded 0/1 work because we are the only<KAIGYO>// images in the sprite sheet (without this we cannot assume<KAIGYO>// where in the sheet we begin/end).': 2, '// TODO: is this necessary anymore?': 4}",1.0,{'//### hard-coded 0/1 work because we are the only<KAIGYO>// images in the sprite sheet (without this we cannot assume<KAIGYO>// where in the sheet we begin/end).': 2},1.0,{}
162,229790.0,4.0,9.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/229790,wasm: fix QNetworkRequest error handling,1.0,"{'//TODO other operations, handle user/pass, handle binary data, data streaming': 1}",1.0,"{'// FIXME TODO do something with null termination lines ??': 1, '//TODO other operations, handle user/pass, handle binary data': 1}",1.0,{}
26,230089.0,4.0,8.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/230089,Open native file dialog inside sandbox when opening directories,1.0,{},0.0,{'// TODO': 1},1.0,{}
23,230097.0,1.0,1.0,0.0,ABANDONED,False,https://codereview.qt-project.org/#/c/230097,Move QInternalMimeData to a separate file,1.0,{'//put png at the front because it is best': 1},1.0,{'//put png at the front because it is best': 1},1.0,{}
153,230576.0,2.0,2.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/230576,Remove old pre-QFileSystemEngine-rewrite code,1.0,{},0.0,{'// XXX Avoid encoding entire path. Should store encoded dirpath in cache': 1},1.0,{}
176,230715.0,1.0,5.0,0.0,ABANDONED,False,https://codereview.qt-project.org/#/c/230715,Remove old pre-QFileSystemEngine-rewrite code,1.0,{},0.0,{'// XXX Avoid encoding entire path. Should store encoded dirpath in cache': 1},1.0,{}
266,230832.0,5.0,8.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/230832,qdoc: Refactor section construction and processing,1.0,{},0.0,"{'/*!<KAIGYO>QString Sections::sortName(const Node *node, const QString* name)<KAIGYO>  Insert the \\a node into the temporary section \\a fs. Whether<KAIGYO>  the \\a node is actually inserted can depend on the \\a style<KAIGYO>  and the \\a status.<KAIGYO>void Sections::insert(FastSection &fs, Node *node, Style style, Status status)<KAIGYO>    bool inheritedMember = false;<KAIGYO>                inheritedMember = true;<KAIGYO>        FunctionNode *func = (FunctionNode *) node;<KAIGYO>        irrelevant = (inheritedMember && (func->isSomeCtor() || func->isDtor()));<KAIGYO>        irrelevant = (inheritedMember && style != Subpage);<KAIGYO>        if (!irrelevant && style == Detailed && node->isTypedef()) {<KAIGYO>        if (status == Obsolete)<KAIGYO>            irrelevant = (node->status() != Node::Obsolete);<KAIGYO>        else<KAIGYO>            irrelevant = (node->status() == Node::Obsolete);<KAIGYO>    }<KAIGYO><KAIGYO>    if (!irrelevant) {<KAIGYO>        if (!inheritedMember || style == Subpage) {<KAIGYO>            QString key = sortName(node);<KAIGYO>            fs.memberMap_.insertMulti(key, node);<KAIGYO>        }<KAIGYO>        else {<KAIGYO>            if (node->parent()->isClass() || node->parent()->isNamespace()) {<KAIGYO>                if (fs.inherited_.isEmpty() || fs.inherited_.last().first != node->parent()) {<KAIGYO>                    fs.inherited_.append(p);<KAIGYO>                fs.inherited_.last().second++;<KAIGYO>  Returns \\c true if \\a node represents a reimplemented member<KAIGYO>  function in the class of the FastSection \\a fs. If it is<KAIGYO>  a reimplemented function, then it is inserted into the<KAIGYO>  reimplemented member map in \\a fs. The test is performed<KAIGYO>  only if \\a status is \\e OK. True is returned if \\a node<KAIGYO>  is inserted into the map. Otherwise, false is returned.<KAIGYO>bool Sections::insertReimpFunc(FastSection& fs, Node* node, Status status)<KAIGYO>        if (!fn->reimplementedFrom().isEmpty() && (status == Okay)) {<KAIGYO>                if (!fs.reimpMemberMap_.contains(key)) {<KAIGYO>                    fs.reimpMemberMap_.insert(key,node);<KAIGYO>  If \\a fs is not empty, convert it to a Section and append<KAIGYO>  the new Section to \\a sectionList.<KAIGYO>void Sections::append(QList<Section>& sectionList, const FastSection& fs, bool includeKeys)<KAIGYO>    if (!fs.isEmpty()) {<KAIGYO>        Section section(fs.name_, fs.divClass_, fs.singular_, fs.plural_);<KAIGYO>        sectionList.append(section);<KAIGYO>        Section* s = &sectionList[sectionList.size()-1];<KAIGYO>        if (fs.classMapList_.isEmpty()) {<KAIGYO>            Section section(fs.name_, fs.divClass_, fs.singular_, fs.plural_);<KAIGYO>            if (includeKeys)<KAIGYO>                s->keys_ = fs.memberMap_.keys();<KAIGYO>            s->members_ = fs.memberMap_.values();<KAIGYO>            s->reimpMembers_ = fs.reimpMemberMap_.values();<KAIGYO>            s->inherited_ = fs.inherited_;<KAIGYO>        }<KAIGYO>        else {<KAIGYO>            for (int i=0; i<fs.classMapList_.size(); i++) {<KAIGYO>                ClassMap* classMap = fs.classMapList_[i];<KAIGYO>                ClassKeysNodes* ckn = new ClassKeysNodes;<KAIGYO>                ckn->first = classMap->first;<KAIGYO>                ckn->second.second = classMap->second.values();<KAIGYO>                ckn->second.first = classMap->second.keys();<KAIGYO>                s->classKeysNodesList_.append(ckn);<KAIGYO>             }<KAIGYO>static void clearClassSummaryVars()<KAIGYO>    privateFuncs.clear();<KAIGYO>    privateSlots.clear();<KAIGYO>    privateTypes.clear();<KAIGYO>    protectedFuncs.clear();<KAIGYO>    protectedSlots.clear();<KAIGYO>    protectedTypes.clear();<KAIGYO>    protectedVars.clear();<KAIGYO>    publicFuncs.clear();<KAIGYO>    publicSignals.clear();<KAIGYO>    publicSlots.clear();<KAIGYO>    publicTypes.clear();<KAIGYO>    publicVars.clear();<KAIGYO>    properties.clear();<KAIGYO>    relatedNonMembs.clear();<KAIGYO>    staticPrivMembs.clear();<KAIGYO>    staticProtMembs.clear();<KAIGYO>    staticPubMembs.clear();<KAIGYO>    macros.clear();<KAIGYO>static void clearClassDetailedVars()<KAIGYO>    detMemberFuncs.clear();<KAIGYO>    detMemberTypes.clear();<KAIGYO>    detMemberVars.clear();<KAIGYO>    detProperties.clear();<KAIGYO>    detRelatedNonMembs.clear();<KAIGYO>    detMacros.clear();<KAIGYO>}<KAIGYO><KAIGYO>QList<Section> Sections::getStdCppSections(const Aggregate *aggregate, Style style, Status status)<KAIGYO>{<KAIGYO>    QList<Section> sections;<KAIGYO>    setCurrentNode(aggregate);<KAIGYO>    if (aggregate->isClass()) {<KAIGYO>        if (style == Summary)<KAIGYO>            getCppClassStdSummarySections(sections, style, status);<KAIGYO>        else if (style == Detailed)<KAIGYO>            getCppClassStdDetailedSections(sections, style, status);<KAIGYO>        else<KAIGYO>            getAllCppClassMembers(sections, style, status);<KAIGYO>    } else if (style == Summary || style == Detailed) {<KAIGYO>        getAllStdCppSections(sections, style, status);<KAIGYO>    }<KAIGYO><KAIGYO>    return sections;<KAIGYO>}<KAIGYO><KAIGYO>void Sections::getAllStdCppSections(QList<Section> &sections, Style style, Status status)<KAIGYO>{<KAIGYO>    FastSection namespaces("""",<KAIGYO>                           style == Detailed ? """" : QString(),<KAIGYO>                           """",<KAIGYO>                           """");<KAIGYO>    FastSection classes("""",<KAIGYO>                        style == Detailed ? """" : QString(),<KAIGYO>                        """",<KAIGYO>                        """");<KAIGYO>    FastSection types(style == Summary ? """",<KAIGYO>                      style == Detailed ? """" : QString(),<KAIGYO>                      """",<KAIGYO>                      """");<KAIGYO>    FastSection variables(style == Summary ? """",<KAIGYO>                          style == Detailed ? """" : QString(),<KAIGYO>                          """",<KAIGYO>                          """");<KAIGYO>    FastSection staticVars("""",<KAIGYO>                           QString(),<KAIGYO>                           """",<KAIGYO>                           """");<KAIGYO>    FastSection functions(style == Summary ? """",<KAIGYO>                          style == Detailed ? """" : QString(),<KAIGYO>                          """",<KAIGYO>                          """");<KAIGYO>    FastSection macros(style == Summary ? """",<KAIGYO>                       style == Detailed ? """" : QString(),<KAIGYO>                       """",<KAIGYO>                       """");<KAIGYO><KAIGYO>    bool documentAll = true;<KAIGYO>    NodeList nodeList = aggregate_->childNodes();<KAIGYO>    nodeList += aggregate_->relatedNodes();<KAIGYO>    if (aggregate_->isNamespace()) {<KAIGYO>        const NamespaceNode* ns = static_cast<const NamespaceNode*>(aggregate_);<KAIGYO>        if (!ns->hasDoc())<KAIGYO>            documentAll = false;<KAIGYO>        if (style == Summary) {<KAIGYO>            if (!ns->orphans().isEmpty())<KAIGYO>                nodeList += ns->orphans();<KAIGYO>        }<KAIGYO>    }<KAIGYO>    NodeList::ConstIterator c = nodeList.constBegin();<KAIGYO>    while (c != nodeList.constEnd()) {<KAIGYO>        Node *n = *c;<KAIGYO>        if (documentAll || n->hasDoc()) {<KAIGYO>            switch (n->type()) {<KAIGYO>            case Node::Namespace:<KAIGYO>                insert(namespaces, n, style, status);<KAIGYO>                break;<KAIGYO>            case Node::Class:<KAIGYO>                insert(classes, n, style, status);<KAIGYO>                break;<KAIGYO>            case Node::Enum:<KAIGYO>            case Node::Typedef:<KAIGYO>                insert(types, n, style, status);<KAIGYO>                break;<KAIGYO>            case Node::Function:<KAIGYO>                {<KAIGYO>                    FunctionNode *func = static_cast<FunctionNode *>(n);<KAIGYO>                    if (func->isMacro())<KAIGYO>                        insert(macros, n, style, status);<KAIGYO>                    else<KAIGYO>                        insert(functions, n, style, status);<KAIGYO>                }<KAIGYO>                break;<KAIGYO>            case Node::Variable:<KAIGYO>                {<KAIGYO>                    const VariableNode* var = static_cast<const VariableNode*>(n);<KAIGYO>                    if (!var->doc().isEmpty()) {<KAIGYO>                        if (var->isStatic())<KAIGYO>                            insert(staticVars, n, style, status);<KAIGYO>                        else<KAIGYO>                            insert(variables, n, style, status);<KAIGYO>                    }<KAIGYO>                }<KAIGYO>                break;<KAIGYO>            case Node::SharedComment:<KAIGYO>                {<KAIGYO>                    SharedCommentNode *scn = static_cast<SharedCommentNode *>(n);<KAIGYO>                    if (!scn->doc().isEmpty())<KAIGYO>                        insert(functions, scn, style, status);<KAIGYO>                }<KAIGYO>                break;<KAIGYO>            default:<KAIGYO>                break;<KAIGYO>            }<KAIGYO>        }<KAIGYO>        ++c;<KAIGYO>    }<KAIGYO>    append(sections, namespaces);<KAIGYO>    append(sections, classes);<KAIGYO>    append(sections, types);<KAIGYO>    append(sections, variables);<KAIGYO>    append(sections, staticVars);<KAIGYO>    append(sections, functions);<KAIGYO>    append(sections, macros);<KAIGYO>void Sections::getCppClassStdSummarySections(QList<Section> &sections, Style style, Status status)<KAIGYO>    clearClassSummaryVars();<KAIGYO>    NodeList::ConstIterator r = aggregate_->relatedNodes().constBegin();<KAIGYO>    while (r != aggregate_->relatedNodes().constEnd()) {<KAIGYO>        if ((*r)->isFunction()) {<KAIGYO>            FunctionNode *func = static_cast<FunctionNode *>(*r);<KAIGYO>            if (func->isMacro())<KAIGYO>                insert(macros, *r, style, status);<KAIGYO>            else<KAIGYO>                insert(relatedNonMembs, *r, style, status);<KAIGYO>        } else {<KAIGYO>            insert(relatedNonMembs, *r, style, status);<KAIGYO>        }<KAIGYO>        ++r;<KAIGYO>    }<KAIGYO><KAIGYO>    if (aggregate_->parent() && !aggregate_->name().isEmpty() && !aggregate_->hasDoc())<KAIGYO>        documentAll = false;<KAIGYO>    QStack<const Aggregate *> stack;<KAIGYO>    stack.push(aggregate_);<KAIGYO>    while (!stack.isEmpty()) {<KAIGYO>        const Aggregate* ancestor = stack.pop();<KAIGYO>        NodeList::ConstIterator c = ancestor->childNodes().constBegin();<KAIGYO>        while (c != ancestor->childNodes().constEnd()) {<KAIGYO>            Node* n = *c;<KAIGYO>            if (!documentAll && !n->hasDoc()) {<KAIGYO>                ++c;<KAIGYO>                continue;<KAIGYO>            }<KAIGYO>            bool isSlot = false;<KAIGYO>            bool isSignal = false;<KAIGYO>            bool isStatic = false;<KAIGYO>            if (n->isFunction()) {<KAIGYO>                const FunctionNode *func = (const FunctionNode *) n;<KAIGYO>                isSlot = (func->isSlot());<KAIGYO>                isSignal = (func->isSignal());<KAIGYO>                isStatic = func->isStatic();<KAIGYO>                if (func->hasAssociatedProperties() && !func->hasActiveAssociatedProperty()) {<KAIGYO>                    ++c;<KAIGYO>                    continue;<KAIGYO>                } else if (func->isIgnored()) {<KAIGYO>                    ++c;<KAIGYO>                    continue;<KAIGYO>                }<KAIGYO>            }<KAIGYO>            else if (n->isVariable()) {<KAIGYO>                const VariableNode *var = static_cast<const VariableNode *>(n);<KAIGYO>                isStatic = var->isStatic();<KAIGYO>            } else if (n->isTypedef()) {<KAIGYO>                if (n->name() == QLatin1String("""")) {<KAIGYO>                    ++c;<KAIGYO>                    continue;<KAIGYO>                }<KAIGYO>            }<KAIGYO>            switch (n->access()) {<KAIGYO>            case Node::Public:<KAIGYO>                if (isSlot) {<KAIGYO>                    insert(publicSlots, n, style, status);<KAIGYO>                }<KAIGYO>                else if (isSignal) {<KAIGYO>                    insert(publicSignals, n, style, status);<KAIGYO>                } else if (isStatic) {<KAIGYO>                    if (!n->isVariable() || !n->doc().isEmpty())<KAIGYO>                        insert(staticPubMembs, n, style, status);<KAIGYO>                } else if (n->isProperty()) {<KAIGYO>                    insert(properties, n, style, status);<KAIGYO>                } else if (n->isVariable()) {<KAIGYO>                    if (!n->doc().isEmpty())<KAIGYO>                        insert(publicVars, n, style, status);<KAIGYO>                } else if (n->isFunction()) {<KAIGYO>                    if (!insertReimpFunc(publicFuncs,n,status))<KAIGYO>                        insert(publicFuncs, n, style, status);<KAIGYO>                } else if (!n->isSharedCommentNode()) {<KAIGYO>                    insert(publicTypes, n, style, status);<KAIGYO>                }<KAIGYO>                break;<KAIGYO>            case Node::Protected:<KAIGYO>                if (isSlot) {<KAIGYO>                    insert(protectedSlots, n, style, status);<KAIGYO>                } else if (isStatic) {<KAIGYO>                    if (!n->isVariable() || !n->doc().isEmpty())<KAIGYO>                        insert(staticProtMembs, n, style, status);<KAIGYO>                } else if (n->isVariable()) {<KAIGYO>                    if (!n->doc().isEmpty())<KAIGYO>                        insert(protectedVars, n, style, status);<KAIGYO>                } else if (n->isFunction()) {<KAIGYO>                    if (!insertReimpFunc(protectedFuncs, n, status))<KAIGYO>                        insert(protectedFuncs, n, style, status);<KAIGYO>                } else {<KAIGYO>                    insert(protectedTypes, n, style, status);<KAIGYO>                }<KAIGYO>                break;<KAIGYO>            case Node::Private:<KAIGYO>                if (isSlot) {<KAIGYO>                    insert(privateSlots, n, style, status);<KAIGYO>                } else if (isStatic) {<KAIGYO>                    if (!n->isVariable() || !n->doc().isEmpty())<KAIGYO>                        insert(staticPrivMembs, n, style, status);<KAIGYO>                } else if (n->isFunction()) {<KAIGYO>                    if (!insertReimpFunc(privateFuncs, n, status))<KAIGYO>                        insert(privateFuncs, n, style, status);<KAIGYO>                } else {<KAIGYO>                    insert(privateTypes, n, style, status);<KAIGYO>                }<KAIGYO>            }<KAIGYO>            ++c;<KAIGYO>        }<KAIGYO>        if (ancestor->isClass()) {<KAIGYO>            const ClassNode* cn = static_cast<const ClassNode*>(ancestor);<KAIGYO>            QList<RelatedClass>::ConstIterator r = cn->baseClasses().constBegin();<KAIGYO>            while (r != cn->baseClasses().constEnd()) {<KAIGYO>                if (r->node_)<KAIGYO>                    stack.prepend(r->node_);<KAIGYO>                ++r;<KAIGYO>            }<KAIGYO>        }<KAIGYO>    }<KAIGYO>    append(sections, publicTypes);<KAIGYO>    append(sections, properties);<KAIGYO>    append(sections, publicFuncs);<KAIGYO>    append(sections, publicSlots);<KAIGYO>    append(sections, publicSignals);<KAIGYO>    append(sections, publicVars);<KAIGYO>    append(sections, staticPubMembs);<KAIGYO>    append(sections, protectedTypes);<KAIGYO>    append(sections, protectedFuncs);<KAIGYO>    append(sections, protectedSlots);<KAIGYO>    append(sections, protectedVars);<KAIGYO>    append(sections, staticProtMembs);<KAIGYO>    append(sections, privateTypes);<KAIGYO>    append(sections, privateFuncs);<KAIGYO>    append(sections, privateSlots);<KAIGYO>    append(sections, staticPrivMembs);<KAIGYO>    append(sections, relatedNonMembs);<KAIGYO>    append(sections, macros);<KAIGYO>void Sections::getCppClassStdDetailedSections(QList<Section> &sections, Style style, Status status)<KAIGYO>    clearClassDetailedVars();<KAIGYO>            if (func->isMacro())<KAIGYO>                insert(detMacros, n, style, status);<KAIGYO>            else if (!func->isSharingComment())<KAIGYO>                insert(detRelatedNonMembs, n, style, status);<KAIGYO>        } else {<KAIGYO>            insert(detRelatedNonMembs, n, style, status);<KAIGYO>        if (n->isSharingComment()) {<KAIGYO>            // do nothing<KAIGYO>        } else if (!documentAll && !n->hasDoc()) {<KAIGYO>            ++c;<KAIGYO>            continue;<KAIGYO>        } else if (n->isEnumType() || n->isTypedef()) {<KAIGYO>            if (n->name() == QLatin1String("""")) {<KAIGYO>                ++c;<KAIGYO>                continue;<KAIGYO>            }<KAIGYO>            insert(detMemberTypes, *c, style, status);<KAIGYO>        } else if (n->isProperty()) {<KAIGYO>            insert(detProperties, *c, style, status);<KAIGYO>        } else if (n->isVariable()) {<KAIGYO>            if (!n->doc().isEmpty())<KAIGYO>                insert(detMemberVars, *c, style, status);<KAIGYO>        } else if (n->isFunction()) {<KAIGYO>            FunctionNode *function = static_cast<FunctionNode *>(n);<KAIGYO>            if (function->isIgnored()) {<KAIGYO>                ++c;<KAIGYO>                continue;<KAIGYO>            }<KAIGYO>            if (!function->isSharingComment()) {<KAIGYO>                if (!function->hasAssociatedProperties() || !function->doc().isEmpty())<KAIGYO>                    insert(detMemberFuncs, function, style, status);<KAIGYO>            }<KAIGYO>        } else if (n->isSharedCommentNode()) {<KAIGYO>            SharedCommentNode *scn = static_cast<SharedCommentNode *>(n);<KAIGYO>            if (!scn->doc().isEmpty())<KAIGYO>                insert(detMemberFuncs, scn, style, status);<KAIGYO>        }<KAIGYO>        ++c;<KAIGYO>    }<KAIGYO><KAIGYO>    append(sections, detMemberTypes);<KAIGYO>    append(sections, detProperties);<KAIGYO>    append(sections, detMemberFuncs);<KAIGYO>    append(sections, detMemberVars);<KAIGYO>    append(sections, detRelatedNonMembs);<KAIGYO>    append(sections, detMacros);<KAIGYO>}<KAIGYO><KAIGYO>/*!<KAIGYO>  Build the """" list for a C++ class.<KAIGYO> */': 1}",1.0,{}
148,231423.0,2.0,5.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/231423,wasm: clean up platform plugin,1.0,{},0.0,"{'// FIXME': 1, '//    if (tb->subControls & SC_TitleBarMinButton<KAIGYO>//            && tb->titleBarFlags & Qt::WindowMinimizeButtonHint<KAIGYO>//            && !(tb->titleBarState & Qt::WindowMinimized)) {<KAIGYO>//        ir = proxy()->subControlRect(CC_TitleBar, tb, SC_TitleBarMinButton, widget);<KAIGYO>//        down = tb->activeSubControls & SC_TitleBarMinButton && (opt->state & State_Sunken);<KAIGYO>//        pm = proxy()->standardIcon(SP_TitleBarMinButton, &tool, widget).pixmap(qt_getWindow(widget), QSize(10, 10));<KAIGYO>//        tool.rect = ir;<KAIGYO>//        tool.state = down ? State_Sunken : State_Raised;<KAIGYO>//        proxy()->drawPrimitive(PE_PanelButtonTool, &tool, p, widget);': 1, '//      painter->restore();<KAIGYO>// SC_TitleBarNormalButton<KAIGYO>//    if (tb->subControls & SC_TitleBarShadeButton<KAIGYO>//            && tb->titleBarFlags & Qt::WindowShadeButtonHint<KAIGYO>//            && !(tb->titleBarState & Qt::WindowMinimized)) {<KAIGYO>//        ir = proxy()->subControlRect(CC_TitleBar, tb, SC_TitleBarShadeButton, widget);<KAIGYO>//        down = (tb->activeSubControls & SC_TitleBarShadeButton && (opt->state & State_Sunken));<KAIGYO>//        pm = proxy()->standardIcon(SP_TitleBarShadeButton, &tool, widget).pixmap(qt_getWindow(widget), QSize(10, 10));<KAIGYO>//        tool.rect = ir;<KAIGYO>//        tool.state = down ? State_Sunken : State_Raised;<KAIGYO>//        proxy()->drawPrimitive(PE_PanelButtonTool, &tool, p, widget);<KAIGYO>//        painter->save();<KAIGYO>//        if (down)<KAIGYO>//            painter->translate(proxy()->pixelMetric(PM_ButtonShiftHorizontal, tb, widget),<KAIGYO>//                         proxy()->pixelMetric(PM_ButtonShiftVertical, tb, widget));<KAIGYO>//        proxy()->drawItemPixmap(p, ir, Qt::AlignCenter, pm);<KAIGYO>//        painter->restore();<KAIGYO>//    }': 1, '//    if (tb->subControls & SC_TitleBarUnshadeButton<KAIGYO>//            && tb->titleBarFlags & Qt::WindowShadeButtonHint<KAIGYO>//            && tb->titleBarState & Qt::WindowMinimized) {<KAIGYO>//        ir = proxy()->subControlRect(CC_TitleBar, tb, SC_TitleBarUnshadeButton, widget);': 1, '//    if (tb->subControls & SC_TitleBarContextHelpButton<KAIGYO>//            && tb->titleBarFlags & Qt::WindowContextHelpButtonHint) {<KAIGYO>//        ir = proxy()->subControlRect(CC_TitleBar, tb, SC_TitleBarContextHelpButton, widget);': 1, '//TODO handle extended alphanumeric keys e.g. EU accents, etc<KAIGYO>//drag event?': 1}",1.0,{}
72,232356.0,5.0,13.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/232356,Cope if mktime() deems times in a spring forward gap to be invalid,1.0,"{'// Note: function doc claims always +1, but this should be reviewed !': 1, '// Linux (i.e. glibc) mktime bug reuses last calculation': 4}",1.0,"{'// Note: function doc claims always +1, but this should be reviewed !<KAIGYO>// Insist on consistency.<KAIGYO>// Test date maths, if result falls in missing hour then becomes next hour': 1}",1.0,{}
117,232503.0,4.0,4.0,0.0,ABANDONED,False,https://codereview.qt-project.org/#/c/232503,wip texturefile stuff,1.0,{},0.0,"{'// Currently unused, declared for future reference': 1, '// Currently the handlers are hardcoded; later maybe a list of plugins': 1}",1.0,{}
130,232636.0,1.0,1.0,0.0,ABANDONED,False,https://codereview.qt-project.org/#/c/232636,WIP: replace the query vtable methods by getOwnProperty,1.0,{'// ### Implement more efficiently.': 1},1.0,{'// ### Implement more efficiently.': 1},1.0,{}
128,233107.0,10.0,27.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/233107,Unify put and putIndexed,1.0,"{""// this is an evil hack, but it works, as the method is only ever called from putIndexed,<KAIGYO>// where we don't use the returned pointer there for non writable attributes"": 2, ""// this is an evil hack, but it works, as the method is only ever called from put,<KAIGYO>// where we don't use the returned pointer there for non writable attributes"": 3}",1.0,"{'// ### fix receiver handling': 1, ""// this is an evil hack, but it works, as the method is only ever called from putIndexed,<KAIGYO>// where we don't use the returned pointer there for non writable attributes"": 2}",1.0,{}
225,233138.0,10.0,26.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/233138,Unify the get and getIndexed vtable functions of QV4::Object,1.0,{},0.0,{'// ### fix receiver handling': 1},1.0,{}
96,233243.0,12.0,27.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/233243,Add a newTarget parameter to the Construct runtime methods,1.0,{},0.0,{'//### Maybe create a ConstructA that takes an accumulator?': 1},1.0,{}
330,233803.0,23.0,94.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/233803,Merge remote-tracking branch 'origin/5.11' into dev,1.0,"{'/*!<KAIGYO>    \\brief handle the XCB screen change event and update properties<KAIGYO><KAIGYO>    On a mobile device, the ideal use case is that the accelerometer would<KAIGYO>    drive the orientation. This could be achieved by using QSensors to read the<KAIGYO>    accelerometer and adjusting the rotation in QML, or by reading the<KAIGYO>    orientation from the QScreen object and doing the same, or in many other<KAIGYO>    ways. However, on X we have the XRandR extension, which makes it possible<KAIGYO>    to have the whole screen rotated, so that individual apps DO NOT have to<KAIGYO>    rotate themselves. Apps could optionally use the<KAIGYO>    QScreen::primaryOrientation property to optimize layout though.<KAIGYO>    Furthermore, there is no support in X for accelerometer events anyway. So<KAIGYO>    it makes more sense on a Linux system running X to just run a daemon which<KAIGYO>    monitors the accelerometer and runs xrandr automatically to do the rotation,<KAIGYO>    then apps do not have to be aware of it (but probably the window manager<KAIGYO>    would resize them accordingly). updateGeometry() is written with this<KAIGYO>    design in mind. Therefore the physical geometry, available geometry,<KAIGYO>    virtual geometry, orientation and primaryOrientation should all change at<KAIGYO>    the same time.  On a system which cannot rotate the whole screen, it would<KAIGYO>    be correct for only the orientation (not the primary orientation) to<KAIGYO>    change.<KAIGYO>*/': 10}",1.0,"{'/*!<KAIGYO>    \\brief handle the XCB screen change event and update properties<KAIGYO><KAIGYO>    On a mobile device, the ideal use case is that the accelerometer would<KAIGYO>    drive the orientation. This could be achieved by using QSensors to read the<KAIGYO>    accelerometer and adjusting the rotation in QML, or by reading the<KAIGYO>    orientation from the QScreen object and doing the same, or in many other<KAIGYO>    ways. However, on X we have the XRandR extension, which makes it possible<KAIGYO>    to have the whole screen rotated, so that individual apps DO NOT have to<KAIGYO>    rotate themselves. Apps could optionally use the<KAIGYO>    QScreen::primaryOrientation property to optimize layout though.<KAIGYO>    Furthermore, there is no support in X for accelerometer events anyway. So<KAIGYO>    it makes more sense on a Linux system running X to just run a daemon which<KAIGYO>    monitors the accelerometer and runs xrandr automatically to do the rotation,<KAIGYO>    then apps do not have to be aware of it (but probably the window manager<KAIGYO>    would resize them accordingly). updateGeometry() is written with this<KAIGYO>    design in mind. Therefore the physical geometry, available geometry,<KAIGYO>    virtual geometry, orientation and primaryOrientation should all change at<KAIGYO>    the same time.  On a system which cannot rotate the whole screen, it would<KAIGYO>    be correct for only the orientation (not the primary orientation) to<KAIGYO>    change.<KAIGYO>*/': 10}",1.0,{}
291,233829.0,2.0,3.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/233829,Compressed textures: Replace file decoding code with QtGui functionality,1.0,{},0.0,"{'// Currently unused, declared for future reference': 1, '// Currently the handlers are hardcoded; later maybe a list of plugins': 1}",1.0,{}
331,233995.0,3.0,11.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/233995,We no longer need a workaround to include PrivateWidgets,1.0,{},0.0,"{'// QTBUG-48424, QTBUG-45977: In release mode, qmlimportscanner does not report<KAIGYO>// the dependency of QtQuick.Controls on QtQuick.PrivateWidgets due to missing files.<KAIGYO>// Recreate the run-time logic here as best as we can - deploy it if<KAIGYO>//      1) QtWidgets is used<KAIGYO>//      2) QtQuick.Controls is used': 2}",1.0,{}
99,234328.0,4.0,21.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/234328,QQuikTableView: use TableViewModel instead of QQmlDelegateModel,1.0,"{'// When the assigned model is not an instance model, we create a wrapper<KAIGYO>// model (QQmlTableInstanceModel) that keeps a pointer to both the<KAIGYO>// assigned model and the assigned delegate. This model will give us a<KAIGYO>// common interface to any kind of model (js arrays, QAIM, number etc), and<KAIGYO>// help us create delegate instances.': 1}",1.0,{'// TODO: implement fine-grained support for model changes': 1},1.0,{}
254,234387.0,23.0,103.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/234387,Add support for SPNEGO/Negotiate authentication,1.0,{},0.0,{'// NTLM is a multi phase authentication. Copying credentials between authenticators would mess things up.': 1},1.0,{}
230,234744.0,2.0,8.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/234744,V4 debugger: Drop redundantRefs option,1.0,{},0.0,"{""// TODO: Directly call addRef() once we don't need to support redundantRefs anymore"": 1, ""// TODO: Drop this method once we don't need to support redundantRefs anymore"": 1, ""// TODO: drop this method once we don't need to support redundantRefs anymore."": 1}",1.0,{}
231,234751.0,2.0,6.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/234751,V4 Debuger: Drop namesAsObjects option,1.0,{},0.0,"{""// TODO: Drop this method once we don't need to support namesAsObjects anymore"": 1}",1.0,{}
333,234756.0,14.0,49.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/234756,Extract qmake parser from lupdate and lrelease,1.0,{'// TODO: take advantage of the file list being sorted': 1},1.0,{'// TODO: take advantage of the file list being sorted': 1},1.0,{}
272,234853.0,2.0,7.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/234853,tst_qquicktableview: actually test that model is reset,1.0,{},0.0,"{""// TODO: When the QAbstractItemModel's column count is set to 0,<KAIGYO>// QQmlAdaptorModel::columnCount() likes to return whatever it was previously,<KAIGYO>// even though the model doesn't actually have any columns... not sure what to do about that."": 1}",1.0,{}
70,235210.0,3.0,10.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/235210,xcb: Fix build when xinput2 is not available,1.0,{'// _NET_WM_MOVERESIZE on this WM is bouncy (WM bug?).': 1},1.0,{'// _NET_WM_MOVERESIZE on this WM is bouncy (WM bug?).': 1},1.0,{}
131,235331.0,11.0,25.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/235331,xcb: partly revert 3bc0f1724ae49c2fd7e6d7bcb650350d20d12246,1.0,{'// ### FIXME QTBUG-69716': 6},1.0,"{'// For touch events we want events only from master devices, at least<KAIGYO>// currently there is no apparent reason why we would need to consider<KAIGYO>// events from slave devices.': 3}",1.0,{}
243,235676.0,2.0,5.0,0.0,DEFERRED,False,https://codereview.qt-project.org/#/c/235676,QuickTestEvent: mouseEvent takes multiple buttons,1.0,"{'// QML test API is oversimplified: multiple buttons can\'t be pressed or released one-at-a-time,<KAIGYO>// because there aren\'t two parameters button and buttons like QMouseEvent has.<KAIGYO>// So here we assume that """" is really just one button.<KAIGYO>// TODO improve the API eventually, or else change usage such that<KAIGYO>// mouseRelease(item, x, y, Qt.NoButton)<KAIGYO>// means release ALL buttons that were held, whereas<KAIGYO>// mouseRelease(item, x, y, Qt.LeftButton)<KAIGYO>// means release EVERYTHING BUT the left button.': 1}",1.0,{'// TODO should be Qt::MouseButtons buttons in case multiple buttons are pressed': 1},1.0,{}
329,235715.0,13.0,60.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/235715,Merge remote-tracking branch 'origin/5.11' into dev,1.0,"{'// For touch events we want events only from master devices, at least<KAIGYO>// currently there is no apparent reason why we would need to consider<KAIGYO>// events from slave devices.': 3}",1.0,"{'// For touch events we want events only from master devices, at least<KAIGYO>// currently there is no apparent reason why we would need to consider<KAIGYO>// events from slave devices.': 5}",1.0,"{'// For touch events we want events only from master devices, at least<KAIGYO>// currently there is no apparent reason why we would need to consider<KAIGYO>// events from slave devices.': '3-5'}"
316,235823.0,5.0,20.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/235823,MultiPointHandler::wantsPointerEvent: reset if different cand count,1.0,"{'// Move some more... MPTA keeps reacting': 2, '// Move some more: DragHandler eventually reacts.': 3}",1.0,{'// Move some more... PinchHandler and MPTA both keep reacting': 2},1.0,{}
363,235969.0,7.0,26.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/235969,SecureTransport - fix verifyPeerTrust for the renegotiation case,1.0,{},0.0,{'// TODO: why this test depends on configuration.peerCertificateChain not being empty????': 1},1.0,{}
373,235977.0,10.0,17.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/235977,Shift close/abort signaling from QBluetoothSocket to private implementations,1.0,{},0.0,"{'// TODO Add return type to d->close() & d->abort() to detect when to emit below signals<KAIGYO>//Android closes when the Java event loop comes around': 1, '//TODO delayed disconnected() not yet implemented<KAIGYO>// delayed disconnected not needed': 1}",1.0,{}
12,236038.0,1.0,0.0,0.0,NEW,False,https://codereview.qt-project.org/#/c/236038,tst_PropertyRequirements: don't fail due to modules that weren't built,1.0,"{""// TODO enable after all failures are fixed<KAIGYO>// check if this type was imported successfully, is derived from QObject and can have signals<KAIGYO>// i.e. weed out the Q_GADGET classes and modules that haven't been built"": 1}",1.0,{'// TODO enable once technical debt is fixes<KAIGYO>// check if this type is derived from QObject and even can have signals<KAIGYO>// i.e. weed out the Q_GADGET classes': 1},1.0,{}
292,236152.0,17.0,45.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/236152,Update Yarr to the latest version from WebKit,1.0,"{""// Note: we haven't changed the value of fp. Hence, it is still pointing to the frame of<KAIGYO>// the caller of the probe (which is what we want in order to play nice with debuggers e.g. lldb).<KAIGYO>// Set the Probe::State* arg.<KAIGYO>// Call the probe handler."": 1, '// A register for describing ARM64 CPU features are only accessible in kernel mode.<KAIGYO>// Thus, some kernel support is necessary to collect CPU features. In Linux, the<KAIGYO>// kernel passes CPU feature flags in AT_HWCAP auxiliary vector which is passed<KAIGYO>// when the process starts. While this may pose a bit conservative information<KAIGYO>// (for example, the Linux kernel may add a flag for a feature after the feature<KAIGYO>// is shipped and implemented in some CPUs. In that case, even if the CPU has<KAIGYO>// that feature, the kernel does not tell it to users.), it is a stable approach.<KAIGYO>// httpswww.kernel.org/doc/Documentation/arm64/elf_hwcaps.txt': 1, '// FIXME: It would be nice if we can release the CStringBuffer from the CString<KAIGYO>// and take ownership of it here instead of copying it again.': 1, '// FIXME: we should consider using the copy function for both ASan and non-ASan builds.<KAIGYO>// httpsbugs.webkit.org/show_bug.cgi?id=176961': 1, '// FIXME: This could be faster if it actually searched backwards.<KAIGYO>// Instead, it just searches forwards, multiple times until it finds the last match.': 1, ""// Successful match! Okay, what's next? - loop around and try to match more!"": 1, ""// Upon entry to a Greedy quantified set of parenthese store the index.<KAIGYO>// We'll use this for two purposes:<KAIGYO>//  - To indicate which iteration we are on of mathing the remainder of<KAIGYO>//    the expression after the parentheses - the first, including the<KAIGYO>//    match within the parentheses, or the second having skipped over them.<KAIGYO>//  - To check for empty matches, which must be rejected.<KAIGYO>//<KAIGYO>// At the head of a NonGreedy set of parentheses we'll immediately set the<KAIGYO>// value on the stack to -1 (indicating a match skipping the subpattern),<KAIGYO>// and plant a jump to the end. We'll also plant a label to backtrack to<KAIGYO>// to reenter the subpattern later, with a store to set up index on the<KAIGYO>// second iteration.<KAIGYO>//<KAIGYO>// FIXME: for capturing parens, could use the index in the capture array?"": 1, '// If the parenthese are capturing, store the starting index value to the<KAIGYO>// captures array, offsetting as necessary.<KAIGYO>//<KAIGYO>// FIXME: could avoid offsetting this value in JIT code, apply<KAIGYO>// offsets only afterwards, at the point the results array is<KAIGYO>// being accessed.': 1, '// If the parenthese are capturing, store the ending index value to the<KAIGYO>// captures array, offsetting as necessary.<KAIGYO>//<KAIGYO>// FIXME: could avoid offsetting this value in JIT code, apply<KAIGYO>// offsets only afterwards, at the point the results array is<KAIGYO>// being accessed.': 1, '// FIXME: Yarr should not use the stack to handle subpatterns (rdarproblem/26436314).': 1}",1.0,"{'// Not really needed for greedy quantifiers.<KAIGYO>// Not really needed for fixed quantifiers.': 1, ""// Successful match! Okay, what's next? - loop around and try to match moar!"": 1, '// Originally, the code was:<KAIGYO>//        callFrameSize = (callFrameSize + 0x3f) & ~0x3f;<KAIGYO>// However, 64 bytes is a bit surprising. The biggest """" requirement is on Aarch64, where:<KAIGYO>// """" (IHI0055B_aapcs64.pdf)': 1}",1.0,{}
117,236396.0,2.0,9.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/236396,xcb: remove unused xcb_icccm.h include from qxcbclipboard.cpp,1.0,{},0.0,{'// Workaround XCB-ICCCM 3.8 breakage': 1},1.0,{}
135,236397.0,9.0,19.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/236397,xcb: cleanup _MOTIF_WM_HINTS handling,1.0,{},0.0,"{""// fixed size, remove the resize handle (since mwm/dtwm<KAIGYO>// isn't smart enough to do it itself)"": 1}",1.0,{}
122,236412.0,2.0,6.0,0.0,NEW,False,https://codereview.qt-project.org/#/c/236412,Add support for flatpak PickColor portal in QColorDialog,1.0,"{""// HACK: Because mouse grabbing doesn't work across processes, we have to have a dummy,<KAIGYO>// invisible window to catch the mouse click, otherwise we will click whatever we clicked<KAIGYO>// and loose focus."": 1}",1.0,"{""// HACK: Because mouse grabbing doesn't work across processes, we have to have a dummy,<KAIGYO>// invisible window to catch the mouse click, otherwise we will click whatever we clicked<KAIGYO>// and loose focus."": 1}",1.0,{}
219,236669.0,4.0,23.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/236669,QDtsl::abortHandshake() - generalize the notion of 'abort',1.0,"{""// Yes, while peer verification failed, we were actually encrypted.<KAIGYO>// Let's play it nice - inform our peer about connection shut down."": 1}",1.0,"{""// Yes, while peer verification failed, we were actually encrypted.<KAIGYO>// Let's play it nice - inform our peer about connection shut down."": 1}",1.0,{}
233,236784.0,4.0,5.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/236784,Simplify ES module body handling,1.0,{},0.0,"{""// We don't accept the ModuleItemList (body) as instead the statement list items<KAIGYO>// as well as the import/export declarations are linked together in the statement<KAIGYO>// list. That way they are processed in correct order and can be used with the codegen's<KAIGYO>// defineFunction() that expects a statement list.<KAIGYO>// accept(body, visitor);"": 1}",1.0,{}
286,236831.0,4.0,9.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/236831,Fix toLocaleString implementations in (Typed)Array.prototype,1.0,{},0.0,{'// ### FIXME': 1},1.0,{}
284,236968.0,2.0,12.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/236968,Texture file support: add mipmap reading to ktx handler,1.0,{},0.0,{'// todo: glBaseInternalFormat': 1},1.0,{}
16,237078.0,3.0,15.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/237078,Flickable: handle the new ScrollMomentum phase in QWheelEvent,1.0,{},0.0,"{'// TODO eliminate this timer when ScrollMomentum has been added': 1, '// TODO most of this should be done at transition to ScrollMomentum phase,<KAIGYO>// then do what the movementEndingTimer triggers at transition to ScrollEnd phase': 1}",1.0,{}
81,237295.0,11.0,21.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/237295,Add a HoverHandler autotest,1.0,{'// take care of any exits': 9},1.0,{'// take care of any exits': 9},1.0,{}
79,237330.0,7.0,16.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/237330,Merge remote-tracking branch 'origin/5.12' into dev,1.0,{},0.0,"{'//introducing secondProxyModel to test the layoutChange when many items appears at once': 1, '// It would be possible to use only the modelReset signal of the source model to clear<KAIGYO>// the data in *this, however, this requires that the slot is connected<KAIGYO>// before QSortFilterProxyModel::setSourceModel is called, and even then depends<KAIGYO>// on the order of invocation of slots being the same as the order of connection.<KAIGYO>// ie, not reliable.<KAIGYO>//         connect(sourceModel, SIGNAL(modelReset()), SLOT(resetInternalData()));': 1, '// In the source model, the rows were moved to row 1 in the parent.<KAIGYO>// m_p2FirstProxyChild was created with row 0 in the proxy.<KAIGYO>// The moved rows in the proxy do not appear at row 1 because of sorting.<KAIGYO>// Sorting causes them to appear at row 0 instead, pushing what used to<KAIGYO>// be row 0 in the proxy down by two rows.': 1}",1.0,{}
121,237389.0,4.0,15.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/237389,Merge remote-tracking branch 'origin/5.11' into 5.12,1.0,{},0.0,"{'//introducing secondProxyModel to test the layoutChange when many items appears at once': 1, '// It would be possible to use only the modelReset signal of the source model to clear<KAIGYO>// the data in *this, however, this requires that the slot is connected<KAIGYO>// before QSortFilterProxyModel::setSourceModel is called, and even then depends<KAIGYO>// on the order of invocation of slots being the same as the order of connection.<KAIGYO>// ie, not reliable.<KAIGYO>//         connect(sourceModel, SIGNAL(modelReset()), SLOT(resetInternalData()));': 1, '// In the source model, the rows were moved to row 1 in the parent.<KAIGYO>// m_p2FirstProxyChild was created with row 0 in the proxy.<KAIGYO>// The moved rows in the proxy do not appear at row 1 because of sorting.<KAIGYO>// Sorting causes them to appear at row 0 instead, pushing what used to<KAIGYO>// be row 0 in the proxy down by two rows.': 1}",1.0,{}
104,237445.0,1.0,1.0,0.0,ABANDONED,False,https://codereview.qt-project.org/#/c/237445,WIP: Collect trace information in the interpreter,1.0,{},0.0,"{'//### Todo: when we add type hints, we can generate an Increment when both the lhs is a number and the rhs == 1': 1}",1.0,{}
101,237497.0,2.0,7.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/237497,Use PointHandler for singlePointProperties manual test,1.0,{},0.0,{'//        acceptedButtons: Qt.AllButtons // TODO: only SinglePointHandler has this so far': 1},1.0,{}
118,237573.0,7.0,32.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/237573,Refactor tst_QFiledialog::clearLineEdit(),1.0,{'// Play it really safe by creating a directory which should show first in<KAIGYO>// a temporary dir': 6},1.0,{'//play it really safe by creating a directory': 1},1.0,{}
153,237678.0,6.0,18.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/237678,Fix a bug where hover events were not sent if the mouse was never moved,1.0,{'// take care of any exits': 1},1.0,{'// take care of any exits': 1},1.0,{}
169,237746.0,3.0,7.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/237746,QQuickTableView: handle RebuildOption::ViewportOnly,1.0,{},0.0,"{'// ###todo: support starting with other top-left items than 0,0': 1}",1.0,{}
199,237850.0,4.0,9.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/237850,Fix Map and WeakMap constructor,1.0,{},0.0,"{'// ### beware, hack alert!<KAIGYO>// Object iteration seems broken right now. if we allow any object to<KAIGYO>// iterate, it endlessly loops in the Map/prototype tests in test262...<KAIGYO>// disable these for now until Object iteration is fixed, just so we can<KAIGYO>// test this.': 1}",1.0,{}
233,237932.0,3.0,6.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/237932,Implement the dead temporal zone,1.0,{'// temp-to-temp move': 1},1.0,{'// temp-to-temp move': 1},1.0,{}
33,238075.0,2.0,7.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/238075,Avoid conversion over RGBA64 for RGB32 LCD text blending,1.0,"{'// Give up and do a naive gray alphablend. Needed to deal with ARGB32 and invalid ARGB32_premultiplied, see QTBUG-60571': 1}",1.0,"{'// Give up and do a naive gray alphablend. Needed to deal with ARGB32 and invalid ARGB32_premultiplied, see QTBUG-60571': 1}",1.0,{}
10,239086.0,1.0,1.0,0.0,ABANDONED,False,https://codereview.qt-project.org/#/c/239086,"Revert ""WebAssembly for QtDeclarative""",1.0,{},0.0,"{'// Hardcode the qml imports to """" relative to the app exe.<KAIGYO>// This should perhaps be set via Qml2Imports in qt.conf.': 1}",1.0,{}
42,239204.0,1.0,0.0,0.0,NEW,False,https://codereview.qt-project.org/#/c/239204,WIP: Process events while we are inside an event handler,1.0,{'// TODO tablet event types': 1},1.0,{'// TODO tablet event types': 1},1.0,{}
110,239315.0,6.0,17.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/239315,Implement QDataStream operator for QCborSimpleValue,1.0,{},0.0,{'// TODO just define a normal QDataStream operator': 1},1.0,{}
107,239354.0,3.0,25.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/239354,winrt: Explicitly set main thread in QCoreApplication's constructor,1.0,{},0.0,"{""// TODO: is there a way to reflect the branch's behavior using<KAIGYO>// WinRT API?"": 2}",1.0,{}
128,239437.0,2.0,3.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/239437,Remove hardcoded Q_OS_WASM “qml/” import path,1.0,{},0.0,"{'// Hardcode the qml imports to """" relative to the app exe.<KAIGYO>// This should perhaps be set via Qml2Imports in qt.conf.': 1}",1.0,{}
143,239529.0,2.0,2.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/239529,QQuickTableView: be more precise about when to call updatePolish(),1.0,{},0.0,"{""// We shouldn't recurse into updatePolish(). And we shouldn't<KAIGYO>// build the table before the component is complete."": 1}",1.0,{}
209,239724.0,2.0,3.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/239724,qmake: make yet more use of ProString::toQStringRef(),1.0,{},0.0,{'// XXX optimize ... somehow': 1},1.0,{}
225,239744.0,2.0,4.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/239744,qmake: make argument validation of built-ins data driven,1.0,"{'// FIXME: this is inconsistent with the """" dogma.': 1}",1.0,"{'// FIXME: this is inconsistent with the """" dogma.': 1}",1.0,{}
43,240148.0,1.0,1.0,0.0,ABANDONED,False,https://codereview.qt-project.org/#/c/240148,Texture file support: add mipmap reading to ktx handler,1.0,{},0.0,{'// todo: glBaseInternalFormat': 1},1.0,{}
70,240343.0,2.0,24.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/240343,QSideBar: take the icon size from a style,1.0,{},0.0,{'// ### TODO make icon size dynamic': 1},1.0,{}
105,240351.0,7.0,16.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/240351,Speed up instanceof operations,1.0,"{""// Add an invalid prototype slot, so that all function objects have the same layout<KAIGYO>// This helps speed up instanceof operations and other things where we need to query<KAIGYO>// prototype property (as we always know it's location)"": 4}",1.0,"{""// Add an invalid prototype slot, so that all function objects have the same layout<KAIGYO>// This helps speed up instanceof operations and other things where we need to query<KAIGYO>// prototype property (as we always know it's location)"": 4}",1.0,{}
93,240440.0,2.0,19.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/240440,"Revert ""qmake: Work around MSVC compiler bug.""",1.0,{},0.0,"{'/* Disable optimization in getProjectUUID() due to a compiler<KAIGYO> * bug in MSVC 2010 that causes ASSERT: """" in the QString<KAIGYO> * copy constructor for non-empty file names at:<KAIGYO> * filename.isEmpty()?project->first(""""):filename */': 1}",1.0,{}
213,240695.0,5.0,11.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/240695,Merge qmlplugindump tests,1.0,{},0.0,"{""// Read a test definition from a file.<KAIGYO>//<KAIGYO>// The file must define a json document that `createTest' can understand.<KAIGYO>//"": 1}",1.0,{}
155,240753.0,8.0,17.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/240753,wasm: refactor and convert from EM_ASM,1.0,{},0.0,{'// easiest way to transliterate binary data to js/wasm': 1},1.0,{}
24,241104.0,2.0,7.0,0.0,ABANDONED,False,https://codereview.qt-project.org/#/c/241104,Fix download from FTP servers that do not support HELP command,1.0,"{'// supported commands<KAIGYO>// the """" ftp command would be nice here, but it is not part of the<KAIGYO>// initial FTP RFC 959, neither ar """" (they are all specified<KAIGYO>// in RFC 3659)': 1}",1.0,"{'//qDebug() << """" << code << text;<KAIGYO>// supported commands<KAIGYO>// the """" ftp command would be nice here, but it is not part of the<KAIGYO>// initial FTP RFC 959, neither ar """" (they are all specified<KAIGYO>// in RFC 3659)': 1, '// supported commands<KAIGYO>// the """" ftp command would be nice here, but it is not part of the<KAIGYO>// initial FTP RFC 959, neither ar """" (they are all specified<KAIGYO>// in RFC 3659)': 2}",1.0,"{'// supported commands<KAIGYO>// the """" ftp command would be nice here, but it is not part of the<KAIGYO>// initial FTP RFC 959, neither ar """" (they are all specified<KAIGYO>// in RFC 3659)': '1-2'}"
69,241403.0,2.0,14.0,0.0,ABANDONED,False,https://codereview.qt-project.org/#/c/241403,xcb: switch xcb_wait_for_event -> xcb_poll_for_event,1.0,{},0.0,{'// A hack to close XCB connection. Apparently XCB does not have any APIs for this?': 1},1.0,{}
112,242199.0,18.0,41.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/242199,Get rid of the deprecated QSet::to/fromList methods,1.0,{},0.0,{'/*<KAIGYO>   ### Qt 5:<KAIGYO>   ### This needs to be removed for next releases of Qt. It is a workaround for vc++ because<KAIGYO>   ### Qt exports QPolygon and QPolygonF that inherit QVector<QPoint> and<KAIGYO>   ### QVector<QPointF> respectively.<KAIGYO>*/': 11},1.0,{}
144,242527.0,5.0,28.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/242527,QQWindow: cancel touch->mouse synthesis when touch is ungrabbed,1.0,{},0.0,{'// XXX todo': 1},1.0,{}
229,242789.0,4.0,5.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/242789,Windows QPA: Fix maximizing windows without title bar,1.0,"{""// This block fixes QTBUG-8361, QTBUG-4362: Frameless/title-less windows shouldn't cover the<KAIGYO>// taskbar when maximized"": 1}",1.0,"{""// This block fixes QTBUG-8361: Frameless windows shouldn't cover the<KAIGYO>// taskbar when maximized"": 1}",1.0,{}
283,242938.0,7.0,7.0,0.0,ABANDONED,False,https://codereview.qt-project.org/#/c/242938,WIP: Adapt to QmlJS parser from QtQml,1.0,{},0.0,{'// ### TODO: AST for initializer': 1},1.0,{}
13,243036.0,3.0,8.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/243036,Emit QBluetoothDeviceDiscoveryAgent::deviceUpdated on Apple platforms,1.0,{'// TODO deviceUpdated() signal not implemented on WinRT': 1},1.0,{'// TODO deviceUpdated() signal not implemented on WinRT and Apple platforms': 1},1.0,{}
37,243041.0,3.0,3.0,0.0,ABANDONED,False,https://codereview.qt-project.org/#/c/243041,Remove FileSaver and FileUtils,1.0,{},0.0,"{""// Unlike QFileInfo, this won't accept a relative path with a drive letter.<KAIGYO>// Such paths result in a royal mess anyway ..."": 1, '// Workaround an assert in Qt -- and provide a useful error message, too:': 1}",1.0,{}
43,243150.0,3.0,3.0,0.0,ABANDONED,False,https://codereview.qt-project.org/#/c/243150,WIP: Rework JsonRPC to only use qtbootstrap,1.0,{},0.0,"{'// We\'re not checking for jsonrpc == """" because that\'s silly.': 1}",1.0,{}
99,244403.0,3.0,30.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/244403,xcb: remove old work-around for building with util-wm,1.0,{},0.0,{'// FIXME This workaround can be removed for xcb-icccm > 3.8': 1},1.0,{}
145,244543.0,2.0,2.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/244543,Remove invalid fixme,1.0,{},0.0,{'// FIXME': 1},1.0,{}
107,245398.0,3.0,9.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/245398,Cleanup gradient blending,1.0,"{'    /*<KAIGYO>        The logic for vertical gradient calculations is a mathematically<KAIGYO>        reduced copy of that in fetchLinearGradient() - which is basically:<KAIGYO><KAIGYO>            qreal ry = data->m22 * (y + 0.5) + data->dy;<KAIGYO>            qreal t = linear.dy*ry + linear.off;<KAIGYO>            t *= (GRADIENT_STOPTABLE_SIZE - 1);<KAIGYO>            quint32 color =<KAIGYO>                qt_gradient_pixel_fixed(&data->gradient,<KAIGYO>                                        int(t * FIXPT_SIZE));<KAIGYO><KAIGYO>        This has then been converted to fixed point to improve performance.<KAIGYO>     */': 1}",1.0,"{'        /*<KAIGYO>            The logic for vertical gradient calculations is a mathematically<KAIGYO>            reduced copy of that in fetchLinearGradient() - which is basically:<KAIGYO><KAIGYO>                qreal ry = data->m22 * (y + 0.5) + data->dy;<KAIGYO>                qreal t = linear.dy*ry + linear.off;<KAIGYO>                t *= (GRADIENT_STOPTABLE_SIZE - 1);<KAIGYO>                quint32 color =<KAIGYO>                    qt_gradient_pixel_fixed(&data->gradient,<KAIGYO>                                            int(t * FIXPT_SIZE));<KAIGYO><KAIGYO>            This has then been converted to fixed point to improve performance.<KAIGYO>         */': 1}",1.0,{}
153,245705.0,1.0,10.0,0.0,ABANDONED,False,https://codereview.qt-project.org/#/c/245705,Fix tst_QFileDialog2::task227930_correctNavigationKeyboardBehavior(),1.0,{},0.0,{'// The following test implies the folder created will appear first in<KAIGYO>// the list. On Mac files sorting depends on the locale and the order<KAIGYO>// displayed cannot be known for sure.': 1},1.0,{}
187,246801.0,1.0,1.0,0.0,ABANDONED,False,https://codereview.qt-project.org/#/c/246801,Wasm: port changeCursor code to emscripten::val,1.0,{'// FIXME: This sets the cursor on the native canvas; when using multiple windows<KAIGYO>// multiple cursors need to be managed taking mouse postion and stacking into account.': 1},1.0,{'// FIXME: The HTML5 plugin sets the cursor on the native canvas; when using multiple windows<KAIGYO>// multiple cursors need to be managed taking mouse postion and stacking into account.': 1},1.0,{}
241,246875.0,12.0,84.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/246875,OpenSSL: drop support for SSLv2 and SSLv3,1.0,{},0.0,"{""// no idea why it does not work, but we don't care about SSL 2"": 1, ""// qt-test-server allows SSLV3, so it allows NoSslV2<KAIGYO>// no idea why it does not work, but we don't care about SSL 2"": 4}",1.0,{}
151,247354.0,16.0,29.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/247354,Handle transparent pen color in fast text path,1.0,"{'// Give up and do a naive gray alphablend. Needed to deal with ARGB32 and invalid ARGB32_premultiplied, see QTBUG-60571': 10}",1.0,"{'// Give up and do a naive gray alphablend. Needed to deal with ARGB32 and invalid ARGB32_premultiplied, see QTBUG-60571': 10}",1.0,{}
82,247376.0,3.0,6.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/247376,uic: No longer generate static_cast for enum values in legacy forms,1.0,{},0.0,"{'// Fixup an enumeration name from class Qt.<KAIGYO>// They are currently stored as """".<KAIGYO>// due to MO issues. This might be fixed in the future.': 1}",1.0,{}
90,247383.0,1.0,1.0,0.0,ABANDONED,False,https://codereview.qt-project.org/#/c/247383,WIP: uic: No longer generate static_cast for enum values in legacy forms,1.0,{},0.0,"{'// Fixup an enumeration name from class Qt.<KAIGYO>// They are currently stored as """".<KAIGYO>// due to MO issues. This might be fixed in the future.': 1}",1.0,{}
109,247402.0,2.0,3.0,0.0,ABANDONED,False,https://codereview.qt-project.org/#/c/247402,uic: No longer generate static_cast for enum values in legacy forms,1.0,{},0.0,"{'// Fixup an enumeration name from class Qt.<KAIGYO>// They are currently stored as """".<KAIGYO>// due to MO issues. This might be fixed in the future.': 1}",1.0,{}
159,247507.0,10.0,49.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/247507,QToolTip - set correct screen before resize,1.0,{},0.0,"{'// The windowHandle must point to the screen where the menu will be shown.<KAIGYO>// The (item) size calculations depend on the menu screen,<KAIGYO>// so a wrong screen would often cause wrong sizes (on high DPI)': 4}",1.0,{}
253,247810.0,13.0,59.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/247810,qmake: rewrite msvc/nmake cross-build environment setup,1.0,{},0.0,{'// Maybe remove for x86 again?': 3},1.0,{}
43,248030.0,4.0,18.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/248030,Remove specialized multi font engine on Windows,1.0,{},0.0,"{'/*!<KAIGYO>    \\class QWindowsMultiFontEngine<KAIGYO>    \\brief Standard Windows Multi font engine.<KAIGYO>    \\internal<KAIGYO>    \\ingroup qt-lighthouse-win<KAIGYO><KAIGYO>    """" several font engines that have gaps in the<KAIGYO>    supported writing systems.<KAIGYO><KAIGYO>    Will probably be superseded by a common Free Type font engine in Qt 5.X.<KAIGYO>*/': 1}",1.0,{}
181,248621.0,14.0,29.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/248621,TableModel: add roleDataProvider callback,1.0,{'// TODO get it converted to a QJSValue construction rather than JSON string?<KAIGYO>// but (this brings it up yet again) the helper functions for that seem to be missing': 1},1.0,"{'//qDebug() << index.column() << index.row() << role << effectiveRole << propertyName << """" << mDefaultDisplayRoles << roleNames();<KAIGYO>// For DisplayRole we must return something unless there is nothing at all.<KAIGYO>// TODO choose smarter?': 1}",1.0,{}
207,248826.0,4.0,25.0,0.0,ABANDONED,False,https://codereview.qt-project.org/#/c/248826,Use isIntegral flag to determine if we can pass a type as int,1.0,{},0.0,"{""// If it wasn't declared as metatype, better don't touch it."": 1}",1.0,{}
252,248921.0,5.0,12.0,0.0,NEW,False,https://codereview.qt-project.org/#/c/248921,"Deprecate Item.transformOrigin, replace with transformOriginPoint",1.0,"{""//            transformOriginPoint { x: 10; y: 10 } // this works, but not what we want<KAIGYO>// does not keep the transformOriginPoint set for long enough to work properly, because the handlers don't stay active for long enough<KAIGYO>//            transformOriginPoint: scaleWheelHandler.active ? scaleWheelHandler.point.position :<KAIGYO>//                                                             rotationWheelHandler.active ? rotationWheelHandler.point.position :<KAIGYO>//                                                                                           parentPinch.centroid.scenePressPosition"": 1}",1.0,"{""// despite what the docs imply, origin is a QVector3D... so we can't bind a QPointF directly! (how annoying)"": 1}",1.0,{}
246,248968.0,5.0,13.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/248968,"Property Cache: Use related meta objects to check for ""enums""",1.0,{},0.0,"{""// If it wasn't declared as metatype, better don't touch it."": 4}",1.0,{}
16,249091.0,1.0,6.0,0.0,ABANDONED,False,https://codereview.qt-project.org/#/c/249091,Avoid locking a mutex for the receiver of connections,1.0,{},0.0,{'//the node has maybe been removed while the mutex was unlocked in relock?': 1},1.0,{}
29,249093.0,5.0,11.0,0.0,ABANDONED,False,https://codereview.qt-project.org/#/c/249093,WIP: Refactor the data structures for connections,1.0,{},0.0,{'//the node has maybe been removed while the mutex was unlocked in relock?': 2},1.0,{}
38,249154.0,2.0,4.0,0.0,ABANDONED,False,https://codereview.qt-project.org/#/c/249154,Deduplicate QWidgetPrivate::invalidateBuffer,1.0,{},0.0,"{""/*!<KAIGYO>    This function is equivalent to calling invalidateBuffer(QRegion(rect), ...), but<KAIGYO>    is more efficient as it eliminates QRegion operations/allocations and can<KAIGYO>    use the rect more precisely for additional cut-offs.<KAIGYO><KAIGYO>    ### Qt 4.6: Merge into a template function (after MSVC isn't supported anymore).<KAIGYO>*/"": 1}",1.0,{}
39,249161.0,3.0,6.0,0.0,ABANDONED,False,https://codereview.qt-project.org/#/c/249161,Deduplicate QWidgetBackingStore::markDirty,1.0,{},0.0,"{""/*!<KAIGYO>    This function is equivalent to calling markDirty(QRegion(rect), ...), but<KAIGYO>    is more efficient as it eliminates QRegion operations/allocations and can<KAIGYO>    use the rect more precisely for additional cut-offs.<KAIGYO><KAIGYO>    ### Qt 4.6: Merge into a template function (after MSVC isn't supported anymore).<KAIGYO>*/"": 1}",1.0,{}
59,250011.0,6.0,23.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/250011,Deduplicate QWidgetPrivate::invalidateBuffer,1.0,{},0.0,"{""/*!<KAIGYO>    This function is equivalent to calling invalidateBuffer(QRegion(rect), ...), but<KAIGYO>    is more efficient as it eliminates QRegion operations/allocations and can<KAIGYO>    use the rect more precisely for additional cut-offs.<KAIGYO><KAIGYO>    ### Qt 4.6: Merge into a template function (after MSVC isn't supported anymore).<KAIGYO>*/"": 1}",1.0,{}
33,250014.0,7.0,19.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/250014,Deduplicate QWidgetBackingStore::markDirty,1.0,{},0.0,"{""/*!<KAIGYO>    This function is equivalent to calling markDirty(QRegion(rect), ...), but<KAIGYO>    is more efficient as it eliminates QRegion operations/allocations and can<KAIGYO>    use the rect more precisely for additional cut-offs.<KAIGYO><KAIGYO>    ### Qt 4.6: Merge into a template function (after MSVC isn't supported anymore).<KAIGYO>*/"": 1}",1.0,{}
192,250881.0,5.0,13.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/250881,PinchHandler: Avoid unwanted translations when axes are disabled,1.0,{},0.0,{'// TODO some translation inadvertently happens; try to hold the chosen pinch origin in place': 1},1.0,{}
71,251249.0,2.0,2.0,0.0,ABANDONED,False,https://codereview.qt-project.org/#/c/251249,QML: Split propertyCache into multiple files,1.0,"{""// If it wasn't declared as metatype, better don't touch it."": 1}",1.0,"{""// If it wasn't declared as metatype, better don't touch it."": 1}",1.0,{}
230,251279.0,13.0,40.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/251279,QML: Split qqmlmetatype{_p.h|.cpp} into multiple files,1.0,"{'// XXX No insertMulti, so no multi-version interfaces?': 1, '/*<KAIGYO>This method is """" to allow us to (potentially) register more types of things in<KAIGYO>the future without adding exported symbols.<KAIGYO>*/': 1, '// Setup extended meta object<KAIGYO>// XXX - very inefficient': 1}",1.0,"{'// Setup extended meta object<KAIGYO>// XXX - very inefficient': 1, '// XXX No insertMulti, so no multi-version interfaces?': 1, '/*<KAIGYO>This method is """" to allow us to (potentially) register more types of things in<KAIGYO>the future without adding exported symbols.<KAIGYO>*/': 1, ""// If it wasn't declared as metatype, better don't touch it."": 3}",1.0,{}
64,251338.0,1.0,6.0,0.0,ABANDONED,False,https://codereview.qt-project.org/#/c/251338,ANGLE: Remove scaling/flipping check in ValidateBlitFramebufferANGLE,1.0,{},0.0,{'// TODO(jmadill): Determine if this should be available on other implementations.': 1},1.0,{}
135,251524.0,6.0,11.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/251524,wasm: make wasm platform target a specific canvas instead of default,1.0,"{'//          canvasIds.append(wasmInt->canvasIds.at(0));<KAIGYO>//        const char *canvasId = 0; // (use default canvas) FIXME: get the actual canvas from the surface.': 1, '// FIXME: get the actual canvas from the surface.': 2}",1.0,{'// (use default canvas) FIXME: get the actual canvas from the surface.': 1},1.0,{}
130,251580.0,4.0,12.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/251580,Switch epilogues of AVX2 conversions to single step,1.0,{},0.0,{'// keep the two _mm_test[zc]_siXXX next to each other': 2},1.0,{}
218,251632.0,18.0,20.0,0.0,ABANDONED,False,https://codereview.qt-project.org/#/c/251632,V4 tracing: Add a clean-up phase after lowering phases,1.0,"{'//        case Operation::Jump: //### TODO': 1, '//        case Meta::Jump: //### TODO': 3, '// neither paths were ever taken, so this is dead code.': 8}",1.0,{'//### FIXME: add a DCE pass': 6},1.0,{}
166,251650.0,5.0,7.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/251650,Improve ARGB32ToRGBA64 conversions,1.0,{},0.0,"{""// The two unpack instructions unpack the low and upper halves of<KAIGYO>// each 128-bit half of the 256-bit register. Here's the tracking<KAIGYO>// of what's where: (p is 32-bit, P is 64-bit)<KAIGYO>//  as loaded:        [ p1, p2, p3, p4; p5, p6, p7, p8 ]<KAIGYO>//  after permute4x64 [ p1, p2, p5, p6; p3, p4, p7, p8 ]<KAIGYO>//  after unpacklo/hi [ P1, P2; P3, P4 ] [ P5, P6; P7, P8 ]"": 1, '// keep the two _mm_test[zc]_siXXX next to each other': 1}",1.0,{}
93,252420.0,3.0,9.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/252420,Move initView() to tests/auto/quick/shared,1.0,"{'// Initialize view, set Url, center in available geometry, move mouse away if desired': 1}",1.0,"{'// Initialize view, set Url, center in available geometry, move mouse away if desired': 1}",1.0,{}
133,253030.0,12.0,58.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/253030,QV4Engine: Unify fromValue and metaTypeToJS,1.0,"{'// XXX Can this be made more by using Array as a prototype and implementing<KAIGYO>// directly against QList<QObject*>?': 1, '// XXX TODO: To be compatible, we still need to handle:<KAIGYO>//    + QObjectList<KAIGYO>//    + QList<int>': 1}",1.0,"{'// XXX Can this be made more by using Array as a prototype and implementing<KAIGYO>// directly against QList<QObject*>?': 1, '// XXX TODO: To be compatible, we still need to handle:<KAIGYO>//    + QObjectList<KAIGYO>//    + QList<int>': 1}",1.0,{}
177,253230.0,6.0,15.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/253230,Support QRegularExpression on the same level as QRegExp,1.0,{},0.0,{'// ### we should probably handle QRegularExpression conversion engine-side': 2},1.0,{}
236,253255.0,15.0,44.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/253255,TableModel: support built-in QML model roles,1.0,"{'// TODO: need a way to may built-in roles to JSON object property keys here': 6, '// TODO: the property used here is undefined': 8, ""// TODO: should we also allow this code to be executed if roleDataProvider doesn't<KAIGYO>// handle the role/column, so that it only has to handle the case where there is<KAIGYO>// more than one role in a column?"": 8, '// TODO: this is currently random when no roleDataProvider handles it<KAIGYO>// we should allow roleDataProvider to': 8, '// TODO: this is currently random when no roleDataProvider handles it<KAIGYO>// we should allow roleDataProvider to be used to handle specific roles only': 11}",1.0,"{'// TODO: make it possible to specify the display role?<KAIGYO>// e.g. { myRoleName: 123, displayRole: """" }': 4, '// The """" role wasn\'t specified for this column,<KAIGYO>// so we use the first role that was declared for that column.<KAIGYO>// TODO: make it possible to specify the display role?<KAIGYO>// e.g. { myRoleName: 123, displayRole: """" }': 6}",1.0,{}
109,253405.0,3.0,6.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/253405,Merge remote-tracking branch 'origin/5.12' into 5.13,1.0,"{""// If it wasn't declared as metatype, better don't touch it."": 1}",1.0,"{""// If it wasn't declared as metatype, better don't touch it."": 2}",1.0,"{""// If it wasn't declared as metatype, better don't touch it."": '1-2'}"
146,253509.0,2.0,8.0,0.0,ABANDONED,False,https://codereview.qt-project.org/#/c/253509,WIP: TableModel: add roleDataLookupPolicy,1.0,"{""// If the role data provider doesn't provide data for this cell,<KAIGYO>// it's probably present in the row data itself."": 1, ""// TODO: could this comparison be slow? would it be better if<KAIGYO>// roleDataProvider returned null or something if it doesn't provide that data?"": 2}",1.0,"{""// TODO: should we also allow this code to be executed if roleDataProvider doesn't<KAIGYO>// handle the role/column, so that it only has to handle the case where there is<KAIGYO>// more than one role in a column?"": 1, '// TODO: this is currently random when no roleDataProvider handles it<KAIGYO>// we should allow roleDataProvider to be used to handle specific roles only': 2}",1.0,{}
224,253581.0,6.0,7.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/253581,wasm: support rendering to multiple canvases,1.0,{},0.0,"{'// FIXME: get the actual canvas from the surface.': 1, '// FIXME: The HTML5 plugin sets the cursor on the native canvas; when using multiple windows<KAIGYO>// multiple cursors need to be managed taking mouse postion and stacking into account.': 3}",1.0,{}
186,253760.0,6.0,11.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/253760,Make no option and invalid option texts customizable,1.0,{},0.0,{'// TODO: make No Option text customizable': 1},1.0,{}
142,254519.0,4.0,4.0,0.0,ABANDONED,False,https://codereview.qt-project.org/#/c/254519,WIP: TableModel: remove rows property,1.0,{},0.0,"{'// Only move forwards - flip if moving backwards.': 1, ""// TODO: should we also allow this code to be executed if roleDataProvider doesn't<KAIGYO>// handle the role/column, so that it only has to handle the case where there is<KAIGYO>// more than one role in a column?"": 1, '// TODO: check if a hash with its string-based lookup is faster,<KAIGYO>// keeping in mind that we may be doing index-based lookups too.': 1}",1.0,{}
179,254795.0,1.0,1.0,0.0,DEFERRED,False,https://codereview.qt-project.org/#/c/254795,WIP: hpack - fix the static table lookup,1.0,{},0.0,"{""// This data is from HPACK's specs and it's quite<KAIGYO>// conveniently sorted == works with binary search as it is.<KAIGYO>// Later this can probably change and instead of simple<KAIGYO>// vector we'll just reuse FieldLookupTable.<KAIGYO>// TODO: it makes sense to generate this table while ...<KAIGYO>// configuring/building Qt (some script downloading/parsing/generating<KAIGYO>// would be quite handy)."": 1}",1.0,{}
229,254812.0,5.0,8.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/254812,Hpack - fix the static lookup,1.0,{},0.0,"{""// This data is from HPACK's specs and it's quite<KAIGYO>// conveniently sorted == works with binary search as it is.<KAIGYO>// Later this can probably change and instead of simple<KAIGYO>// vector we'll just reuse FieldLookupTable.<KAIGYO>// TODO: it makes sense to generate this table while ...<KAIGYO>// configuring/building Qt (some script downloading/parsing/generating<KAIGYO>// would be quite handy)."": 1}",1.0,{}
231,255185.0,29.0,60.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/255185,Add TableModelColumn,1.0,"{'/*!<KAIGYO>    \\qmltype TableModelColumn<KAIGYO>    \\instantiates QQmlTableModelColumn<KAIGYO>    \\inqmlmodule Qt.labs.qmlmodels<KAIGYO>    \\brief Represents a column in a model.<KAIGYO>    \\since 5.14<KAIGYO><KAIGYO>    TODO<KAIGYO><KAIGYO>    \\sa TableModel, TableView<KAIGYO>*/': 1, '// TODO: do this for each built-in role': 3, ""// TODO: how do we get the value that was set on the user's JS data?<KAIGYO>//modifiedRow = ?"": 5, '// TODO: move this into shared getter utility function<KAIGYO>//        auto engine = qmlEngine(this);<KAIGYO>//        const auto args = QJSValueList() << QJSValue(engine->handle(), engine->handle()->fromVariant(QVariant(QVariant::ModelIndex, &index)));<KAIGYO>//        const QVariant cellData = tableModelColumn->display().call(args).toVariant();': 6, ""// Check that the column contains data that matches what the TableModelColumn specified.<KAIGYO>// It can contain extra data, too; we'll just ignore it."": 8, '// TODO: use QAbstractItemModelPrivate::defaultRoleNames() instead': 11, '//    // Move it back again.<KAIGYO>//    QVERIFY(QMetaObject::invokeMethod(model, """", Q_ARG(int, 4), Q_ARG(int, 0)));<KAIGYO>//    QCOMPARE(model->rowCount(), 5);<KAIGYO>//    QCOMPARE(model->columnCount(), 2);<KAIGYO>//    QCOMPARE(model->data(model->index(0, 0, QModelIndex()), roleNames.key(""""));<KAIGYO>//    QCOMPARE(model->data(model->index(0, 1, QModelIndex()), roleNames.key("""")).toInt(), 22);<KAIGYO>//    QCOMPARE(model->data(model->index(1, 0, QModelIndex()), roleNames.key(""""));<KAIGYO>//    QCOMPARE(model->data(model->index(1, 1, QModelIndex()), roleNames.key("""")).toInt(), 33);<KAIGYO>//    QCOMPARE(model->data(model->index(2, 0, QModelIndex()), roleNames.key(""""));<KAIGYO>//    QCOMPARE(model->data(model->index(2, 1, QModelIndex()), roleNames.key("""")).toInt(), 40);<KAIGYO>//    QCOMPARE(model->data(model->index(3, 0, QModelIndex()), roleNames.key(""""));<KAIGYO>//    QCOMPARE(model->data(model->index(3, 1, QModelIndex()), roleNames.key("""")).toInt(), 30);<KAIGYO>//    QCOMPARE(model->data(model->index(4, 0, QModelIndex()), roleNames.key(""""));<KAIGYO>//    QCOMPARE(model->data(model->index(4, 1, QModelIndex()), roleNames.key("""")).toInt(), 48);<KAIGYO>//    QCOMPARE(columnCountSpy.count(), 0);<KAIGYO>//    QCOMPARE(rowCountSpy.count(), rowCountSignalEmissions);': 14, '//void tst_QQmlTableModel::setRowsMultipleTimes()<KAIGYO>//{<KAIGYO>//    QQuickView view(testFileUrl(""""));<KAIGYO>//    QCOMPARE(view.status(), QQuickView::Ready);<KAIGYO>//    view.show();<KAIGYO>//    QVERIFY(QTest::qWaitForWindowActive(&view));<KAIGYO>//    QQmlTableModel *model = view.rootObject()->property("""").value<QQmlTableModel*>();<KAIGYO>//    QVERIFY(model);<KAIGYO>//    QCOMPARE(model->rowCount(), 2);<KAIGYO>//    QCOMPARE(model->columnCount(), 2);<KAIGYO>//    QSignalSpy columnCountSpy(model, SIGNAL(columnCountChanged()));<KAIGYO>//    QVERIFY(columnCountSpy.isValid());<KAIGYO>//    QSignalSpy rowCountSpy(model, SIGNAL(rowCountChanged()));<KAIGYO>//    QVERIFY(rowCountSpy.isValid());<KAIGYO>//    QQuickTableView *tableView = view.rootObject()->property("""").value<QQuickTableView*>();<KAIGYO>//    QVERIFY(tableView);<KAIGYO>//    QCOMPARE(tableView->rows(), 2);<KAIGYO>//    QCOMPARE(tableView->columns(), 2);<KAIGYO>//    // Set valid rows after they\'ve already been declared.<KAIGYO>//    QVERIFY(QMetaObject::invokeMethod(view.rootObject(), """"));<KAIGYO>//    QCOMPARE(model->rowCount(), 3);<KAIGYO>//    QCOMPARE(model->columnCount(), 2);<KAIGYO>//    const QHash<int, QByteArray> roleNames = model->roleNames();<KAIGYO>//    QCOMPARE(model->data(model->index(0, 0, QModelIndex()), roleNames.key(""""));<KAIGYO>//    QCOMPARE(model->data(model->index(0, 1, QModelIndex()), roleNames.key("""")).toInt(), 20);<KAIGYO>//    QCOMPARE(model->data(model->index(1, 0, QModelIndex()), roleNames.key(""""));<KAIGYO>//    QCOMPARE(model->data(model->index(1, 1, QModelIndex()), roleNames.key("""")).toInt(), 41);<KAIGYO>//    QCOMPARE(model->data(model->index(2, 0, QModelIndex()), roleNames.key(""""));<KAIGYO>//    QCOMPARE(model->data(model->index(2, 1, QModelIndex()), roleNames.key("""")).toInt(), 89);<KAIGYO>//    QCOMPARE(columnCountSpy.count(), 0);<KAIGYO>//    QCOMPARE(rowCountSpy.count(), 1);<KAIGYO>//    QTRY_COMPARE(tableView->rows(), 3);<KAIGYO>//    QCOMPARE(tableView->columns(), 2);<KAIGYO>//    // Set invalid rows; we should get a warning and nothing should change.<KAIGYO>//    // TODO: add quotes to the warning message<KAIGYO>//    QTest::ignoreMessage(QtWarningMsg, QRegularExpression(<KAIGYO>//        """"));<KAIGYO>//    QVERIFY(QMetaObject::invokeMethod(view.rootObject(), """"));<KAIGYO>//    QCOMPARE(model->rowCount(), 3);<KAIGYO>//    QCOMPARE(model->columnCount(), 2);<KAIGYO>//    QCOMPARE(model->data(model->index(0, 0, QModelIndex()), roleNames.key(""""));<KAIGYO>//    QCOMPARE(model->data(model->index(0, 1, QModelIndex()), roleNames.key("""")).toInt(), 20);<KAIGYO>//    QCOMPARE(model->data(model->index(1, 0, QModelIndex()), roleNames.key(""""));<KAIGYO>//    QCOMPARE(model->data(model->index(1, 1, QModelIndex()), roleNames.key("""")).toInt(), 41);<KAIGYO>//    QCOMPARE(model->data(model->index(2, 0, QModelIndex()), roleNames.key(""""));<KAIGYO>//    QCOMPARE(model->data(model->index(2, 1, QModelIndex()), roleNames.key("""")).toInt(), 89);<KAIGYO>//    QCOMPARE(columnCountSpy.count(), 0);<KAIGYO>//    QCOMPARE(rowCountSpy.count(), 1);<KAIGYO>//    QCOMPARE(tableView->rows(), 3);<KAIGYO>//    QCOMPARE(tableView->columns(), 2);<KAIGYO>//}<KAIGYO>//void tst_QQmlTableModel::builtInRoles_data()<KAIGYO>//{<KAIGYO>//    QTest::addColumn<int>("""");<KAIGYO>//    QTest::addColumn<int>("""");<KAIGYO>//    QTest::addColumn<QByteArray>("""");<KAIGYO>//    QTest::addColumn<QVariant>("""");<KAIGYO>//    const QByteArray displayRole = """";<KAIGYO>//    QTest::addRow(""""));<KAIGYO>//    QTest::addRow(""""));<KAIGYO>//    QTest::addRow(""""));<KAIGYO>//    QTest::addRow(""""));<KAIGYO>//}<KAIGYO>//void tst_QQmlTableModel::builtInRoles()<KAIGYO>//{<KAIGYO>//    QFETCH(int, row);<KAIGYO>//    QFETCH(int, column);<KAIGYO>//    QFETCH(QByteArray, roleName);<KAIGYO>//    QFETCH(QVariant, expectedValue);<KAIGYO>//    QQmlEngine engine;<KAIGYO>//    QQmlComponent component(&engine, testFileUrl(""""));<KAIGYO>//    QCOMPARE(component.status(), QQmlComponent::Ready);<KAIGYO>//    QScopedPointer<QQmlTableModel> model(qobject_cast<QQmlTableModel*>(component.create()));<KAIGYO>//    QVERIFY(model);<KAIGYO>//    QCOMPARE(model->rowCount(), 2);<KAIGYO>//    QCOMPARE(model->columnCount(), 2);<KAIGYO>//    const QHash<int, QByteArray> roleNames = model->roleNames();<KAIGYO>//    QCOMPARE(roleNames.size(), 4 + builtInRoleCount);<KAIGYO>//    QVERIFY(roleNames.values().contains(""""));<KAIGYO>//    QVERIFY(roleNames.values().contains(""""));<KAIGYO>//    QVERIFY(roleNames.values().contains(""""));<KAIGYO>//    QVERIFY(roleNames.values().contains(""""));<KAIGYO>//    QVERIFY(roleNames.values().contains(""""));<KAIGYO>//    QVERIFY(roleNames.values().contains(""""));<KAIGYO>//    QVERIFY(roleNames.values().contains(""""));<KAIGYO>//    QVERIFY(roleNames.values().contains(""""));<KAIGYO>//    QVERIFY(roleNames.values().contains(""""));<KAIGYO>//    QVERIFY(roleNames.values().contains(""""));<KAIGYO>//    QCOMPARE(model->data(model->index(row, column, QModelIndex()), roleNames.key(roleName)), expectedValue);<KAIGYO>//}<KAIGYO>//void tst_QQmlTableModel::explicitDisplayRole()<KAIGYO>//{<KAIGYO>//    QQmlEngine engine;<KAIGYO>//    QQmlComponent component(&engine, testFileUrl(""""));<KAIGYO>//    QCOMPARE(component.status(), QQmlComponent::Ready);<KAIGYO>//    QScopedPointer<QQmlTableModel> model(qobject_cast<QQmlTableModel*>(component.create()));<KAIGYO>//    QVERIFY(model);<KAIGYO>//    QCOMPARE(model->rowCount(), 1);<KAIGYO>//    QCOMPARE(model->columnCount(), 2);<KAIGYO>//    const QHash<int, QByteArray> roleNames = model->roleNames();<KAIGYO>//    QCOMPARE(model->data(model->index(0, 0, QModelIndex()), roleNames.key(""""));<KAIGYO>//    QCOMPARE(model->data(model->index(0, 1, QModelIndex()), roleNames.key(""""));<KAIGYO>//}<KAIGYO>//void tst_QQmlTableModel::roleDataProvider()<KAIGYO>//{<KAIGYO>//    QQuickView view(testFileUrl(""""));<KAIGYO>//    QCOMPARE(view.status(), QQuickView::Ready);<KAIGYO>//    view.show();<KAIGYO>//    QVERIFY(QTest::qWaitForWindowActive(&view));<KAIGYO>//    QQmlTableModel *model = view.rootObject()->property("""").value<QQmlTableModel*>();<KAIGYO>//    QVERIFY(model);<KAIGYO>//    const QHash<int, QByteArray> roleNames = model->roleNames();<KAIGYO>//    QVERIFY(roleNames.values().contains(""""));<KAIGYO>//    QCOMPARE(model->data(model->index(0, 0, QModelIndex()), roleNames.key(""""));<KAIGYO>//    QCOMPARE(model->data(model->index(0, 1, QModelIndex()), roleNames.key("""")).toInt(), 3 * 7);<KAIGYO>//    QCOMPARE(model->data(model->index(1, 0, QModelIndex()), roleNames.key(""""));<KAIGYO>//    QCOMPARE(model->data(model->index(1, 1, QModelIndex()), roleNames.key("""")).toInt(), 5 * 7);<KAIGYO>//}<KAIGYO>//void tst_QQmlTableModel::dataAndEditing()<KAIGYO>//{<KAIGYO>//    QQuickView view(testFileUrl(""""));<KAIGYO>//    QCOMPARE(view.status(), QQuickView::Ready);<KAIGYO>//    view.show();<KAIGYO>//    QVERIFY(QTest::qWaitForWindowActive(&view));<KAIGYO>//    QQmlTableModel *model = view.rootObject()->property("""").value<QQmlTableModel*>();<KAIGYO>//    QVERIFY(model);<KAIGYO>//    const QHash<int, QByteArray> roleNames = model->roleNames();<KAIGYO>//    QVERIFY(roleNames.values().contains(""""));<KAIGYO>//    QCOMPARE(model->data(model->index(0, 1, QModelIndex()), roleNames.key("""")).toInt(), 22);<KAIGYO>//    QCOMPARE(model->data(model->index(1, 1, QModelIndex()), roleNames.key("""")).toInt(), 33);<KAIGYO>//    QVERIFY(QMetaObject::invokeMethod(model, """"))));<KAIGYO>//    QCOMPARE(model->data(model->index(0, 0, QModelIndex()), roleNames.key(""""));<KAIGYO>//    QCOMPARE(model->data(model->index(0, 1, QModelIndex()), roleNames.key("""")).toInt(), 22);<KAIGYO>//    QCOMPARE(model->data(model->index(1, 0, QModelIndex()), roleNames.key(""""));<KAIGYO>//    QCOMPARE(model->data(model->index(1, 1, QModelIndex()), roleNames.key("""")).toInt(), 34);<KAIGYO>//}': 14, ""// TODO: test with TableView; it's failing"": 20}",1.0,"{""// TODO: should we also allow this code to be executed if roleDataProvider doesn't<KAIGYO>// handle the role/column, so that it only has to handle the case where there is<KAIGYO>// more than one role in a column?"": 7, '// TODO: check if a hash with its string-based lookup is faster,<KAIGYO>// keeping in mind that we may be doing index-based lookups too.': 8, '// TODO: this is currently random when no roleDataProvider handles it<KAIGYO>// we should allow roleDataProvider to be used to handle specific roles only': 14, '// Move it back again.': 14, '// Set invalid rows; we should get a warning and nothing should change.<KAIGYO>// TODO: add quotes to the warning message': 14, '// TODO: add quotes to the warning message': 15, '// TODO: the property used here is undefined': 16}",1.0,{}
125,255504.0,2.0,13.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/255504,Schannel: support for AES-encrypted keys,1.0,{},0.0,{'// TODO: Add SChannel version too!': 1},1.0,{}
181,255751.0,7.0,24.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/255751,qdoc: Fix regressions in WebXML output,1.0,{},0.0,"{'// TODO: Here, filter non-aggregate nodes based on their type if output<KAIGYO>// contains items that Shiboken cannot (and does not need to) handle.': 6}",1.0,{}
123,256511.0,8.0,27.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/256511,Merge remote-tracking branch 'origin/5.13' into dev,1.0,{},0.0,"{'// give up': 2, '// FIXME: on deleting a screen while a Window is on it, Qt will automatically<KAIGYO>// move the window to the primaryScreen(). This will trigger a screenChanged<KAIGYO>// signal, causing things like QQuickScreenAttached to re-fetch screen properties<KAIGYO>// like DPI and physical size. However this is crashing, as Qt is calling virtual<KAIGYO>// functions on QPlatformScreen, for reasons unclear. As workaround, move window<KAIGYO>// to primaryScreen() before deleting the screen. Might be QTBUG-38650': 2}",1.0,{}
205,256716.0,2.0,6.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/256716,Publish overloaded methods and signals to JavaScript,1.0,{},0.0,"{'// optimize: skip overloaded methods/signals or property getters, on the JS side we can only<KAIGYO>// call one of them anyways<KAIGYO>// TODO: basic support for overloaded signals, methods': 1}",1.0,{}
226,256895.0,2.0,3.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/256895,Remove winrt TODOs about manufacturer data,1.0,{},0.0,"{'// TODO deviceUpdated() signal not implemented on WinRT': 1, '// TODO Currently not implemented on WinRT': 1}",1.0,{}
22,257062.0,2.0,4.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/257062,tslib: fix detection of missing release coordinates,1.0,{},0.0,{'// work around missing coordinates on mouse release': 1},1.0,{}
169,257551.0,7.0,7.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/257551,winrt: Proper error handling in obtainCharList,1.0,{'// TODO': 1},1.0,"{""// TODO We should check if we found any characteristics. It makes no sense but<KAIGYO>// there is a possibility that device doesn't state any characteristics under a service.<KAIGYO>// So, for sanity, we should not continue endless loop here."": 1}",1.0,{}
295,257720.0,4.0,8.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/257720,Make the 64 bit raster backend an optional feature,1.0,"{'// Give up and do a naive gray alphablend. Needed to deal with ARGB32 and invalid ARGB32_premultiplied, see QTBUG-60571': 1}",1.0,"{'// Give up and do a naive gray alphablend. Needed to deal with ARGB32 and invalid ARGB32_premultiplied, see QTBUG-60571': 1}",1.0,{}
298,257957.0,7.0,18.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/257957,Merge remote-tracking branch 'origin/5.13' into dev,1.0,{'// Setup extended meta object<KAIGYO>// XXX - very inefficient': 1},1.0,{'// Setup extended meta object<KAIGYO>// XXX - very inefficient': 6},1.0,{'// Setup extended meta object<KAIGYO>// XXX - very inefficient': '1-6'}
35,258165.0,2.0,3.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/258165,Check the reverted UUID when filtering,1.0,{'/*<KAIGYO> * This function is part of a workaround for QTBUG-61392<KAIGYO> *<KAIGYO> * Returns null uuid if the given \\a serviceUuid is not a uuid<KAIGYO> * derived from the Bluetooth base uuid.<KAIGYO> */': 1},1.0,{'/*<KAIGYO> * This function is part of a workaround for QTBUG-61392<KAIGYO> *<KAIGYO> * Returns null uuid if the given \\a serviceUuid is not a uuid<KAIGYO> * derived from the Bluetooth base uuid.<KAIGYO> */': 1},1.0,{}
124,258175.0,2.0,5.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/258175,Replace qMove with std::move,1.0,"{'// move assignment<KAIGYO>// move construction': 1, ""// could be move or copy construction, so don't check p1's state"": 1, ""// could be move or copy assignment, so don't check p1's state"": 1}",1.0,"{'// move assignment<KAIGYO>// move construction': 1, ""// could be move or copy construction, so don't check p1's state"": 1, ""// could be move or copy assignment, so don't check p1's state"": 1}",1.0,{}
59,258227.0,3.0,4.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/258227,qmake: Remove special-handling of cl.exe's -Gm option,1.0,{},0.0,"{'// Cannot use -Gm with -FI & -Yu, as this gives an<KAIGYO>// internal compiler error, on the newer compilers<KAIGYO>// ### work-around for a VS 2003 bug. Move to some prf file or remove completely.': 1, '// Remove internal compiler error option<KAIGYO>// ### work-around for a VS 2003 bug. Move to some prf file or remove completely.': 1, '// Minimal build option triggers an Internal Compiler Error<KAIGYO>// when used in conjunction with /FI and /Yu, so remove it<KAIGYO>// ### work-around for a VS 2003 bug. Move to some prf file or remove completely.': 2}",1.0,{}
77,258265.0,3.0,5.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/258265,QStyle/QWidget: Avoid repetitive invocation of QStyleHelper::dpiScaled(),1.0,"{""// ### should ideally work without the '+ 1'"": 1}",1.0,"{""// ### should ideally work without the '+ 1'"": 1}",1.0,{}
213,258304.0,8.0,10.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/258304,Add accessors for QWindow and QScreen to QWidgetPrivate,1.0,{'// This seems to workaround an issue in xcb+multi GPU+multiscreen<KAIGYO>// environment where the window might not always show up when screen<KAIGYO>// is changed.': 1},1.0,{'// This seems to workaround an issue in xcb+multi GPU+multiscreen<KAIGYO>// environment where the window might not always show up when screen<KAIGYO>// is changed.': 1},1.0,{}
98,258360.0,3.0,2.0,0.0,NEW,False,https://codereview.qt-project.org/#/c/258360,Unify overload resolution code,1.0,{},0.0,{'// We already have a better option': 1},1.0,{}
282,258960.0,2.0,1.0,0.0,NEW,False,https://codereview.qt-project.org/#/c/258960,Clean up resolveProperty() code,1.0,{'// See if there is a better candidate': 1},1.0,{'// See if there is a better candidate': 1},1.0,{}
58,259158.0,5.0,11.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/259158,Use QCommandLineParser in the qml runtime tool,1.0,{},0.0,"{""// ### Should command line arguments have translations? Qt creator doesn't, so maybe it's not worth it."": 1}",1.0,{}
91,259301.0,3.0,13.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/259301,Fix memory leak with QQuickEventPoint,1.0,{},0.0,{'// TODO optimize: stop this dynamic memory thrashing': 1},1.0,{}
111,259353.0,4.0,8.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/259353,Merge remote-tracking branch 'origin/5.13' into dev,1.0,{'// Setup extended meta object<KAIGYO>// XXX - very inefficient': 1},1.0,{'// Setup extended meta object<KAIGYO>// XXX - very inefficient': 3},1.0,{'// Setup extended meta object<KAIGYO>// XXX - very inefficient': '1-3'}
121,259414.0,4.0,3.0,0.0,NEW,False,https://codereview.qt-project.org/#/c/259414,Resolve properties through the meta objects,1.0,"{'// fallback and search through the derived objects<KAIGYO>// ### Qt6: see if we can get rid of this, as it leaks the encapsulation': 2}",1.0,{'// See if there is a better candidate': 4},1.0,{}
254,259484.0,5.0,4.0,0.0,NEW,False,https://codereview.qt-project.org/#/c/259484,WIP: remove QML versioning,1.0,"{""// ### Qt6: get rid of this. It's only checking that the syntax is ok, but minor is ignored"": 1}",1.0,"{'// TODO: The copy should be mutable, and the original should be const<KAIGYO>//       Considering this, the setAllowedRevision() below does not violate<KAIGYO>//       the immutability of already published property caches.': 1}",1.0,{}
184,259626.0,1.0,0.0,0.0,NEW,False,https://codereview.qt-project.org/#/c/259626,WIP: also remove major version numbers for QML imports,1.0,{},0.0,"{'// Is this better than the previous candidate?': 1, '// This is our best candidate so far': 1, '// XXX version_major<0 just a kludge for QQmlPropertyPrivate::initProperty': 1}",1.0,{}
159,259682.0,3.0,5.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/259682,QQuickTableView: update viewportMoved() to take syncView into account,1.0,"{'// If the viewport has moved more than one page vertically or horizontally, we switch<KAIGYO>// strategy from refilling edges around the current table to instead rebuild the table<KAIGYO>// from scratch inside the new viewport. This will greatly improve performance when flicking<KAIGYO>// a long distance in one go, which can easily happen when dragging on scrollbars.': 1}",1.0,"{'// When the viewport has moved more than one page vertically or horizontally, we switch<KAIGYO>// strategy from refilling edges around the current table to instead rebuild the table<KAIGYO>// from scratch inside the new viewport. This will greatly improve performance when flicking<KAIGYO>// a long distance in one go, which can easily happen when dragging on scrollbars.': 1}",1.0,{}
203,259833.0,2.0,2.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/259833,Qt Designer: Enable Python code preview using uic,1.0,{},0.0,{'// ### fixme: Enable when PYSIDE-797 is done (uic extended by Python generator)': 1},1.0,{}
20,260070.0,2.0,4.0,0.0,ABANDONED,False,https://codereview.qt-project.org/#/c/260070,QTextMarkdownImporter: try harder to find a mono font,1.0,{'// workaround for QTBUG-54623': 1},1.0,{'// workaround for QTBUG-54623': 1},1.0,{}
301,260174.0,4.0,15.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/260174,Prefix textstream operators with Qt::,1.0,"{'// prints """"<KAIGYO>// prints """"<KAIGYO>// the node really is an element.': 2}",1.0,"{'// prints """"<KAIGYO>// prints """"<KAIGYO>// the node really is an element.': 2}",1.0,{}
93,261288.0,7.0,14.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/261288,QQuickTableView: don't recalculate content width while flicking,1.0,{},0.0,"{'// At this point, we should have the exact content width/height set, because<KAIGYO>// TableView knows where the large cells start in the viewport, and how many<KAIGYO>// columns that remain in the model. It will assume that the rest of the the<KAIGYO>// columns have the same average size as the ones currently inside the viewport.': 4}",1.0,{}
290,261926.0,6.0,8.0,0.0,NEW,False,https://codereview.qt-project.org/#/c/261926,Use QMetaObjectBuilder to create the dbus meta objects,1.0,{},0.0,{'// ### Fix this: metaObjects!<KAIGYO>//obj->d.extradata = 0;': 3},1.0,{}
38,262026.0,17.0,54.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/262026,Merge remote-tracking branch 'origin/5.12' into 5.13,1.0,{'// FIXME: this should not be conditional on staticlib': 13},1.0,{'// FIXME: this should not be conditional on staticlib': 13},1.0,{}
157,262027.0,15.0,43.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/262027,Merge remote-tracking branch 'origin/5.13' into dev,1.0,{'// FIXME: this should not be conditional on staticlib': 6},1.0,"{'// FIXME: this should not be conditional on staticlib': 6, '// maybe first week of next year': 6, '// QTBUG-36080 Workaround for systems without the POSIX timezone<KAIGYO>// variable. This solution is not very efficient but fixing it is up to<KAIGYO>// the libc implementations.<KAIGYO>//<KAIGYO>// tm_gmtoff has some important differences compared to the timezone<KAIGYO>// variable:<KAIGYO>// - It returns the number of seconds east of UTC, and we want the<KAIGYO>//   number of seconds west of UTC.<KAIGYO>// - It also takes DST into account, so we need to adjust it to always<KAIGYO>//   get the Standard Time offset.': 6, '// Docs state any LocalTime after 2037-12-31 *will* have any DST applied<KAIGYO>// but this may fall outside the supported time_t range, so need to fake it.<KAIGYO>// Use existing method to fake the conversion, but this is deeply flawed as it may<KAIGYO>// apply the conversion from the wrong day number, e.g. if rule is last Sunday of month<KAIGYO>// TODO Use QTimeZone when available to apply the future rule correctly': 6, '// Use existing method to fake the conversion, but this is deeply flawed as it may<KAIGYO>// apply the conversion from the wrong day number, e.g. if rule is last Sunday of month<KAIGYO>// TODO Use QTimeZone when available to apply the future rule correctly': 6, '// same as, but producing better code<KAIGYO>//return d.data.msecs;': 6, '// same as, but producing better code<KAIGYO>//return StatusFlag(d.data.status);': 6, '/*!<KAIGYO>    \\class QDateTime<KAIGYO>    \\inmodule QtCore<KAIGYO>    \\ingroup shared<KAIGYO>    \\reentrant<KAIGYO>    \\brief The QDateTime class provides date and time functions.<KAIGYO><KAIGYO><KAIGYO>    A QDateTime object encodes a calendar date and a clock time (a<KAIGYO>    """"). It combines features of the QDate and QTime classes.<KAIGYO>    It can read the current datetime from the system clock. It<KAIGYO>    provides functions for comparing datetimes and for manipulating a<KAIGYO>    datetime by adding a number of seconds, days, months, or years.<KAIGYO><KAIGYO>    QDateTime can describe datetimes with respect to \\l{Qt::LocalTime}{local<KAIGYO>    time}, to \\l{Qt::UTC}{UTC}, to a specified \\l{{Qt::OffsetFromUTC}{offset<KAIGYO>    from UTC} or to a specified \\l{{Qt::TimeZone}{time zone}, in conjunction<KAIGYO>    with the QTimeZone class. For example, a time zone of """" will<KAIGYO>    apply the daylight-saving rules as used in Germany since 1970. In contrast,<KAIGYO>    an offset from UTC of +3600 seconds is one hour ahead of UTC (usually<KAIGYO>    written in ISO standard notation as """"), with no daylight-saving<KAIGYO>    offset or changes. When using either local time or a specified time zone,<KAIGYO>    time-zone transitions such as the starts and ends of daylight-saving time<KAIGYO>    (DST) are taken into account. The choice of system used to represent a<KAIGYO>    datetime is described as its """".<KAIGYO><KAIGYO>    A QDateTime object is typically created either by giving a date and time<KAIGYO>    explicitly in the constructor, or by using a static function such as<KAIGYO>    currentDateTime() or fromMSecsSinceEpoch(). The date and time can be changed<KAIGYO>    with setDate() and setTime(). A datetime can also be set using the<KAIGYO>    setMSecsSinceEpoch() function that takes the time, in milliseconds, since<KAIGYO>    00:00:00 on January 1, 1970. The fromString() function returns a QDateTime,<KAIGYO>    given a string and a date format used to interpret the date within the<KAIGYO>    string.<KAIGYO><KAIGYO>    QDateTime::currentDateTime() returns a QDateTime that expresses the current<KAIGYO>    time with respect to local time. QDateTime::currentDateTimeUtc() returns a<KAIGYO>    QDateTime that expresses the current time with respect to UTC.<KAIGYO><KAIGYO>    The date() and time() functions provide access to the date and<KAIGYO>    time parts of the datetime. The same information is provided in<KAIGYO>    textual format by the toString() function.<KAIGYO><KAIGYO>    QDateTime provides a full set of operators to compare two<KAIGYO>    QDateTime objects, where smaller means earlier and larger means<KAIGYO>    later.<KAIGYO><KAIGYO>    You can increment (or decrement) a datetime by a given number of<KAIGYO>    milliseconds using addMSecs(), seconds using addSecs(), or days using<KAIGYO>    addDays(). Similarly, you can use addMonths() and addYears(). The daysTo()<KAIGYO>    function returns the number of days between two datetimes, secsTo() returns<KAIGYO>    the number of seconds between two datetimes, and msecsTo() returns the<KAIGYO>    number of milliseconds between two datetimes. These operations are aware of<KAIGYO>    daylight-saving time (DST) and other time-zone transitions, where<KAIGYO>    applicable.<KAIGYO><KAIGYO>    Use toTimeSpec() to express a datetime in local time or UTC,<KAIGYO>    toOffsetFromUtc() to express in terms of an offset from UTC, or toTimeZone()<KAIGYO>    to express it with respect to a general time zone. You can use timeSpec() to<KAIGYO>    find out what time-spec a QDateTime object stores its time relative to. When<KAIGYO>    that is Qt::TimeZone, you can use timeZone() to find out which zone it is<KAIGYO>    using.<KAIGYO><KAIGYO>    \\note QDateTime does not account for leap seconds.<KAIGYO><KAIGYO>    \\section1 Remarks<KAIGYO><KAIGYO>    \\section2 No Year 0<KAIGYO><KAIGYO>    There is no year 0. Dates in that year are considered invalid. The<KAIGYO>    year -1 is the year """"<KAIGYO>    The day before 1 January 1 CE is 31 December 1 BCE.<KAIGYO><KAIGYO>    \\section2 Range of Valid Dates<KAIGYO><KAIGYO>    The range of values that QDateTime can represent is dependent on the<KAIGYO>    internal storage implementation. QDateTime is currently stored in a qint64<KAIGYO>    as a serial msecs value encoding the date and time. This restricts the date<KAIGYO>    range to about +/- 292 million years, compared to the QDate range of +/- 2<KAIGYO>    billion years. Care must be taken when creating a QDateTime with extreme<KAIGYO>    values that you do not overflow the storage. The exact range of supported<KAIGYO>    values varies depending on the Qt::TimeSpec and time zone.<KAIGYO><KAIGYO>    \\section2 Use of Timezones<KAIGYO><KAIGYO>    QDateTime uses the system\'s time zone information to determine the current<KAIGYO>    local time zone and its offset from UTC. If the system is not configured<KAIGYO>    correctly or not up-to-date, QDateTime will give wrong results.<KAIGYO><KAIGYO>    QDateTime likewise uses system-provided information to determine the offsets<KAIGYO>    of other timezones from UTC. If this information is incomplete or out of<KAIGYO>    date, QDateTime will give wrong results. See the QTimeZone documentation for<KAIGYO>    more details.<KAIGYO><KAIGYO>    On modern Unix systems, this means QDateTime usually has accurate<KAIGYO>    information about historical transitions (including DST, see below) whenever<KAIGYO>    possible. On Windows, where the system doesn\'t support historical timezone<KAIGYO>    data, historical accuracy is not maintained with respect to timezone<KAIGYO>    transitions, notably including DST.<KAIGYO><KAIGYO>    \\section2 Daylight-Saving Time (DST)<KAIGYO><KAIGYO>    QDateTime takes into account transitions between Standard Time and<KAIGYO>    Daylight-Saving Time. For example, if the transition is at 2am and the clock<KAIGYO>    goes forward to 3am, then there is a """" hour from 02:00:00 to<KAIGYO>    02:59:59.999 which QDateTime considers to be invalid. Any date arithmetic<KAIGYO>    performed will take this missing hour into account and return a valid<KAIGYO>    result. For example, adding one minute to 01:59:59 will get 03:00:00.<KAIGYO><KAIGYO>    The range of valid dates taking DST into account is 1970-01-01 to the<KAIGYO>    present, and rules are in place for handling DST correctly until 2037-12-31,<KAIGYO>    but these could change. For dates falling outside that range, QDateTime<KAIGYO>    makes a \\e{best guess} using the rules for year 1970 or 2037, but we can\'t<KAIGYO>    guarantee accuracy. This means QDateTime doesn\'t take into account changes<KAIGYO>    in a time zone before 1970, even if the system\'s time zone database provides<KAIGYO>    that information.<KAIGYO><KAIGYO>    \\section2 Offsets From UTC<KAIGYO><KAIGYO>    There is no explicit size restriction on an offset from UTC, but there is an<KAIGYO>    implicit limit imposed when using the toString() and fromString() methods<KAIGYO>    which use a [+|-]hh:mm format, effectively limiting the range to +/- 99<KAIGYO>    hours and 59 minutes and whole minutes only. Note that currently no time<KAIGYO>    zone lies outside the range of +/- 14 hours.<KAIGYO><KAIGYO>    \\sa QDate, QTime, QDateTimeEdit, QTimeZone<KAIGYO>*/': 6, '/*!<KAIGYO>    \\since 5.8<KAIGYO>    Moves the content of the temporary \\a other datetime to this object and<KAIGYO>    leaves \\a other in an unspecified (but proper) state.<KAIGYO>*/': 6, '// FIXME: QSql relies on QVariant::toDateTime() accepting a space here:': 6, '// If both failed, give up': 6, '// FIXME: need to use a different constructor !': 6, '// TODO QTextStream inefficient, replace later': 6, '// TODO small risk may not match if tran times differ due to outdated files<KAIGYO>// TODO Some valid TZ names are not valid ICU names, use translation table?': 6, '// TODO Perhaps cache as frequently accessed?': 6, '// TODO Could cache the value and monitor the required files for any changes': 6, '// Give up for now and return UTC': 6, '// TODO AnyCountry': 6, '/*!<KAIGYO>    \\class QDateTime<KAIGYO>    \\inmodule QtCore<KAIGYO>    \\ingroup shared<KAIGYO>    \\reentrant<KAIGYO>    \\brief The QDateTime class provides date and time functions.<KAIGYO><KAIGYO><KAIGYO>    A QDateTime object encodes a calendar date and a clock time (a<KAIGYO>    """"). It combines features of the QDate and QTime classes.<KAIGYO>    It can read the current datetime from the system clock. It<KAIGYO>    provides functions for comparing datetimes and for manipulating a<KAIGYO>    datetime by adding a number of seconds, days, months, or years.<KAIGYO><KAIGYO>    QDateTime can describe datetimes with respect to \\l{Qt::LocalTime}{local<KAIGYO>    time}, to \\l{Qt::UTC}{UTC}, to a specified \\l{Qt::OffsetFromUTC}{offset<KAIGYO>    from UTC} or to a specified \\l{{Qt::TimeZone}{time zone}, in conjunction<KAIGYO>    with the QTimeZone class. For example, a time zone of """" will<KAIGYO>    apply the daylight-saving rules as used in Germany since 1970. In contrast,<KAIGYO>    an offset from UTC of +3600 seconds is one hour ahead of UTC (usually<KAIGYO>    written in ISO standard notation as """"), with no daylight-saving<KAIGYO>    offset or changes. When using either local time or a specified time zone,<KAIGYO>    time-zone transitions such as the starts and ends of daylight-saving time<KAIGYO>    (DST) are taken into account. The choice of system used to represent a<KAIGYO>    datetime is described as its """".<KAIGYO><KAIGYO>    A QDateTime object is typically created either by giving a date and time<KAIGYO>    explicitly in the constructor, or by using a static function such as<KAIGYO>    currentDateTime() or fromMSecsSinceEpoch(). The date and time can be changed<KAIGYO>    with setDate() and setTime(). A datetime can also be set using the<KAIGYO>    setMSecsSinceEpoch() function that takes the time, in milliseconds, since<KAIGYO>    00:00:00 on January 1, 1970. The fromString() function returns a QDateTime,<KAIGYO>    given a string and a date format used to interpret the date within the<KAIGYO>    string.<KAIGYO><KAIGYO>    QDateTime::currentDateTime() returns a QDateTime that expresses the current<KAIGYO>    time with respect to local time. QDateTime::currentDateTimeUtc() returns a<KAIGYO>    QDateTime that expresses the current time with respect to UTC.<KAIGYO><KAIGYO>    The date() and time() functions provide access to the date and<KAIGYO>    time parts of the datetime. The same information is provided in<KAIGYO>    textual format by the toString() function.<KAIGYO><KAIGYO>    QDateTime provides a full set of operators to compare two<KAIGYO>    QDateTime objects, where smaller means earlier and larger means<KAIGYO>    later.<KAIGYO><KAIGYO>    You can increment (or decrement) a datetime by a given number of<KAIGYO>    milliseconds using addMSecs(), seconds using addSecs(), or days using<KAIGYO>    addDays(). Similarly, you can use addMonths() and addYears(). The daysTo()<KAIGYO>    function returns the number of days between two datetimes, secsTo() returns<KAIGYO>    the number of seconds between two datetimes, and msecsTo() returns the<KAIGYO>    number of milliseconds between two datetimes. These operations are aware of<KAIGYO>    daylight-saving time (DST) and other time-zone transitions, where<KAIGYO>    applicable.<KAIGYO><KAIGYO>    Use toTimeSpec() to express a datetime in local time or UTC,<KAIGYO>    toOffsetFromUtc() to express in terms of an offset from UTC, or toTimeZone()<KAIGYO>    to express it with respect to a general time zone. You can use timeSpec() to<KAIGYO>    find out what time-spec a QDateTime object stores its time relative to. When<KAIGYO>    that is Qt::TimeZone, you can use timeZone() to find out which zone it is<KAIGYO>    using.<KAIGYO><KAIGYO>    \\note QDateTime does not account for leap seconds.<KAIGYO><KAIGYO>    \\section1 Remarks<KAIGYO><KAIGYO>    \\section2 No Year 0<KAIGYO><KAIGYO>    There is no year 0. Dates in that year are considered invalid. The<KAIGYO>    year -1 is the year """"<KAIGYO>    The day before 1 January 1 CE is 31 December 1 BCE.<KAIGYO><KAIGYO>    \\section2 Range of Valid Dates<KAIGYO><KAIGYO>    The range of values that QDateTime can represent is dependent on the<KAIGYO>    internal storage implementation. QDateTime is currently stored in a qint64<KAIGYO>    as a serial msecs value encoding the date and time. This restricts the date<KAIGYO>    range to about +/- 292 million years, compared to the QDate range of +/- 2<KAIGYO>    billion years. Care must be taken when creating a QDateTime with extreme<KAIGYO>    values that you do not overflow the storage. The exact range of supported<KAIGYO>    values varies depending on the Qt::TimeSpec and time zone.<KAIGYO><KAIGYO>    \\section2 Use of Timezones<KAIGYO><KAIGYO>    QDateTime uses the system\'s time zone information to determine the current<KAIGYO>    local time zone and its offset from UTC. If the system is not configured<KAIGYO>    correctly or not up-to-date, QDateTime will give wrong results.<KAIGYO><KAIGYO>    QDateTime likewise uses system-provided information to determine the offsets<KAIGYO>    of other timezones from UTC. If this information is incomplete or out of<KAIGYO>    date, QDateTime will give wrong results. See the QTimeZone documentation for<KAIGYO>    more details.<KAIGYO><KAIGYO>    On modern Unix systems, this means QDateTime usually has accurate<KAIGYO>    information about historical transitions (including DST, see below) whenever<KAIGYO>    possible. On Windows, where the system doesn\'t support historical timezone<KAIGYO>    data, historical accuracy is not maintained with respect to timezone<KAIGYO>    transitions, notably including DST.<KAIGYO><KAIGYO>    \\section2 Daylight-Saving Time (DST)<KAIGYO><KAIGYO>    QDateTime takes into account transitions between Standard Time and<KAIGYO>    Daylight-Saving Time. For example, if the transition is at 2am and the clock<KAIGYO>    goes forward to 3am, then there is a """" hour from 02:00:00 to<KAIGYO>    02:59:59.999 which QDateTime considers to be invalid. Any date arithmetic<KAIGYO>    performed will take this missing hour into account and return a valid<KAIGYO>    result. For example, adding one minute to 01:59:59 will get 03:00:00.<KAIGYO><KAIGYO>    The range of valid dates taking DST into account is 1970-01-01 to the<KAIGYO>    present, and rules are in place for handling DST correctly until 2037-12-31,<KAIGYO>    but these could change. For dates falling outside that range, QDateTime<KAIGYO>    makes a \\e{best guess} using the rules for year 1970 or 2037, but we can\'t<KAIGYO>    guarantee accuracy. This means QDateTime doesn\'t take into account changes<KAIGYO>    in a time zone before 1970, even if the system\'s time zone database provides<KAIGYO>    that information.<KAIGYO><KAIGYO>    \\section2 Offsets From UTC<KAIGYO><KAIGYO>    There is no explicit size restriction on an offset from UTC, but there is an<KAIGYO>    implicit limit imposed when using the toString() and fromString() methods<KAIGYO>    which use a [+|-]hh:mm format, effectively limiting the range to +/- 99<KAIGYO>    hours and 59 minutes and whole minutes only. Note that currently no time<KAIGYO>    zone lies outside the range of +/- 14 hours.<KAIGYO><KAIGYO>    \\sa QDate, QTime, QDateTimeEdit, QTimeZone<KAIGYO>*/': 14}",1.0,{}
81,262350.0,3.0,6.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/262350,QFileSystemWatcher: lock autotest code away into a cold section,1.0,{'// Normal runtime case - search intelligently for best engine': 1},1.0,{'// Normal runtime case - search intelligently for best engine': 1},1.0,{}
134,262579.0,2.0,7.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/262579,Tooling: Use QRegularExpression rather than QRegExp,1.0,{},0.0,"{""// Don't use QStringLiteral here. QRegExp has a global cache and will save an implicitly<KAIGYO>// shared copy of the passed string. That copy isn't properly detached when the library<KAIGYO>// is unloaded if the original string lives in the library's .rodata"": 1}",1.0,{}
216,262881.0,1.0,1.0,0.0,NEW,False,https://codereview.qt-project.org/#/c/262881,libinput: Map touch device to correct screen,1.0,{},0.0,{'// TODO Map to correct screen using QTouchOutputMapping.<KAIGYO>// Perhaps investigate libinput_device_get_output_name as well.<KAIGYO>// For now just use the primary screen.': 1},1.0,{}
62,263104.0,15.0,21.0,0.0,MERGED,True,https://codereview.qt-project.org/#/c/263104,Add support for the Islamic Civil calendar,1.0,"{'// Maybe 1360 for Jalali, 1420 for Islamic, etc.': 1, '// TODO: confirm this is correct': 1}",1.0,"{'// Maybe 1360 for Jalali, etc.': 1}",1.0,{}
